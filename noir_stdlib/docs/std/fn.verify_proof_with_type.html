<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../styles.css">
<title>Function verify_proof_with_type documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../index.html">noir_stdlib</a></h1><div><a href="../all.html">All items</a></div>
<h2>In crate std</h2><h3>Modules</h3><ul class="item-list"><li><a href="aes128/index.html" class="module">aes128</a></div></li>
<li><a href="append/index.html" class="module">append</a></div></li>
<li><a href="cmp/index.html" class="module">cmp</a></div></li>
<li><a href="collections/index.html" class="module">collections</a></div></li>
<li><a href="compat/index.html" class="module">compat</a></div></li>
<li><a href="convert/index.html" class="module">convert</a></div></li>
<li><a href="default/index.html" class="module">default</a></div></li>
<li><a href="ecdsa_secp256k1/index.html" class="module">ecdsa_secp256k1</a></div></li>
<li><a href="ecdsa_secp256r1/index.html" class="module">ecdsa_secp256r1</a></div></li>
<li><a href="embedded_curve_ops/index.html" class="module">embedded_curve_ops</a></div></li>
<li><a href="field/index.html" class="module">field</a></div></li>
<li><a href="hash/index.html" class="module">hash</a></div></li>
<li><a href="hint/index.html" class="module">hint</a></div></li>
<li><a href="mem/index.html" class="module">mem</a></div></li>
<li><a href="meta/index.html" class="module">meta</a></div></li>
<li><a href="option/index.html" class="module">option</a></div></li>
<li><a href="panic/index.html" class="module">panic</a></div></li>
<li><a href="runtime/index.html" class="module">runtime</a></div></li>
<li><a href="test/index.html" class="module">test</a></div></li>
</ul><h3>Primitive types</h3><ul class="item-list"><li><a href="primitive.array.html" class="primitive">array</a></div></li>
<li><a href="primitive.bool.html" class="primitive">bool</a></div></li>
<li><a href="primitive.CtString.html" class="primitive">CtString</a></div></li>
<li><a href="primitive.Expr.html" class="primitive">Expr</a></div></li>
<li><a href="primitive.Field.html" class="primitive">Field</a></div></li>
<li><a href="primitive.fmtstr.html" class="primitive">fmtstr</a></div></li>
<li><a href="primitive.FunctionDefinition.html" class="primitive">FunctionDefinition</a></div></li>
<li><a href="primitive.i16.html" class="primitive">i16</a></div></li>
<li><a href="primitive.i32.html" class="primitive">i32</a></div></li>
<li><a href="primitive.i64.html" class="primitive">i64</a></div></li>
<li><a href="primitive.i8.html" class="primitive">i8</a></div></li>
<li><a href="primitive.Module.html" class="primitive">Module</a></div></li>
<li><a href="primitive.Quoted.html" class="primitive">Quoted</a></div></li>
<li><a href="primitive.slice.html" class="primitive">slice</a></div></li>
<li><a href="primitive.str.html" class="primitive">str</a></div></li>
<li><a href="primitive.TopLevelItem.html" class="primitive">TopLevelItem</a></div></li>
<li><a href="primitive.TraitConstraint.html" class="primitive">TraitConstraint</a></div></li>
<li><a href="primitive.TraitDefinition.html" class="primitive">TraitDefinition</a></div></li>
<li><a href="primitive.TraitImpl.html" class="primitive">TraitImpl</a></div></li>
<li><a href="primitive.Type.html" class="primitive">Type</a></div></li>
<li><a href="primitive.TypeDefinition.html" class="primitive">TypeDefinition</a></div></li>
<li><a href="primitive.TypeExpr.html" class="primitive">TypeExpr</a></div></li>
<li><a href="primitive.u1.html" class="primitive">u1</a></div></li>
<li><a href="primitive.u128.html" class="primitive">u128</a></div></li>
<li><a href="primitive.u16.html" class="primitive">u16</a></div></li>
<li><a href="primitive.u32.html" class="primitive">u32</a></div></li>
<li><a href="primitive.u64.html" class="primitive">u64</a></div></li>
<li><a href="primitive.u8.html" class="primitive">u8</a></div></li>
<li><a href="primitive.UnresolvedType.html" class="primitive">UnresolvedType</a></div></li>
</ul><h3>Functions</h3><ul class="item-list"><li><a href="fn.as_witness.html" class="fn">as_witness</a></div></li>
<li><a href="fn.assert_constant.html" class="fn">assert_constant</a></div></li>
<li><a href="fn.print.html" class="fn">print</a></div></li>
<li><a href="fn.println.html" class="fn">println</a></div></li>
<li><a href="fn.static_assert.html" class="fn">static_assert</a></div></li>
<li><a href="fn.verify_proof_with_type.html" class="fn">verify_proof_with_type</a></div></li>
<li><a href="fn.wrapping_add.html" class="fn">wrapping_add</a></div></li>
<li><a href="fn.wrapping_mul.html" class="fn">wrapping_mul</a></div></li>
<li><a href="fn.wrapping_sub.html" class="fn">wrapping_sub</a></div></li>
</ul></nav>
<main>
<div><a href="../index.html">noir_stdlib</a> - <a href="index.html">std</a></div><h1>Function <span class="fn">verify_proof_with_type</span></h1><pre><code>pub fn verify_proof_with_type&lt;let N: <a href="../std/primitive.u32.html" class="primitive">u32</a>, let M: <a href="../std/primitive.u32.html" class="primitive">u32</a>, let K: <a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;(
    verification_key: [<a href="../std/primitive.Field.html" class="primitive">Field</a>; N],
    proof: [<a href="../std/primitive.Field.html" class="primitive">Field</a>; M],
    public_inputs: [<a href="../std/primitive.Field.html" class="primitive">Field</a>; K],
    key_hash: <a href="../std/primitive.Field.html" class="primitive">Field</a>,
    proof_type: <a href="../std/primitive.u32.html" class="primitive">u32</a>,
)</code></pre>

<div class="comments">
<p>Asserts the validity of the provided proof and public inputs against the provided verification key and hash.</p>
<p>The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of
the backend against which the program is being proven. However if an invalid proof if submitted, the program may
fail to prove or the backend may generate a proof which will subsequently fail to verify.</p>
<h2>Important Note</h2>
<p>If you are not developing your own backend such as <a href="https://github.com/AztecProtocol/barretenberg">Barretenberg</a>
you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification
library which is published by the developers of the backend which will document or enforce any safety requirements.</p>
<p>If you use this directly, you're liable to introduce underconstrainedness bugs and <em>your circuit will be insecure</em>.</p>
<h2>Arguments</h2>
<ul>
<li>verification_key: The verification key of the circuit to be verified.</li>
<li>proof: The proof to be verified.</li>
<li>public_inputs: The public inputs associated with <code>proof</code></li>
<li>key_hash: The hash of <code>verification_key</code> of the form expected by the backend.</li>
<li>proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows
for a single backend to support verifying multiple proving schemes.</li>
</ul>
<h2>Constraining <code>key_hash</code></h2>
<p>The Noir compiler does not by itself constrain that <code>key_hash</code> is a valid hash of <code>verification_key</code>.
This is because different backends may differ in how they hash their verification keys.
It is then the responsibility of either the noir developer (by explicitly hashing the verification key
in the correct manner) or by the proving system itself internally asserting the correctness of <code>key_hash</code>.</p>
</div>
</main>
</body>
</html>
