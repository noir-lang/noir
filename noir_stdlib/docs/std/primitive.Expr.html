<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../styles.css">
<script defer src="../nargo_doc.js"></script>
<title>Primitive type Expr documentation</title>
</head>
<body>
<div id="sidebar-toggle">
<button id="sidebar-toggle-button"></button>
<div id="sidebar-toggle-title">Expr</div>
</div>
<span id="main-contents">
<nav class="sidebar">
<h1><a href="../index.html">noir_stdlib</a></h1>
<div><a href="../all.html">All items</a></div>
<h2 id="crate-name"><a href="index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#primitive">Primitive type Expr</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#as_array">as_array</a></li>
<li><a href="#as_assert">as_assert</a></li>
<li><a href="#as_assert_eq">as_assert_eq</a></li>
<li><a href="#as_assign">as_assign</a></li>
<li><a href="#as_binary_op">as_binary_op</a></li>
<li><a href="#as_block">as_block</a></li>
<li><a href="#as_bool">as_bool</a></li>
<li><a href="#as_cast">as_cast</a></li>
<li><a href="#as_comptime">as_comptime</a></li>
<li><a href="#as_constructor">as_constructor</a></li>
<li><a href="#as_for">as_for</a></li>
<li><a href="#as_for_range">as_for_range</a></li>
<li><a href="#as_function_call">as_function_call</a></li>
<li><a href="#as_if">as_if</a></li>
<li><a href="#as_index">as_index</a></li>
<li><a href="#as_integer">as_integer</a></li>
<li><a href="#as_lambda">as_lambda</a></li>
<li><a href="#as_let">as_let</a></li>
<li><a href="#as_member_access">as_member_access</a></li>
<li><a href="#as_method_call">as_method_call</a></li>
<li><a href="#as_repeated_element_array">as_repeated_element_array</a></li>
<li><a href="#as_repeated_element_slice">as_repeated_element_slice</a></li>
<li><a href="#as_repeated_element_vector">as_repeated_element_vector</a></li>
<li><a href="#as_slice">as_slice</a></li>
<li><a href="#as_tuple">as_tuple</a></li>
<li><a href="#as_unary_op">as_unary_op</a></li>
<li><a href="#as_unsafe">as_unsafe</a></li>
<li><a href="#as_vector">as_vector</a></li>
<li><a href="#has_semicolon">has_semicolon</a></li>
<li><a href="#is_break">is_break</a></li>
<li><a href="#is_continue">is_continue</a></li>
<li><a href="#modify">modify</a></li>
<li><a href="#quoted">quoted</a></li>
<li><a href="#resolve">resolve</a></li>
</ul>
<h2>In crate std</h2>
<h3>Modules</h3><ul class="item-list">
<li><a href="aes128/index.html">aes128</a></div></li>
<li><a href="append/index.html">append</a></div></li>
<li><a href="cmp/index.html">cmp</a></div></li>
<li><a href="collections/index.html">collections</a></div></li>
<li><a href="compat/index.html">compat</a></div></li>
<li><a href="convert/index.html">convert</a></div></li>
<li><a href="default/index.html">default</a></div></li>
<li><a href="ecdsa_secp256k1/index.html">ecdsa_secp256k1</a></div></li>
<li><a href="ecdsa_secp256r1/index.html">ecdsa_secp256r1</a></div></li>
<li><a href="embedded_curve_ops/index.html">embedded_curve_ops</a></div></li>
<li><a href="field/index.html">field</a></div></li>
<li><a href="hash/index.html">hash</a></div></li>
<li><a href="hint/index.html">hint</a></div></li>
<li><a href="mem/index.html">mem</a></div></li>
<li><a href="meta/index.html">meta</a></div></li>
<li><a href="ops/index.html">ops</a></div></li>
<li><a href="option/index.html">option</a></div></li>
<li><a href="panic/index.html">panic</a></div></li>
<li><a href="prelude/index.html">prelude</a></div></li>
<li><a href="runtime/index.html">runtime</a></div></li>
<li><a href="test/index.html">test</a></div></li>
</ul>
<h3>Primitive types</h3><ul class="item-list">
<li><a href="primitive.array.html">array</a></div></li>
<li><a href="primitive.bool.html">bool</a></div></li>
<li><a href="primitive.CtString.html">CtString</a></div></li>
<li><a href="primitive.Expr.html">Expr</a></div></li>
<li><a href="primitive.Field.html">Field</a></div></li>
<li><a href="primitive.fmtstr.html">fmtstr</a></div></li>
<li><a href="primitive.FunctionDefinition.html">FunctionDefinition</a></div></li>
<li><a href="primitive.i16.html">i16</a></div></li>
<li><a href="primitive.i32.html">i32</a></div></li>
<li><a href="primitive.i64.html">i64</a></div></li>
<li><a href="primitive.i8.html">i8</a></div></li>
<li><a href="primitive.Module.html">Module</a></div></li>
<li><a href="primitive.Quoted.html">Quoted</a></div></li>
<li><a href="primitive.str.html">str</a></div></li>
<li><a href="primitive.TraitConstraint.html">TraitConstraint</a></div></li>
<li><a href="primitive.TraitDefinition.html">TraitDefinition</a></div></li>
<li><a href="primitive.TraitImpl.html">TraitImpl</a></div></li>
<li><a href="primitive.Type.html">Type</a></div></li>
<li><a href="primitive.TypeDefinition.html">TypeDefinition</a></div></li>
<li><a href="primitive.TypedExpr.html">TypedExpr</a></div></li>
<li><a href="primitive.u1.html">u1</a></div></li>
<li><a href="primitive.u128.html">u128</a></div></li>
<li><a href="primitive.u16.html">u16</a></div></li>
<li><a href="primitive.u32.html">u32</a></div></li>
<li><a href="primitive.u64.html">u64</a></div></li>
<li><a href="primitive.u8.html">u8</a></div></li>
<li><a href="primitive.UnresolvedType.html">UnresolvedType</a></div></li>
<li><a href="primitive.vector.html">vector</a></div></li>
</ul>
<h3>Functions</h3><ul class="item-list">
<li><a href="fn.as_witness.html">as_witness</a></div></li>
<li><a href="fn.assert_constant.html">assert_constant</a></div></li>
<li><a href="fn.print.html">print</a></div></li>
<li><a href="fn.println.html">println</a></div></li>
<li><a href="fn.static_assert.html">static_assert</a></div></li>
<li><a href="fn.verify_proof_with_type.html">verify_proof_with_type</a></div></li>
<li><a href="fn.wrapping_add.html">wrapping_add</a></div></li>
<li><a href="fn.wrapping_mul.html">wrapping_mul</a></div></li>
<li><a href="fn.wrapping_sub.html">wrapping_sub</a></div></li>
</ul>
</nav>
<main>
<div><a href="../index.html">noir_stdlib</a> - <a href="index.html">std</a></div>
<h1>Primitive type <span id="primitive" class="primitive">Expr</span></h1>
<div class="comments">
<p>A compile-time, quoted, syntactically valid expression.</p>
<p>An <code>Expr</code> can be obtained using <a href="../std/primitive.Quoted.html#as_expr"><code>Quoted::as_expr</code></a>:</p>
<pre><code><span class="kw">fn</span> main() {
    <span class="kw">comptime</span> {
        <span class="kw">let</span> expr = <span class="kw">quote</span> { <span class="number">1</span> + <span class="number">2</span> }.as_expr().unwrap();
    }
}</code></pre></div>
<h2>Implementations</h2>
<h3><code class="code-header">impl <a href="../std/primitive.Expr.html" class="primitive">Expr</a></code></h3>

<div class="padded-methods"><code id="as_array" class="code-header">pub comptime fn <a href="#as_array"><span class="fn">as_array</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an array literal <code>[elem1, ..., elemN]</code>, this returns a vector of each element in the array.</p>
</div>
</div><code id="as_assert" class="code-header">pub comptime fn <a href="#as_assert"><span class="fn">as_assert</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an assert, this returns the assert expression and the optional message.</p>
</div>
</div><code id="as_assert_eq" class="code-header">pub comptime fn <a href="#as_assert_eq"><span class="fn">as_assert_eq</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an assert_eq, this returns the left-hand-side and right-hand-side
expressions, together with the optional message.</p>
</div>
</div><code id="as_assign" class="code-header">pub comptime fn <a href="#as_assign"><span class="fn">as_assign</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an assignment, this returns a tuple with the left hand side
and right hand side in order.</p>
</div>
</div><code id="as_binary_op" class="code-header">pub comptime fn <a href="#as_binary_op"><span class="fn">as_binary_op</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/meta/op/struct.BinaryOp.html" class="struct">BinaryOp</a>, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a binary operator operation <code>&lt;lhs&gt; &lt;op&gt; &lt;rhs&gt;</code>,
return the left-hand side, operator, and the right-hand side of the operation.</p>
</div>
</div><code id="as_block" class="code-header">pub comptime fn <a href="#as_block"><span class="fn">as_block</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a block <code>{ stmt1; stmt2; ...; stmtN }</code>, return
a vector containing each statement.</p>
</div>
</div><code id="as_bool" class="code-header">pub comptime fn <a href="#as_bool"><span class="fn">as_bool</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.bool.html" class="primitive">bool</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a boolean literal, return that literal.</p>
</div>
</div><code id="as_cast" class="code-header">pub comptime fn <a href="#as_cast"><span class="fn">as_cast</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a cast expression <code>expr as type</code>, returns the casted
expression and the type to cast to.</p>
</div>
</div><code id="as_comptime" class="code-header">pub comptime fn <a href="#as_comptime"><span class="fn">as_comptime</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a <code>comptime { stmt1; stmt2; ...; stmtN }</code> block,
return each statement in the block.</p>
</div>
</div><code id="as_constructor" class="code-header">pub comptime fn <a href="#as_constructor"><span class="fn">as_constructor</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>, [(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, Self)])&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a constructor <code>Type { field1: expr1, ..., fieldN: exprN }</code>,
return the type and the fields.</p>
</div>
</div><code id="as_for" class="code-header">pub comptime fn <a href="#as_for"><span class="fn">as_for</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a for statement over a single expression, return the identifier,
the expression and the for loop body.</p>
</div>
</div><code id="as_for_range" class="code-header">pub comptime fn <a href="#as_for_range"><span class="fn">as_for_range</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, Self, Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a for statement over a range, return the identifier,
the range start, the range end and the for loop body.</p>
</div>
</div><code id="as_function_call" class="code-header">pub comptime fn <a href="#as_function_call"><span class="fn">as_function_call</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, [Self])&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a function call <code>foo(arg1, ..., argN)</code>, return
the function and a vector of each argument.</p>
</div>
</div><code id="as_if" class="code-header">pub comptime fn <a href="#as_if"><span class="fn">as_if</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an <code>if condition { then_branch } else { else_branch }</code>,
return the condition, then branch, and else branch. If there is no else branch,
<code>None</code> is returned for that branch instead.</p>
</div>
</div><code id="as_index" class="code-header">pub comptime fn <a href="#as_index"><span class="fn">as_index</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an index into an array <code>array[index]</code>, return the
array and the index.</p>
</div>
</div><code id="as_integer" class="code-header">pub comptime fn <a href="#as_integer"><span class="fn">as_integer</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.Field.html" class="primitive">Field</a>, <a href="../std/primitive.bool.html" class="primitive">bool</a>)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an integer literal, return the integer as a field
as well as whether the integer is negative (true) or not (false).</p>
</div>
</div><code id="as_lambda" class="code-header">pub comptime fn <a href="#as_lambda"><span class="fn">as_lambda</span></a>(
    self,
) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;([(Self, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>&gt;)], <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>&gt;, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a lambda, returns the parameters, return type and body.</p>
</div>
</div><code id="as_let" class="code-header">pub comptime fn <a href="#as_let"><span class="fn">as_let</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>&gt;, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a let statement, returns the let pattern as an <code>Expr</code>,
the optional type annotation, and the assigned expression.</p>
</div>
</div><code id="as_member_access" class="code-header">pub comptime fn <a href="#as_member_access"><span class="fn">as_member_access</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a member access <code>foo.bar</code>, return the struct/tuple
expression and the field. The field will be represented as a quoted value.</p>
</div>
</div><code id="as_method_call" class="code-header">pub comptime fn <a href="#as_method_call"><span class="fn">as_method_call</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, [<a href="../std/primitive.UnresolvedType.html" class="primitive">UnresolvedType</a>], [Self])&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a method call <code>foo.bar::&lt;generic1, ..., genericM&gt;(arg1, ..., argN)</code>, return
the receiver, method name, a vector of each generic argument, and a vector of each argument.</p>
</div>
</div><code id="as_repeated_element_array" class="code-header">pub comptime fn <a href="#as_repeated_element_array"><span class="fn">as_repeated_element_array</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a repeated element array <code>[elem; length]</code>, return
the repeated element and the length expressions.</p>
</div>
</div><code id="as_repeated_element_vector" class="code-header">pub comptime fn <a href="#as_repeated_element_vector"><span class="fn">as_repeated_element_vector</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a repeated element vector <code>[elem; length]</code>, return
the repeated element and the length expressions.</p>
</div>
</div><code id="as_repeated_element_slice" class="code-header">pub comptime fn <a href="#as_repeated_element_slice"><span class="fn">as_repeated_element_slice</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="deprecated">
<span class="emoji">ðŸ‘Ž</span>
Deprecated: This method has been renamed to `as_repeated_element_vector`
</div>
<div class="comments">
<p>If this expression is a repeated element vector <code>[elem; length]</code>, return
the repeated element and the length expressions.
This method is deprecated in favor of <code>as_repeated_element_vector</code></p>
</div>
</div><code id="as_vector" class="code-header">pub comptime fn <a href="#as_vector"><span class="fn">as_vector</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a vector literal <code>@[elem1, ..., elemN]</code>,
return each element of the vector.</p>
</div>
</div><code id="as_slice" class="code-header">pub comptime fn <a href="#as_slice"><span class="fn">as_slice</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="deprecated">
<span class="emoji">ðŸ‘Ž</span>
Deprecated: This method has been renamed to `as_vector`
</div>
<div class="comments">
<p>If this expression is a vector literal <code>@[elem1, ..., elemN]</code>,
return each element of the vector.
This method is deprecated in favor of <code>as_vector</code></p>
</div>
</div><code id="as_tuple" class="code-header">pub comptime fn <a href="#as_tuple"><span class="fn">as_tuple</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a tuple <code>(field1, ..., fieldN)</code>,
return each element of the tuple.</p>
</div>
</div><code id="as_unary_op" class="code-header">pub comptime fn <a href="#as_unary_op"><span class="fn">as_unary_op</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/meta/op/struct.UnaryOp.html" class="struct">UnaryOp</a>, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is a unary operation <code>&lt;op&gt; &lt;rhs&gt;</code>,
return the unary operator as well as the right-hand side expression.</p>
</div>
</div><code id="as_unsafe" class="code-header">pub comptime fn <a href="#as_unsafe"><span class="fn">as_unsafe</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this expression is an <code>unsafe { stmt1; ...; stmtN }</code> block,
return each statement inside in a vector.</p>
</div>
</div><code id="has_semicolon" class="code-header">pub comptime fn <a href="#has_semicolon"><span class="fn">has_semicolon</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this expression is trailed by a semicolon.</p>
<p>Example:</p>
<pre><code><span class="kw">comptime</span> {
    <span class="kw">let</span> expr1 = <span class="kw">quote</span> { <span class="number">1</span> + <span class="number">2</span> }.as_expr().unwrap();
    <span class="kw">let</span> expr2 = <span class="kw">quote</span> { <span class="number">1</span> + <span class="number">2</span>; }.as_expr().unwrap();

    <span class="kw">assert</span>(expr1.as_binary_op().is_some());
    <span class="kw">assert</span>(expr2.as_binary_op().is_some());

    <span class="kw">assert</span>(!expr1.has_semicolon());
    <span class="kw">assert</span>(expr2.has_semicolon());
}</code></pre></div>
</div><code id="is_break" class="code-header">pub comptime fn <a href="#is_break"><span class="fn">is_break</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this expression is <code>break</code>.</p>
</div>
</div><code id="is_continue" class="code-header">pub comptime fn <a href="#is_continue"><span class="fn">is_continue</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this expression is <code>continue</code>.</p>
</div>
</div><code id="modify" class="code-header">pub comptime fn <a href="#modify"><span class="fn">modify</span></a>&lt;Env&gt;(self, f: fn[Env](Self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Applies a mapping function to this expression and to all of its sub-expressions.
<code>f</code> will be applied to each sub-expression first, then applied to the expression itself.</p>
<p>This happens recursively for every expression within <code>self</code>.</p>
<p>For example, calling <code>modify</code> on <code>(@[1], @[2, 3])</code> with an <code>f</code> that returns <code>Option::some</code>
for expressions that are integers, doubling them, would return <code>(@[2], @[4, 6])</code>.</p>
</div>
</div><code id="quoted" class="code-header">pub comptime fn <a href="#quoted"><span class="fn">quoted</span></a>(self) -> <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a></code>

<div class="padded-description"><div class="comments">
<p>Returns this expression as a <code>Quoted</code> value. It's the same as <code>quote { $self }</code>.</p>
</div>
</div><code id="resolve" class="code-header">pub comptime fn <a href="#resolve"><span class="fn">resolve</span></a>(self, in_function: <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.FunctionDefinition.html" class="primitive">FunctionDefinition</a>&gt;) -> <a href="../std/primitive.TypedExpr.html" class="primitive">TypedExpr</a></code>

<div class="padded-description"><div class="comments">
<p>Resolves and type-checks this expression and returns the result as a <code>TypedExpr</code>.</p>
<p>The <code>in_function</code> argument specifies where the expression is resolved:</p>
<ul>
<li>If it's <code>none</code>, the expression is resolved in the function where <code>resolve</code> was called</li>
<li>If it's <code>some</code>, the expression is resolved in the given function</li>
</ul>
<p>If any names used by this expression are not in scope or if there are any type errors,
this will give compiler errors as if the expression was written directly into
the current <code>comptime</code> function.</p>
</div>
</div></div></main>
</span>
</body>
</html>
