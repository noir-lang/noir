<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../styles.css">
<script defer src="../nargo_doc.js"></script>
<title>Primitive type Type documentation</title>
</head>
<body>
<div id="sidebar-toggle">
<button id="sidebar-toggle-button"></button>
<div id="sidebar-toggle-title">Type</div>
</div>
<span id="main-contents">
<nav class="sidebar">
<h1><a href="../index.html">noir_stdlib</a></h1>
<div><a href="../all.html">All items</a></div>
<h2 id="crate-name"><a href="index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#primitive">Primitive type Type</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#as_array">as_array</a></li>
<li><a href="#as_constant">as_constant</a></li>
<li><a href="#as_data_type">as_data_type</a></li>
<li><a href="#as_integer">as_integer</a></li>
<li><a href="#as_mutable_reference">as_mutable_reference</a></li>
<li><a href="#as_slice">as_slice</a></li>
<li><a href="#as_str">as_str</a></li>
<li><a href="#as_struct">as_struct</a></li>
<li><a href="#as_tuple">as_tuple</a></li>
<li><a href="#as_vector">as_vector</a></li>
<li><a href="#get_trait_impl">get_trait_impl</a></li>
<li><a href="#implements">implements</a></li>
<li><a href="#is_bool">is_bool</a></li>
<li><a href="#is_field">is_field</a></li>
<li><a href="#is_unit">is_unit</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-Eq-for-Type">Eq</a></li>
<li><a href="#impl-Hash-for-Type">Hash</a></li>
</ul>
<h2>In crate std</h2>
<h3>Modules</h3><ul class="item-list">
<li><a href="aes128/index.html">aes128</a></div></li>
<li><a href="append/index.html">append</a></div></li>
<li><a href="cmp/index.html">cmp</a></div></li>
<li><a href="collections/index.html">collections</a></div></li>
<li><a href="compat/index.html">compat</a></div></li>
<li><a href="convert/index.html">convert</a></div></li>
<li><a href="default/index.html">default</a></div></li>
<li><a href="ecdsa_secp256k1/index.html">ecdsa_secp256k1</a></div></li>
<li><a href="ecdsa_secp256r1/index.html">ecdsa_secp256r1</a></div></li>
<li><a href="embedded_curve_ops/index.html">embedded_curve_ops</a></div></li>
<li><a href="field/index.html">field</a></div></li>
<li><a href="hash/index.html">hash</a></div></li>
<li><a href="hint/index.html">hint</a></div></li>
<li><a href="mem/index.html">mem</a></div></li>
<li><a href="meta/index.html">meta</a></div></li>
<li><a href="ops/index.html">ops</a></div></li>
<li><a href="option/index.html">option</a></div></li>
<li><a href="panic/index.html">panic</a></div></li>
<li><a href="prelude/index.html">prelude</a></div></li>
<li><a href="runtime/index.html">runtime</a></div></li>
<li><a href="test/index.html">test</a></div></li>
</ul>
<h3>Primitive types</h3><ul class="item-list">
<li><a href="primitive.array.html">array</a></div></li>
<li><a href="primitive.bool.html">bool</a></div></li>
<li><a href="primitive.CtString.html">CtString</a></div></li>
<li><a href="primitive.Expr.html">Expr</a></div></li>
<li><a href="primitive.Field.html">Field</a></div></li>
<li><a href="primitive.fmtstr.html">fmtstr</a></div></li>
<li><a href="primitive.FunctionDefinition.html">FunctionDefinition</a></div></li>
<li><a href="primitive.i16.html">i16</a></div></li>
<li><a href="primitive.i32.html">i32</a></div></li>
<li><a href="primitive.i64.html">i64</a></div></li>
<li><a href="primitive.i8.html">i8</a></div></li>
<li><a href="primitive.Module.html">Module</a></div></li>
<li><a href="primitive.Quoted.html">Quoted</a></div></li>
<li><a href="primitive.str.html">str</a></div></li>
<li><a href="primitive.TraitConstraint.html">TraitConstraint</a></div></li>
<li><a href="primitive.TraitDefinition.html">TraitDefinition</a></div></li>
<li><a href="primitive.TraitImpl.html">TraitImpl</a></div></li>
<li><a href="primitive.Type.html">Type</a></div></li>
<li><a href="primitive.TypeDefinition.html">TypeDefinition</a></div></li>
<li><a href="primitive.TypedExpr.html">TypedExpr</a></div></li>
<li><a href="primitive.u1.html">u1</a></div></li>
<li><a href="primitive.u128.html">u128</a></div></li>
<li><a href="primitive.u16.html">u16</a></div></li>
<li><a href="primitive.u32.html">u32</a></div></li>
<li><a href="primitive.u64.html">u64</a></div></li>
<li><a href="primitive.u8.html">u8</a></div></li>
<li><a href="primitive.UnresolvedType.html">UnresolvedType</a></div></li>
<li><a href="primitive.vector.html">vector</a></div></li>
</ul>
<h3>Functions</h3><ul class="item-list">
<li><a href="fn.as_witness.html">as_witness</a></div></li>
<li><a href="fn.assert_constant.html">assert_constant</a></div></li>
<li><a href="fn.print.html">print</a></div></li>
<li><a href="fn.println.html">println</a></div></li>
<li><a href="fn.static_assert.html">static_assert</a></div></li>
<li><a href="fn.verify_proof_with_type.html">verify_proof_with_type</a></div></li>
</ul>
</nav>
<main>
<div><a href="../index.html">noir_stdlib</a> - <a href="index.html">std</a></div>
<h1>Primitive type <span id="primitive" class="primitive">Type</span></h1>
<div class="comments">
<p>A compile-time type which represents a type in the source program.</p>
<p>It can be obtained using [<code>Quoted::as_type](../std/primitive.Quoted.html#as_type)</code>:</p>
<pre><code><span class="kw">fn</span> main() {
    <span class="kw">comptime</span> {
        <span class="kw">let</span> typ = <span class="kw">quote</span> { i32 }.as_type();
        println(typ); <span class="comment">// outputs "i32"</span>
    }
}</code></pre></div>
<h2>Implementations</h2>
<h3><code class="code-header">impl <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code id="as_array" class="code-header">pub comptime fn <a href="#as_array"><span class="fn">as_array</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this type is an array, return a pair of (element type, size type).</p>
<p>Example:</p>
<pre><code><span class="kw">comptime</span> {
    <span class="kw">let</span> array_type = <span class="kw">quote</span> { [Field; <span class="number">3</span>] }.as_type();
    <span class="kw">let</span> (field_type, three_type) = array_type.as_array().unwrap();

    <span class="kw">assert</span>(field_type.is_field());
    <span class="kw">assert_eq</span>(three_type.as_constant().unwrap(), <span class="number">3</span>);
}</code></pre></div>
</div><code id="as_constant" class="code-header">pub comptime fn <a href="#as_constant"><span class="fn">as_constant</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this type is a constant integer (such as the <code>3</code> in the array type <code>[Field; 3]</code>),
return the numeric constant.</p>
</div>
</div><code id="as_integer" class="code-header">pub comptime fn <a href="#as_integer"><span class="fn">as_integer</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.bool.html" class="primitive">bool</a>, <a href="../std/primitive.u8.html" class="primitive">u8</a>)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is an integer type, return a boolean which is <code>true</code>
if the type is signed, as well as the number of bits of this integer type.</p>
</div>
</div><code id="as_mutable_reference" class="code-header">pub comptime fn <a href="#as_mutable_reference"><span class="fn">as_mutable_reference</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a mutable reference type <code>&amp;mut T</code>, returns the mutable type <code>T</code>.</p>
</div>
</div><code id="as_vector" class="code-header">pub comptime fn <a href="#as_vector"><span class="fn">as_vector</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a vector type, return the element type of the vector.</p>
</div>
</div><code id="as_slice" class="code-header">pub comptime fn <a href="#as_slice"><span class="fn">as_slice</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="deprecated">
<span class="emoji">ðŸ‘Ž</span>
Deprecated: This method has been renamed to `as_vector`
</div>
<div class="comments">
<p>If this is a vector type, return the element type of the vector.</p>
</div>
</div><code id="as_str" class="code-header">pub comptime fn <a href="#as_str"><span class="fn">as_str</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a <code>str&lt;N&gt;</code> type, returns the length <code>N</code> as a type.</p>
</div>
</div><code id="as_struct" class="code-header">pub comptime fn <a href="#as_struct"><span class="fn">as_struct</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a>, [Self])&gt;</code>

<div class="padded-description"><div class="deprecated">
<span class="emoji">ðŸ‘Ž</span>
Deprecated: This method has been renamed to `as_data_type`
</div>
</div><code id="as_data_type" class="code-header">pub comptime fn <a href="#as_data_type"><span class="fn">as_data_type</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a>, [Self])&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a struct or enum type, returns the type in addition to any generic arguments on this type.</p>
</div>
</div><code id="as_tuple" class="code-header">pub comptime fn <a href="#as_tuple"><span class="fn">as_tuple</span></a>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a tuple type, returns each element type of the tuple.</p>
</div>
</div><code id="get_trait_impl" class="code-header">pub comptime fn <a href="#get_trait_impl"><span class="fn">get_trait_impl</span></a>(self, constraint: <a href="../std/primitive.TraitConstraint.html" class="primitive">TraitConstraint</a>) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.TraitImpl.html" class="primitive">TraitImpl</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>Retrieves the trait implementation that implements the given
trait constraint for this type. If the trait constraint is not
found, <code>None</code> is returned. Note that since the concrete trait implementation
for a trait constraint specified from a <code>where</code> clause is unknown,
this function will return <code>None</code> in these cases. If you only want to know
whether a type implements a trait, use <code>implements</code> instead.</p>
<p>Example:</p>
<pre><code><span class="kw">comptime</span> {
    <span class="kw">let</span> field_type = <span class="kw">quote</span> { Field }.as_type();
    <span class="kw">let</span> default = <span class="kw">quote</span> { Default }.as_trait_constraint();

    <span class="kw">let</span> the_impl: TraitImpl = field_type.get_trait_impl(default).unwrap();
    <span class="kw">assert</span>(the_impl.methods().len(), <span class="number">1</span>);
}</code></pre></div>
</div><code id="implements" class="code-header">pub comptime fn <a href="#implements"><span class="fn">implements</span></a>(self, constraint: <a href="../std/primitive.TraitConstraint.html" class="primitive">TraitConstraint</a>) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type implements the given trait. Note that unlike
<code>get_trait_impl</code> this will also return true for any <code>where</code> constraints
in scope.</p>
<p>Example:</p>
<pre><code><span class="kw">fn</span> foo&lt;T&gt;() <span class="kw">where</span> T: Default {
    <span class="kw">comptime</span> {
        <span class="kw">let</span> field_type = <span class="kw">quote</span> { Field }.as_type();
        <span class="kw">let</span> default = <span class="kw">quote</span> { Default }.as_trait_constraint();
        <span class="kw">assert</span>(field_type.implements(default));

        <span class="kw">let</span> t = <span class="kw">quote</span> { T }.as_type();
        <span class="kw">assert</span>(t.implements(default));
    }
}</code></pre></div>
</div><code id="is_bool" class="code-header">pub comptime fn <a href="#is_bool"><span class="fn">is_bool</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is <code>bool</code>.</p>
</div>
</div><code id="is_field" class="code-header">pub comptime fn <a href="#is_field"><span class="fn">is_field</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is <code>Field</code>.</p>
</div>
</div><code id="is_unit" class="code-header">pub comptime fn <a href="#is_unit"><span class="fn">is_unit</span></a>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is the unit <code>()</code> type.</p>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Eq-for-Type"><code class="code-header">impl <a href="../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">eq</span>(self, other: Self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Note that this is syntactic equality, this is not the same as whether two types will type check
to be the same type. Unless type inference or generics are being used however, users should not
typically have to worry about this distinction.</p>
</div>
</div></div><h3 id="impl-Hash-for-Type"><code class="code-header">impl <a href="../std/hash/trait.Hash.html" class="trait">Hash</a> for <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">hash</span>&lt;H&gt;(self, state: &mut H)
<div class="where-clause">where
    H: <a href="../std/hash/trait.Hasher.html" class="trait">Hasher</a></div></code>

</div></main>
</span>
</body>
</html>
