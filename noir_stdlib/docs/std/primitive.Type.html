<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../styles.css">
<title>Primitive type Type documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../index.html">noir_stdlib</a></h1>
<div><a href="../all.html">All items</a></div>
<h2 id="crate-name"><a href="index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#primitive">Primitive type Type</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#as_array">as_array</a></li>
<li><a href="#as_constant">as_constant</a></li>
<li><a href="#as_data_type">as_data_type</a></li>
<li><a href="#as_integer">as_integer</a></li>
<li><a href="#as_mutable_reference">as_mutable_reference</a></li>
<li><a href="#as_slice">as_slice</a></li>
<li><a href="#as_str">as_str</a></li>
<li><a href="#as_struct">as_struct</a></li>
<li><a href="#as_tuple">as_tuple</a></li>
<li><a href="#get_trait_impl">get_trait_impl</a></li>
<li><a href="#implements">implements</a></li>
<li><a href="#is_bool">is_bool</a></li>
<li><a href="#is_field">is_field</a></li>
<li><a href="#is_unit">is_unit</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-Eq-for-Type">Eq</a></li>
<li><a href="#impl-Hash-for-Type">Hash</a></li>
</ul>
<h2>In crate std</h2>
<h3>Modules</h3><ul class="item-list">
<li><a href="aes128/index.html">aes128</a></div></li>
<li><a href="append/index.html">append</a></div></li>
<li><a href="cmp/index.html">cmp</a></div></li>
<li><a href="collections/index.html">collections</a></div></li>
<li><a href="compat/index.html">compat</a></div></li>
<li><a href="convert/index.html">convert</a></div></li>
<li><a href="default/index.html">default</a></div></li>
<li><a href="ecdsa_secp256k1/index.html">ecdsa_secp256k1</a></div></li>
<li><a href="ecdsa_secp256r1/index.html">ecdsa_secp256r1</a></div></li>
<li><a href="embedded_curve_ops/index.html">embedded_curve_ops</a></div></li>
<li><a href="field/index.html">field</a></div></li>
<li><a href="hash/index.html">hash</a></div></li>
<li><a href="hint/index.html">hint</a></div></li>
<li><a href="mem/index.html">mem</a></div></li>
<li><a href="meta/index.html">meta</a></div></li>
<li><a href="ops/index.html">ops</a></div></li>
<li><a href="option/index.html">option</a></div></li>
<li><a href="panic/index.html">panic</a></div></li>
<li><a href="prelude/index.html">prelude</a></div></li>
<li><a href="runtime/index.html">runtime</a></div></li>
<li><a href="test/index.html">test</a></div></li>
</ul>
<h3>Primitive types</h3><ul class="item-list">
<li><a href="primitive.array.html">array</a></div></li>
<li><a href="primitive.bool.html">bool</a></div></li>
<li><a href="primitive.CtString.html">CtString</a></div></li>
<li><a href="primitive.Expr.html">Expr</a></div></li>
<li><a href="primitive.Field.html">Field</a></div></li>
<li><a href="primitive.fmtstr.html">fmtstr</a></div></li>
<li><a href="primitive.FunctionDefinition.html">FunctionDefinition</a></div></li>
<li><a href="primitive.i16.html">i16</a></div></li>
<li><a href="primitive.i32.html">i32</a></div></li>
<li><a href="primitive.i64.html">i64</a></div></li>
<li><a href="primitive.i8.html">i8</a></div></li>
<li><a href="primitive.Module.html">Module</a></div></li>
<li><a href="primitive.Quoted.html">Quoted</a></div></li>
<li><a href="primitive.slice.html">slice</a></div></li>
<li><a href="primitive.str.html">str</a></div></li>
<li><a href="primitive.TraitConstraint.html">TraitConstraint</a></div></li>
<li><a href="primitive.TraitDefinition.html">TraitDefinition</a></div></li>
<li><a href="primitive.TraitImpl.html">TraitImpl</a></div></li>
<li><a href="primitive.Type.html">Type</a></div></li>
<li><a href="primitive.TypeDefinition.html">TypeDefinition</a></div></li>
<li><a href="primitive.TypedExpr.html">TypedExpr</a></div></li>
<li><a href="primitive.u1.html">u1</a></div></li>
<li><a href="primitive.u128.html">u128</a></div></li>
<li><a href="primitive.u16.html">u16</a></div></li>
<li><a href="primitive.u32.html">u32</a></div></li>
<li><a href="primitive.u64.html">u64</a></div></li>
<li><a href="primitive.u8.html">u8</a></div></li>
<li><a href="primitive.UnresolvedType.html">UnresolvedType</a></div></li>
</ul>
<h3>Functions</h3><ul class="item-list">
<li><a href="fn.as_witness.html">as_witness</a></div></li>
<li><a href="fn.assert_constant.html">assert_constant</a></div></li>
<li><a href="fn.print.html">print</a></div></li>
<li><a href="fn.println.html">println</a></div></li>
<li><a href="fn.static_assert.html">static_assert</a></div></li>
<li><a href="fn.verify_proof_with_type.html">verify_proof_with_type</a></div></li>
<li><a href="fn.wrapping_add.html">wrapping_add</a></div></li>
<li><a href="fn.wrapping_mul.html">wrapping_mul</a></div></li>
<li><a href="fn.wrapping_sub.html">wrapping_sub</a></div></li>
</ul>
</nav>
<main>
<div><a href="../index.html">noir_stdlib</a> - <a href="index.html">std</a></div>
<h1>Primitive type <span id="primitive" class="primitive">Type</span></h1>
<h2>Implementations</h2>
<h3><code class="code-header">impl <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code id="as_array" class="code-header">pub comptime fn <span class="fn">as_array</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(Self, Self)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this type is an array, return a pair of (element type, size type).</p>
<p>Example:</p>
<pre><code class="language-noir">comptime {
    let array_type = quote { [Field; 3] }.as_type();
    let (field_type, three_type) = array_type.as_array().unwrap();

    assert(field_type.is_field());
    assert_eq(three_type.as_constant().unwrap(), 3);
}
</code></pre>
</div>
</div><code id="as_constant" class="code-header">pub comptime fn <span class="fn">as_constant</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this type is a constant integer (such as the <code>3</code> in the array type <code>[Field; 3]</code>),
return the numeric constant.</p>
</div>
</div><code id="as_integer" class="code-header">pub comptime fn <span class="fn">as_integer</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.bool.html" class="primitive">bool</a>, <a href="../std/primitive.u8.html" class="primitive">u8</a>)&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is an integer type, return a boolean which is <code>true</code>
if the type is signed, as well as the number of bits of this integer type.</p>
</div>
</div><code id="as_mutable_reference" class="code-header">pub comptime fn <span class="fn">as_mutable_reference</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a mutable reference type <code>&amp;mut T</code>, returns the mutable type <code>T</code>.</p>
</div>
</div><code id="as_slice" class="code-header">pub comptime fn <span class="fn">as_slice</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a slice type, return the element type of the slice.</p>
</div>
</div><code id="as_str" class="code-header">pub comptime fn <span class="fn">as_str</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;Self&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a <code>str&lt;N&gt;</code> type, returns the length <code>N</code> as a type.</p>
</div>
</div><code id="as_struct" class="code-header">pub comptime fn <span class="fn">as_struct</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a>, [Self])&gt;</code>

<code id="as_data_type" class="code-header">pub comptime fn <span class="fn">as_data_type</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;(<a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a>, [Self])&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a struct or enum type, returns the type in addition to any generic arguments on this type.</p>
</div>
</div><code id="as_tuple" class="code-header">pub comptime fn <span class="fn">as_tuple</span>(self) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;[Self]&gt;</code>

<div class="padded-description"><div class="comments">
<p>If this is a tuple type, returns each element type of the tuple.</p>
</div>
</div><code id="get_trait_impl" class="code-header">pub comptime fn <span class="fn">get_trait_impl</span>(self, constraint: <a href="../std/primitive.TraitConstraint.html" class="primitive">TraitConstraint</a>) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.TraitImpl.html" class="primitive">TraitImpl</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>Retrieves the trait implementation that implements the given
trait constraint for this type. If the trait constraint is not
found, <code>None</code> is returned. Note that since the concrete trait implementation
for a trait constraint specified from a <code>where</code> clause is unknown,
this function will return <code>None</code> in these cases. If you only want to know
whether a type implements a trait, use <code>implements</code> instead.</p>
<p>Example:</p>
<pre><code class="language-rust">comptime {
    let field_type = quote { Field }.as_type();
    let default = quote { Default }.as_trait_constraint();

    let the_impl: TraitImpl = field_type.get_trait_impl(default).unwrap();
    assert(the_impl.methods().len(), 1);
}
</code></pre>
</div>
</div><code id="implements" class="code-header">pub comptime fn <span class="fn">implements</span>(self, constraint: <a href="../std/primitive.TraitConstraint.html" class="primitive">TraitConstraint</a>) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type implements the given trait. Note that unlike
<code>get_trait_impl</code> this will also return true for any <code>where</code> constraints
in scope.</p>
<p>Example:</p>
<pre><code class="language-rust">fn foo&lt;T&gt;() where T: Default {
    comptime {
        let field_type = quote { Field }.as_type();
        let default = quote { Default }.as_trait_constraint();
        assert(field_type.implements(default));

        let t = quote { T }.as_type();
        assert(t.implements(default));
    }
}
</code></pre>
</div>
</div><code id="is_bool" class="code-header">pub comptime fn <span class="fn">is_bool</span>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is <code>bool</code>.</p>
</div>
</div><code id="is_field" class="code-header">pub comptime fn <span class="fn">is_field</span>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is <code>Field</code>.</p>
</div>
</div><code id="is_unit" class="code-header">pub comptime fn <span class="fn">is_unit</span>(self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if this type is the unit <code>()</code> type.</p>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Eq-for-Type"><code class="code-header">impl <a href="../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">eq</span>(self, other: Self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Note that this is syntactic equality, this is not the same as whether two types will type check
to be the same type. Unless type inference or generics are being used however, users should not
typically have to worry about this distinction.</p>
</div>
</div></div><h3 id="impl-Hash-for-Type"><code class="code-header">impl <a href="../std/hash/trait.Hash.html" class="trait">Hash</a> for <a href="../std/primitive.Type.html" class="primitive">Type</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">hash</span>&lt;H&gt;(self, state: &mut H)
<div class="where-clause">where
    H: <a href="../std/hash/trait.Hasher.html" class="trait">Hasher</a></div></code>

</div></main>
</body>
</html>
