<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<script defer src="../../../nargo_doc.js"></script>
<title>Function fresh_type_variable documentation</title>
</head>
<body>
<div id="sidebar-toggle">
<button id="sidebar-toggle-button"></button>
<div id="sidebar-toggle-title">fresh_type_variable</div>
</div>
<span id="main-contents">
<nav class="sidebar">
<h1><a href="../../../index.html">noir_stdlib</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2 id="crate-name"><a href="../../index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2>In module typ</h2>
<h3>Functions</h3><ul class="item-list">
<li><a href="fn.fresh_type_variable.html">fresh_type_variable</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">noir_stdlib</a> - <a href="../../index.html">std</a>::<a href="../index.html">meta</a>::<a href="index.html">typ</a></div>
<h1>Function <span class="fn">fresh_type_variable</span></h1>
<pre><code>pub comptime fn fresh_type_variable() -> <a href="../../../std/primitive.Type.html" class="primitive">Type</a></code></pre>

<div class="comments">
<p>Creates and returns an unbound type variable. This is a special kind of type internal
to type checking which will type check with any other type. When it is type checked
against another type it will also be set to that type. For example, if <code>a</code> is a type
variable and we have the type equality <code>(a, i32) = (u8, i32)</code>, the compiler will set
<code>a</code> equal to <code>u8</code>.</p>
<p>Unbound type variables will often be rendered as <code>_</code> while printing them. Bound type
variables will appear as the type they are bound to.</p>
<p>This can be used in conjunction with functions which internally perform type checks
such as <a href="../../../std/primitive.Type.html#implements"><code>Type::implements</code></a> or <a href="../../../std/primitive.Type.html#get_trait_impl"><code>Type::get_trait_impl</code></a> to potentially grab some of the types used.</p>
<p>Note that calling <a href="../../../std/primitive.Type.html#implements"><code>Type::implements</code></a> or <a href="../../../std/primitive.Type.html#get_trait_impl"><code>Type::get_trait_impl</code></a> on a type variable will always
fail.</p>
<p>Example:</p>
<pre><code><span class="kw">trait</span> Serialize&lt;<span class="kw">let</span> N: u32&gt; {}

<span class="kw">impl</span> Serialize&lt;<span class="number">1</span>&gt; <span class="kw">for</span> Field {}

<span class="kw">impl</span>&lt;T, <span class="kw">let</span> N: u32, <span class="kw">let</span> M: u32&gt; Serialize&lt;N * M&gt; <span class="kw">for</span> [T; N]
    <span class="kw">where</span> T: Serialize&lt;M&gt; {}

<span class="kw">impl</span>&lt;T, U, <span class="kw">let</span> N: u32, <span class="kw">let</span> M: u32&gt; Serialize&lt;N + M&gt; <span class="kw">for</span> (T, U)
    <span class="kw">where</span> T: Serialize&lt;N&gt;, U: Serialize&lt;M&gt; {}

<span class="kw">fn</span> fresh_variable_example() {
    <span class="kw">let</span> typevar1 = std::meta::typ::fresh_type_variable();
    <span class="kw">let</span> constraint = <span class="kw">quote</span> { Serialize&lt;$typevar1&gt; }.as_trait_constraint();
    <span class="kw">let</span> field_type = <span class="kw">quote</span> { Field }.as_type();

    <span class="comment">// Search for a trait impl (binding typevar1 to 1 when the impl is found):</span>
    <span class="kw">assert</span>(field_type.implements(constraint));

    <span class="comment">// typevar1 should be bound to the "1" generic now:</span>
    <span class="kw">assert_eq</span>(typevar1.as_constant().unwrap(), <span class="number">1</span>);

    <span class="comment">// If we want to do the same with a different type, we need to</span>
    <span class="comment">// create a new type variable now that `typevar1` is bound</span>
    <span class="kw">let</span> typevar2 = std::meta::typ::fresh_type_variable();
    <span class="kw">let</span> constraint = <span class="kw">quote</span> { Serialize&lt;$typevar2&gt; }.as_trait_constraint();
    <span class="kw">let</span> array_type = <span class="kw">quote</span> { [(Field, Field); <span class="number">5</span>] }.as_type();
    <span class="kw">assert</span>(array_type.implements(constraint));

    <span class="comment">// Now typevar2 should be bound to the serialized pair size 2 times the array length 5</span>
    <span class="kw">assert_eq</span>(typevar2.as_constant().unwrap(), <span class="number">10</span>);
}</code></pre></div>
</main>
</span>
</body>
</html>
