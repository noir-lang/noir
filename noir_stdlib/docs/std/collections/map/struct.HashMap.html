<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct HashMap documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">noir_stdlib</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2 id="crate-name"><a href="../../index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#struct">Struct HashMap</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#capacity">capacity</a></li>
<li><a href="#clear">clear</a></li>
<li><a href="#contains_key">contains_key</a></li>
<li><a href="#entries">entries</a></li>
<li><a href="#get">get</a></li>
<li><a href="#insert">insert</a></li>
<li><a href="#is_empty">is_empty</a></li>
<li><a href="#iter_keys_mut">iter_keys_mut</a></li>
<li><a href="#iter_mut">iter_mut</a></li>
<li><a href="#iter_values_mut">iter_values_mut</a></li>
<li><a href="#keys">keys</a></li>
<li><a href="#len">len</a></li>
<li><a href="#remove">remove</a></li>
<li><a href="#retain">retain</a></li>
<li><a href="#values">values</a></li>
<li><a href="#with_hasher">with_hasher</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-Default-for-HashMap<K, V, N, B>">Default</a></li>
<li><a href="#impl-Eq-for-HashMap<K, V, N, B>">Eq</a></li>
</ul>
<h2>In module map</h2>
<h3>Structs</h3><ul class="item-list">
<li><a href="struct.HashMap.html">HashMap</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">noir_stdlib</a> - <a href="../../index.html">std</a>::<a href="../index.html">collections</a>::<a href="index.html">map</a></div>
<h1>Struct <span id="struct" class="struct">HashMap</span></h1>
<pre><code>pub struct HashMap&lt;K, V, let N: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, B&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<div class="comments">
<p><code>HashMap&lt;Key, Value, MaxLen, Hasher&gt;</code> is used to efficiently store and look up key-value pairs.</p>
<p><code>HashMap</code> is a bounded type which can store anywhere from zero to <code>MaxLen</code> total elements.
Note that due to hash collisions, the actual maximum number of elements stored by any particular
hashmap is likely lower than <code>MaxLen</code>. This is true even with cryptographic hash functions since
every hash value will be performed modulo <code>MaxLen</code>.</p>
<p>Example:</p>
<pre><code class="language-noir">// Create a mapping from Fields to u32s with a maximum length of 12
// using a poseidon2 hasher
use std::hash::poseidon2::Poseidon2Hasher;
let mut map: HashMap&lt;Field, u32, 12, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();

map.insert(1, 2);
map.insert(3, 4);

let two = map.get(1).unwrap();
</code></pre>
</div>
<h2>Implementations</h2>
<h3><code class="code-header">impl&lt;B, K, let N: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, V&gt; <a href="../../../std/collections/map/struct.HashMap.html" class="struct">HashMap</a>&lt;K, V, N, B&gt;</code></h3>

<div class="padded-methods"><code id="with_hasher" class="code-header">pub fn <span class="fn">with_hasher</span>(_build_hasher: B) -> Self
<div class="where-clause">where
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Creates a hashmap with an existing <code>BuildHasher</code>. This can be used to ensure multiple
hashmaps are created with the same hasher instance.</p>
<p>Example:</p>
<pre><code class="language-noir">let my_hasher: BuildHasherDefault&lt;Poseidon2Hasher&gt; = Default::default();
let hashmap: HashMap&lt;u8, u32, 10, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::with_hasher(my_hasher);
assert(hashmap.is_empty());
</code></pre>
</div>
</div><code id="clear" class="code-header">pub fn <span class="fn">clear</span>(&mut self)</code>

<div class="padded-description"><div class="comments">
<p>Clears the hashmap, removing all key-value pairs from it.</p>
<p>Example:</p>
<pre><code class="language-noir">assert(!map.is_empty());
map.clear();
assert(map.is_empty());
</code></pre>
</div>
</div><code id="contains_key" class="code-header">pub fn <span class="fn">contains_key</span>(self, key: K) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a>
<div class="where-clause">where
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if the hashmap contains the given key. Unlike [<code>get</code>][Self::get], this will not also return
the value associated with the key.</p>
<p>Example:</p>
<pre><code class="language-noir">if map.contains_key(7) {
    let value = map.get(7);
    assert(value.is_some());
} else {
    println(&quot;No value for key 7!&quot;);
}
</code></pre>
</div>
</div><code id="is_empty" class="code-header">pub fn <span class="fn">is_empty</span>(self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns <code>true</code> if the length of the hash map is empty.</p>
<p>Example:</p>
<pre><code class="language-noir">assert(map.is_empty());

map.insert(1, 2);
assert(!map.is_empty());

map.remove(1);
assert(map.is_empty());
</code></pre>
</div>
</div><code id="entries" class="code-header">pub fn <span class="fn">entries</span>(self) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;(K, V), N&gt;</code>

<div class="padded-description"><div class="comments">
<p>Returns a vector of each key-value pair present in the hashmap.</p>
<p>The length of the returned vector is always equal to the length of the hashmap.</p>
<p>Example:</p>
<pre><code class="language-noir">let entries = map.entries();

// The length of a hashmap may not be compile-time known, so we
// need to loop over its capacity instead
for i in 0..map.capacity() {
    if i &lt; entries.len() {
        let (key, value) = entries.get(i);
        println(f&quot;{key} -&gt; {value}&quot;);
    }
}
</code></pre>
</div>
</div><code id="keys" class="code-header">pub fn <span class="fn">keys</span>(self) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;K, N&gt;</code>

<div class="padded-description"><div class="comments">
<p>Returns a vector of each key present in the hashmap.</p>
<p>The length of the returned vector is always equal to the length of the hashmap.</p>
<p>Example:</p>
<pre><code class="language-noir">let keys = map.keys();

for i in 0..keys.max_len() {
    if i &lt; keys.len() {
        let key = keys.get_unchecked(i);
        let value = map.get(key).unwrap_unchecked();
        println(f&quot;{key} -&gt; {value}&quot;);
    }
}
</code></pre>
</div>
</div><code id="values" class="code-header">pub fn <span class="fn">values</span>(self) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;V, N&gt;</code>

<div class="padded-description"><div class="comments">
<p>Returns a vector of each value present in the hashmap.</p>
<p>The length of the returned vector is always equal to the length of the hashmap.</p>
<p>Example:</p>
<pre><code class="language-noir">let values = map.values();

for i in 0..values.max_len() {
    if i &lt; values.len() {
        let value = values.get_unchecked(i);
        println(f&quot;Found value {value}&quot;);
    }
}
</code></pre>
</div>
</div><code id="iter_mut" class="code-header">pub fn <span class="fn">iter_mut</span>(&mut self, f: fn(K, V) -> (K, V))
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Iterates through each key-value pair of the HashMap, setting each key-value pair to the
result returned from the given function.</p>
<p>Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated
through. If this is not desired, use [<code>iter_values_mut</code>][Self::iter_values_mut] if only values need to be mutated,
or [<code>entries</code>][Self::entries] if neither keys nor values need to be mutated.</p>
<p>The iteration order is left unspecified. As a result, if two keys are mutated to become
equal, which of the two values that will be present for the key in the resulting map is also unspecified.</p>
<p>Example:</p>
<pre><code class="language-noir">// Add 1 to each key in the map, and double the value associated with that key.
map.iter_mut(|k, v| (k + 1, v * 2));
</code></pre>
</div>
</div><code id="iter_keys_mut" class="code-header">pub fn <span class="fn">iter_keys_mut</span>(&mut self, f: fn(K) -> K)
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Iterates through the HashMap, mutating each key to the result returned from
the given function.</p>
<p>Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated
through. If only iteration is desired and the keys are not intended to be mutated,
prefer using [<code>entries</code>][Self::entries] instead.</p>
<p>The iteration order is left unspecified. As a result, if two keys are mutated to become
equal, which of the two values that will be present for the key in the resulting map is also unspecified.</p>
<p>Example:</p>
<pre><code class="language-noir">// Double each key, leaving the value associated with that key untouched
map.iter_keys_mut(|k| k * 2);
</code></pre>
</div>
</div><code id="iter_values_mut" class="code-header">pub fn <span class="fn">iter_values_mut</span>(&mut self, f: fn(V) -> V)</code>

<div class="padded-description"><div class="comments">
<p>Iterates through the HashMap, applying the given function to each value and mutating the
value to equal the result. This function is more efficient than [<code>iter_mut</code>][Self::iter_mut] and [<code>iter_keys_mut</code>][Self::iter_keys_mut]
because the keys are untouched and the underlying hashmap thus does not need to be reordered.</p>
<p>Example:</p>
<pre><code class="language-noir">// Halve each value
map.iter_values_mut(|v| v / 2);
</code></pre>
</div>
</div><code id="retain" class="code-header">pub fn <span class="fn">retain</span>(&mut self, f: fn(K, V) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a>)</code>

<div class="padded-description"><div class="comments">
<p>Retains only the key-value pairs for which the given function returns true.
Any key-value pairs for which the function returns false will be removed from the map.</p>
<p>Example:</p>
<pre><code class="language-noir">map.retain(|k, v| (k != 0) &amp; (v != 0));
</code></pre>
</div>
</div><code id="len" class="code-header">pub fn <span class="fn">len</span>(self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the current length of this hash map.</p>
<p>Example:</p>
<pre><code class="language-noir">// This is equivalent to checking map.is_empty()
assert(map.len() == 0);

map.insert(1, 2);
map.insert(3, 4);
map.insert(5, 6);
assert(map.len() == 3);

// 3 was already present as a key in the hash map, so the length is unchanged
map.insert(3, 7);
assert(map.len() == 3);

map.remove(1);
assert(map.len() == 2);
</code></pre>
</div>
</div><code id="capacity" class="code-header">pub fn <span class="fn">capacity</span>(_self: Self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the maximum capacity of this hashmap. This is always equal to the capacity
specified in the hashmap's type.</p>
<p>Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a
static capacity that does not increase as the map grows larger. Thus, this capacity
is also the maximum possible element count that can be inserted into the hashmap.
Due to hash collisions (modulo the hashmap length), it is likely the actual maximum
element count will be lower than the full capacity.</p>
<p>Example:</p>
<pre><code class="language-noir">let empty_map: HashMap&lt;Field, Field, 42, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();
assert(empty_map.len() == 0);
assert(empty_map.capacity() == 42);
</code></pre>
</div>
</div><code id="get" class="code-header">pub fn <span class="fn">get</span>(self, key: K) -> <a href="../../../std/option/struct.Option.html" class="struct">Option</a>&lt;V&gt;
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Retrieves a value from the hashmap, returning <code>Option::none()</code> if it was not found.</p>
<p>Example:</p>
<pre><code class="language-noir">fn get_example(map: HashMap&lt;Field, Field, 5, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt;) {
    let x = map.get(12);

    if x.is_some() {
        assert(x.unwrap() == 42);
    }
}
</code></pre>
</div>
</div><code id="insert" class="code-header">pub fn <span class="fn">insert</span>(&mut self, key: K, value: V)
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Inserts a new key-value pair into the map. If the key was already in the map, its
previous value will be overridden with the newly provided one.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut map: HashMap&lt;Field, Field, 5, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();
map.insert(12, 42);
assert(map.len() == 1);
</code></pre>
</div>
</div><code id="remove" class="code-header">pub fn <span class="fn">remove</span>(&mut self, key: K)
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code>

<div class="padded-description"><div class="comments">
<p>Removes the given key-value pair from the map. If the key was not already present
in the map, this does nothing.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut map: HashMap&lt;Field, Field, 5, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();
map.insert(12, 42);
assert(!map.is_empty());

map.remove(12);
assert(map.is_empty());

// If a key was not present in the map, remove does nothing
map.remove(12);
assert(map.is_empty());
</code></pre>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Default-for-HashMap<K, V, N, B>"><code class="code-header">impl&lt;B, K, let N: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, V&gt; <a href="../../../std/default/trait.Default.html" class="trait">Default</a> for <a href="../../../std/collections/map/struct.HashMap.html" class="struct">HashMap</a>&lt;K, V, N, B&gt;
<div class="where-clause">where
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a>,
    B: <a href="../../../std/default/trait.Default.html" class="trait">Default</a></div></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">default</span>() -> Self</code>

<div class="padded-description"><div class="comments">
<p>Constructs an empty HashMap.</p>
<p>Example:</p>
<pre><code class="language-noir">let hashmap: HashMap&lt;u8, u32, 10, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();
assert(hashmap.is_empty());
</code></pre>
</div>
</div></div><h3 id="impl-Eq-for-HashMap<K, V, N, B>"><code class="code-header">impl&lt;B, K, let N: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, V&gt; <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../../../std/collections/map/struct.HashMap.html" class="struct">HashMap</a>&lt;K, V, N, B&gt;
<div class="where-clause">where
    K: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    K: <a href="../../../std/hash/trait.Hash.html" class="trait">Hash</a>,
    V: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a>,
    B: <a href="../../../std/hash/trait.BuildHasher.html" class="trait">BuildHasher</a></div></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">eq</span>(self, other: Self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Checks if two HashMaps are equal.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut map1: HashMap&lt;Field, u64, 4, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();
let mut map2: HashMap&lt;Field, u64, 4, BuildHasherDefault&lt;Poseidon2Hasher&gt;&gt; = HashMap::default();

map1.insert(1, 2);
map1.insert(3, 4);

map2.insert(3, 4);
map2.insert(1, 2);

assert(map1 == map2);
</code></pre>
</div>
</div></div></main>
</body>
</html>
