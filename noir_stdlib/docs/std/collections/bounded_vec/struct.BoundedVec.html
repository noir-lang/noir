<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<title>Struct BoundedVec documentation</title>
</head>
<body>
<nav class="sidebar">
<h1><a href="../../../index.html">noir_stdlib</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2 id="crate-name"><a href="../../index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#struct">Struct BoundedVec</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#any">any</a></li>
<li><a href="#extend_from_array">extend_from_array</a></li>
<li><a href="#extend_from_bounded_vec">extend_from_bounded_vec</a></li>
<li><a href="#extend_from_slice">extend_from_slice</a></li>
<li><a href="#for_each">for_each</a></li>
<li><a href="#for_eachi">for_eachi</a></li>
<li><a href="#from_array">from_array</a></li>
<li><a href="#from_parts">from_parts</a></li>
<li><a href="#from_parts_unchecked">from_parts_unchecked</a></li>
<li><a href="#get">get</a></li>
<li><a href="#get_unchecked">get_unchecked</a></li>
<li><a href="#len">len</a></li>
<li><a href="#map">map</a></li>
<li><a href="#mapi">mapi</a></li>
<li><a href="#max_len">max_len</a></li>
<li><a href="#new">new</a></li>
<li><a href="#pop">pop</a></li>
<li><a href="#push">push</a></li>
<li><a href="#set">set</a></li>
<li><a href="#set_unchecked">set_unchecked</a></li>
<li><a href="#storage">storage</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-Eq-for-BoundedVec<T, MaxLen>">Eq</a></li>
<li><a href="#impl-From&lt;[T; Len]&gt;-for-BoundedVec<T, MaxLen>">From&lt;[T; Len]&gt;</a></li>
</ul>
<h2>In module bounded_vec</h2>
<h3>Structs</h3><ul class="item-list">
<li><a href="struct.BoundedVec.html">BoundedVec</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">noir_stdlib</a> - <a href="../../index.html">std</a>::<a href="../index.html">collections</a>::<a href="index.html">bounded_vec</a></div>
<h1>Struct <span id="struct" class="struct">BoundedVec</span></h1>
<pre><code>pub struct BoundedVec&lt;T, let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<div class="comments">
<p>A <code>BoundedVec&lt;T, MaxLen&gt;</code> is a growable storage similar to a [<code>Vec</code>][crate::collections::vec::Vec]<code>&lt;T&gt;</code> except that it
is bounded with a maximum possible length. Unlike <code>Vec</code>, <code>BoundedVec</code> is not implemented
via slices and thus is not subject to the same restrictions slices are (notably, nested
slices - and thus nested vectors as well - are disallowed).</p>
<p>Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by
pushing an additional element is also more efficient - the length only needs to be increased
by one.</p>
<p>For these reasons <code>BoundedVec&lt;T, N&gt;</code> should generally be preferred over <code>Vec&lt;T&gt;</code> when there
is a reasonable maximum bound that can be placed on the vector.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut vector: BoundedVec&lt;Field, 10&gt; = BoundedVec::new();
for i in 0..5 {
    vector.push(i);
}
assert(vector.len() == 5);
assert(vector.max_len() == 10);
</code></pre>
</div>
<h2>Implementations</h2>
<h3><code class="code-header">impl&lt;let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;</code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <span class="fn">new</span>() -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new, empty vector of length zero.</p>
<p>Since this container is backed by an array internally, it still needs an initial value
to give each element. To resolve this, each element is zeroed internally. This value
is guaranteed to be inaccessible unless <code>get_unchecked</code> is used.</p>
<p>Example:</p>
<pre><code class="language-noir">let empty_vector: BoundedVec&lt;Field, 10&gt; = BoundedVec::new();
assert(empty_vector.len() == 0);
</code></pre>
<p>Note that whenever calling <code>new</code> the maximum length of the vector should always be specified
via a type signature:</p>
<pre><code class="language-noir">fn good() -&gt; BoundedVec&lt;Field, 10&gt; {
    // Ok! MaxLen is specified with a type annotation
    let v1: BoundedVec&lt;Field, 3&gt; = BoundedVec::new();
    let v2 = BoundedVec::new();

    // Ok! MaxLen is known from the type of `good`'s return value
    v2
}

fn bad() {
    // Error: Type annotation needed
    // The compiler can't infer `MaxLen` from the following code:
    let mut v3 = BoundedVec::new();
    v3.push(5);
}
</code></pre>
<p>This defaulting of <code>MaxLen</code> (and numeric generics in general) to zero may change in future noir versions
but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a
constraint failure at runtime when the vec is pushed to.</p>
</div>
</div><code id="get" class="code-header">pub fn <span class="fn">get</span>(self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> T</code>

<div class="padded-description"><div class="comments">
<p>Retrieves an element from the vector at the given index, starting from zero.</p>
<p>If the given index is equal to or greater than the length of the vector, this
will issue a constraint failure.</p>
<p>Example:</p>
<pre><code class="language-noir">fn foo&lt;let N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) {
    let first = v.get(0);
    let last = v.get(v.len() - 1);
    assert(first != last);
}
</code></pre>
</div>
</div><code id="get_unchecked" class="code-header">pub fn <span class="fn">get_unchecked</span>(self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> T</code>

<div class="padded-description"><div class="comments">
<p>Retrieves an element from the vector at the given index, starting from zero, without
performing a bounds check.</p>
<p>Since this function does not perform a bounds check on length before accessing the element,
it is unsafe! Use at your own risk!</p>
<p>Example:</p>
<pre><code class="language-noir">fn sum_of_first_three&lt;let N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) -&gt; u32 {
    // Always ensure the length is larger than the largest
    // index passed to get_unchecked
    assert(v.len() &gt; 2);
    let first = v.get_unchecked(0);
    let second = v.get_unchecked(1);
    let third = v.get_unchecked(2);
    first + second + third
}
</code></pre>
</div>
</div><code id="set" class="code-header">pub fn <span class="fn">set</span>(&mut self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, value: T)</code>

<div class="padded-description"><div class="comments">
<p>Writes an element to the vector at the given index, starting from zero.</p>
<p>If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.</p>
<p>Example:</p>
<pre><code class="language-noir">fn foo&lt;let N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) {
    let first = v.get(0);
    assert(first != 42);
    v.set(0, 42);
    let new_first = v.get(0);
    assert(new_first == 42);
}
</code></pre>
</div>
</div><code id="set_unchecked" class="code-header">pub fn <span class="fn">set_unchecked</span>(&mut self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, value: T)</code>

<div class="padded-description"><div class="comments">
<p>Writes an element to the vector at the given index, starting from zero, without performing a bounds check.</p>
<p>Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!</p>
<p>Example:</p>
<pre><code class="language-noir">fn set_unchecked_example() {
    let mut vec: BoundedVec&lt;u32, 5&gt; = BoundedVec::new();
    vec.extend_from_array([1, 2]);

    // Here we're safely writing within the valid range of `vec`
    // `vec` now has the value [42, 2]
    vec.set_unchecked(0, 42);

    // We can then safely read this value back out of `vec`.
    // Notice that we use the checked version of `get` which would prevent reading unsafe values.
    assert_eq(vec.get(0), 42);

    // We've now written past the end of `vec`.
    // As this index is still within the maximum potential length of `v`,
    // it won't cause a constraint failure.
    vec.set_unchecked(2, 42);
    println(vec);

    // This will write past the end of the maximum potential length of `vec`,
    // it will then trigger a constraint failure.
    vec.set_unchecked(5, 42);
    println(vec);
}
</code></pre>
</div>
</div><code id="push" class="code-header">pub fn <span class="fn">push</span>(&mut self, elem: T)</code>

<div class="padded-description"><div class="comments">
<p>Pushes an element to the end of the vector. This increases the length
of the vector by one.</p>
<p>Panics if the new length of the vector will be greater than the max length.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;Field, 2&gt; = BoundedVec::new();

v.push(1);
v.push(2);

// Panics with failed assertion &quot;push out of bounds&quot;
v.push(3);
</code></pre>
</div>
</div><code id="len" class="code-header">pub fn <span class="fn">len</span>(self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the current length of this vector</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;Field, 4&gt; = BoundedVec::new();
assert(v.len() == 0);

v.push(100);
assert(v.len() == 1);

v.push(200);
v.push(300);
v.push(400);
assert(v.len() == 4);

let _ = v.pop();
let _ = v.pop();
assert(v.len() == 2);
</code></pre>
</div>
</div><code id="max_len" class="code-header">pub fn <span class="fn">max_len</span>(_self: Self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the maximum length of this vector. This is always
equal to the <code>MaxLen</code> parameter this vector was initialized with.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;Field, 5&gt; = BoundedVec::new();

assert(v.max_len() == 5);
v.push(10);
assert(v.max_len() == 5);
</code></pre>
</div>
</div><code id="storage" class="code-header">pub fn <span class="fn">storage</span>(self) -> [T; MaxLen]</code>

<div class="padded-description"><div class="comments">
<p>Returns the internal array within this vector.</p>
<p>Since arrays in Noir are immutable, mutating the returned storage array will not mutate
the storage held internally by this vector.</p>
<p>Note that uninitialized elements may be zeroed out!</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;Field, 5&gt; = BoundedVec::new();

assert(v.storage() == [0, 0, 0, 0, 0]);

v.push(57);
assert(v.storage() == [57, 0, 0, 0, 0]);
</code></pre>
</div>
</div><code id="extend_from_array" class="code-header">pub fn <span class="fn">extend_from_array</span>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(&mut self, array: [T; Len])</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the given array to this vector.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut vec: BoundedVec&lt;Field, 3&gt; = BoundedVec::new();
vec.extend_from_array([2, 4]);

assert(vec.len == 2);
assert(vec.get(0) == 2);
assert(vec.get(1) == 4);
</code></pre>
</div>
</div><code id="extend_from_slice" class="code-header">pub fn <span class="fn">extend_from_slice</span>(&mut self, slice: [T])</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the given slice to this vector.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut vec: BoundedVec&lt;Field, 3&gt; = BoundedVec::new();
vec.extend_from_slice(&amp;[2, 4]);

assert(vec.len == 2);
assert(vec.get(0) == 2);
assert(vec.get(1) == 4);
</code></pre>
</div>
</div><code id="extend_from_bounded_vec" class="code-header">pub fn <span class="fn">extend_from_bounded_vec</span>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(&mut self, vec: <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, Len&gt;)</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the other vector to this vector. The length of
the other vector is left unchanged.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<pre><code class="language-noir">let mut v1: BoundedVec&lt;Field, 5&gt; = BoundedVec::new();
let mut v2: BoundedVec&lt;Field, 7&gt; = BoundedVec::new();

v2.extend_from_array([1, 2, 3]);
v1.extend_from_bounded_vec(v2);

assert(v1.storage() == [1, 2, 3, 0, 0]);
assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);
</code></pre>
</div>
</div><code id="from_array" class="code-header">pub fn <span class="fn">from_array</span>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(array: [T; Len]) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector, populating it with values derived from an array input.
The maximum length of the vector is determined based on the type signature.</p>
<p>Example:</p>
<pre><code class="language-noir">let bounded_vec: BoundedVec&lt;Field, 10&gt; = BoundedVec::from_array([1, 2, 3])
</code></pre>
</div>
</div><code id="pop" class="code-header">pub fn <span class="fn">pop</span>(&mut self) -> T</code>

<div class="padded-description"><div class="comments">
<p>Pops the element at the end of the vector. This will decrease the length
of the vector by one.</p>
<p>Panics if the vector is empty.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;Field, 2&gt; = BoundedVec::new();
v.push(1);
v.push(2);

let two = v.pop();
let one = v.pop();

assert(two == 2);
assert(one == 1);

// error: cannot pop from an empty vector
let _ = v.pop();
</code></pre>
</div>
</div><code id="any" class="code-header">pub fn <span class="fn">any</span>&lt;Env&gt;(self, predicate: fn[Env](T) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a>) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns true if the given predicate returns true for any element
in this vector.</p>
<p>Example:</p>
<pre><code class="language-noir">let mut v: BoundedVec&lt;u32, 3&gt; = BoundedVec::new();
v.extend_from_array([2, 4, 6]);

let all_even = !v.any(|elem: u32| elem % 2 != 0);
assert(all_even);
</code></pre>
</div>
</div><code id="map" class="code-header">pub fn <span class="fn">map</span>&lt;U, Env&gt;(self, f: fn[Env](T) -> U) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;U, MaxLen&gt;</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector of equal size by calling a closure on each element in this vector.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_array([1, 2, 3, 4]);
let result = vec.map(|value| value * 2);

let expected = BoundedVec::from_array([2, 4, 6, 8]);
assert_eq(result, expected);
</code></pre>
</div>
</div><code id="mapi" class="code-header">pub fn <span class="fn">mapi</span>&lt;U, Env&gt;(self, f: fn[Env](<a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T) -> U) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;U, MaxLen&gt;</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector of equal size by calling a closure on each element
in this vector, along with its index.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_array([1, 2, 3, 4]);
let result = vec.mapi(|i, value| i + value * 2);

let expected = BoundedVec::from_array([2, 5, 8, 11]);
assert_eq(result, expected);
</code></pre>
</div>
</div><code id="for_each" class="code-header">pub fn <span class="fn">for_each</span>&lt;Env&gt;(self, f: fn[Env](T))</code>

<div class="padded-description"><div class="comments">
<p>Calls a closure on each element in this vector.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_array([1, 2, 3, 4]);
let mut result = BoundedVec::&lt;u32, 4&gt;::new();
vec.for_each(|value| result.push(value * 2));

let expected = BoundedVec::from_array([2, 4, 6, 8]);
assert_eq(result, expected);
</code></pre>
</div>
</div><code id="for_eachi" class="code-header">pub fn <span class="fn">for_eachi</span>&lt;Env&gt;(self, f: fn[Env](<a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T))</code>

<div class="padded-description"><div class="comments">
<p>Calls a closure on each element in this vector, along with its index.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_array([1, 2, 3, 4]);
let mut result = BoundedVec::&lt;u32, 4&gt;::new();
vec.for_eachi(|i, value| result.push(i + value * 2));

let expected = BoundedVec::from_array([2, 5, 8, 11]);
assert_eq(result, expected);
</code></pre>
</div>
</div><code id="from_parts" class="code-header">pub fn <span class="fn">from_parts</span>(array: [T; MaxLen], len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new BoundedVec from the given array and length.
The given length must be less than or equal to the length of the array.</p>
<p>This function will zero out any elements at or past index <code>len</code> of <code>array</code>.
This incurs an extra runtime cost of O(MaxLen). If you are sure your array is
zeroed after that index, you can use [<code>from_parts_unchecked</code>][Self::from_parts_unchecked] to remove the extra loop.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_parts([1, 2, 3, 0], 3);
assert_eq(vec.len(), 3);
</code></pre>
</div>
</div><code id="from_parts_unchecked" class="code-header">pub fn <span class="fn">from_parts_unchecked</span>(array: [T; MaxLen], len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new BoundedVec from the given array and length.
The given length must be less than or equal to the length of the array.</p>
<p>This function is unsafe because it expects all elements past the <code>len</code> index
of <code>array</code> to be zeroed, but does not check for this internally. Use <code>from_parts</code>
for a safe version of this function which does zero out any indices past the
given length. Invalidating this assumption can notably cause <code>BoundedVec::eq</code>
to give incorrect results since it will check even elements past <code>len</code>.</p>
<p>Example:</p>
<pre><code class="language-noir">let vec: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);
assert_eq(vec.len(), 3);

// invalid use!
let vec1: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);
let vec2: BoundedVec&lt;u32, 4&gt; = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);

// both vecs have length 3 so we'd expect them to be equal, but this
// fails because elements past the length are still checked in eq
assert_eq(vec1, vec2); // fails
</code></pre>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Eq-for-BoundedVec<T, MaxLen>"><code class="code-header">impl&lt;let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;
<div class="where-clause">where
    T: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a></div></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">eq</span>(self, other: Self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

</div><h3 id="impl-From&lt;[T; Len]&gt;-for-BoundedVec<T, MaxLen>"><code class="code-header">impl&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/convert/trait.From.html" class="trait">From</a>&lt;[T; Len]&gt; for <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">from</span>(array: [T; Len]) -> Self</code>

</div></main>
</body>
</html>
