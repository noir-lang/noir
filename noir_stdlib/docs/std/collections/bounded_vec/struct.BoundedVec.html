<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../../../styles.css">
<script defer src="../../../nargo_doc.js"></script>
<title>Struct BoundedVec documentation</title>
</head>
<body>
<div id="sidebar-toggle">
<button id="sidebar-toggle-button"></button>
<div id="sidebar-toggle-title">BoundedVec</div>
</div>
<span id="main-contents">
<nav class="sidebar">
<h1><a href="../../../index.html">noir_stdlib</a></h1>
<div><a href="../../../all.html">All items</a></div>
<h2 id="crate-name"><a href="../../index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#struct">Struct BoundedVec</a></h2>
<h3>Methods</h3>
<ul class="sidebar-vector">
<li><a href="#any">any</a></li>
<li><a href="#extend_from_array">extend_from_array</a></li>
<li><a href="#extend_from_bounded_vec">extend_from_bounded_vec</a></li>
<li><a href="#extend_from_slice">extend_from_slice</a></li>
<li><a href="#for_each">for_each</a></li>
<li><a href="#for_eachi">for_eachi</a></li>
<li><a href="#from_array">from_array</a></li>
<li><a href="#from_parts">from_parts</a></li>
<li><a href="#from_parts_unchecked">from_parts_unchecked</a></li>
<li><a href="#get">get</a></li>
<li><a href="#get_unchecked">get_unchecked</a></li>
<li><a href="#len">len</a></li>
<li><a href="#map">map</a></li>
<li><a href="#mapi">mapi</a></li>
<li><a href="#max_len">max_len</a></li>
<li><a href="#new">new</a></li>
<li><a href="#pop">pop</a></li>
<li><a href="#push">push</a></li>
<li><a href="#set">set</a></li>
<li><a href="#set_unchecked">set_unchecked</a></li>
<li><a href="#storage">storage</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-vector">
<li><a href="#impl-Eq-for-BoundedVec<T, MaxLen>">Eq</a></li>
<li><a href="#impl-From&lt;[T; Len]&gt;-for-BoundedVec<T, MaxLen>">From&lt;[T; Len]&gt;</a></li>
</ul>
<h2>In module bounded_vec</h2>
<h3>Structs</h3><ul class="item-vector">
<li><a href="struct.BoundedVec.html">BoundedVec</a></div></li>
</ul>
</nav>
<main>
<div><a href="../../../index.html">noir_stdlib</a> - <a href="../../index.html">std</a>::<a href="../index.html">collections</a>::<a href="index.html">bounded_vec</a></div>
<h1>Struct <span id="struct" class="struct">BoundedVec</span></h1>
<pre><code>pub struct BoundedVec&lt;T, let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;
{ <span class="comment">/* private fields */</span> }
</code></pre>
<div class="comments">
<p>A <code>BoundedVec&lt;T, MaxLen&gt;</code> is a growable storage similar to a <a href="../../../std/collections/vec/struct.Vec.html"><code>Vec</code></a><code>&lt;T&gt;</code> except that it
is bounded with a maximum possible length. Unlike <code>Vec</code>, <code>BoundedVec</code> is not implemented
via slices and thus is not subject to the same restrictions slices are (notably, nested
slices - and thus nested vectors as well - are disallowed).</p>
<p>Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by
pushing an additional element is also more efficient - the length only needs to be increased
by one.</p>
<p>For these reasons <code>BoundedVec&lt;T, N&gt;</code> should generally be preferred over <code>Vec&lt;T&gt;</code> when there
is a reasonable maximum bound that can be placed on the vector.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> vector: BoundedVec&lt;Field, <span class="number">10</span>&gt; = BoundedVec::new();
<span class="kw">for</span> i <span class="kw">in</span> <span class="number">0</span>..<span class="number">5</span> {
    vector.push(i);
}
<span class="kw">assert</span>(vector.len() == <span class="number">5</span>);
<span class="kw">assert</span>(vector.max_len() == <span class="number">10</span>);</code></pre></div>
<h2>Implementations</h2>
<h3><code class="code-header">impl&lt;let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;</code></h3>

<div class="padded-methods"><code id="new" class="code-header">pub fn <a href="#new"><span class="fn">new</span></a>() -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new, empty vector of length zero.</p>
<p>Since this container is backed by an array internally, it still needs an initial value
to give each element. To resolve this, each element is zeroed internally. This value
is guaranteed to be inaccessible unless <code>get_unchecked</code> is used.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> empty_vector: BoundedVec&lt;Field, <span class="number">10</span>&gt; = BoundedVec::new();
<span class="kw">assert</span>(empty_vector.len() == <span class="number">0</span>);</code></pre>
<p>Note that whenever calling <code>new</code> the maximum length of the vector should always be specified
via a type signature:</p>
<pre><code><span class="kw">fn</span> good() -&gt; BoundedVec&lt;Field, <span class="number">10</span>&gt; {
    <span class="comment">// Ok! MaxLen is specified with a type annotation</span>
    <span class="kw">let</span> v1: BoundedVec&lt;Field, <span class="number">3</span>&gt; = BoundedVec::new();
    <span class="kw">let</span> v2 = BoundedVec::new();

    <span class="comment">// Ok! MaxLen is known from the type of `good`'s return value</span>
    v2
}

<span class="kw">fn</span> bad() {
    <span class="comment">// Error: Type annotation needed</span>
    <span class="comment">// The compiler can't infer `MaxLen` from the following code:</span>
    <span class="kw">let</span> <span class="kw">mut</span> v3 = BoundedVec::new();
    v3.push(<span class="number">5</span>);
}</code></pre>
<p>This defaulting of <code>MaxLen</code> (and numeric generics in general) to zero may change in future noir versions
but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a
constraint failure at runtime when the vec is pushed to.</p></div>
</div><code id="get" class="code-header">pub fn <a href="#get"><span class="fn">get</span></a>(self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> T</code>

<div class="padded-description"><div class="comments">
<p>Retrieves an element from the vector at the given index, starting from zero.</p>
<p>If the given index is equal to or greater than the length of the vector, this
will issue a constraint failure.</p>
<p>Example:</p>
<pre><code><span class="kw">fn</span> foo&lt;<span class="kw">let</span> N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) {
    <span class="kw">let</span> first = v.get(<span class="number">0</span>);
    <span class="kw">let</span> last = v.get(v.len() - <span class="number">1</span>);
    <span class="kw">assert</span>(first != last);
}</code></pre></div>
</div><code id="get_unchecked" class="code-header">pub fn <a href="#get_unchecked"><span class="fn">get_unchecked</span></a>(self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> T</code>

<div class="padded-description"><div class="comments">
<p>Retrieves an element from the vector at the given index, starting from zero, without
performing a bounds check.</p>
<p>Since this function does not perform a bounds check on length before accessing the element,
it is unsafe! Use at your own risk!</p>
<p>Example:</p>
<pre><code><span class="kw">fn</span> sum_of_first_three&lt;<span class="kw">let</span> N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) -&gt; u32 {
    <span class="comment">// Always ensure the length is larger than the largest</span>
    <span class="comment">// index passed to get_unchecked</span>
    <span class="kw">assert</span>(v.len() &gt; <span class="number">2</span>);
    <span class="kw">let</span> first = v.get_unchecked(<span class="number">0</span>);
    <span class="kw">let</span> second = v.get_unchecked(<span class="number">1</span>);
    <span class="kw">let</span> third = v.get_unchecked(<span class="number">2</span>);
    first + second + third
}</code></pre></div>
</div><code id="set" class="code-header">pub fn <a href="#set"><span class="fn">set</span></a>(&mut self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, value: T)</code>

<div class="padded-description"><div class="comments">
<p>Writes an element to the vector at the given index, starting from zero.</p>
<p>If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.</p>
<p>Example:</p>
<pre><code><span class="kw">fn</span> foo&lt;<span class="kw">let</span> N: u32&gt;(v: BoundedVec&lt;u32, N&gt;) {
    <span class="kw">let</span> first = v.get(<span class="number">0</span>);
    <span class="kw">assert</span>(first != <span class="number">42</span>);
    v.set(<span class="number">0</span>, <span class="number">42</span>);
    <span class="kw">let</span> new_first = v.get(<span class="number">0</span>);
    <span class="kw">assert</span>(new_first == <span class="number">42</span>);
}</code></pre></div>
</div><code id="set_unchecked" class="code-header">pub fn <a href="#set_unchecked"><span class="fn">set_unchecked</span></a>(&mut self, index: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, value: T)</code>

<div class="padded-description"><div class="comments">
<p>Writes an element to the vector at the given index, starting from zero, without performing a bounds check.</p>
<p>Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!</p>
<p>Example:</p>
<pre><code><span class="kw">fn</span> set_unchecked_example() {
    <span class="kw">let</span> <span class="kw">mut</span> vec: BoundedVec&lt;u32, <span class="number">5</span>&gt; = BoundedVec::new();
    vec.extend_from_array([<span class="number">1</span>, <span class="number">2</span>]);

    <span class="comment">// Here we're safely writing within the valid range of `vec`</span>
    <span class="comment">// `vec` now has the value [42, 2]</span>
    vec.set_unchecked(<span class="number">0</span>, <span class="number">42</span>);

    <span class="comment">// We can then safely read this value back out of `vec`.</span>
    <span class="comment">// Notice that we use the checked version of `get` which would prevent reading unsafe values.</span>
    <span class="kw">assert_eq</span>(vec.get(<span class="number">0</span>), <span class="number">42</span>);

    <span class="comment">// We've now written past the end of `vec`.</span>
    <span class="comment">// As this index is still within the maximum potential length of `v`,</span>
    <span class="comment">// it won't cause a constraint failure.</span>
    vec.set_unchecked(<span class="number">2</span>, <span class="number">42</span>);
    println(vec);

    <span class="comment">// This will write past the end of the maximum potential length of `vec`,</span>
    <span class="comment">// it will then trigger a constraint failure.</span>
    vec.set_unchecked(<span class="number">5</span>, <span class="number">42</span>);
    println(vec);
}</code></pre></div>
</div><code id="push" class="code-header">pub fn <a href="#push"><span class="fn">push</span></a>(&mut self, elem: T)</code>

<div class="padded-description"><div class="comments">
<p>Pushes an element to the end of the vector. This increases the length
of the vector by one.</p>
<p>Panics if the new length of the vector will be greater than the max length.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;Field, <span class="number">2</span>&gt; = BoundedVec::new();

v.push(<span class="number">1</span>);
v.push(<span class="number">2</span>);

<span class="comment">// Panics with failed assertion "push out of bounds"</span>
v.push(<span class="number">3</span>);</code></pre></div>
</div><code id="len" class="code-header">pub fn <a href="#len"><span class="fn">len</span></a>(self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the current length of this vector</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;Field, <span class="number">4</span>&gt; = BoundedVec::new();
<span class="kw">assert</span>(v.len() == <span class="number">0</span>);

v.push(<span class="number">100</span>);
<span class="kw">assert</span>(v.len() == <span class="number">1</span>);

v.push(<span class="number">200</span>);
v.push(<span class="number">300</span>);
v.push(<span class="number">400</span>);
<span class="kw">assert</span>(v.len() == <span class="number">4</span>);

<span class="kw">let</span> _ = v.pop();
<span class="kw">let</span> _ = v.pop();
<span class="kw">assert</span>(v.len() == <span class="number">2</span>);</code></pre></div>
</div><code id="max_len" class="code-header">pub fn <a href="#max_len"><span class="fn">max_len</span></a>(_self: Self) -> <a href="../../../std/primitive.u32.html" class="primitive">u32</a></code>

<div class="padded-description"><div class="comments">
<p>Returns the maximum length of this vector. This is always
equal to the <code>MaxLen</code> parameter this vector was initialized with.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;Field, <span class="number">5</span>&gt; = BoundedVec::new();

<span class="kw">assert</span>(v.max_len() == <span class="number">5</span>);
v.push(<span class="number">10</span>);
<span class="kw">assert</span>(v.max_len() == <span class="number">5</span>);</code></pre></div>
</div><code id="storage" class="code-header">pub fn <a href="#storage"><span class="fn">storage</span></a>(self) -> [T; MaxLen]</code>

<div class="padded-description"><div class="comments">
<p>Returns the internal array within this vector.</p>
<p>Since arrays in Noir are immutable, mutating the returned storage array will not mutate
the storage held internally by this vector.</p>
<p>Note that uninitialized elements may be zeroed out!</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;Field, <span class="number">5</span>&gt; = BoundedVec::new();

<span class="kw">assert</span>(v.storage() == [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);

v.push(<span class="number">57</span>);
<span class="kw">assert</span>(v.storage() == [<span class="number">57</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div><code id="extend_from_array" class="code-header">pub fn <a href="#extend_from_array"><span class="fn">extend_from_array</span></a>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(&mut self, array: [T; Len])</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the given array to this vector.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> vec: BoundedVec&lt;Field, <span class="number">3</span>&gt; = BoundedVec::new();
vec.extend_from_array([<span class="number">2</span>, <span class="number">4</span>]);

<span class="kw">assert</span>(vec.len == <span class="number">2</span>);
<span class="kw">assert</span>(vec.get(<span class="number">0</span>) == <span class="number">2</span>);
<span class="kw">assert</span>(vec.get(<span class="number">1</span>) == <span class="number">4</span>);</code></pre></div>
</div><code id="extend_from_slice" class="code-header">pub fn <a href="#extend_from_slice"><span class="fn">extend_from_slice</span></a>(&mut self, slice: [T])</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the given slice to this vector.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> vec: BoundedVec&lt;Field, <span class="number">3</span>&gt; = BoundedVec::new();
vec.extend_from_slice(&[<span class="number">2</span>, <span class="number">4</span>]);

<span class="kw">assert</span>(vec.len == <span class="number">2</span>);
<span class="kw">assert</span>(vec.get(<span class="number">0</span>) == <span class="number">2</span>);
<span class="kw">assert</span>(vec.get(<span class="number">1</span>) == <span class="number">4</span>);</code></pre></div>
</div><code id="extend_from_bounded_vec" class="code-header">pub fn <a href="#extend_from_bounded_vec"><span class="fn">extend_from_bounded_vec</span></a>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(&mut self, vec: <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, Len&gt;)</code>

<div class="padded-description"><div class="comments">
<p>Pushes each element from the other vector to this vector. The length of
the other vector is left unchanged.</p>
<p>Panics if pushing each element would cause the length of this vector
to exceed the maximum length.</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v1: BoundedVec&lt;Field, <span class="number">5</span>&gt; = BoundedVec::new();
<span class="kw">let</span> <span class="kw">mut</span> v2: BoundedVec&lt;Field, <span class="number">7</span>&gt; = BoundedVec::new();

v2.extend_from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
v1.extend_from_bounded_vec(v2);

<span class="kw">assert</span>(v1.storage() == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="kw">assert</span>(v2.storage() == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div><code id="from_array" class="code-header">pub fn <a href="#from_array"><span class="fn">from_array</span></a>&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>&gt;(array: [T; Len]) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector, populating it with values derived from an array input.
The maximum length of the vector is determined based on the type signature.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> bounded_vec: BoundedVec&lt;Field, <span class="number">10</span>&gt; = BoundedVec::from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</code></pre></div>
</div><code id="pop" class="code-header">pub fn <a href="#pop"><span class="fn">pop</span></a>(&mut self) -> T</code>

<div class="padded-description"><div class="comments">
<p>Pops the element at the end of the vector. This will decrease the length
of the vector by one.</p>
<p>Panics if the vector is empty.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;Field, <span class="number">2</span>&gt; = BoundedVec::new();
v.push(<span class="number">1</span>);
v.push(<span class="number">2</span>);

<span class="kw">let</span> two = v.pop();
<span class="kw">let</span> one = v.pop();

<span class="kw">assert</span>(two == <span class="number">2</span>);
<span class="kw">assert</span>(one == <span class="number">1</span>);

<span class="comment">// error: cannot pop from an empty vector</span>
<span class="kw">let</span> _ = v.pop();</code></pre></div>
</div><code id="any" class="code-header">pub fn <a href="#any"><span class="fn">any</span></a>&lt;Env&gt;(self, predicate: fn[Env](T) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a>) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

<div class="padded-description"><div class="comments">
<p>Returns true if the given predicate returns true for any element
in this vector.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> <span class="kw">mut</span> v: BoundedVec&lt;u32, <span class="number">3</span>&gt; = BoundedVec::new();
v.extend_from_array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]);

<span class="kw">let</span> all_even = !v.any(|elem: u32| elem % <span class="number">2</span> != <span class="number">0</span>);
<span class="kw">assert</span>(all_even);</code></pre></div>
</div><code id="map" class="code-header">pub fn <a href="#map"><span class="fn">map</span></a>&lt;U, Env&gt;(self, f: fn[Env](T) -> U) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;U, MaxLen&gt;</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector of equal size by calling a closure on each element in this vector.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">let</span> result = vec.map(|value| value * <span class="number">2</span>);

<span class="kw">let</span> expected = BoundedVec::from_array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);
<span class="kw">assert_eq</span>(result, expected);</code></pre></div>
</div><code id="mapi" class="code-header">pub fn <a href="#mapi"><span class="fn">mapi</span></a>&lt;U, Env&gt;(self, f: fn[Env](<a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T) -> U) -> <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;U, MaxLen&gt;</code>

<div class="padded-description"><div class="comments">
<p>Creates a new vector of equal size by calling a closure on each element
in this vector, along with its index.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">let</span> result = vec.mapi(|i, value| i + value * <span class="number">2</span>);

<span class="kw">let</span> expected = BoundedVec::from_array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>]);
<span class="kw">assert_eq</span>(result, expected);</code></pre></div>
</div><code id="for_each" class="code-header">pub fn <a href="#for_each"><span class="fn">for_each</span></a>&lt;Env&gt;(self, f: fn[Env](T))</code>

<div class="padded-description"><div class="comments">
<p>Calls a closure on each element in this vector.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">let</span> <span class="kw">mut</span> result = BoundedVec::&lt;u32, <span class="number">4</span>&gt;::new();
vec.for_each(|value| result.push(value * <span class="number">2</span>));

<span class="kw">let</span> expected = BoundedVec::from_array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);
<span class="kw">assert_eq</span>(result, expected);</code></pre></div>
</div><code id="for_eachi" class="code-header">pub fn <a href="#for_eachi"><span class="fn">for_eachi</span></a>&lt;Env&gt;(self, f: fn[Env](<a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T))</code>

<div class="padded-description"><div class="comments">
<p>Calls a closure on each element in this vector, along with its index.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="kw">let</span> <span class="kw">mut</span> result = BoundedVec::&lt;u32, <span class="number">4</span>&gt;::new();
vec.for_eachi(|i, value| result.push(i + value * <span class="number">2</span>));

<span class="kw">let</span> expected = BoundedVec::from_array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>]);
<span class="kw">assert_eq</span>(result, expected);</code></pre></div>
</div><code id="from_parts" class="code-header">pub fn <a href="#from_parts"><span class="fn">from_parts</span></a>(array: [T; MaxLen], len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new BoundedVec from the given array and length.
The given length must be less than or equal to the length of the array.</p>
<p>This function will zero out any elements at or past index <code>len</code> of <code>array</code>.
This incurs an extra runtime cost of O(MaxLen). If you are sure your array is
zeroed after that index, you can use <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html#from_parts_unchecked"><code>from_parts_unchecked</code></a> to remove the extra loop.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_parts([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], <span class="number">3</span>);
<span class="kw">assert_eq</span>(vec.len(), <span class="number">3</span>);</code></pre></div>
</div><code id="from_parts_unchecked" class="code-header">pub fn <a href="#from_parts_unchecked"><span class="fn">from_parts_unchecked</span></a>(array: [T; MaxLen], len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>) -> Self</code>

<div class="padded-description"><div class="comments">
<p>Creates a new BoundedVec from the given array and length.
The given length must be less than or equal to the length of the array.</p>
<p>This function is unsafe because it expects all elements past the <code>len</code> index
of <code>array</code> to be zeroed, but does not check for this internally. Use <code>from_parts</code>
for a safe version of this function which does zero out any indices past the
given length. Invalidating this assumption can notably cause <code>BoundedVec::eq</code>
to give incorrect results since it will check even elements past <code>len</code>.</p>
<p>Example:</p>
<pre><code><span class="kw">let</span> vec: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_parts_unchecked([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], <span class="number">3</span>);
<span class="kw">assert_eq</span>(vec.len(), <span class="number">3</span>);

<span class="comment">// invalid use!</span>
<span class="kw">let</span> vec1: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_parts_unchecked([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="number">3</span>);
<span class="kw">let</span> vec2: BoundedVec&lt;u32, <span class="number">4</span>&gt; = BoundedVec::from_parts_unchecked([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>], <span class="number">3</span>);

<span class="comment">// both vecs have length 3 so we'd expect them to be equal, but this</span>
<span class="comment">// fails because elements past the length are still checked in eq</span>
<span class="kw">assert_eq</span>(vec1, vec2); <span class="comment">// fails</span></code></pre></div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Eq-for-BoundedVec<T, MaxLen>"><code class="code-header">impl&lt;let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;
<div class="where-clause">where
    T: <a href="../../../std/cmp/trait.Eq.html" class="trait">Eq</a></div></code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">eq</span>(self, other: Self) -> <a href="../../../std/primitive.bool.html" class="primitive">bool</a></code>

</div><h3 id="impl-From&lt;[T; Len]&gt;-for-BoundedVec<T, MaxLen>"><code class="code-header">impl&lt;let Len: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, let MaxLen: <a href="../../../std/primitive.u32.html" class="primitive">u32</a>, T&gt; <a href="../../../std/convert/trait.From.html" class="trait">From</a>&lt;[T; Len]&gt; for <a href="../../../std/collections/bounded_vec/struct.BoundedVec.html" class="struct">BoundedVec</a>&lt;T, MaxLen&gt;</code></h3>

<div class="padded-methods"><code class="code-header">pub fn <span class="fn">from</span>(array: [T; Len]) -> Self</code>

</div></main>
</span>
</body>
</html>
