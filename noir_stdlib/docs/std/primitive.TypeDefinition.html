<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../styles.css">
<script defer src="../nargo_doc.js"></script>
<title>Primitive type TypeDefinition documentation</title>
</head>
<body>
<div id="sidebar-toggle">
<button id="sidebar-toggle-button"></button>
<div id="sidebar-toggle-title">TypeDefinition</div>
</div>
<span id="main-contents">
<nav class="sidebar">
<h1><a href="../index.html">noir_stdlib</a></h1>
<div><a href="../all.html">All items</a></div>
<h2 id="crate-name"><a href="index.html">std</a></h2>
<div id="crate-version">1.0.0-beta.14</div>
<h2><a href="#primitive">Primitive type TypeDefinition</a></h2>
<h3>Methods</h3>
<ul class="sidebar-list">
<li><a href="#add_attribute">add_attribute</a></li>
<li><a href="#add_generic">add_generic</a></li>
<li><a href="#as_type">as_type</a></li>
<li><a href="#as_type_with_generics">as_type_with_generics</a></li>
<li><a href="#fields">fields</a></li>
<li><a href="#fields_as_written">fields_as_written</a></li>
<li><a href="#generics">generics</a></li>
<li><a href="#has_named_attribute">has_named_attribute</a></li>
<li><a href="#module">module</a></li>
<li><a href="#name">name</a></li>
<li><a href="#set_fields">set_fields</a></li>
</ul>
<h3>Trait implementations</h3>
<ul class="sidebar-list">
<li><a href="#impl-Eq-for-TypeDefinition">Eq</a></li>
<li><a href="#impl-Hash-for-TypeDefinition">Hash</a></li>
</ul>
<h2>In crate std</h2>
<h3>Modules</h3><ul class="item-list">
<li><a href="aes128/index.html">aes128</a></div></li>
<li><a href="append/index.html">append</a></div></li>
<li><a href="cmp/index.html">cmp</a></div></li>
<li><a href="collections/index.html">collections</a></div></li>
<li><a href="compat/index.html">compat</a></div></li>
<li><a href="convert/index.html">convert</a></div></li>
<li><a href="default/index.html">default</a></div></li>
<li><a href="ecdsa_secp256k1/index.html">ecdsa_secp256k1</a></div></li>
<li><a href="ecdsa_secp256r1/index.html">ecdsa_secp256r1</a></div></li>
<li><a href="embedded_curve_ops/index.html">embedded_curve_ops</a></div></li>
<li><a href="field/index.html">field</a></div></li>
<li><a href="hash/index.html">hash</a></div></li>
<li><a href="hint/index.html">hint</a></div></li>
<li><a href="mem/index.html">mem</a></div></li>
<li><a href="meta/index.html">meta</a></div></li>
<li><a href="ops/index.html">ops</a></div></li>
<li><a href="option/index.html">option</a></div></li>
<li><a href="panic/index.html">panic</a></div></li>
<li><a href="prelude/index.html">prelude</a></div></li>
<li><a href="runtime/index.html">runtime</a></div></li>
<li><a href="test/index.html">test</a></div></li>
</ul>
<h3>Primitive types</h3><ul class="item-list">
<li><a href="primitive.array.html">array</a></div></li>
<li><a href="primitive.bool.html">bool</a></div></li>
<li><a href="primitive.CtString.html">CtString</a></div></li>
<li><a href="primitive.Expr.html">Expr</a></div></li>
<li><a href="primitive.Field.html">Field</a></div></li>
<li><a href="primitive.fmtstr.html">fmtstr</a></div></li>
<li><a href="primitive.FunctionDefinition.html">FunctionDefinition</a></div></li>
<li><a href="primitive.i16.html">i16</a></div></li>
<li><a href="primitive.i32.html">i32</a></div></li>
<li><a href="primitive.i64.html">i64</a></div></li>
<li><a href="primitive.i8.html">i8</a></div></li>
<li><a href="primitive.Module.html">Module</a></div></li>
<li><a href="primitive.Quoted.html">Quoted</a></div></li>
<li><a href="primitive.str.html">str</a></div></li>
<li><a href="primitive.TraitConstraint.html">TraitConstraint</a></div></li>
<li><a href="primitive.TraitDefinition.html">TraitDefinition</a></div></li>
<li><a href="primitive.TraitImpl.html">TraitImpl</a></div></li>
<li><a href="primitive.Type.html">Type</a></div></li>
<li><a href="primitive.TypeDefinition.html">TypeDefinition</a></div></li>
<li><a href="primitive.TypedExpr.html">TypedExpr</a></div></li>
<li><a href="primitive.u1.html">u1</a></div></li>
<li><a href="primitive.u128.html">u128</a></div></li>
<li><a href="primitive.u16.html">u16</a></div></li>
<li><a href="primitive.u32.html">u32</a></div></li>
<li><a href="primitive.u64.html">u64</a></div></li>
<li><a href="primitive.u8.html">u8</a></div></li>
<li><a href="primitive.UnresolvedType.html">UnresolvedType</a></div></li>
<li><a href="primitive.vector.html">vector</a></div></li>
</ul>
<h3>Functions</h3><ul class="item-list">
<li><a href="fn.as_witness.html">as_witness</a></div></li>
<li><a href="fn.assert_constant.html">assert_constant</a></div></li>
<li><a href="fn.print.html">print</a></div></li>
<li><a href="fn.println.html">println</a></div></li>
<li><a href="fn.static_assert.html">static_assert</a></div></li>
<li><a href="fn.verify_proof_with_type.html">verify_proof_with_type</a></div></li>
<li><a href="fn.wrapping_add.html">wrapping_add</a></div></li>
<li><a href="fn.wrapping_mul.html">wrapping_mul</a></div></li>
<li><a href="fn.wrapping_sub.html">wrapping_sub</a></div></li>
</ul>
</nav>
<main>
<div><a href="../index.html">noir_stdlib</a> - <a href="index.html">std</a></div>
<h1>Primitive type <span id="primitive" class="primitive">TypeDefinition</span></h1>
<div class="comments">
<p>A compile-time type which represents a type definition such as <code>struct Foo { ... }</code>.</p>
<p>A <code>TypeDefinition</code> is passed as the first argument to a macro attribute on top of a struct:</p>
<pre><code>#[attr]
<span class="kw">struct</span> Foo {}

<span class="kw">comptime</span> <span class="kw">fn</span> attr(type_definition: TypeDefinition) {
    println(type_definition.name()); <span class="comment">// outputs "Foo"</span>
}</code></pre></div>
<h2>Implementations</h2>
<h3><code class="code-header">impl <a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a></code></h3>

<div class="padded-methods"><code id="add_attribute" class="code-header">pub comptime fn <a href="#add_attribute"><span class="fn">add_attribute</span></a>&lt;let N: <a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;(self, attribute: <a href="../std/primitive.str.html" class="primitive">str</a>&lt;N&gt;)</code>

<code id="add_generic" class="code-header">pub comptime fn <a href="#add_generic"><span class="fn">add_generic</span></a>&lt;let N: <a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;(self, generic_name: <a href="../std/primitive.str.html" class="primitive">str</a>&lt;N&gt;) -> <a href="../std/primitive.Type.html" class="primitive">Type</a></code>

<code id="as_type" class="code-header">pub comptime fn <a href="#as_type"><span class="fn">as_type</span></a>(self) -> <a href="../std/primitive.Type.html" class="primitive">Type</a></code>

<div class="padded-description"><div class="comments">
<p>Return a syntactic version of this type definition as a type.
For example, <code>type Foo&lt;A, B&gt; { ... })</code> would return <code>Foo&lt;A, B&gt;</code> when called with this method.</p>
</div>
</div><code id="as_type_with_generics" class="code-header">pub comptime fn <a href="#as_type_with_generics"><span class="fn">as_type_with_generics</span></a>(self, generics: [<a href="../std/primitive.Type.html" class="primitive">Type</a>]) -> <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.Type.html" class="primitive">Type</a>&gt;</code>

<div class="padded-description"><div class="comments">
<p>Return this type applied to the given generic arguments.
For example, given <code>type Foo&lt;A, B&gt; { ... })</code> could be applied to <code>&amp;[quote[i32].as_type(), quote[Field].as_type()]</code>
to return <code>Foo&lt;i32, Field&gt;</code>.</p>
<p>If an incorrect number of generic arguments are given, this function will return None.
Otherwise, this function returns Some with the resulting type inside.</p>
</div>
</div><code id="has_named_attribute" class="code-header">pub comptime fn <a href="#has_named_attribute"><span class="fn">has_named_attribute</span></a>&lt;let N: <a href="../std/primitive.u32.html" class="primitive">u32</a>&gt;(self, name: <a href="../std/primitive.str.html" class="primitive">str</a>&lt;N&gt;) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

<code id="generics" class="code-header">pub comptime fn <a href="#generics"><span class="fn">generics</span></a>(self) -> [(<a href="../std/primitive.Type.html" class="primitive">Type</a>, <a href="../std/option/struct.Option.html" class="struct">Option</a>&lt;<a href="../std/primitive.Type.html" class="primitive">Type</a>&gt;)]</code>

<div class="padded-description"><div class="comments">
<p>Return (type, option<type>) pairs of each generic in this type definition.
If a generic is numeric, the second element of the pair will contain the numeric type.</p>
</div>
</div><code id="fields" class="code-header">pub comptime fn <a href="#fields"><span class="fn">fields</span></a>(self, generic_args: [<a href="../std/primitive.Type.html" class="primitive">Type</a>]) -> [(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, <a href="../std/primitive.Type.html" class="primitive">Type</a>, <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>)]</code>

<div class="padded-description"><div class="comments">
<p>Returns (name, type, visibility) tuples of each field in this type.
Any generic types used in each field type is automatically substituted with the
provided generic arguments.</p>
</div>
</div><code id="fields_as_written" class="code-header">pub comptime fn <a href="#fields_as_written"><span class="fn">fields_as_written</span></a>(self) -> [(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, <a href="../std/primitive.Type.html" class="primitive">Type</a>, <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>)]</code>

<div class="padded-description"><div class="comments">
<p>Returns (name, type, visibility) tuples of each field in this type. Each type is as-is
with any generic arguments unchanged. Unless the field types are not needed,
users should generally prefer to use <a href="../std/primitive.TypeDefinition.html#fields"><code>TypeDefinition::fields</code></a> over this
function if possible.</p></div>
</div><code id="module" class="code-header">pub comptime fn <a href="#module"><span class="fn">module</span></a>(self) -> <a href="../std/primitive.Module.html" class="primitive">Module</a></code>

<code id="name" class="code-header">pub comptime fn <a href="#name"><span class="fn">name</span></a>(self) -> <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a></code>

<code id="set_fields" class="code-header">pub comptime fn <a href="#set_fields"><span class="fn">set_fields</span></a>(self, new_fields: [(<a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>, <a href="../std/primitive.Type.html" class="primitive">Type</a>, <a href="../std/primitive.Quoted.html" class="primitive">Quoted</a>)])</code>

<div class="padded-description"><div class="comments">
<p>Sets the fields of this type to the given fields vector.
All existing fields of the type will be overridden with the given fields.
Each element of the fields vector corresponds to the name and type of a field.
Each name is expected to be a single identifier.</p>
</div>
</div></div><h2>Trait implementations</h2>
<h3 id="impl-Eq-for-TypeDefinition"><code class="code-header">impl <a href="../std/cmp/trait.Eq.html" class="trait">Eq</a> for <a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">eq</span>(self, other: Self) -> <a href="../std/primitive.bool.html" class="primitive">bool</a></code>

</div><h3 id="impl-Hash-for-TypeDefinition"><code class="code-header">impl <a href="../std/hash/trait.Hash.html" class="trait">Hash</a> for <a href="../std/primitive.TypeDefinition.html" class="primitive">TypeDefinition</a></code></h3>

<div class="padded-methods"><code class="code-header">pub comptime fn <span class="fn">hash</span>&lt;H&gt;(self, state: &mut H)
<div class="where-clause">where
    H: <a href="../std/hash/trait.Hasher.html" class="trait">Hasher</a></div></code>

</div></main>
</span>
</body>
</html>
