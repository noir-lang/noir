After Initial SSA (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Removing Unreachable Functions (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Defunctionalization (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Inlining functions with at most one instruction (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Removing Paired rc_inc & rc_decs (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Preprocessing Functions (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Inlining (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    store v1 at v2
    v3 = load v2 -> [u1; 3]
    v5 = array_set v3, index u32 1, value v0
    store v5 at v2
    v6 = load v2 -> [u1; 3]
    return v6
}

After Mem2Reg (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Simplifying (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After `as_slice` optimization (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Removing Unreachable Functions (2):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After `static_assert` and `assert_constant` (1):
brillig(inline) fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Purity Analysis (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Loop Invariant Code Motion (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Unrolling (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Simplifying (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Mem2Reg (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Flattening (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Removing Bit Shifts (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Mem2Reg (3):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Inlining (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Remove IfElse (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Purity Analysis (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Constant Folding (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v4 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v4
    v6 = call f1(v0, v4) -> [u1; 3]
    jmpif v0 then: b1, else: b2
  b1():
    jmp b3(v4)
  b2():
    jmp b3(v6)
  b3(v1: [u1; 3]):
    return v1
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Simplify conditionals for unconstrained (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After EnableSideEffectsIf removal (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Constraint Folding (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Unrolling (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Adding constrain not equal (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Check u128 mul overflow (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v2 = allocate -> &mut [u1; 3]
    v4 = array_set v1, index u32 1, value v0
    return v4
}

After Dead Instruction Elimination (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Simplifying (3):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Mem2Reg (4):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Array Set Optimizations (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Brillig Entry Point Analysis (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Removing Unreachable Functions (3):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Removing Truncate after RangeCheck (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Brillig Array Get Optimizations (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Dead Instruction Elimination (2):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Removing Unreachable Functions (4):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Checked to unchecked (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Inlining Brillig Calls (1):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Removing Unreachable Functions (5):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

After Dead Instruction Elimination (3):
brillig(inline) predicate_pure fn main f0 {
  b0(v0: u1):
    v3 = make_array [u1 1, u1 0, u1 1] : [u1; 3]
    inc_rc v3
    v5 = call f1(v0, v3) -> [u1; 3]
    v6 = not v0
    v7 = if v0 then v3 else (if v6) v5
    return v7
}
brillig(inline) predicate_pure fn func_1 f1 {
  b0(v0: u1, v1: [u1; 3]):
    v3 = array_set v1, index u32 1, value v0
    return v3
}

[regression_8259] Circuit witness successfully solved
[regression_8259] Witness saved to target/regression_8259.gz
[regression_8259] Circuit output: Vec([Field(1), Field(0), Field(1)])
