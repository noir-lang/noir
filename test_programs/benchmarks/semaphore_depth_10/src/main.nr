// Implementation taken from https://github.com/hashcloak/semaphore-noir/blob/d14e0475ad93b5f70ad16a0dafbc8b5b0519c4c5/packages/circuits-noir/src/main.nr
// Used under MIT licence.

use ec::bjj::BabyJubJubParams;
use ec::{Curve, CurveTrait};
use ec::ScalarField;
use poseidon::poseidon::bn254::hash_2 as poseidon;
use std::field::bn254::assert_lt;

// The maximum depth of the Merkle Tree the inclusion proof will be coming from.
// This value can get updated by overwriting this line.
pub global MAX_DEPTH: u32 = 10;

// Generator point of Baby Jubjub curve.
// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13
global BASE8: [Field; 2] = [
    5299619240641551281634865583518297030282874472190772894086521144482721001553,
    16950150798460657717958625567821834550301663161624707787222815936182638968203,
];

// This is a 251 bit value.
global L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;

// There are 3 main steps in the Noir program.
// - The first part generates the Semaphore identity by obtaining
//   the public key from the secret key and consequently hash the public key.
//   This resulting hash is the identity_commitment.
// - In the second part, it is verified that the identity_commitment is indeed
//   part of the merkle tree by calculating the merkleRoot using the merkle proof.
// - In the third part the nullifier is generated by hashing the hashed_scope
//   with the secret key.
//
// There are 4 public values: hashed scope, hashed message, the nullifier and the
// the Merkle tree root. Whether the scope and message are actually hashed doesn't
// affect the circuit; the names just match how they're used in the Semaphore SDK.
//
// The message is tied to the circuit by adding it as a (public) input to the circuit.
//
// Returns: (Merkle tree root, nullifier)
fn main(
    secret_key: Field,
    index_bits: [u1; MAX_DEPTH], // these bits indicate the order of inputs for hashing of the merkle proof
    hash_path: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof
    merkle_proof_length: u32, // the number of non-zero elements in hash_path
    hashed_scope: pub Field,
    hashed_message: pub Field,
) -> pub (Field, Field) {
    // Part 1
    // Ensure secret_key < l.
    assert_lt(secret_key, L);

    // Identity generation.
    // The public key is derived by multiplying the generator point with the secret key,
    // interpreted as a scalar.
    let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };
    // ScalarField is parameterised by the number of 4-bit slices it contains.
    // Since secret key is already known to be max 251 bits, there are 63 slices.
    let secret_scalar: ScalarField<63> = ScalarField::from(secret_key);
    let pubkey = generator.mul(secret_scalar);

    // Obtain the identity commitment by hashing the public key
    let identity_commitment = poseidon([pubkey.x, pubkey.y]);

    // Part 2
    // Verifies membership by repeatedly hashing with the elements from the merkle proof.
    // Depending on the index bit, we swap the siblings for hashing or not.
    let mut node = identity_commitment;
    for i in 0..MAX_DEPTH {
        if i < merkle_proof_length {
            let sibling = hash_path[i];
            let (left, right) = if index_bits[i] == 0 {
                (node, sibling)
            } else {
                (sibling, node)
            };
            node = poseidon([left, right]);
        }
    }

    // Part 3
    // Obtain the nullifier by hashing the hashed scope and secret key.
    let nullifier = poseidon([hashed_scope, secret_key]);

    // Return the calculated Merkle tree root & nullifier
    (node, nullifier)
}
