After Initial SSA:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Removing Unreachable Functions (1st):
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Defunctionalization:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Inlining simple functions:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Removing Paired rc_inc & rc_decs:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Preprocessing Functions:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Inlining (1st):
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Mem2Reg (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Simplifying (1st):
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After `as_slice` optimization:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Removing Unreachable Functions (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After `static_assert` and `assert_constant`:
g0 = Field 2
g1 = Field 3

acir(inline) fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Purity Analysis:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Loop Invariant Code Motion:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Unrolling:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Simplifying (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Mem2Reg (3rd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Flattening:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Removing Bit Shifts:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Mem2Reg (4th):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Inlining (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Remove IfElse:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Purity Analysis (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Constant Folding:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After EnableSideEffectsIf removal:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Constraint Folding:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

After Adding constrain not equal:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}

entry_point f1, old_id f4, new_id f5
entry_point f1, old_id f3, new_id f6
entry_point f2, old_id f4, new_id f7
entry_point f2, old_id f3, new_id f8
entry_point: f1
{
    Id(
        4,
    ),
    Id(
        3,
    ),
}
call to f3 in entry f1
new_id f6
call to f4 in f6 from entry f1
new_id f5
entry_point: f2
{
    Id(
        4,
    ),
    Id(
        3,
    ),
}
call to f3 in entry f2
new_id f8
call to f4 in f8 from entry f2
new_id f7
After Brillig Entry Point Duplication:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f8(v2, v3)
    return
}
brillig(inline) predicate_pure fn inner_func_two f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f7 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f8 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f7(v2, v3)
    return
}

After Removing Unreachable Functions (3rd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    v7 = eq v5, Field 4
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    v6 = eq v5, Field 3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Dead Instruction Elimination (1st):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Simplifying (3rd)::
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Array Set Optimizations:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Inlining Brillig Calls Inlining:
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Removing Unreachable Functions (3rd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

After Dead Instruction Elimination (2nd):
g0 = Field 2
g1 = Field 3

acir(inline) predicate_pure fn main f0 {
  b0(v2: Field, v3: Field):
    call f1(v2, v3)
    call f2(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_two f1 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f4(v2, v3)
    return
}
brillig(inline) predicate_pure fn entry_point_three f2 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f6(v2, v3)
    return
}
brillig(inline) predicate_pure fn nested_inner_func f3 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) predicate_pure fn inner_func_two f4 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f3(v2, v3)
    return
}
brillig(inline) fn nested_inner_func f5 {
  b0(v2: Field, v3: Field):
    v4 = add Field 3, v2
    v5 = add v4, v3
    constrain v5 == Field 4
    return
}
brillig(inline) fn inner_func_two f6 {
  b0(v2: Field, v3: Field):
    v4 = add Field 2, v2
    v5 = add v4, v3
    constrain v5 == Field 3
    call f5(v2, v3)
    return
}

[global_var_multiple_entry_points_nested] Circuit witness successfully solved
[global_var_multiple_entry_points_nested] Witness saved to /mnt/user-data/maxim/noir/test_programs/execution_success/global_var_multiple_entry_points_nested/target/global_var_multiple_entry_points_nested.gz
