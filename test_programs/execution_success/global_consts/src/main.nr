mod foo;
mod baz;

global M: field = 32;
global L: field = 10; // Unused globals currently allowed
global N: u64 = 5;
global T_LEN = 2; // Type inference is allowed on globals

// Globals can reference other globals
global DERIVED = M + L;

struct Dummy {
     x: [field; N],
     y: [field; foo::MAGIC_NUMBER]
}

struct Test {
    v: field,
}
global VALS: [Test; 1] = [Test { v: 100 }];
global NESTED = [VALS, VALS];

unconstrained fn calculate_global_value() -> field {
    42
}

// Regression test for https://github.com/noir-lang/noir/issues/4318
global CALCULATED_GLOBAL: field = calculate_global_value();

fn main(
    a: [field; M + N - N],
    b: [field; 30 + N / 2],
    c: pub [field; foo::MAGIC_NUMBER],
    d: [field; foo::bar::N]
) {
    let test_struct = Dummy { x: d, y: c };

    for i in 0..foo::MAGIC_NUMBER {
        assert(c[i] == foo::MAGIC_NUMBER as field);
        assert(test_struct.y[i] == foo::MAGIC_NUMBER as field);
        assert(test_struct.y[i] != NESTED[1][0].v);
    }

    assert(N as field != M);

    let expected: u32 = 42;
    assert(foo::TYPE_INFERRED == expected);

    let mut y = 5;
    let mut x = M;
    for i in 0..N * N {
        let M: field = 10;
        x = M;

        y = i;
    }
    assert(y == 24);
    assert(x == 10);

    let q = multiplyByM(3);
    assert(q == 96);

    arrays_neq(a, b);

    let t: [field; T_LEN] = [N as field, M];
    assert(t[1] == 32);

    assert(15 == my_submodule::my_helper());

    let add_submodules_N = my_submodule::N + foo::bar::N as field;
    assert(15 == add_submodules_N);
    let add_from_bar_N = my_submodule::N + foo::bar::from_bar(1);
    assert(15 == add_from_bar_N);
    // Example showing an array filled with (my_submodule::N + 2) 0's
    let sugared = [0; my_submodule::N + 2];
    assert(sugared[my_submodule::N + 1] == 0);

    let arr: [field; my_submodule::N] = [N as field; 10];
    assert((arr[0] == 5) & (arr[9] == 5));

    foo::from_foo(d);
    baz::from_baz(c);
    assert(DERIVED == M + L);

    assert(CALCULATED_GLOBAL == 42);
}

fn multiplyByM(x: field) -> field {
    x * M
}

fn arrays_neq(a: [field; M], b: [field; M]) {
    assert(a != b);
}

mod my_submodule {
    global N: field = 10;
    global L: field = 50;

    fn my_bool_or(x: u1, y: u1) {
        assert(x | y == 1);
    }

    pub fn my_helper() -> field {
        let N: field = 15; // Like in Rust, local variables override globals
        let x = N;
        x
    }
}

struct Foo {
  a: field,
}

struct Bar {}

impl Bar {
    fn get_a() -> field {
        1
    }
}

// Regression for #1440
global foo = Foo {
    a: Bar::get_a(),
};
