After Initial SSA::
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v5, v6 = call f1() -> ([(Field, u32, Field, Field); 4], u32)
    inc_rc v5
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v5
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v5 at v9
    v10 = allocate -> &mut u32
    store v6 at v10
    v12 = array_get v0, index u32 0 -> Field
    v14 = array_get v0, index u32 1 -> Field
    v16, v17, v18, v19, v20, v21 = call f3(v7, v8, v9, v10, v1) -> (&mut u32, &mut [u32; 3], &mut [(Field, u32, Field, Field); 4], &mut u32, Field, function)
    call f2(v12, v14, v16, v17, v18, v19, v20, v21)
    return
}
acir(inline) fn new f1 {
  b0():
    v2 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v2
    return v2, u32 0
}
acir(inline) fn emit f2 {
  b0(v0: Field, v1: Field, v2: &mut u32, v3: &mut [u32; 3], v4: &mut [(Field, u32, Field, Field); 4], v5: &mut u32, v6: Field, v7: function):
    v8 = load v3 -> [u32; 3]
    inc_rc v8
    v9 = load v4 -> [(Field, u32, Field, Field); 4]
    inc_rc v9
    call v7(v2, v3, v4, v5, v6, v0, v1)
    return
}
acir(inline) fn encode_event_with_randomness f3 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field):
    v5 = load v1 -> [u32; 3]
    inc_rc v5
    v6 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v6
    v7 = load v1 -> [u32; 3]
    inc_rc v7
    v8 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v8
    return v0, v1, v2, v3, v4, f4
}
acir(inline) fn lambda f4 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field):
    v7 = allocate -> &mut &mut u32
    store v0 at v7
    v8 = load v1 -> [u32; 3]
    inc_rc v8
    v9 = allocate -> &mut &mut [u32; 3]
    store v1 at v9
    v10 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v10
    v11 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v2 at v11
    v12 = allocate -> &mut &mut u32
    store v3 at v12
    v13 = allocate -> &mut Field
    store v4 at v13
    v14 = load v7 -> &mut u32
    v15 = load v9 -> &mut [u32; 3]
    v16 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v17 = load v12 -> &mut u32
    v18 = load v13 -> Field
    v19 = load v14 -> u32
    v20 = load v15 -> [u32; 3]
    v21 = load v16 -> [(Field, u32, Field, Field); 4]
    v22 = load v17 -> u32
    call f5(v19)
    v24 = load v7 -> &mut u32
    v25 = load v9 -> &mut [u32; 3]
    v26 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v27 = load v12 -> &mut u32
    v28 = load v13 -> Field
    v29 = load v7 -> &mut u32
    v30 = load v9 -> &mut [u32; 3]
    v31 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v32 = load v12 -> &mut u32
    v33 = load v13 -> Field
    call f6(v24, v25, v26, v27, v33, v5, v6, f7)
    return
}
brillig(inline) fn func f5 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}
acir(inline) fn emit_with_keys f6 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field, v7: function):
    v8, v9 = call v7(v5, v6) -> ([u8; 5], Field)
    inc_rc v8
    inc_rc v8
    call f8(v0, v1, v2, v3, v4, v8, v9)
    return
}
acir(inline) fn compute f7 {
  b0(v0: Field, v1: Field):
    v3 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    return v3, Field 0
}
acir(inline) fn emit_raw_log f8 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: [u8; 5], v6: Field):
    call f9(v2, v3, v6, u32 0, Field 0, v4)
    return
}
acir(inline) fn push f9 {
  b0(v0: &mut [(Field, u32, Field, Field); 4], v1: &mut u32, v2: Field, v3: u32, v4: Field, v5: Field):
    v6 = load v0 -> [(Field, u32, Field, Field); 4]
    v7 = load v1 -> u32
    v9 = lt v7, u32 4
    constrain v9 == u1 1, "push out of bounds"
    v11 = load v0 -> [(Field, u32, Field, Field); 4]
    v12 = load v1 -> u32
    v13 = load v0 -> [(Field, u32, Field, Field); 4]
    v14 = load v1 -> u32
    v15 = mul v14, u32 4
    v16 = array_set v11, index v15, value v2
    v18 = add v15, u32 1
    v19 = array_set v16, index v18, value v3
    v20 = add v18, u32 1
    v21 = array_set v19, index v20, value v4
    v22 = add v20, u32 1
    v23 = array_set v21, index v22, value v5
    v24 = add v22, u32 1
    store v23 at v0
    store v12 at v1
    v25 = load v0 -> [(Field, u32, Field, Field); 4]
    v26 = load v1 -> u32
    v27 = load v0 -> [(Field, u32, Field, Field); 4]
    v28 = load v1 -> u32
    v29 = add v28, u32 1
    store v25 at v0
    store v29 at v1
    return
}

After Removing Unreachable Functions:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v5, v6 = call f1() -> ([(Field, u32, Field, Field); 4], u32)
    inc_rc v5
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v5
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v5 at v9
    v10 = allocate -> &mut u32
    store v6 at v10
    v12 = array_get v0, index u32 0 -> Field
    v14 = array_get v0, index u32 1 -> Field
    v16, v17, v18, v19, v20, v21 = call f3(v7, v8, v9, v10, v1) -> (&mut u32, &mut [u32; 3], &mut [(Field, u32, Field, Field); 4], &mut u32, Field, function)
    call f2(v12, v14, v16, v17, v18, v19, v20, v21)
    return
}
acir(inline) fn new f1 {
  b0():
    v2 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v2
    return v2, u32 0
}
acir(inline) fn emit f2 {
  b0(v0: Field, v1: Field, v2: &mut u32, v3: &mut [u32; 3], v4: &mut [(Field, u32, Field, Field); 4], v5: &mut u32, v6: Field, v7: function):
    v8 = load v3 -> [u32; 3]
    inc_rc v8
    v9 = load v4 -> [(Field, u32, Field, Field); 4]
    inc_rc v9
    call v7(v2, v3, v4, v5, v6, v0, v1)
    return
}
acir(inline) fn encode_event_with_randomness f3 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field):
    v5 = load v1 -> [u32; 3]
    inc_rc v5
    v6 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v6
    v7 = load v1 -> [u32; 3]
    inc_rc v7
    v8 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v8
    return v0, v1, v2, v3, v4, f4
}
acir(inline) fn lambda f4 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field):
    v7 = allocate -> &mut &mut u32
    store v0 at v7
    v8 = load v1 -> [u32; 3]
    inc_rc v8
    v9 = allocate -> &mut &mut [u32; 3]
    store v1 at v9
    v10 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v10
    v11 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v2 at v11
    v12 = allocate -> &mut &mut u32
    store v3 at v12
    v13 = allocate -> &mut Field
    store v4 at v13
    v14 = load v7 -> &mut u32
    v15 = load v9 -> &mut [u32; 3]
    v16 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v17 = load v12 -> &mut u32
    v18 = load v13 -> Field
    v19 = load v14 -> u32
    v20 = load v15 -> [u32; 3]
    v21 = load v16 -> [(Field, u32, Field, Field); 4]
    v22 = load v17 -> u32
    call f5(v19)
    v24 = load v7 -> &mut u32
    v25 = load v9 -> &mut [u32; 3]
    v26 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v27 = load v12 -> &mut u32
    v28 = load v13 -> Field
    v29 = load v7 -> &mut u32
    v30 = load v9 -> &mut [u32; 3]
    v31 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v32 = load v12 -> &mut u32
    v33 = load v13 -> Field
    call f6(v24, v25, v26, v27, v33, v5, v6, f7)
    return
}
brillig(inline) fn func f5 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}
acir(inline) fn emit_with_keys f6 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field, v7: function):
    v8, v9 = call v7(v5, v6) -> ([u8; 5], Field)
    inc_rc v8
    inc_rc v8
    call f8(v0, v1, v2, v3, v4, v8, v9)
    return
}
acir(inline) fn compute f7 {
  b0(v0: Field, v1: Field):
    v3 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    return v3, Field 0
}
acir(inline) fn emit_raw_log f8 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: [u8; 5], v6: Field):
    call f9(v2, v3, v6, u32 0, Field 0, v4)
    return
}
acir(inline) fn push f9 {
  b0(v0: &mut [(Field, u32, Field, Field); 4], v1: &mut u32, v2: Field, v3: u32, v4: Field, v5: Field):
    v6 = load v0 -> [(Field, u32, Field, Field); 4]
    v7 = load v1 -> u32
    v9 = lt v7, u32 4
    constrain v9 == u1 1, "push out of bounds"
    v11 = load v0 -> [(Field, u32, Field, Field); 4]
    v12 = load v1 -> u32
    v13 = load v0 -> [(Field, u32, Field, Field); 4]
    v14 = load v1 -> u32
    v15 = mul v14, u32 4
    v16 = array_set v11, index v15, value v2
    v18 = add v15, u32 1
    v19 = array_set v16, index v18, value v3
    v20 = add v18, u32 1
    v21 = array_set v19, index v20, value v4
    v22 = add v20, u32 1
    v23 = array_set v21, index v22, value v5
    v24 = add v22, u32 1
    store v23 at v0
    store v12 at v1
    v25 = load v0 -> [(Field, u32, Field, Field); 4]
    v26 = load v1 -> u32
    v27 = load v0 -> [(Field, u32, Field, Field); 4]
    v28 = load v1 -> u32
    v29 = add v28, u32 1
    store v25 at v0
    store v29 at v1
    return
}

After Defunctionalization:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v5, v6 = call f1() -> ([(Field, u32, Field, Field); 4], u32)
    inc_rc v5
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v5
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v5 at v9
    v10 = allocate -> &mut u32
    store v6 at v10
    v12 = array_get v0, index u32 0 -> Field
    v14 = array_get v0, index u32 1 -> Field
    v16, v17, v18, v19, v20, v21 = call f3(v7, v8, v9, v10, v1) -> (&mut u32, &mut [u32; 3], &mut [(Field, u32, Field, Field); 4], &mut u32, Field, Field)
    call f2(v12, v14, v16, v17, v18, v19, v20, v21)
    return
}
acir(inline) fn new f1 {
  b0():
    v2 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v2
    return v2, u32 0
}
acir(inline) fn emit f2 {
  b0(v0: Field, v1: Field, v2: &mut u32, v3: &mut [u32; 3], v4: &mut [(Field, u32, Field, Field); 4], v5: &mut u32, v6: Field, v7: Field):
    v8 = load v3 -> [u32; 3]
    inc_rc v8
    v9 = load v4 -> [(Field, u32, Field, Field); 4]
    inc_rc v9
    call f4(v2, v3, v4, v5, v6, v0, v1)
    return
}
acir(inline) fn encode_event_with_randomness f3 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field):
    v5 = load v1 -> [u32; 3]
    inc_rc v5
    v6 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v6
    v7 = load v1 -> [u32; 3]
    inc_rc v7
    v8 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v8
    return v0, v1, v2, v3, v4, Field 4
}
acir(inline) fn lambda f4 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field):
    v7 = allocate -> &mut &mut u32
    store v0 at v7
    v8 = load v1 -> [u32; 3]
    inc_rc v8
    v9 = allocate -> &mut &mut [u32; 3]
    store v1 at v9
    v10 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v10
    v11 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v2 at v11
    v12 = allocate -> &mut &mut u32
    store v3 at v12
    v13 = allocate -> &mut Field
    store v4 at v13
    v14 = load v7 -> &mut u32
    v15 = load v9 -> &mut [u32; 3]
    v16 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v17 = load v12 -> &mut u32
    v18 = load v13 -> Field
    v19 = load v14 -> u32
    v20 = load v15 -> [u32; 3]
    v21 = load v16 -> [(Field, u32, Field, Field); 4]
    v22 = load v17 -> u32
    call f5(v19)
    v24 = load v7 -> &mut u32
    v25 = load v9 -> &mut [u32; 3]
    v26 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v27 = load v12 -> &mut u32
    v28 = load v13 -> Field
    v29 = load v7 -> &mut u32
    v30 = load v9 -> &mut [u32; 3]
    v31 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v32 = load v12 -> &mut u32
    v33 = load v13 -> Field
    call f6(v24, v25, v26, v27, v33, v5, v6, Field 7)
    return
}
brillig(inline) fn func f5 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}
acir(inline) fn emit_with_keys f6 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field, v7: Field):
    v9, v10 = call f7(v5, v6) -> ([u8; 5], Field)
    inc_rc v9
    inc_rc v9
    call f8(v0, v1, v2, v3, v4, v9, v10)
    return
}
acir(inline) fn compute f7 {
  b0(v0: Field, v1: Field):
    v3 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    return v3, Field 0
}
acir(inline) fn emit_raw_log f8 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: [u8; 5], v6: Field):
    call f9(v2, v3, v6, u32 0, Field 0, v4)
    return
}
acir(inline) fn push f9 {
  b0(v0: &mut [(Field, u32, Field, Field); 4], v1: &mut u32, v2: Field, v3: u32, v4: Field, v5: Field):
    v6 = load v0 -> [(Field, u32, Field, Field); 4]
    v7 = load v1 -> u32
    v9 = lt v7, u32 4
    constrain v9 == u1 1, "push out of bounds"
    v11 = load v0 -> [(Field, u32, Field, Field); 4]
    v12 = load v1 -> u32
    v13 = load v0 -> [(Field, u32, Field, Field); 4]
    v14 = load v1 -> u32
    v15 = mul v14, u32 4
    v16 = array_set v11, index v15, value v2
    v18 = add v15, u32 1
    v19 = array_set v16, index v18, value v3
    v20 = add v18, u32 1
    v21 = array_set v19, index v20, value v4
    v22 = add v20, u32 1
    v23 = array_set v21, index v22, value v5
    v24 = add v22, u32 1
    store v23 at v0
    store v12 at v1
    v25 = load v0 -> [(Field, u32, Field, Field); 4]
    v26 = load v1 -> u32
    v27 = load v0 -> [(Field, u32, Field, Field); 4]
    v28 = load v1 -> u32
    v29 = add v28, u32 1
    store v25 at v0
    store v29 at v1
    return
}

After Removing Paired rc_inc & rc_decs:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v5, v6 = call f1() -> ([(Field, u32, Field, Field); 4], u32)
    inc_rc v5
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v5
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v5 at v9
    v10 = allocate -> &mut u32
    store v6 at v10
    v12 = array_get v0, index u32 0 -> Field
    v14 = array_get v0, index u32 1 -> Field
    v16, v17, v18, v19, v20, v21 = call f3(v7, v8, v9, v10, v1) -> (&mut u32, &mut [u32; 3], &mut [(Field, u32, Field, Field); 4], &mut u32, Field, Field)
    call f2(v12, v14, v16, v17, v18, v19, v20, v21)
    return
}
acir(inline) fn new f1 {
  b0():
    v2 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v2
    return v2, u32 0
}
acir(inline) fn emit f2 {
  b0(v0: Field, v1: Field, v2: &mut u32, v3: &mut [u32; 3], v4: &mut [(Field, u32, Field, Field); 4], v5: &mut u32, v6: Field, v7: Field):
    v8 = load v3 -> [u32; 3]
    inc_rc v8
    v9 = load v4 -> [(Field, u32, Field, Field); 4]
    inc_rc v9
    call f4(v2, v3, v4, v5, v6, v0, v1)
    return
}
acir(inline) fn encode_event_with_randomness f3 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field):
    v5 = load v1 -> [u32; 3]
    inc_rc v5
    v6 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v6
    v7 = load v1 -> [u32; 3]
    inc_rc v7
    v8 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v8
    return v0, v1, v2, v3, v4, Field 4
}
acir(inline) fn lambda f4 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field):
    v7 = allocate -> &mut &mut u32
    store v0 at v7
    v8 = load v1 -> [u32; 3]
    inc_rc v8
    v9 = allocate -> &mut &mut [u32; 3]
    store v1 at v9
    v10 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v10
    v11 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v2 at v11
    v12 = allocate -> &mut &mut u32
    store v3 at v12
    v13 = allocate -> &mut Field
    store v4 at v13
    v14 = load v7 -> &mut u32
    v15 = load v9 -> &mut [u32; 3]
    v16 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v17 = load v12 -> &mut u32
    v18 = load v13 -> Field
    v19 = load v14 -> u32
    v20 = load v15 -> [u32; 3]
    v21 = load v16 -> [(Field, u32, Field, Field); 4]
    v22 = load v17 -> u32
    call f5(v19)
    v24 = load v7 -> &mut u32
    v25 = load v9 -> &mut [u32; 3]
    v26 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v27 = load v12 -> &mut u32
    v28 = load v13 -> Field
    v29 = load v7 -> &mut u32
    v30 = load v9 -> &mut [u32; 3]
    v31 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v32 = load v12 -> &mut u32
    v33 = load v13 -> Field
    call f6(v24, v25, v26, v27, v33, v5, v6, Field 7)
    return
}
brillig(inline) fn func f5 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}
acir(inline) fn emit_with_keys f6 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field, v7: Field):
    v9, v10 = call f7(v5, v6) -> ([u8; 5], Field)
    inc_rc v9
    inc_rc v9
    call f8(v0, v1, v2, v3, v4, v9, v10)
    return
}
acir(inline) fn compute f7 {
  b0(v0: Field, v1: Field):
    v3 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    return v3, Field 0
}
acir(inline) fn emit_raw_log f8 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: [u8; 5], v6: Field):
    call f9(v2, v3, v6, u32 0, Field 0, v4)
    return
}
acir(inline) fn push f9 {
  b0(v0: &mut [(Field, u32, Field, Field); 4], v1: &mut u32, v2: Field, v3: u32, v4: Field, v5: Field):
    v6 = load v0 -> [(Field, u32, Field, Field); 4]
    v7 = load v1 -> u32
    v9 = lt v7, u32 4
    constrain v9 == u1 1, "push out of bounds"
    v11 = load v0 -> [(Field, u32, Field, Field); 4]
    v12 = load v1 -> u32
    v13 = load v0 -> [(Field, u32, Field, Field); 4]
    v14 = load v1 -> u32
    v15 = mul v14, u32 4
    v16 = array_set v11, index v15, value v2
    v18 = add v15, u32 1
    v19 = array_set v16, index v18, value v3
    v20 = add v18, u32 1
    v21 = array_set v19, index v20, value v4
    v22 = add v20, u32 1
    v23 = array_set v21, index v22, value v5
    v24 = add v22, u32 1
    store v23 at v0
    store v12 at v1
    v25 = load v0 -> [(Field, u32, Field, Field); 4]
    v26 = load v1 -> u32
    v27 = load v0 -> [(Field, u32, Field, Field); 4]
    v28 = load v1 -> u32
    v29 = add v28, u32 1
    store v25 at v0
    store v29 at v1
    return
}

After Resolving IsUnconstrained:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v5, v6 = call f1() -> ([(Field, u32, Field, Field); 4], u32)
    inc_rc v5
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v5
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v5 at v9
    v10 = allocate -> &mut u32
    store v6 at v10
    v12 = array_get v0, index u32 0 -> Field
    v14 = array_get v0, index u32 1 -> Field
    v16, v17, v18, v19, v20, v21 = call f3(v7, v8, v9, v10, v1) -> (&mut u32, &mut [u32; 3], &mut [(Field, u32, Field, Field); 4], &mut u32, Field, Field)
    call f2(v12, v14, v16, v17, v18, v19, v20, v21)
    return
}
acir(inline) fn new f1 {
  b0():
    v2 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v2
    return v2, u32 0
}
acir(inline) fn emit f2 {
  b0(v0: Field, v1: Field, v2: &mut u32, v3: &mut [u32; 3], v4: &mut [(Field, u32, Field, Field); 4], v5: &mut u32, v6: Field, v7: Field):
    v8 = load v3 -> [u32; 3]
    inc_rc v8
    v9 = load v4 -> [(Field, u32, Field, Field); 4]
    inc_rc v9
    call f4(v2, v3, v4, v5, v6, v0, v1)
    return
}
acir(inline) fn encode_event_with_randomness f3 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field):
    v5 = load v1 -> [u32; 3]
    inc_rc v5
    v6 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v6
    v7 = load v1 -> [u32; 3]
    inc_rc v7
    v8 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v8
    return v0, v1, v2, v3, v4, Field 4
}
acir(inline) fn lambda f4 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field):
    v7 = allocate -> &mut &mut u32
    store v0 at v7
    v8 = load v1 -> [u32; 3]
    inc_rc v8
    v9 = allocate -> &mut &mut [u32; 3]
    store v1 at v9
    v10 = load v2 -> [(Field, u32, Field, Field); 4]
    inc_rc v10
    v11 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v2 at v11
    v12 = allocate -> &mut &mut u32
    store v3 at v12
    v13 = allocate -> &mut Field
    store v4 at v13
    v14 = load v7 -> &mut u32
    v15 = load v9 -> &mut [u32; 3]
    v16 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v17 = load v12 -> &mut u32
    v18 = load v13 -> Field
    v19 = load v14 -> u32
    v20 = load v15 -> [u32; 3]
    v21 = load v16 -> [(Field, u32, Field, Field); 4]
    v22 = load v17 -> u32
    call f5(v19)
    v24 = load v7 -> &mut u32
    v25 = load v9 -> &mut [u32; 3]
    v26 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v27 = load v12 -> &mut u32
    v28 = load v13 -> Field
    v29 = load v7 -> &mut u32
    v30 = load v9 -> &mut [u32; 3]
    v31 = load v11 -> &mut [(Field, u32, Field, Field); 4]
    v32 = load v12 -> &mut u32
    v33 = load v13 -> Field
    call f6(v24, v25, v26, v27, v33, v5, v6, Field 7)
    return
}
brillig(inline) fn func f5 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}
acir(inline) fn emit_with_keys f6 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: Field, v6: Field, v7: Field):
    v9, v10 = call f7(v5, v6) -> ([u8; 5], Field)
    inc_rc v9
    inc_rc v9
    call f8(v0, v1, v2, v3, v4, v9, v10)
    return
}
acir(inline) fn compute f7 {
  b0(v0: Field, v1: Field):
    v3 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    return v3, Field 0
}
acir(inline) fn emit_raw_log f8 {
  b0(v0: &mut u32, v1: &mut [u32; 3], v2: &mut [(Field, u32, Field, Field); 4], v3: &mut u32, v4: Field, v5: [u8; 5], v6: Field):
    call f9(v2, v3, v6, u32 0, Field 0, v4)
    return
}
acir(inline) fn push f9 {
  b0(v0: &mut [(Field, u32, Field, Field); 4], v1: &mut u32, v2: Field, v3: u32, v4: Field, v5: Field):
    v6 = load v0 -> [(Field, u32, Field, Field); 4]
    v7 = load v1 -> u32
    v9 = lt v7, u32 4
    constrain v9 == u1 1, "push out of bounds"
    v11 = load v0 -> [(Field, u32, Field, Field); 4]
    v12 = load v1 -> u32
    v13 = load v0 -> [(Field, u32, Field, Field); 4]
    v14 = load v1 -> u32
    v15 = mul v14, u32 4
    v16 = array_set v11, index v15, value v2
    v18 = add v15, u32 1
    v19 = array_set v16, index v18, value v3
    v20 = add v18, u32 1
    v21 = array_set v19, index v20, value v4
    v22 = add v20, u32 1
    v23 = array_set v21, index v22, value v5
    v24 = add v22, u32 1
    store v23 at v0
    store v12 at v1
    v25 = load v0 -> [(Field, u32, Field, Field); 4]
    v26 = load v1 -> u32
    v27 = load v0 -> [(Field, u32, Field, Field); 4]
    v28 = load v1 -> u32
    v29 = add v28, u32 1
    store v25 at v0
    store v29 at v1
    return
}

After Inlining (1st):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    store v2 at v7
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    store v3 at v8
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    store v6 at v9
    v10 = allocate -> &mut u32
    store u32 0 at v10
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    v14 = load v8 -> [u32; 3]
    inc_rc v14
    v15 = load v9 -> [(Field, u32, Field, Field); 4]
    inc_rc v15
    v16 = load v8 -> [u32; 3]
    inc_rc v16
    v17 = load v9 -> [(Field, u32, Field, Field); 4]
    inc_rc v17
    v18 = load v8 -> [u32; 3]
    inc_rc v18
    v19 = load v9 -> [(Field, u32, Field, Field); 4]
    inc_rc v19
    v20 = allocate -> &mut &mut u32
    store v7 at v20
    v21 = load v8 -> [u32; 3]
    inc_rc v21
    v22 = allocate -> &mut &mut [u32; 3]
    store v8 at v22
    v23 = load v9 -> [(Field, u32, Field, Field); 4]
    inc_rc v23
    v24 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    store v9 at v24
    v25 = allocate -> &mut &mut u32
    store v10 at v25
    v26 = allocate -> &mut Field
    store v1 at v26
    v27 = load v20 -> &mut u32
    v28 = load v22 -> &mut [u32; 3]
    v29 = load v24 -> &mut [(Field, u32, Field, Field); 4]
    v30 = load v25 -> &mut u32
    v31 = load v26 -> Field
    v32 = load v27 -> u32
    v33 = load v28 -> [u32; 3]
    v34 = load v29 -> [(Field, u32, Field, Field); 4]
    v35 = load v30 -> u32
    call f1(v32)
    v37 = load v20 -> &mut u32
    v38 = load v22 -> &mut [u32; 3]
    v39 = load v24 -> &mut [(Field, u32, Field, Field); 4]
    v40 = load v25 -> &mut u32
    v41 = load v26 -> Field
    v42 = load v20 -> &mut u32
    v43 = load v22 -> &mut [u32; 3]
    v44 = load v24 -> &mut [(Field, u32, Field, Field); 4]
    v45 = load v25 -> &mut u32
    v46 = load v26 -> Field
    v48 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v48
    inc_rc v48
    v49 = load v39 -> [(Field, u32, Field, Field); 4]
    v50 = load v40 -> u32
    v52 = lt v50, u32 4
    constrain v52 == u1 1, "push out of bounds"
    v54 = load v39 -> [(Field, u32, Field, Field); 4]
    v55 = load v40 -> u32
    v56 = load v39 -> [(Field, u32, Field, Field); 4]
    v57 = load v40 -> u32
    v58 = mul v57, u32 4
    v59 = array_set v54, index v58, value Field 0
    v60 = add v58, u32 1
    v61 = array_set v59, index v60, value u32 0
    v62 = add v60, u32 1
    v63 = array_set v61, index v62, value Field 0
    v64 = add v62, u32 1
    v65 = array_set v63, index v64, value v46
    v66 = add v64, u32 1
    store v65 at v39
    store v55 at v40
    v67 = load v39 -> [(Field, u32, Field, Field); 4]
    v68 = load v40 -> u32
    v69 = load v39 -> [(Field, u32, Field, Field); 4]
    v70 = load v40 -> u32
    v71 = add v70, u32 1
    store v67 at v39
    store v71 at v40
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After Mem2Reg (1st):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After Simplifying (1st):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After `as_slice` optimization:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After Removing Unreachable Functions:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After `static_assert` and `assert_constant`:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After Loop Invariant Code Motion:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v2 = allocate -> &mut u32
    store v0 at v2
    v3 = allocate -> &mut &mut u32
    store v2 at v3
    jmp b1(u32 0)
  b1(v1: u32):
    v5 = eq v1, u32 0
    jmpif v5 then: b3, else: b2
  b2():
    v6 = load v2 -> u32
    v8 = eq v6, u32 2
    constrain v6 == u32 2
    v9 = load v3 -> &mut u32
    v10 = load v9 -> u32
    v11 = eq v10, u32 2
    constrain v10 == u32 2
    return
  b3():
    v12 = load v3 -> &mut u32
    store u32 2 at v12
    v14 = add v1, u32 1
    jmp b1(v14)
}

After Unrolling:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = allocate -> &mut &mut u32
    store v1 at v2
    v3 = load v2 -> &mut u32
    store u32 2 at v3
    jmp b1()
  b1():
    v5 = load v1 -> u32
    v6 = eq v5, u32 2
    constrain v5 == u32 2
    v7 = load v2 -> &mut u32
    v8 = load v7 -> u32
    v9 = eq v8, u32 2
    constrain v8 == u32 2
    return
}

After Simplifying (2nd):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = allocate -> &mut &mut u32
    store v1 at v2
    v3 = load v2 -> &mut u32
    store u32 2 at v3
    v5 = load v1 -> u32
    v6 = eq v5, u32 2
    constrain v5 == u32 2
    v7 = load v2 -> &mut u32
    v8 = load v7 -> u32
    v9 = eq v8, u32 2
    constrain v8 == u32 2
    return
}

After Flattening:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = allocate -> &mut &mut u32
    store v1 at v2
    v3 = load v2 -> &mut u32
    store u32 2 at v3
    v5 = load v1 -> u32
    v6 = eq v5, u32 2
    constrain v5 == u32 2
    v7 = load v2 -> &mut u32
    v8 = load v7 -> u32
    v9 = eq v8, u32 2
    constrain v8 == u32 2
    return
}

After After Removing Bit Shifts:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = allocate -> &mut &mut u32
    store v1 at v2
    v3 = load v2 -> &mut u32
    store u32 2 at v3
    v5 = load v1 -> u32
    v6 = eq v5, u32 2
    constrain v5 == u32 2
    v7 = load v2 -> &mut u32
    v8 = load v7 -> u32
    v9 = eq v8, u32 2
    constrain v8 == u32 2
    return
}

After Mem2Reg (2nd):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After Inlining (2nd):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After Remove IfElse:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    v22 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v23 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v24 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    v25 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After Constant Folding:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    inc_rc v6
    inc_rc v6
    inc_rc v6
    v22 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After EnableSideEffectsIf removal:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    inc_rc v6
    inc_rc v6
    inc_rc v6
    v22 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After Constraint Folding:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    v3 = make_array [v2, v2, v2] : [u32; 3]
    inc_rc v3
    inc_rc v3
    v6 = make_array [Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    inc_rc v6
    inc_rc v6
    v7 = allocate -> &mut u32
    inc_rc v3
    v8 = allocate -> &mut [u32; 3]
    inc_rc v6
    v9 = allocate -> &mut [(Field, u32, Field, Field); 4]
    v10 = allocate -> &mut u32
    v11 = array_get v0, index u32 0 -> Field
    v13 = array_get v0, index u32 1 -> Field
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    inc_rc v3
    inc_rc v6
    v14 = allocate -> &mut &mut u32
    inc_rc v3
    v15 = allocate -> &mut &mut [u32; 3]
    inc_rc v6
    v16 = allocate -> &mut &mut [(Field, u32, Field, Field); 4]
    v17 = allocate -> &mut &mut u32
    v18 = allocate -> &mut Field
    call f1(v2)
    v21 = make_array [u8 0, u8 0, u8 0, u8 0, u8 0] : [u8; 5]
    inc_rc v21
    inc_rc v21
    inc_rc v6
    inc_rc v6
    inc_rc v6
    v22 = make_array [Field 0, u32 0, Field 0, v1, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0, Field 0, u32 0, Field 0, Field 0] : [(Field, u32, Field, Field); 4]
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    v2 = allocate -> &mut &mut u32
    return
}

After Dead Instruction Elimination (1st):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    call f1(v2)
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    return
}

After Simplifying::
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    call f1(v2)
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    return
}

After Array Set Optimizations:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    call f1(v2)
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    return
}

After Inlining Brillig Calls Inlining:
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    call f1(v2)
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    return
}

After Dead Instruction Elimination (2nd):
acir(inline) fn main f0 {
  b0(v0: [Field; 4], v1: Field, v2: u32):
    call f1(v2)
    return
}
brillig(inline) fn func f1 {
  b0(v0: u32):
    return
}

[reference_only_used_as_alias] Circuit witness successfully solved
[reference_only_used_as_alias] Witness saved to /home/rndmprsn/Code/Noir/noir/test_programs/execution_success/reference_only_used_as_alias/target/reference_only_used_as_alias.gz
