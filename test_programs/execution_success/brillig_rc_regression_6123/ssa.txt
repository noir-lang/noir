Initial SSA:
brillig fn main f0 {
  b0():
    v2, v3 = call f1()
    inc_rc v2
    v5, v6 = call f1()
    inc_rc v5
    inc_rc v2
    v7 = allocate
    store v2 at v7
    v8 = allocate
    store v3 at v8
    inc_rc v5
    v9 = allocate
    store v5 at v9
    v10 = allocate
    store v6 at v10
    call f2(v7, v8, v9, v10, u32 2)
    v13 = load v7
    v14 = load v8
    v15 = load v9
    v16 = load v10
    v19 = array_set v15, index u32 1, value Field 27
    store v13 at v7
    store v14 at v8
    store v19 at v9
    store v16 at v10
    v20 = load v7
    v21 = load v8
    v22 = load v9
    v23 = load v10
    inc_rc v20
    v25 = array_get v20, index u32 0
    call f3(v7, v8, u32 1, u32 0)
    jmp b1(u32 0)
  b1(v0: u32):
    v27 = eq v0, u32 0
    jmpif v27 then: b3, else: b2
  b3():
    v28 = array_get v20, index v0
    v29 = eq v28, v25
    constrain v28 == v25
    v30 = add v0, u32 1
    jmp b1(v30)
  b2():
    return 
}
acir(inline) fn new f1 {
  b0():
    inc_rc [Field 0, Field 0]
    return [Field 0, Field 0], u32 0
}
acir(inline) fn append_note_hashes_with_logs f2 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: u32):
    v6 = load v0
    inc_rc v6
    v7 = load v2
    inc_rc v7
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v11 = load v3
    v13 = call f4(v8, v9)
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v19 = call f5(v14, v15)
    jmp b1(u32 0)
  b1(v5: u32):
    v21 = lt v5, v19
    jmpif v21 then: b3, else: b2
  b3():
    v24 = lt v5, v4
    jmpif v24 then: b4, else: b5
  b4():
    v25 = add v13, v5
    v26 = cast v25 as Field
    call f6(v0, v1, v2, v3, v26)
    jmp b5()
  b5():
    v29 = add v5, u32 1
    jmp b1(v29)
  b2():
    v22 = load v0
    dec_rc v22
    v23 = load v2
    dec_rc v23
    return 
}
acir(inline) fn swap_items f3 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: u32, v3: u32):
    v4 = load v0
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = array_get v5, index v2
    v8 = load v0
    v9 = load v1
    v10 = load v0
    v11 = load v1
    v12 = array_get v10, index v3
    v13 = array_set v8, index v2, value v12
    v15 = add v2, u32 1
    store v13 at v0
    store v9 at v1
    v16 = load v0
    v17 = load v1
    v18 = array_set v16, index v3, value v7
    v19 = add v3, u32 1
    store v18 at v0
    store v17 at v1
    v20 = load v0
    dec_rc v20
    return 
}
acir(inline) fn len f4 {
  b0(v0: [Field; 2], v1: u32):
    inc_rc v0
    dec_rc v0
    return v1
}
acir(inline) fn max_len f5 {
  b0(v0: [Field; 2], v1: u32):
    inc_rc v0
    dec_rc v0
    return u32 2
}
acir(inline) fn add_new_note_hash f6 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v2
    inc_rc v6
    call f7(v0, v1, v4)
    v8 = load v0
    dec_rc v8
    v9 = load v2
    dec_rc v9
    return 
}
acir(inline) fn push f7 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: Field):
    v3 = load v0
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v7 = lt v5, u32 2
    constrain v7 == u1 1 '"push out of bounds"'
    v9 = load v0
    v10 = load v1
    v11 = load v0
    v12 = load v1
    v13 = array_set v9, index v12, value v2
    v15 = add v12, u32 1
    store v13 at v0
    store v10 at v1
    v16 = load v0
    v17 = load v1
    v18 = load v0
    v19 = load v1
    v20 = add v19, u32 1
    store v16 at v0
    store v20 at v1
    v21 = load v0
    dec_rc v21
    return 
}

After Defunctionalization:
brillig fn main f0 {
  b0():
    v2, v3 = call f1()
    inc_rc v2
    v5, v6 = call f1()
    inc_rc v5
    inc_rc v2
    v7 = allocate
    store v2 at v7
    v8 = allocate
    store v3 at v8
    inc_rc v5
    v9 = allocate
    store v5 at v9
    v10 = allocate
    store v6 at v10
    call f2(v7, v8, v9, v10, u32 2)
    v13 = load v7
    v14 = load v8
    v15 = load v9
    v16 = load v10
    v19 = array_set v15, index u32 1, value Field 27
    store v13 at v7
    store v14 at v8
    store v19 at v9
    store v16 at v10
    v20 = load v7
    v21 = load v8
    v22 = load v9
    v23 = load v10
    inc_rc v20
    v25 = array_get v20, index u32 0
    call f3(v7, v8, u32 1, u32 0)
    jmp b1(u32 0)
  b1(v0: u32):
    v27 = eq v0, u32 0
    jmpif v27 then: b3, else: b2
  b3():
    v28 = array_get v20, index v0
    v29 = eq v28, v25
    constrain v28 == v25
    v30 = add v0, u32 1
    jmp b1(v30)
  b2():
    return 
}
acir(inline) fn new f1 {
  b0():
    inc_rc [Field 0, Field 0]
    return [Field 0, Field 0], u32 0
}
acir(inline) fn append_note_hashes_with_logs f2 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: u32):
    v6 = load v0
    inc_rc v6
    v7 = load v2
    inc_rc v7
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v11 = load v3
    v13 = call f4(v8, v9)
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v19 = call f5(v14, v15)
    jmp b1(u32 0)
  b1(v5: u32):
    v21 = lt v5, v19
    jmpif v21 then: b3, else: b2
  b3():
    v24 = lt v5, v4
    jmpif v24 then: b4, else: b5
  b4():
    v25 = add v13, v5
    v26 = cast v25 as Field
    call f6(v0, v1, v2, v3, v26)
    jmp b5()
  b5():
    v29 = add v5, u32 1
    jmp b1(v29)
  b2():
    v22 = load v0
    dec_rc v22
    v23 = load v2
    dec_rc v23
    return 
}
acir(inline) fn swap_items f3 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: u32, v3: u32):
    v4 = load v0
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = array_get v5, index v2
    v8 = load v0
    v9 = load v1
    v10 = load v0
    v11 = load v1
    v12 = array_get v10, index v3
    v13 = array_set v8, index v2, value v12
    v15 = add v2, u32 1
    store v13 at v0
    store v9 at v1
    v16 = load v0
    v17 = load v1
    v18 = array_set v16, index v3, value v7
    v19 = add v3, u32 1
    store v18 at v0
    store v17 at v1
    v20 = load v0
    dec_rc v20
    return 
}
acir(inline) fn len f4 {
  b0(v0: [Field; 2], v1: u32):
    inc_rc v0
    dec_rc v0
    return v1
}
acir(inline) fn max_len f5 {
  b0(v0: [Field; 2], v1: u32):
    inc_rc v0
    dec_rc v0
    return u32 2
}
acir(inline) fn add_new_note_hash f6 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v2
    inc_rc v6
    call f7(v0, v1, v4)
    v8 = load v0
    dec_rc v8
    v9 = load v2
    dec_rc v9
    return 
}
acir(inline) fn push f7 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: Field):
    v3 = load v0
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v7 = lt v5, u32 2
    constrain v7 == u1 1 '"push out of bounds"'
    v9 = load v0
    v10 = load v1
    v11 = load v0
    v12 = load v1
    v13 = array_set v9, index v12, value v2
    v15 = add v12, u32 1
    store v13 at v0
    store v10 at v1
    v16 = load v0
    v17 = load v1
    v18 = load v0
    v19 = load v1
    v20 = add v19, u32 1
    store v16 at v0
    store v20 at v1
    v21 = load v0
    dec_rc v21
    return 
}

After Removing Paired rc_inc & rc_decs:
brillig fn main f0 {
  b0():
    v2, v3 = call f1()
    inc_rc v2
    v5, v6 = call f1()
    inc_rc v5
    inc_rc v2
    v7 = allocate
    store v2 at v7
    v8 = allocate
    store v3 at v8
    inc_rc v5
    v9 = allocate
    store v5 at v9
    v10 = allocate
    store v6 at v10
    call f2(v7, v8, v9, v10, u32 2)
    v13 = load v7
    v14 = load v8
    v15 = load v9
    v16 = load v10
    v19 = array_set v15, index u32 1, value Field 27
    store v13 at v7
    store v14 at v8
    store v19 at v9
    store v16 at v10
    v20 = load v7
    v21 = load v8
    v22 = load v9
    v23 = load v10
    inc_rc v20
    v25 = array_get v20, index u32 0
    call f3(v7, v8, u32 1, u32 0)
    jmp b1(u32 0)
  b1(v0: u32):
    v27 = eq v0, u32 0
    jmpif v27 then: b3, else: b2
  b3():
    v28 = array_get v20, index v0
    v29 = eq v28, v25
    constrain v28 == v25
    v30 = add v0, u32 1
    jmp b1(v30)
  b2():
    return 
}
acir(inline) fn new f1 {
  b0():
    inc_rc [Field 0, Field 0]
    return [Field 0, Field 0], u32 0
}
acir(inline) fn append_note_hashes_with_logs f2 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: u32):
    v6 = load v0
    inc_rc v6
    v7 = load v2
    inc_rc v7
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v11 = load v3
    v13 = call f4(v8, v9)
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v19 = call f5(v14, v15)
    jmp b1(u32 0)
  b1(v5: u32):
    v21 = lt v5, v19
    jmpif v21 then: b3, else: b2
  b3():
    v24 = lt v5, v4
    jmpif v24 then: b4, else: b5
  b4():
    v25 = add v13, v5
    v26 = cast v25 as Field
    call f6(v0, v1, v2, v3, v26)
    jmp b5()
  b5():
    v29 = add v5, u32 1
    jmp b1(v29)
  b2():
    v22 = load v0
    dec_rc v22
    v23 = load v2
    dec_rc v23
    return 
}
acir(inline) fn swap_items f3 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: u32, v3: u32):
    v4 = load v0
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = array_get v5, index v2
    v8 = load v0
    v9 = load v1
    v10 = load v0
    v11 = load v1
    v12 = array_get v10, index v3
    v13 = array_set v8, index v2, value v12
    v15 = add v2, u32 1
    store v13 at v0
    store v9 at v1
    v16 = load v0
    v17 = load v1
    v18 = array_set v16, index v3, value v7
    v19 = add v3, u32 1
    store v18 at v0
    store v17 at v1
    v20 = load v0
    dec_rc v20
    return 
}
acir(inline) fn len f4 {
  b0(v0: [Field; 2], v1: u32):
    return v1
}
acir(inline) fn max_len f5 {
  b0(v0: [Field; 2], v1: u32):
    return u32 2
}
acir(inline) fn add_new_note_hash f6 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v2
    inc_rc v6
    call f7(v0, v1, v4)
    v8 = load v0
    dec_rc v8
    v9 = load v2
    dec_rc v9
    return 
}
acir(inline) fn push f7 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: Field):
    v3 = load v0
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v7 = lt v5, u32 2
    constrain v7 == u1 1 '"push out of bounds"'
    v9 = load v0
    v10 = load v1
    v11 = load v0
    v12 = load v1
    v13 = array_set v9, index v12, value v2
    v15 = add v12, u32 1
    store v13 at v0
    store v10 at v1
    v16 = load v0
    v17 = load v1
    v18 = load v0
    v19 = load v1
    v20 = add v19, u32 1
    store v16 at v0
    store v20 at v1
    v21 = load v0
    dec_rc v21
    return 
}

After Runtime Separation:
brillig fn main f0 {
  b0():
    v2, v3 = call f1()
    inc_rc v2
    v5, v6 = call f1()
    inc_rc v5
    inc_rc v2
    v7 = allocate
    store v2 at v7
    v8 = allocate
    store v3 at v8
    inc_rc v5
    v9 = allocate
    store v5 at v9
    v10 = allocate
    store v6 at v10
    call f2(v7, v8, v9, v10, u32 2)
    v13 = load v7
    v14 = load v8
    v15 = load v9
    v16 = load v10
    v19 = array_set v15, index u32 1, value Field 27
    store v13 at v7
    store v14 at v8
    store v19 at v9
    store v16 at v10
    v20 = load v7
    v21 = load v8
    v22 = load v9
    v23 = load v10
    inc_rc v20
    v25 = array_get v20, index u32 0
    call f3(v7, v8, u32 1, u32 0)
    jmp b1(u32 0)
  b1(v0: u32):
    v27 = eq v0, u32 0
    jmpif v27 then: b3, else: b2
  b3():
    v28 = array_get v20, index v0
    v29 = eq v28, v25
    constrain v28 == v25
    v30 = add v0, u32 1
    jmp b1(v30)
  b2():
    return 
}
brillig fn new f1 {
  b0():
    inc_rc [Field 0, Field 0]
    return [Field 0, Field 0], u32 0
}
brillig fn append_note_hashes_with_logs f2 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: u32):
    v6 = load v0
    inc_rc v6
    v7 = load v2
    inc_rc v7
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v11 = load v3
    v13 = call f4(v8, v9)
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v19 = call f5(v14, v15)
    jmp b1(u32 0)
  b1(v5: u32):
    v21 = lt v5, v19
    jmpif v21 then: b3, else: b2
  b3():
    v24 = lt v5, v4
    jmpif v24 then: b4, else: b5
  b4():
    v25 = add v13, v5
    v26 = cast v25 as Field
    call f6(v0, v1, v2, v3, v26)
    jmp b5()
  b5():
    v29 = add v5, u32 1
    jmp b1(v29)
  b2():
    v22 = load v0
    dec_rc v22
    v23 = load v2
    dec_rc v23
    return 
}
brillig fn swap_items f3 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: u32, v3: u32):
    v4 = load v0
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = array_get v5, index v2
    v8 = load v0
    v9 = load v1
    v10 = load v0
    v11 = load v1
    v12 = array_get v10, index v3
    v13 = array_set v8, index v2, value v12
    v15 = add v2, u32 1
    store v13 at v0
    store v9 at v1
    v16 = load v0
    v17 = load v1
    v18 = array_set v16, index v3, value v7
    v19 = add v3, u32 1
    store v18 at v0
    store v17 at v1
    v20 = load v0
    dec_rc v20
    return 
}
brillig fn len f4 {
  b0(v0: [Field; 2], v1: u32):
    return v1
}
brillig fn max_len f5 {
  b0(v0: [Field; 2], v1: u32):
    return u32 2
}
brillig fn add_new_note_hash f6 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v2
    inc_rc v6
    call f7(v0, v1, v4)
    v8 = load v0
    dec_rc v8
    v9 = load v2
    dec_rc v9
    return 
}
brillig fn push f7 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: Field):
    v3 = load v0
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v7 = lt v5, u32 2
    constrain v7 == u1 1 '"push out of bounds"'
    v9 = load v0
    v10 = load v1
    v11 = load v0
    v12 = load v1
    v13 = array_set v9, index v12, value v2
    v15 = add v12, u32 1
    store v13 at v0
    store v10 at v1
    v16 = load v0
    v17 = load v1
    v18 = load v0
    v19 = load v1
    v20 = add v19, u32 1
    store v16 at v0
    store v20 at v1
    v21 = load v0
    dec_rc v21
    return 
}

After Resolving IsUnconstrained:
brillig fn main f0 {
  b0():
    v2, v3 = call f1()
    inc_rc v2
    v5, v6 = call f1()
    inc_rc v5
    inc_rc v2
    v7 = allocate
    store v2 at v7
    v8 = allocate
    store v3 at v8
    inc_rc v5
    v9 = allocate
    store v5 at v9
    v10 = allocate
    store v6 at v10
    call f2(v7, v8, v9, v10, u32 2)
    v13 = load v7
    v14 = load v8
    v15 = load v9
    v16 = load v10
    v19 = array_set v15, index u32 1, value Field 27
    store v13 at v7
    store v14 at v8
    store v19 at v9
    store v16 at v10
    v20 = load v7
    v21 = load v8
    v22 = load v9
    v23 = load v10
    inc_rc v20
    v25 = array_get v20, index u32 0
    call f3(v7, v8, u32 1, u32 0)
    jmp b1(u32 0)
  b1(v0: u32):
    v27 = eq v0, u32 0
    jmpif v27 then: b3, else: b2
  b3():
    v28 = array_get v20, index v0
    v29 = eq v28, v25
    constrain v28 == v25
    v30 = add v0, u32 1
    jmp b1(v30)
  b2():
    return 
}
brillig fn new f1 {
  b0():
    inc_rc [Field 0, Field 0]
    return [Field 0, Field 0], u32 0
}
brillig fn append_note_hashes_with_logs f2 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: u32):
    v6 = load v0
    inc_rc v6
    v7 = load v2
    inc_rc v7
    v8 = load v0
    v9 = load v1
    v10 = load v2
    v11 = load v3
    v13 = call f4(v8, v9)
    v14 = load v0
    v15 = load v1
    v16 = load v2
    v17 = load v3
    v19 = call f5(v14, v15)
    jmp b1(u32 0)
  b1(v5: u32):
    v21 = lt v5, v19
    jmpif v21 then: b3, else: b2
  b3():
    v24 = lt v5, v4
    jmpif v24 then: b4, else: b5
  b4():
    v25 = add v13, v5
    v26 = cast v25 as Field
    call f6(v0, v1, v2, v3, v26)
    jmp b5()
  b5():
    v29 = add v5, u32 1
    jmp b1(v29)
  b2():
    v22 = load v0
    dec_rc v22
    v23 = load v2
    dec_rc v23
    return 
}
brillig fn swap_items f3 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: u32, v3: u32):
    v4 = load v0
    inc_rc v4
    v5 = load v0
    v6 = load v1
    v7 = array_get v5, index v2
    v8 = load v0
    v9 = load v1
    v10 = load v0
    v11 = load v1
    v12 = array_get v10, index v3
    v13 = array_set v8, index v2, value v12
    v15 = add v2, u32 1
    store v13 at v0
    store v9 at v1
    v16 = load v0
    v17 = load v1
    v18 = array_set v16, index v3, value v7
    v19 = add v3, u32 1
    store v18 at v0
    store v17 at v1
    v20 = load v0
    dec_rc v20
    return 
}
brillig fn len f4 {
  b0(v0: [Field; 2], v1: u32):
    return v1
}
brillig fn max_len f5 {
  b0(v0: [Field; 2], v1: u32):
    return u32 2
}
brillig fn add_new_note_hash f6 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: &mut [Field; 2], v3: &mut u32, v4: Field):
    v5 = load v0
    inc_rc v5
    v6 = load v2
    inc_rc v6
    call f7(v0, v1, v4)
    v8 = load v0
    dec_rc v8
    v9 = load v2
    dec_rc v9
    return 
}
brillig fn push f7 {
  b0(v0: &mut [Field; 2], v1: &mut u32, v2: Field):
    v3 = load v0
    inc_rc v3
    v4 = load v0
    v5 = load v1
    v7 = lt v5, u32 2
    constrain v7 == u1 1 '"push out of bounds"'
    v9 = load v0
    v10 = load v1
    v11 = load v0
    v12 = load v1
    v13 = array_set v9, index v12, value v2
    v15 = add v12, u32 1
    store v13 at v0
    store v10 at v1
    v16 = load v0
    v17 = load v1
    v18 = load v0
    v19 = load v1
    v20 = add v19, u32 1
    store v16 at v0
    store v20 at v1
    v21 = load v0
    dec_rc v21
    return 
}

After Inlining:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v5 = allocate
    store [Field 0, Field 0] at v5
    v6 = allocate
    store u32 0 at v6
    inc_rc [Field 0, Field 0]
    v8 = allocate
    store [Field 0, Field 0] at v8
    v9 = allocate
    store u32 0 at v9
    v10 = load v5
    inc_rc v10
    v11 = load v8
    inc_rc v11
    v12 = load v5
    v13 = load v6
    v14 = load v8
    v15 = load v9
    v16 = load v5
    v17 = load v6
    v18 = load v8
    v19 = load v9
    jmp b1(u32 0)
  b1(v0: u32):
    v21 = lt v0, u32 2
    jmpif v21 then: b6, else: b2
  b6():
    v54 = lt v0, u32 2
    jmpif v54 then: b7, else: b8
  b7():
    v55 = add v13, v0
    v56 = cast v55 as Field
    v57 = load v5
    inc_rc v57
    v58 = load v8
    inc_rc v58
    v59 = load v5
    inc_rc v59
    v60 = load v5
    v61 = load v6
    v62 = lt v61, u32 2
    constrain v62 == u1 1 '"push out of bounds"'
    v64 = load v5
    v65 = load v6
    v66 = load v5
    v67 = load v6
    v68 = array_set v64, index v67, value v56
    v69 = add v67, u32 1
    store v68 at v5
    store v65 at v6
    v70 = load v5
    v71 = load v6
    v72 = load v5
    v73 = load v6
    v74 = add v73, u32 1
    store v70 at v5
    store v74 at v6
    v75 = load v5
    dec_rc v75
    v76 = load v5
    dec_rc v76
    v77 = load v8
    dec_rc v77
    jmp b8()
  b8():
    v78 = add v0, u32 1
    jmp b1(v78)
  b2():
    v22 = load v5
    dec_rc v22
    v23 = load v8
    dec_rc v23
    v24 = load v5
    v25 = load v6
    v26 = load v8
    v27 = load v9
    v30 = array_set v26, index u32 1, value Field 27
    store v24 at v5
    store v25 at v6
    store v30 at v8
    store v27 at v9
    v31 = load v5
    v32 = load v6
    v33 = load v8
    v34 = load v9
    inc_rc v31
    v35 = array_get v31, index u32 0
    v36 = load v5
    inc_rc v36
    v37 = load v5
    v38 = load v6
    v39 = array_get v37, index u32 1
    v40 = load v5
    v41 = load v6
    v42 = load v5
    v43 = load v6
    v44 = array_get v42, index u32 0
    v45 = array_set v40, index u32 1, value v44
    store v45 at v5
    store v41 at v6
    v46 = load v5
    v47 = load v6
    v48 = array_set v46, index u32 0, value v39
    store v48 at v5
    store v47 at v6
    v49 = load v5
    dec_rc v49
    jmp b3(u32 0)
  b3(v1: u32):
    v50 = eq v1, u32 0
    jmpif v50 then: b5, else: b4
  b5():
    v51 = array_get v31, index v1
    v52 = eq v51, v35
    constrain v51 == v35
    v53 = add v1, u32 1
    jmp b3(v53)
  b4():
    return 
}

After Mem2Reg:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After `as_slice` optimization
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After `static_assert` and `assert_constant`:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Unrolling:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Simplifying:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Flattening:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Removing Bit Shifts:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Mem2Reg:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Inlining:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Remove IfElse:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v32 = lt v0, u32 2
    jmpif v32 then: b7, else: b8
  b7():
    v33 = cast v0 as Field
    v34 = load v6
    inc_rc v34
    v35 = load v10
    inc_rc v35
    v36 = load v6
    inc_rc v36
    v37 = load v7
    v38 = lt v37, u32 2
    constrain v38 == u1 1 '"push out of bounds"'
    v40 = load v6
    v41 = load v7
    v42 = load v7
    v43 = array_set v40, index v42, value v33
    v44 = add v42, u32 1
    v45 = add v41, u32 1
    store v43 at v6
    store v45 at v7
    dec_rc v43
    dec_rc v43
    v46 = load v10
    dec_rc v46
    jmp b8()
  b8():
    v47 = add v0, u32 1
    jmp b1(v47)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_get v18, index u32 0
    v26 = array_set v18, index u32 1, value v25
    v27 = array_set v26, index u32 0, value v24
    store v27 at v6
    dec_rc v27
    jmp b3(u32 0)
  b3(v1: u32):
    v28 = eq v1, u32 0
    jmpif v28 then: b5, else: b4
  b5():
    v29 = array_get v18, index v1
    v30 = eq v29, v23
    constrain v29 == v23
    v31 = add v1, u32 1
    jmp b3(v31)
  b4():
    return 
}

After Constant Folding:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v31 = lt v0, u32 2
    jmpif v31 then: b7, else: b8
  b7():
    v32 = cast v0 as Field
    v33 = load v6
    inc_rc v33
    v34 = load v10
    inc_rc v34
    v35 = load v6
    inc_rc v35
    v36 = load v7
    v37 = lt v36, u32 2
    constrain v37 == u1 1 '"push out of bounds"'
    v39 = load v6
    v40 = load v7
    v41 = load v7
    v42 = array_set v39, index v41, value v32
    v43 = add v41, u32 1
    v44 = add v40, u32 1
    store v42 at v6
    store v44 at v7
    dec_rc v42
    dec_rc v42
    v45 = load v10
    dec_rc v45
    jmp b8()
  b8():
    v46 = add v0, u32 1
    jmp b1(v46)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_set v18, index u32 1, value v23
    v26 = array_set v25, index u32 0, value v24
    store v26 at v6
    dec_rc v26
    jmp b3(u32 0)
  b3(v1: u32):
    v27 = eq v1, u32 0
    jmpif v27 then: b5, else: b4
  b5():
    v28 = array_get v18, index v1
    v29 = eq v28, v23
    constrain v28 == v23
    v30 = add v1, u32 1
    jmp b3(v30)
  b4():
    return 
}

After EnableSideEffectsIf removal:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v31 = lt v0, u32 2
    jmpif v31 then: b7, else: b8
  b7():
    v32 = cast v0 as Field
    v33 = load v6
    inc_rc v33
    v34 = load v10
    inc_rc v34
    v35 = load v6
    inc_rc v35
    v36 = load v7
    v37 = lt v36, u32 2
    constrain v37 == u1 1 '"push out of bounds"'
    v39 = load v6
    v40 = load v7
    v41 = load v7
    v42 = array_set v39, index v41, value v32
    v43 = add v41, u32 1
    v44 = add v40, u32 1
    store v42 at v6
    store v44 at v7
    dec_rc v42
    dec_rc v42
    v45 = load v10
    dec_rc v45
    jmp b8()
  b8():
    v46 = add v0, u32 1
    jmp b1(v46)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_set v18, index u32 1, value v23
    v26 = array_set v25, index u32 0, value v24
    store v26 at v6
    dec_rc v26
    jmp b3(u32 0)
  b3(v1: u32):
    v27 = eq v1, u32 0
    jmpif v27 then: b5, else: b4
  b5():
    v28 = array_get v18, index v1
    v29 = eq v28, v23
    constrain v28 == v23
    v30 = add v1, u32 1
    jmp b3(v30)
  b4():
    return 
}

After Constraint Folding:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    v6 = allocate
    store [Field 0, Field 0] at v6
    v7 = allocate
    store u32 0 at v7
    inc_rc [Field 0, Field 0]
    v10 = allocate
    store [Field 0, Field 0] at v10
    v11 = allocate
    inc_rc [Field 0, Field 0]
    inc_rc [Field 0, Field 0]
    jmp b1(u32 0)
  b1(v0: u32):
    v15 = lt v0, u32 2
    jmpif v15 then: b6, else: b2
  b6():
    v31 = lt v0, u32 2
    jmpif v31 then: b7, else: b8
  b7():
    v32 = cast v0 as Field
    v33 = load v6
    inc_rc v33
    v34 = load v10
    inc_rc v34
    v35 = load v6
    inc_rc v35
    v36 = load v7
    v37 = lt v36, u32 2
    constrain v37 == u1 1 '"push out of bounds"'
    v39 = load v6
    v40 = load v7
    v41 = load v7
    v42 = array_set v39, index v41, value v32
    v43 = add v41, u32 1
    v44 = add v40, u32 1
    store v42 at v6
    store v44 at v7
    dec_rc v42
    dec_rc v42
    v45 = load v10
    dec_rc v45
    jmp b8()
  b8():
    v46 = add v0, u32 1
    jmp b1(v46)
  b2():
    v16 = load v6
    dec_rc v16
    v17 = load v10
    dec_rc v17
    v18 = load v6
    v19 = load v10
    v22 = array_set v19, index u32 1, value Field 27
    store v22 at v10
    inc_rc v18
    v23 = array_get v18, index u32 0
    inc_rc v18
    v24 = array_get v18, index u32 1
    v25 = array_set v18, index u32 1, value v23
    v26 = array_set v25, index u32 0, value v24
    store v26 at v6
    dec_rc v26
    jmp b3(u32 0)
  b3(v1: u32):
    v27 = eq v1, u32 0
    jmpif v27 then: b5, else: b4
  b5():
    v28 = array_get v18, index v1
    v29 = eq v28, v23
    constrain v28 == v23
    v30 = add v1, u32 1
    jmp b3(v30)
  b4():
    return 
}

After Dead Instruction Elimination:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0] at v4
    v5 = allocate
    store u32 0 at v5
    inc_rc [Field 0, Field 0]
    v8 = allocate
    store [Field 0, Field 0] at v8
    jmp b1(u32 0)
  b1(v0: u32):
    v10 = lt v0, u32 2
    jmpif v10 then: b6, else: b2
  b6():
    v23 = lt v0, u32 2
    jmpif v23 then: b7, else: b8
  b7():
    v24 = cast v0 as Field
    v25 = load v5
    v26 = lt v25, u32 2
    constrain v26 == u1 1 '"push out of bounds"'
    v28 = load v4
    v29 = load v5
    v30 = load v5
    v31 = array_set v28, index v30, value v24
    v32 = add v29, u32 1
    store v31 at v4
    store v32 at v5
    dec_rc v31
    dec_rc v31
    jmp b8()
  b8():
    v33 = add v0, u32 1
    jmp b1(v33)
  b2():
    v11 = load v4
    v12 = load v8
    v15 = array_set v12, index u32 1, value Field 27
    store v15 at v8
    inc_rc v11
    v16 = array_get v11, index u32 0
    inc_rc v11
    v17 = array_get v11, index u32 1
    v18 = array_set v11, index u32 1, value v16
    v19 = array_set v18, index u32 0, value v17
    store v19 at v4
    dec_rc v19
    jmp b3(u32 0)
  b3(v1: u32):
    v20 = eq v1, u32 0
    jmpif v20 then: b5, else: b4
  b5():
    v21 = array_get v11, index v1
    constrain v21 == v16
    v22 = add v1, u32 1
    jmp b3(v22)
  b4():
    return 
}

After Array Set Optimizations:
brillig fn main f0 {
  b0():
    inc_rc [Field 0, Field 0]
    v4 = allocate
    store [Field 0, Field 0] at v4
    v5 = allocate
    store u32 0 at v5
    inc_rc [Field 0, Field 0]
    v8 = allocate
    store [Field 0, Field 0] at v8
    jmp b1(u32 0)
  b1(v0: u32):
    v10 = lt v0, u32 2
    jmpif v10 then: b6, else: b2
  b6():
    v23 = lt v0, u32 2
    jmpif v23 then: b7, else: b8
  b7():
    v24 = cast v0 as Field
    v25 = load v5
    v26 = lt v25, u32 2
    constrain v26 == u1 1 '"push out of bounds"'
    v28 = load v4
    v29 = load v5
    v30 = load v5
    v31 = array_set v28, index v30, value v24
    v32 = add v29, u32 1
    store v31 at v4
    store v32 at v5
    dec_rc v31
    dec_rc v31
    jmp b8()
  b8():
    v33 = add v0, u32 1
    jmp b1(v33)
  b2():
    v11 = load v4
    v12 = load v8
    v15 = array_set v12, index u32 1, value Field 27
    store v15 at v8
    inc_rc v11
    v16 = array_get v11, index u32 0
    inc_rc v11
    v17 = array_get v11, index u32 1
    v18 = array_set v11, index u32 1, value v16
    v19 = array_set v18, index u32 0, value v17
    store v19 at v4
    dec_rc v19
    jmp b3(u32 0)
  b3(v1: u32):
    v20 = eq v1, u32 0
    jmpif v20 then: b5, else: b4
  b5():
    v21 = array_get v11, index v1
    constrain v21 == v16
    v22 = add v1, u32 1
    jmp b3(v22)
  b4():
    return 
}

