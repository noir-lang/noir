After Initial SSA:
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After expand signed checks (1) (step 1):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Removing Unreachable Functions (1) (step 2):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Defunctionalization (1) (step 3):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Inlining simple functions (1) (step 4):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Removing Paired rc_inc & rc_decs (1) (step 5):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v10 = array_get v5, index v9 -> Field         	// src/main.nr:21:14
    v11 = unchecked_add v9, u32 1                 	// src/main.nr:21:14
    v12 = array_get v5, index v11 -> Field        	// src/main.nr:21:14
    v14 = unchecked_add v9, u32 2                 	// src/main.nr:21:14
    v15 = array_get v5, index v14 -> Field        	// src/main.nr:21:14
    v16 = make_array [v10, v12, v15] : [Field; 3] 	// src/main.nr:21:14
    v18 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v19 = array_get v5, index v18 -> Field        	// src/main.nr:21:14
    v20 = unchecked_add v18, u32 1                	// src/main.nr:21:14
    v21 = array_get v5, index v20 -> Field        	// src/main.nr:21:14
    v22 = unchecked_add v18, u32 2                	// src/main.nr:21:14
    v23 = array_get v5, index v22 -> Field        	// src/main.nr:21:14
    v24 = make_array [v19, v21, v23] : [Field; 3] 	// src/main.nr:21:14
    v26 = eq v8, Field 7                          	// src/main.nr:21:12
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]
    v7 = unchecked_mul v4, u32 7
    v8 = array_get v5, index v7 -> Field
    v9 = unchecked_add v7, u32 1
    v10 = array_get v5, index v9 -> Field
    v11 = unchecked_add v9, u32 1
    v12 = array_get v5, index v11 -> Field
    v14 = unchecked_add v9, u32 2
    v15 = array_get v5, index v14 -> Field
    v16 = make_array [v10, v12, v15] : [Field; 3]
    v18 = unchecked_add v7, u32 4
    v19 = array_get v5, index v18 -> Field
    v20 = unchecked_add v18, u32 1
    v21 = array_get v5, index v20 -> Field
    v22 = unchecked_add v18, u32 2
    v23 = array_get v5, index v22 -> Field
    v24 = make_array [v19, v21, v23] : [Field; 3]
    v26 = eq v8, Field 7
    constrain v8 == Field 7
    return
}
After Preprocessing Functions (1) (step 6):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v11 = lt v9, u32 28                           	// src/main.nr:21:14
    constrain v11 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v14 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v15 = lt v14, u32 28                          	// src/main.nr:21:14
    constrain v15 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Inlining (1) (step 7):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    store v0 at v2
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = load v2 -> [(Field, [Field; 3], [Field; 3]); 4]	// src/main.nr:21:14
    v7 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v8 = array_get v5, index v7 -> Field          	// src/main.nr:21:14
    v9 = unchecked_add v7, u32 1                  	// src/main.nr:21:14
    v11 = lt v9, u32 28                           	// src/main.nr:21:14
    constrain v11 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v14 = unchecked_add v7, u32 4                 	// src/main.nr:21:14
    v15 = lt v14, u32 28                          	// src/main.nr:21:14
    constrain v15 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v8 == Field 7                       	// src/main.nr:21:12
    return
}

After Mem2Reg (1) (step 8):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Simplifying (1) (step 9):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After `as_slice` optimization (1) (step 10):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After `static_assert` and `assert_constant` (1) (step 11):
acir(inline) fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Purity Analysis (1) (step 12):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Loop Invariant Code Motion (1) (step 13):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Unrolling (1) (step 14):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Simplifying (2) (step 15):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Mem2Reg (2) (step 16):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Removing Bit Shifts (1) (step 17):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Simplifying (3) (step 18):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Flattening (1) (step 19):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Mem2Reg (3) (step 20):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Inlining (2) (step 21):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Remove IfElse (1) (step 22):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Purity Analysis (2) (step 23):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Constant Folding (1) (step 24):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Simplify conditionals for unconstrained (1) (step 25):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After EnableSideEffectsIf removal (1) (step 26):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Constant Folding using constraints (1) (step 27):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Unrolling (2) (step 28):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Adding constrain not equal (1) (step 29):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Check u128 mul overflow (1) (step 30):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Simplifying (4) (step 31):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Mem2Reg (4) (step 32):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Remove Unreachable Instructions (1) (step 33):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v2 = allocate -> &mut [(Field, [Field; 3], [Field; 3]); 4]
    v4 = sub v1, u32 1                            	// src/main.nr:21:14
    v6 = unchecked_mul v4, u32 7                  	// src/main.nr:21:14
    v7 = array_get v0, index v6 -> Field          	// src/main.nr:21:14
    v8 = unchecked_add v6, u32 1                  	// src/main.nr:21:14
    v10 = lt v8, u32 28                           	// src/main.nr:21:14
    constrain v10 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    v13 = unchecked_add v6, u32 4                 	// src/main.nr:21:14
    v14 = lt v13, u32 28                          	// src/main.nr:21:14
    constrain v14 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v7 == Field 7                       	// src/main.nr:21:12
    return
}

After Dead Instruction Elimination (1) (step 34):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Array Set Optimizations (1) (step 35):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Brillig Entry Point Analysis (1) (step 36):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Removing Truncate after RangeCheck (1) (step 37):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Brillig Array Get and Set Optimizations (1) (step 38):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Dead Instruction Elimination (2) (step 39):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Checked to unchecked (1) (step 40):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Verifying no dynamic array indices to reference value elements (1) (step 41):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Inlining Brillig Calls (1) (step 42):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Remove Unreachable Instructions (2) (step 43):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

After Dead Instruction Elimination - ACIR (1) (step 44):
acir(inline) predicate_pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4], v1: u32):
    v3 = sub v1, u32 1                            	// src/main.nr:21:14
    v5 = unchecked_mul v3, u32 7                  	// src/main.nr:21:14
    v6 = array_get v0, index v5 -> Field          	// src/main.nr:21:14
    v7 = unchecked_add v5, u32 1                  	// src/main.nr:21:14
    v9 = lt v7, u32 28                            	// src/main.nr:21:14
    constrain v9 == u1 1, "Index out of bounds"   	// src/main.nr:21:14
    v12 = unchecked_add v5, u32 4                 	// src/main.nr:21:14
    v13 = lt v12, u32 28                          	// src/main.nr:21:14
    constrain v13 == u1 1, "Index out of bounds"  	// src/main.nr:21:14
    constrain v6 == Field 7                       	// src/main.nr:21:12
    return
}

[nested_array_dynamic] Circuit witness successfully solved
[nested_array_dynamic] Witness saved to target/nested_array_dynamic.gz
