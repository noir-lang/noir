After Initial SSA::
brillig(inline) fn main f0 {
  b0(v0: Field):
    call f1(u32 0)
    call f2(Field 0, v0)
    jmpif u1 0 then: b1, else: b2
  b1():
    jmp b3(f3)
  b2():
    jmp b3(f4)
  b3(v13: function):
    call f5(Field 1, v13)
    v16 = call v13() -> [u32; 2]
    v18 = array_get v16, index u32 1 -> u32
    v20 = eq v18, u32 2
    constrain v18 == u32 2
    v25 = call f6(f7, Field 5) -> Field
    v27 = eq v25, Field 20
    constrain v25 == Field 20
    v31 = call f8(Field 2, Field 3) -> Field
    v33 = eq v31, Field 6
    constrain v31 == Field 6
    v35 = call f9(Field 0, Field 1) -> Field
    v36 = eq v35, Field 3
    constrain v35 == Field 3
    call f2(Field 2, Field 42)
    call f11(Field 3, Field 42, f10)
    v41 = call f10(Field 42) -> Field
    v42 = eq v41, Field 42
    constrain v41 == Field 42
    v43 = allocate -> &mut Field
    store Field 2 at v43
    v46 = load v43 -> Field
    call f2(Field 4, v46)
    v47 = load v43 -> Field
    v48 = allocate -> &mut Field
    store v47 at v48
    v49 = load v48 -> Field
    v50 = add v49, Field 1
    call f2(Field 4, v50)
    store v50 at v48
    v52 = load v48 -> Field
    call f2(Field 5, v52)
    v54 = load v48 -> Field
    v55 = add v54, Field 1
    call f2(Field 4, v55)
    store v55 at v48
    v58 = call f12(v52, Field 1) -> Field
    v59 = eq v58, Field 4
    constrain v58 == Field 4
    v60 = load v48 -> Field
    call f14(Field 6, v60, f13)
    v63 = call f13(v60, Field 1) -> Field
    v64 = eq v63, Field 5
    constrain v63 == Field 5
    v65 = load v48 -> Field
    v66 = add v65, Field 1
    call f2(Field 4, v66)
    store v66 at v48
    v68 = call f13(v60, Field 1) -> Field
    v69 = eq v68, Field 5
    constrain v68 == Field 5
    call f15()
    v73 = call f6(f16, Field 3) -> Field
    call f2(Field 7, v73)
    call f17()
    v77 = add v0, v73
    call f18(Field 0)
    call f18(Field 6)
    call f18(Field 2)
    call f18(Field 5)
    call f18(Field 4)
    call f18(Field 7)
    call f18(Field 1)
    call f18(Field 3)
    call f19(u32 0)
    return v77
}
brillig(inline) fn __debug_fn_enter f1 {
  b0(v0: u32):
    call f64(v0)
    return
}
brillig(inline) fn __debug_var_assign f2 {
  b0(v0: u32, v1: Field):
    call f63(v0, v1)
    return
}
brillig(inline) fn foo f3 {
  b0():
    call f1(u32 2)
    v4 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v4
    call f19(u32 2)
    return v4
}
brillig(inline) fn bar f4 {
  b0():
    call f1(u32 3)
    v3 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v3
    call f19(u32 3)
    return v3
}
brillig(inline) fn __debug_var_assign f5 {
  b0(v0: u32, v1: function):
    call f62(v0, v1)
    return
}
brillig(inline) fn twice f6 {
  b0(v0: function, v1: Field):
    call f1(u32 5)
    call f60(Field 8, v0)
    call f2(Field 9, v1)
    v8 = call v0(v1) -> Field
    v9 = call v0(v8) -> Field
    call f18(Field 9)
    call f18(Field 8)
    call f19(u32 5)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f8 {
  b0(v0: Field, v1: Field):
    v3 = call f59(v0, v1) -> Field
    v5 = add v3, Field 1
    return v5
}
brillig(inline) fn lambda f9 {
  b0(v0: Field, v1: Field):
    v3 = call f58(v1) -> Field
    v4 = add v0, v3
    return v4
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn __debug_var_assign f11 {
  b0(v0: u32, v1: Field, v2: function):
    call f57(v0, v1, v2)
    return
}
brillig(inline) fn lambda f12 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn lambda f13 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn __debug_var_assign f14 {
  b0(v0: u32, v1: Field, v2: function):
    call f56(v0, v1, v2)
    return
}
brillig(inline) fn regression_2154 f15 {
  b0():
    call f1(u32 6)
    call f50(Field 10, u32 32)
    jmpif u1 1 then: b1, else: b2
  b1():
    jmp b3(u32 32, f51)
  b2():
    jmp b3(u32 32, f52)
  b3(v9: u32, v10: function):
    call f53(Field 11, v9, v10)
    v13 = call v10(v9) -> u32
    v14 = eq v13, u32 32
    constrain v13 == u32 32
    call f18(Field 10)
    call f18(Field 11)
    call f19(u32 6)
    return
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call f1(u32 4)
    call f2(Field 12, v0)
    v6 = add v0, Field 1
    call f18(Field 12)
    call f19(u32 4)
    return v6
}
brillig(inline) fn test_array_functions f17 {
  b0():
    call f1(u32 1)
    call f22(Field 13, i32 2)
    v7 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v7
    call f23(Field 14, v7)
    inc_rc v7
    inc_rc v7
    v12 = call f24(v7, f25) -> u1
    constrain v12 == u1 1
    v16 = call f26(v7, i32 2, f27) -> u1
    constrain v16 == u1 1
    v19 = call f28(v7, i32 2, f29) -> [i32; 3]
    inc_rc v19
    call f23(Field 15, v19)
    inc_rc v19
    inc_rc v19
    v24 = call f30(v19, f31) -> u1
    constrain v24 == u1 1
    v27 = call f32(v19, i32 2, f33) -> u1
    constrain v27 == u1 1
    v31 = call f34(v19, i32 0, f35) -> i32
    v33 = eq v31, i32 12
    constrain v31 == i32 12
    v36 = call f36(v19, i32 0, i32 2, f37) -> i32
    v38 = eq v36, i32 18
    constrain v36 == i32 18
    v41 = call f38(v19, f39) -> i32
    v42 = eq v41, i32 12
    constrain v41 == i32 12
    v45 = call f40(v19, i32 2, f41) -> i32
    v47 = eq v45, i32 16
    constrain v45 == i32 16
    v51 = call f43(v19, f44) -> [i32; 3]
    v52 = call f42(v51, v7) -> u1
    constrain v52 == u1 1
    v56 = call f28(v19, i32 2, f45) -> [i32; 3]
    v57 = call f42(v56, v7) -> u1
    constrain v57 == u1 1
    call f18(Field 15)
    call f18(Field 13)
    call f18(Field 14)
    call f19(u32 1)
    return
}
brillig(inline) fn __debug_var_drop f18 {
  b0(v0: u32):
    call f21(v0)
    return
}
brillig(inline) fn __debug_fn_exit f19 {
  b0(v0: u32):
    call f20(v0)
    return
}
brillig(inline) fn __debug_fn_exit_inner f20 {
  b0(v0: u32):
    call __debug_fn_exit(v0)
    return
}
brillig(inline) fn __debug_var_drop_inner f21 {
  b0(v0: u32):
    call __debug_var_drop(v0)
    return
}
brillig(inline) fn __debug_var_assign f22 {
  b0(v0: u32, v1: i32):
    call f49(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f23 {
  b0(v0: u32, v1: [i32; 3]):
    call f48(v0, v1)
    return
}
brillig(inline) fn any f24 {
  b0(v0: [i32; 3], v1: function):
    v3 = allocate -> &mut u1
    store u1 0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call v1(v10) -> u1
    v13 = or v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn any f26 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = allocate -> &mut u1
    store u1 0 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call v2(v1, v11) -> u1
    v14 = or v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v3, v2
    return v4
}
brillig(inline) fn map f28 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v4
    v5 = allocate -> &mut [i32; 3]
    store v4 at v5
    jmp b1(u32 0)
  b1(v6: u32):
    v10 = lt v6, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v5 -> [i32; 3]
    v13 = array_get v0, index v6 -> i32
    v14 = call v2(v1, v13) -> i32
    v15 = array_set v11, index v6, value v14
    v16 = add v6, u32 1
    store v15 at v5
    v17 = add v6, u32 1
    jmp b1(v17)
  b3():
    v18 = load v5 -> [i32; 3]
    return v18
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = mul v2, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v8 = cast v2 as u32
    v9 = cast v3 as u32
    v10 = lt v8, u32 2147483648
    v11 = lt v9, u32 2147483648
    v12 = eq v10, v11
    v14 = not v10
    v15 = cast v2 as Field
    v16 = cast v10 as Field
    v17 = mul v16, v15
    v18 = sub Field 4294967296, v15
    v19 = cast v14 as Field
    v20 = mul v19, v18
    v21 = add v17, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn all f30 {
  b0(v0: [i32; 3], v1: function):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call v1(v10) -> u1
    v13 = mul v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn all f32 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = allocate -> &mut u1
    store u1 1 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call v2(v1, v11) -> u1
    v14 = mul v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v2, v3
    v5 = not v4
    return v5
}
brillig(inline) fn fold f34 {
  b0(v0: [i32; 3], v1: i32, v3: function):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v2 -> i32
    v12 = call v3(v11, v10) -> i32
    store v12 at v2
    v13 = add v4, u32 1
    jmp b1(v13)
  b3():
    v14 = load v2 -> i32
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn fold f36 {
  b0(v0: [i32; 3], v1: i32, v3: i32, v4: function):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v2 -> i32
    v13 = call v4(v3, v12, v11) -> i32
    store v13 at v2
    v14 = add v5, u32 1
    jmp b1(v14)
  b3():
    v15 = load v2 -> i32
    return v15
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn reduce f38 {
  b0(v0: [i32; 3], v1: function):
    v5 = array_get v0, index u32 0 -> i32
    v6 = allocate -> &mut i32
    store v5 at v6
    jmp b1(u32 1)
  b1(v7: u32):
    v10 = lt v7, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v6 -> i32
    v12 = array_get v0, index v7 -> i32
    v13 = call v1(v11, v12) -> i32
    store v13 at v6
    v14 = add v7, u32 1
    jmp b1(v14)
  b3():
    v15 = load v6 -> i32
    return v15
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn reduce f40 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v6 = array_get v0, index u32 0 -> i32
    v7 = allocate -> &mut i32
    store v6 at v7
    jmp b1(u32 1)
  b1(v8: u32):
    v11 = lt v8, u32 3
    jmpif v11 then: b2, else: b3
  b2():
    v12 = load v7 -> i32
    v13 = array_get v0, index v8 -> i32
    v14 = call v2(v1, v12, v13) -> i32
    store v14 at v7
    v15 = add v8, u32 1
    jmp b1(v15)
  b3():
    v16 = load v7 -> i32
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn eq f42 {
  b0(v0: [i32; 3], v1: [i32; 3]):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v9 = load v3 -> u1
    v12 = array_get v0, index v4 -> i32
    v13 = array_get v1, index v4 -> i32
    v14 = call f46(v12, v13) -> u1
    v15 = mul v9, v14
    store v15 at v3
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v3 -> u1
    return v17
}
brillig(inline) fn map f43 {
  b0(v0: [i32; 3], v1: function):
    v3 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v3
    v4 = allocate -> &mut [i32; 3]
    store v3 at v4
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v10 = load v4 -> [i32; 3]
    v12 = array_get v0, index v5 -> i32
    v13 = call v1(v12) -> i32
    v14 = array_set v10, index v5, value v13
    v15 = add v5, u32 1
    store v14 at v4
    v16 = add v5, u32 1
    jmp b1(v16)
  b3():
    v17 = load v4 -> [i32; 3]
    return v17
}
brillig(inline) fn lambda f44 {
  b0(v0: i32):
    v2 = div v0, i32 2
    return v2
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = div v2, v3
    return v4
}
brillig(inline) fn eq f46 {
  b0(v0: i32, v1: i32):
    v2 = eq v0, v1
    return v2
}
brillig(inline) fn add f47 {
  b0(v0: i32, v1: i32):
    v2 = add v0, v1
    v3 = truncate v2 to 32 bits, max_bit_size: 33
    v4 = cast v3 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v8 = lt v6, u32 2147483648
    v9 = lt v7, u32 2147483648
    v10 = eq v8, v9
    v11 = lt v4, u32 2147483648
    v12 = eq v11, v8
    v13 = mul v12, v10
    constrain v13 == v10, "attempt to add with overflow"
    v14 = cast v3 as i32
    return v14
}
brillig(inline) fn __debug_var_assign_inner f48 {
  b0(v0: u32, v1: [i32; 3]):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f49 {
  b0(v0: u32, v1: i32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f50 {
  b0(v0: u32, v1: u32):
    call f55(v0, v1)
    return
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}
brillig(inline) fn __debug_var_assign f53 {
  b0(v0: u32, v1: u32, v2: function):
    call f54(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f54 {
  b0(v0: u32, v1: u32, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f55 {
  b0(v0: u32, v1: u32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f56 {
  b0(v0: u32, v1: Field, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f57 {
  b0(v0: u32, v1: Field, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn lambda f58 {
  b0(v0: Field):
    v2 = add v0, Field 2
    return v2
}
brillig(inline) fn add f59 {
  b0(v0: Field, v1: Field):
    v2 = add v0, v1
    return v2
}
brillig(inline) fn __debug_var_assign f60 {
  b0(v0: u32, v1: function):
    call f61(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f61 {
  b0(v0: u32, v1: function):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f62 {
  b0(v0: u32, v1: function):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f63 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_fn_enter_inner f64 {
  b0(v0: u32):
    call __debug_fn_enter(v0)
    return
}

After Removing Unreachable Functions:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call f1(u32 0)
    call f2(Field 0, v0)
    jmpif u1 0 then: b1, else: b2
  b1():
    jmp b3(f3)
  b2():
    jmp b3(f4)
  b3(v13: function):
    call f5(Field 1, v13)
    v16 = call v13() -> [u32; 2]
    v18 = array_get v16, index u32 1 -> u32
    v20 = eq v18, u32 2
    constrain v18 == u32 2
    v25 = call f6(f7, Field 5) -> Field
    v27 = eq v25, Field 20
    constrain v25 == Field 20
    v31 = call f8(Field 2, Field 3) -> Field
    v33 = eq v31, Field 6
    constrain v31 == Field 6
    v35 = call f9(Field 0, Field 1) -> Field
    v36 = eq v35, Field 3
    constrain v35 == Field 3
    call f2(Field 2, Field 42)
    call f11(Field 3, Field 42, f10)
    v41 = call f10(Field 42) -> Field
    v42 = eq v41, Field 42
    constrain v41 == Field 42
    v43 = allocate -> &mut Field
    store Field 2 at v43
    v46 = load v43 -> Field
    call f2(Field 4, v46)
    v47 = load v43 -> Field
    v48 = allocate -> &mut Field
    store v47 at v48
    v49 = load v48 -> Field
    v50 = add v49, Field 1
    call f2(Field 4, v50)
    store v50 at v48
    v52 = load v48 -> Field
    call f2(Field 5, v52)
    v54 = load v48 -> Field
    v55 = add v54, Field 1
    call f2(Field 4, v55)
    store v55 at v48
    v58 = call f12(v52, Field 1) -> Field
    v59 = eq v58, Field 4
    constrain v58 == Field 4
    v60 = load v48 -> Field
    call f14(Field 6, v60, f13)
    v63 = call f13(v60, Field 1) -> Field
    v64 = eq v63, Field 5
    constrain v63 == Field 5
    v65 = load v48 -> Field
    v66 = add v65, Field 1
    call f2(Field 4, v66)
    store v66 at v48
    v68 = call f13(v60, Field 1) -> Field
    v69 = eq v68, Field 5
    constrain v68 == Field 5
    call f15()
    v73 = call f6(f16, Field 3) -> Field
    call f2(Field 7, v73)
    call f17()
    v77 = add v0, v73
    call f18(Field 0)
    call f18(Field 6)
    call f18(Field 2)
    call f18(Field 5)
    call f18(Field 4)
    call f18(Field 7)
    call f18(Field 1)
    call f18(Field 3)
    call f19(u32 0)
    return v77
}
brillig(inline) fn __debug_fn_enter f1 {
  b0(v0: u32):
    call f64(v0)
    return
}
brillig(inline) fn __debug_var_assign f2 {
  b0(v0: u32, v1: Field):
    call f63(v0, v1)
    return
}
brillig(inline) fn foo f3 {
  b0():
    call f1(u32 2)
    v4 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v4
    call f19(u32 2)
    return v4
}
brillig(inline) fn bar f4 {
  b0():
    call f1(u32 3)
    v3 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v3
    call f19(u32 3)
    return v3
}
brillig(inline) fn __debug_var_assign f5 {
  b0(v0: u32, v1: function):
    call f62(v0, v1)
    return
}
brillig(inline) fn twice f6 {
  b0(v0: function, v1: Field):
    call f1(u32 5)
    call f60(Field 8, v0)
    call f2(Field 9, v1)
    v8 = call v0(v1) -> Field
    v9 = call v0(v8) -> Field
    call f18(Field 9)
    call f18(Field 8)
    call f19(u32 5)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f8 {
  b0(v0: Field, v1: Field):
    v3 = call f59(v0, v1) -> Field
    v5 = add v3, Field 1
    return v5
}
brillig(inline) fn lambda f9 {
  b0(v0: Field, v1: Field):
    v3 = call f58(v1) -> Field
    v4 = add v0, v3
    return v4
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn __debug_var_assign f11 {
  b0(v0: u32, v1: Field, v2: function):
    call f57(v0, v1, v2)
    return
}
brillig(inline) fn lambda f12 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn lambda f13 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn __debug_var_assign f14 {
  b0(v0: u32, v1: Field, v2: function):
    call f56(v0, v1, v2)
    return
}
brillig(inline) fn regression_2154 f15 {
  b0():
    call f1(u32 6)
    call f50(Field 10, u32 32)
    jmpif u1 1 then: b1, else: b2
  b1():
    jmp b3(u32 32, f51)
  b2():
    jmp b3(u32 32, f52)
  b3(v9: u32, v10: function):
    call f53(Field 11, v9, v10)
    v13 = call v10(v9) -> u32
    v14 = eq v13, u32 32
    constrain v13 == u32 32
    call f18(Field 10)
    call f18(Field 11)
    call f19(u32 6)
    return
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call f1(u32 4)
    call f2(Field 12, v0)
    v6 = add v0, Field 1
    call f18(Field 12)
    call f19(u32 4)
    return v6
}
brillig(inline) fn test_array_functions f17 {
  b0():
    call f1(u32 1)
    call f22(Field 13, i32 2)
    v7 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v7
    call f23(Field 14, v7)
    inc_rc v7
    inc_rc v7
    v12 = call f24(v7, f25) -> u1
    constrain v12 == u1 1
    v16 = call f26(v7, i32 2, f27) -> u1
    constrain v16 == u1 1
    v19 = call f28(v7, i32 2, f29) -> [i32; 3]
    inc_rc v19
    call f23(Field 15, v19)
    inc_rc v19
    inc_rc v19
    v24 = call f30(v19, f31) -> u1
    constrain v24 == u1 1
    v27 = call f32(v19, i32 2, f33) -> u1
    constrain v27 == u1 1
    v31 = call f34(v19, i32 0, f35) -> i32
    v33 = eq v31, i32 12
    constrain v31 == i32 12
    v36 = call f36(v19, i32 0, i32 2, f37) -> i32
    v38 = eq v36, i32 18
    constrain v36 == i32 18
    v41 = call f38(v19, f39) -> i32
    v42 = eq v41, i32 12
    constrain v41 == i32 12
    v45 = call f40(v19, i32 2, f41) -> i32
    v47 = eq v45, i32 16
    constrain v45 == i32 16
    v51 = call f43(v19, f44) -> [i32; 3]
    v52 = call f42(v51, v7) -> u1
    constrain v52 == u1 1
    v56 = call f28(v19, i32 2, f45) -> [i32; 3]
    v57 = call f42(v56, v7) -> u1
    constrain v57 == u1 1
    call f18(Field 15)
    call f18(Field 13)
    call f18(Field 14)
    call f19(u32 1)
    return
}
brillig(inline) fn __debug_var_drop f18 {
  b0(v0: u32):
    call f21(v0)
    return
}
brillig(inline) fn __debug_fn_exit f19 {
  b0(v0: u32):
    call f20(v0)
    return
}
brillig(inline) fn __debug_fn_exit_inner f20 {
  b0(v0: u32):
    call __debug_fn_exit(v0)
    return
}
brillig(inline) fn __debug_var_drop_inner f21 {
  b0(v0: u32):
    call __debug_var_drop(v0)
    return
}
brillig(inline) fn __debug_var_assign f22 {
  b0(v0: u32, v1: i32):
    call f49(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f23 {
  b0(v0: u32, v1: [i32; 3]):
    call f48(v0, v1)
    return
}
brillig(inline) fn any f24 {
  b0(v0: [i32; 3], v1: function):
    v3 = allocate -> &mut u1
    store u1 0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call v1(v10) -> u1
    v13 = or v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn any f26 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = allocate -> &mut u1
    store u1 0 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call v2(v1, v11) -> u1
    v14 = or v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v3, v2
    return v4
}
brillig(inline) fn map f28 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v4
    v5 = allocate -> &mut [i32; 3]
    store v4 at v5
    jmp b1(u32 0)
  b1(v6: u32):
    v10 = lt v6, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v5 -> [i32; 3]
    v13 = array_get v0, index v6 -> i32
    v14 = call v2(v1, v13) -> i32
    v15 = array_set v11, index v6, value v14
    v16 = add v6, u32 1
    store v15 at v5
    v17 = add v6, u32 1
    jmp b1(v17)
  b3():
    v18 = load v5 -> [i32; 3]
    return v18
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = mul v2, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v8 = cast v2 as u32
    v9 = cast v3 as u32
    v10 = lt v8, u32 2147483648
    v11 = lt v9, u32 2147483648
    v12 = eq v10, v11
    v14 = not v10
    v15 = cast v2 as Field
    v16 = cast v10 as Field
    v17 = mul v16, v15
    v18 = sub Field 4294967296, v15
    v19 = cast v14 as Field
    v20 = mul v19, v18
    v21 = add v17, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn all f30 {
  b0(v0: [i32; 3], v1: function):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call v1(v10) -> u1
    v13 = mul v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn all f32 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v4 = allocate -> &mut u1
    store u1 1 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call v2(v1, v11) -> u1
    v14 = mul v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v2, v3
    v5 = not v4
    return v5
}
brillig(inline) fn fold f34 {
  b0(v0: [i32; 3], v1: i32, v3: function):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v2 -> i32
    v12 = call v3(v11, v10) -> i32
    store v12 at v2
    v13 = add v4, u32 1
    jmp b1(v13)
  b3():
    v14 = load v2 -> i32
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn fold f36 {
  b0(v0: [i32; 3], v1: i32, v3: i32, v4: function):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v2 -> i32
    v13 = call v4(v3, v12, v11) -> i32
    store v13 at v2
    v14 = add v5, u32 1
    jmp b1(v14)
  b3():
    v15 = load v2 -> i32
    return v15
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn reduce f38 {
  b0(v0: [i32; 3], v1: function):
    v5 = array_get v0, index u32 0 -> i32
    v6 = allocate -> &mut i32
    store v5 at v6
    jmp b1(u32 1)
  b1(v7: u32):
    v10 = lt v7, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v6 -> i32
    v12 = array_get v0, index v7 -> i32
    v13 = call v1(v11, v12) -> i32
    store v13 at v6
    v14 = add v7, u32 1
    jmp b1(v14)
  b3():
    v15 = load v6 -> i32
    return v15
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn reduce f40 {
  b0(v0: [i32; 3], v1: i32, v2: function):
    v6 = array_get v0, index u32 0 -> i32
    v7 = allocate -> &mut i32
    store v6 at v7
    jmp b1(u32 1)
  b1(v8: u32):
    v11 = lt v8, u32 3
    jmpif v11 then: b2, else: b3
  b2():
    v12 = load v7 -> i32
    v13 = array_get v0, index v8 -> i32
    v14 = call v2(v1, v12, v13) -> i32
    store v14 at v7
    v15 = add v8, u32 1
    jmp b1(v15)
  b3():
    v16 = load v7 -> i32
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn eq f42 {
  b0(v0: [i32; 3], v1: [i32; 3]):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v9 = load v3 -> u1
    v12 = array_get v0, index v4 -> i32
    v13 = array_get v1, index v4 -> i32
    v14 = call f46(v12, v13) -> u1
    v15 = mul v9, v14
    store v15 at v3
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v3 -> u1
    return v17
}
brillig(inline) fn map f43 {
  b0(v0: [i32; 3], v1: function):
    v3 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v3
    v4 = allocate -> &mut [i32; 3]
    store v3 at v4
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v10 = load v4 -> [i32; 3]
    v12 = array_get v0, index v5 -> i32
    v13 = call v1(v12) -> i32
    v14 = array_set v10, index v5, value v13
    v15 = add v5, u32 1
    store v14 at v4
    v16 = add v5, u32 1
    jmp b1(v16)
  b3():
    v17 = load v4 -> [i32; 3]
    return v17
}
brillig(inline) fn lambda f44 {
  b0(v0: i32):
    v2 = div v0, i32 2
    return v2
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = div v2, v3
    return v4
}
brillig(inline) fn eq f46 {
  b0(v0: i32, v1: i32):
    v2 = eq v0, v1
    return v2
}
brillig(inline) fn add f47 {
  b0(v0: i32, v1: i32):
    v2 = add v0, v1
    v3 = truncate v2 to 32 bits, max_bit_size: 33
    v4 = cast v3 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v8 = lt v6, u32 2147483648
    v9 = lt v7, u32 2147483648
    v10 = eq v8, v9
    v11 = lt v4, u32 2147483648
    v12 = eq v11, v8
    v13 = mul v12, v10
    constrain v13 == v10, "attempt to add with overflow"
    v14 = cast v3 as i32
    return v14
}
brillig(inline) fn __debug_var_assign_inner f48 {
  b0(v0: u32, v1: [i32; 3]):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f49 {
  b0(v0: u32, v1: i32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f50 {
  b0(v0: u32, v1: u32):
    call f55(v0, v1)
    return
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}
brillig(inline) fn __debug_var_assign f53 {
  b0(v0: u32, v1: u32, v2: function):
    call f54(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f54 {
  b0(v0: u32, v1: u32, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f55 {
  b0(v0: u32, v1: u32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f56 {
  b0(v0: u32, v1: Field, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f57 {
  b0(v0: u32, v1: Field, v2: function):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn lambda f58 {
  b0(v0: Field):
    v2 = add v0, Field 2
    return v2
}
brillig(inline) fn add f59 {
  b0(v0: Field, v1: Field):
    v2 = add v0, v1
    return v2
}
brillig(inline) fn __debug_var_assign f60 {
  b0(v0: u32, v1: function):
    call f61(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f61 {
  b0(v0: u32, v1: function):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f62 {
  b0(v0: u32, v1: function):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f63 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_fn_enter_inner f64 {
  b0(v0: u32):
    call __debug_fn_enter(v0)
    return
}

After Defunctionalization:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call f1(u32 0)
    call f2(Field 0, v0)
    jmpif u1 0 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    jmp b3(Field 4)
  b3(v13: Field):
    call f5(Field 1, v13)
    v16 = call f65(v13) -> [u32; 2]
    v18 = array_get v16, index u32 1 -> u32
    v20 = eq v18, u32 2
    constrain v18 == u32 2
    v25 = call f6(Field 7, Field 5) -> Field
    v27 = eq v25, Field 20
    constrain v25 == Field 20
    v31 = call f8(Field 2, Field 3) -> Field
    v33 = eq v31, Field 6
    constrain v31 == Field 6
    v35 = call f9(Field 0, Field 1) -> Field
    v36 = eq v35, Field 3
    constrain v35 == Field 3
    call f2(Field 2, Field 42)
    call f11(Field 3, Field 42, f10)
    v41 = call f10(Field 42) -> Field
    v42 = eq v41, Field 42
    constrain v41 == Field 42
    v43 = allocate -> &mut Field
    store Field 2 at v43
    v46 = load v43 -> Field
    call f2(Field 4, v46)
    v47 = load v43 -> Field
    v48 = allocate -> &mut Field
    store v47 at v48
    v49 = load v48 -> Field
    v50 = add v49, Field 1
    call f2(Field 4, v50)
    store v50 at v48
    v52 = load v48 -> Field
    call f2(Field 5, v52)
    v54 = load v48 -> Field
    v55 = add v54, Field 1
    call f2(Field 4, v55)
    store v55 at v48
    v58 = call f12(v52, Field 1) -> Field
    v59 = eq v58, Field 4
    constrain v58 == Field 4
    v60 = load v48 -> Field
    call f14(Field 6, v60, f13)
    v63 = call f13(v60, Field 1) -> Field
    v64 = eq v63, Field 5
    constrain v63 == Field 5
    v65 = load v48 -> Field
    v66 = add v65, Field 1
    call f2(Field 4, v66)
    store v66 at v48
    v68 = call f13(v60, Field 1) -> Field
    v69 = eq v68, Field 5
    constrain v68 == Field 5
    call f15()
    v73 = call f6(Field 16, Field 3) -> Field
    call f2(Field 7, v73)
    call f17()
    v77 = add v0, v73
    call f18(Field 0)
    call f18(Field 6)
    call f18(Field 2)
    call f18(Field 5)
    call f18(Field 4)
    call f18(Field 7)
    call f18(Field 1)
    call f18(Field 3)
    call f19(u32 0)
    return v77
}
brillig(inline) fn __debug_fn_enter f1 {
  b0(v0: u32):
    call f64(v0)
    return
}
brillig(inline) fn __debug_var_assign f2 {
  b0(v0: u32, v1: Field):
    call f63(v0, v1)
    return
}
brillig(inline) fn foo f3 {
  b0():
    call f1(u32 2)
    v4 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v4
    call f19(u32 2)
    return v4
}
brillig(inline) fn bar f4 {
  b0():
    call f1(u32 3)
    v3 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v3
    call f19(u32 3)
    return v3
}
brillig(inline) fn __debug_var_assign f5 {
  b0(v0: u32, v1: Field):
    call f62(v0, v1)
    return
}
brillig(inline) fn twice f6 {
  b0(v0: Field, v1: Field):
    call f1(u32 5)
    call f60(Field 8, v0)
    call f2(Field 9, v1)
    v8 = call f71(v0, v1) -> Field
    v9 = call f71(v0, v8) -> Field
    call f18(Field 9)
    call f18(Field 8)
    call f19(u32 5)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f8 {
  b0(v0: Field, v1: Field):
    v3 = call f59(v0, v1) -> Field
    v5 = add v3, Field 1
    return v5
}
brillig(inline) fn lambda f9 {
  b0(v0: Field, v1: Field):
    v3 = call f58(v1) -> Field
    v4 = add v0, v3
    return v4
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn __debug_var_assign f11 {
  b0(v0: u32, v1: Field, v2: Field):
    call f57(v0, v1, v2)
    return
}
brillig(inline) fn lambda f12 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn lambda f13 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn __debug_var_assign f14 {
  b0(v0: u32, v1: Field, v2: Field):
    call f56(v0, v1, v2)
    return
}
brillig(inline) fn regression_2154 f15 {
  b0():
    call f1(u32 6)
    call f50(Field 10, u32 32)
    jmpif u1 1 then: b1, else: b2
  b1():
    jmp b3(u32 32, Field 51)
  b2():
    jmp b3(u32 32, Field 52)
  b3(v9: u32, v10: Field):
    call f53(Field 11, v9, v10)
    v13 = call f70(v10, v9) -> u32
    v14 = eq v13, u32 32
    constrain v13 == u32 32
    call f18(Field 10)
    call f18(Field 11)
    call f19(u32 6)
    return
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call f1(u32 4)
    call f2(Field 12, v0)
    v6 = add v0, Field 1
    call f18(Field 12)
    call f19(u32 4)
    return v6
}
brillig(inline) fn test_array_functions f17 {
  b0():
    call f1(u32 1)
    call f22(Field 13, i32 2)
    v7 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v7
    call f23(Field 14, v7)
    inc_rc v7
    inc_rc v7
    v12 = call f24(v7, Field 25) -> u1
    constrain v12 == u1 1
    v16 = call f26(v7, i32 2, Field 27) -> u1
    constrain v16 == u1 1
    v19 = call f28(v7, i32 2, Field 29) -> [i32; 3]
    inc_rc v19
    call f23(Field 15, v19)
    inc_rc v19
    inc_rc v19
    v24 = call f30(v19, Field 31) -> u1
    constrain v24 == u1 1
    v27 = call f32(v19, i32 2, Field 33) -> u1
    constrain v27 == u1 1
    v31 = call f34(v19, i32 0, Field 35) -> i32
    v33 = eq v31, i32 12
    constrain v31 == i32 12
    v36 = call f36(v19, i32 0, i32 2, Field 37) -> i32
    v38 = eq v36, i32 18
    constrain v36 == i32 18
    v41 = call f38(v19, Field 39) -> i32
    v42 = eq v41, i32 12
    constrain v41 == i32 12
    v45 = call f40(v19, i32 2, Field 41) -> i32
    v47 = eq v45, i32 16
    constrain v45 == i32 16
    v51 = call f43(v19, Field 44) -> [i32; 3]
    v52 = call f42(v51, v7) -> u1
    constrain v52 == u1 1
    v56 = call f28(v19, i32 2, Field 45) -> [i32; 3]
    v57 = call f42(v56, v7) -> u1
    constrain v57 == u1 1
    call f18(Field 15)
    call f18(Field 13)
    call f18(Field 14)
    call f19(u32 1)
    return
}
brillig(inline) fn __debug_var_drop f18 {
  b0(v0: u32):
    call f21(v0)
    return
}
brillig(inline) fn __debug_fn_exit f19 {
  b0(v0: u32):
    call f20(v0)
    return
}
brillig(inline) fn __debug_fn_exit_inner f20 {
  b0(v0: u32):
    call __debug_fn_exit(v0)
    return
}
brillig(inline) fn __debug_var_drop_inner f21 {
  b0(v0: u32):
    call __debug_var_drop(v0)
    return
}
brillig(inline) fn __debug_var_assign f22 {
  b0(v0: u32, v1: i32):
    call f49(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f23 {
  b0(v0: u32, v1: [i32; 3]):
    call f48(v0, v1)
    return
}
brillig(inline) fn any f24 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = or v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn any f26 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 0 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = or v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v3, v2
    return v4
}
brillig(inline) fn map f28 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v4
    v5 = allocate -> &mut [i32; 3]
    store v4 at v5
    jmp b1(u32 0)
  b1(v6: u32):
    v10 = lt v6, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v5 -> [i32; 3]
    v13 = array_get v0, index v6 -> i32
    v14 = call f67(v2, v1, v13) -> i32
    v15 = array_set v11, index v6, value v14
    v16 = add v6, u32 1
    store v15 at v5
    v17 = add v6, u32 1
    jmp b1(v17)
  b3():
    v18 = load v5 -> [i32; 3]
    return v18
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = mul v2, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v8 = cast v2 as u32
    v9 = cast v3 as u32
    v10 = lt v8, u32 2147483648
    v11 = lt v9, u32 2147483648
    v12 = eq v10, v11
    v14 = not v10
    v15 = cast v2 as Field
    v16 = cast v10 as Field
    v17 = mul v16, v15
    v18 = sub Field 4294967296, v15
    v19 = cast v14 as Field
    v20 = mul v19, v18
    v21 = add v17, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn all f30 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = mul v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn all f32 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 1 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = mul v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v2, v3
    v5 = not v4
    return v5
}
brillig(inline) fn fold f34 {
  b0(v0: [i32; 3], v1: i32, v3: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v2 -> i32
    v12 = call f67(v3, v11, v10) -> i32
    store v12 at v2
    v13 = add v4, u32 1
    jmp b1(v13)
  b3():
    v14 = load v2 -> i32
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn fold f36 {
  b0(v0: [i32; 3], v1: i32, v3: i32, v4: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v2 -> i32
    v13 = call f69(v4, v3, v12, v11) -> i32
    store v13 at v2
    v14 = add v5, u32 1
    jmp b1(v14)
  b3():
    v15 = load v2 -> i32
    return v15
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn reduce f38 {
  b0(v0: [i32; 3], v1: Field):
    v5 = array_get v0, index u32 0 -> i32
    v6 = allocate -> &mut i32
    store v5 at v6
    jmp b1(u32 1)
  b1(v7: u32):
    v10 = lt v7, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v6 -> i32
    v12 = array_get v0, index v7 -> i32
    v13 = call f67(v1, v11, v12) -> i32
    store v13 at v6
    v14 = add v7, u32 1
    jmp b1(v14)
  b3():
    v15 = load v6 -> i32
    return v15
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn reduce f40 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v6 = array_get v0, index u32 0 -> i32
    v7 = allocate -> &mut i32
    store v6 at v7
    jmp b1(u32 1)
  b1(v8: u32):
    v11 = lt v8, u32 3
    jmpif v11 then: b2, else: b3
  b2():
    v12 = load v7 -> i32
    v13 = array_get v0, index v8 -> i32
    v14 = call f69(v2, v1, v12, v13) -> i32
    store v14 at v7
    v15 = add v8, u32 1
    jmp b1(v15)
  b3():
    v16 = load v7 -> i32
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn eq f42 {
  b0(v0: [i32; 3], v1: [i32; 3]):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v9 = load v3 -> u1
    v12 = array_get v0, index v4 -> i32
    v13 = array_get v1, index v4 -> i32
    v14 = call f46(v12, v13) -> u1
    v15 = mul v9, v14
    store v15 at v3
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v3 -> u1
    return v17
}
brillig(inline) fn map f43 {
  b0(v0: [i32; 3], v1: Field):
    v3 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v3
    v4 = allocate -> &mut [i32; 3]
    store v3 at v4
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v10 = load v4 -> [i32; 3]
    v12 = array_get v0, index v5 -> i32
    v13 = call f44(v12) -> i32
    v14 = array_set v10, index v5, value v13
    v15 = add v5, u32 1
    store v14 at v4
    v16 = add v5, u32 1
    jmp b1(v16)
  b3():
    v17 = load v4 -> [i32; 3]
    return v17
}
brillig(inline) fn lambda f44 {
  b0(v0: i32):
    v2 = div v0, i32 2
    return v2
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = div v2, v3
    return v4
}
brillig(inline) fn eq f46 {
  b0(v0: i32, v1: i32):
    v2 = eq v0, v1
    return v2
}
brillig(inline) fn add f47 {
  b0(v0: i32, v1: i32):
    v2 = add v0, v1
    v3 = truncate v2 to 32 bits, max_bit_size: 33
    v4 = cast v3 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v8 = lt v6, u32 2147483648
    v9 = lt v7, u32 2147483648
    v10 = eq v8, v9
    v11 = lt v4, u32 2147483648
    v12 = eq v11, v8
    v13 = mul v12, v10
    constrain v13 == v10, "attempt to add with overflow"
    v14 = cast v3 as i32
    return v14
}
brillig(inline) fn __debug_var_assign_inner f48 {
  b0(v0: u32, v1: [i32; 3]):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f49 {
  b0(v0: u32, v1: i32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f50 {
  b0(v0: u32, v1: u32):
    call f55(v0, v1)
    return
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}
brillig(inline) fn __debug_var_assign f53 {
  b0(v0: u32, v1: u32, v2: Field):
    call f54(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f54 {
  b0(v0: u32, v1: u32, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f55 {
  b0(v0: u32, v1: u32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f56 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f57 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn lambda f58 {
  b0(v0: Field):
    v2 = add v0, Field 2
    return v2
}
brillig(inline) fn add f59 {
  b0(v0: Field, v1: Field):
    v2 = add v0, v1
    return v2
}
brillig(inline) fn __debug_var_assign f60 {
  b0(v0: u32, v1: Field):
    call f61(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f61 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f62 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f63 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_fn_enter_inner f64 {
  b0(v0: u32):
    call __debug_fn_enter(v0)
    return
}
acir(inline) fn apply f65 {
  b0(v0: Field):
    v2 = eq v0, Field 3
    jmpif v2 then: b2, else: b1
  b1():
    constrain v0 == Field 4
    v9 = call f4() -> [u32; 2]
    jmp b4(v9)
  b2():
    v5 = call f3() -> [u32; 2]
    jmp b3(v5)
  b3(v3: [u32; 2]):
    return v3
  b4(v7: [u32; 2]):
    jmp b3(v7)
}
acir(inline) fn apply f66 {
  b0(v0: Field, v1: i32):
    v3 = eq v0, Field 25
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 31
    v10 = call f31(v1) -> u1
    jmp b4(v10)
  b2():
    v6 = call f25(v1) -> u1
    jmp b3(v6)
  b3(v4: u1):
    return v4
  b4(v8: u1):
    jmp b3(v8)
}
acir(inline) fn apply f67 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 29
    jmpif v4 then: b2, else: b1
  b1():
    v9 = eq v0, Field 35
    jmpif v9 then: b5, else: b4
  b2():
    v7 = call f29(v1, v2) -> i32
    jmp b3(v7)
  b3(v5: i32):
    return v5
  b4():
    v14 = eq v0, Field 39
    jmpif v14 then: b8, else: b7
  b5():
    v12 = call f35(v1, v2) -> i32
    jmp b6(v12)
  b6(v10: i32):
    jmp b3(v10)
  b7():
    constrain v0 == Field 45
    v21 = call f45(v1, v2) -> i32
    jmp b10(v21)
  b8():
    v17 = call f39(v1, v2) -> i32
    jmp b9(v17)
  b9(v15: i32):
    jmp b6(v15)
  b10(v19: i32):
    jmp b9(v19)
}
acir(inline) fn apply f68 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 27
    jmpif v4 then: b2, else: b1
  b1():
    constrain v0 == Field 33
    v11 = call f33(v1, v2) -> u1
    jmp b4(v11)
  b2():
    v7 = call f27(v1, v2) -> u1
    jmp b3(v7)
  b3(v5: u1):
    return v5
  b4(v9: u1):
    jmp b3(v9)
}
acir(inline) fn apply f69 {
  b0(v0: Field, v1: i32, v2: i32, v3: i32):
    v5 = eq v0, Field 37
    jmpif v5 then: b2, else: b1
  b1():
    constrain v0 == Field 41
    v12 = call f41(v1, v2, v3) -> i32
    jmp b4(v12)
  b2():
    v8 = call f37(v1, v2, v3) -> i32
    jmp b3(v8)
  b3(v6: i32):
    return v6
  b4(v10: i32):
    jmp b3(v10)
}
acir(inline) fn apply f70 {
  b0(v0: Field, v1: u32):
    v3 = eq v0, Field 51
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 52
    v10 = call f52(v1) -> u32
    jmp b4(v10)
  b2():
    v6 = call f51(v1) -> u32
    jmp b3(v6)
  b3(v4: u32):
    return v4
  b4(v8: u32):
    jmp b3(v8)
}
acir(inline) fn apply f71 {
  b0(v0: Field, v1: Field):
    v3 = eq v0, Field 7
    jmpif v3 then: b2, else: b1
  b1():
    v8 = eq v0, Field 10
    jmpif v8 then: b5, else: b4
  b2():
    v6 = call f7(v1) -> Field
    jmp b3(v6)
  b3(v4: Field):
    return v4
  b4():
    constrain v0 == Field 16
    v15 = call f16(v1) -> Field
    jmp b7(v15)
  b5():
    v11 = call f10(v1) -> Field
    jmp b6(v11)
  b6(v9: Field):
    jmp b3(v9)
  b7(v13: Field):
    jmp b6(v13)
}

After Removing Paired rc_inc & rc_decs:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call f1(u32 0)
    call f2(Field 0, v0)
    jmpif u1 0 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    jmp b3(Field 4)
  b3(v13: Field):
    call f5(Field 1, v13)
    v16 = call f65(v13) -> [u32; 2]
    v18 = array_get v16, index u32 1 -> u32
    v20 = eq v18, u32 2
    constrain v18 == u32 2
    v25 = call f6(Field 7, Field 5) -> Field
    v27 = eq v25, Field 20
    constrain v25 == Field 20
    v31 = call f8(Field 2, Field 3) -> Field
    v33 = eq v31, Field 6
    constrain v31 == Field 6
    v35 = call f9(Field 0, Field 1) -> Field
    v36 = eq v35, Field 3
    constrain v35 == Field 3
    call f2(Field 2, Field 42)
    call f11(Field 3, Field 42, f10)
    v41 = call f10(Field 42) -> Field
    v42 = eq v41, Field 42
    constrain v41 == Field 42
    v43 = allocate -> &mut Field
    store Field 2 at v43
    v46 = load v43 -> Field
    call f2(Field 4, v46)
    v47 = load v43 -> Field
    v48 = allocate -> &mut Field
    store v47 at v48
    v49 = load v48 -> Field
    v50 = add v49, Field 1
    call f2(Field 4, v50)
    store v50 at v48
    v52 = load v48 -> Field
    call f2(Field 5, v52)
    v54 = load v48 -> Field
    v55 = add v54, Field 1
    call f2(Field 4, v55)
    store v55 at v48
    v58 = call f12(v52, Field 1) -> Field
    v59 = eq v58, Field 4
    constrain v58 == Field 4
    v60 = load v48 -> Field
    call f14(Field 6, v60, f13)
    v63 = call f13(v60, Field 1) -> Field
    v64 = eq v63, Field 5
    constrain v63 == Field 5
    v65 = load v48 -> Field
    v66 = add v65, Field 1
    call f2(Field 4, v66)
    store v66 at v48
    v68 = call f13(v60, Field 1) -> Field
    v69 = eq v68, Field 5
    constrain v68 == Field 5
    call f15()
    v73 = call f6(Field 16, Field 3) -> Field
    call f2(Field 7, v73)
    call f17()
    v77 = add v0, v73
    call f18(Field 0)
    call f18(Field 6)
    call f18(Field 2)
    call f18(Field 5)
    call f18(Field 4)
    call f18(Field 7)
    call f18(Field 1)
    call f18(Field 3)
    call f19(u32 0)
    return v77
}
brillig(inline) fn __debug_fn_enter f1 {
  b0(v0: u32):
    call f64(v0)
    return
}
brillig(inline) fn __debug_var_assign f2 {
  b0(v0: u32, v1: Field):
    call f63(v0, v1)
    return
}
brillig(inline) fn foo f3 {
  b0():
    call f1(u32 2)
    v4 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v4
    call f19(u32 2)
    return v4
}
brillig(inline) fn bar f4 {
  b0():
    call f1(u32 3)
    v3 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v3
    call f19(u32 3)
    return v3
}
brillig(inline) fn __debug_var_assign f5 {
  b0(v0: u32, v1: Field):
    call f62(v0, v1)
    return
}
brillig(inline) fn twice f6 {
  b0(v0: Field, v1: Field):
    call f1(u32 5)
    call f60(Field 8, v0)
    call f2(Field 9, v1)
    v8 = call f71(v0, v1) -> Field
    v9 = call f71(v0, v8) -> Field
    call f18(Field 9)
    call f18(Field 8)
    call f19(u32 5)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f8 {
  b0(v0: Field, v1: Field):
    v3 = call f59(v0, v1) -> Field
    v5 = add v3, Field 1
    return v5
}
brillig(inline) fn lambda f9 {
  b0(v0: Field, v1: Field):
    v3 = call f58(v1) -> Field
    v4 = add v0, v3
    return v4
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn __debug_var_assign f11 {
  b0(v0: u32, v1: Field, v2: Field):
    call f57(v0, v1, v2)
    return
}
brillig(inline) fn lambda f12 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn lambda f13 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn __debug_var_assign f14 {
  b0(v0: u32, v1: Field, v2: Field):
    call f56(v0, v1, v2)
    return
}
brillig(inline) fn regression_2154 f15 {
  b0():
    call f1(u32 6)
    call f50(Field 10, u32 32)
    jmpif u1 1 then: b1, else: b2
  b1():
    jmp b3(u32 32, Field 51)
  b2():
    jmp b3(u32 32, Field 52)
  b3(v9: u32, v10: Field):
    call f53(Field 11, v9, v10)
    v13 = call f70(v10, v9) -> u32
    v14 = eq v13, u32 32
    constrain v13 == u32 32
    call f18(Field 10)
    call f18(Field 11)
    call f19(u32 6)
    return
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call f1(u32 4)
    call f2(Field 12, v0)
    v6 = add v0, Field 1
    call f18(Field 12)
    call f19(u32 4)
    return v6
}
brillig(inline) fn test_array_functions f17 {
  b0():
    call f1(u32 1)
    call f22(Field 13, i32 2)
    v7 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v7
    call f23(Field 14, v7)
    inc_rc v7
    inc_rc v7
    v12 = call f24(v7, Field 25) -> u1
    constrain v12 == u1 1
    v16 = call f26(v7, i32 2, Field 27) -> u1
    constrain v16 == u1 1
    v19 = call f28(v7, i32 2, Field 29) -> [i32; 3]
    inc_rc v19
    call f23(Field 15, v19)
    inc_rc v19
    inc_rc v19
    v24 = call f30(v19, Field 31) -> u1
    constrain v24 == u1 1
    v27 = call f32(v19, i32 2, Field 33) -> u1
    constrain v27 == u1 1
    v31 = call f34(v19, i32 0, Field 35) -> i32
    v33 = eq v31, i32 12
    constrain v31 == i32 12
    v36 = call f36(v19, i32 0, i32 2, Field 37) -> i32
    v38 = eq v36, i32 18
    constrain v36 == i32 18
    v41 = call f38(v19, Field 39) -> i32
    v42 = eq v41, i32 12
    constrain v41 == i32 12
    v45 = call f40(v19, i32 2, Field 41) -> i32
    v47 = eq v45, i32 16
    constrain v45 == i32 16
    v51 = call f43(v19, Field 44) -> [i32; 3]
    v52 = call f42(v51, v7) -> u1
    constrain v52 == u1 1
    v56 = call f28(v19, i32 2, Field 45) -> [i32; 3]
    v57 = call f42(v56, v7) -> u1
    constrain v57 == u1 1
    call f18(Field 15)
    call f18(Field 13)
    call f18(Field 14)
    call f19(u32 1)
    return
}
brillig(inline) fn __debug_var_drop f18 {
  b0(v0: u32):
    call f21(v0)
    return
}
brillig(inline) fn __debug_fn_exit f19 {
  b0(v0: u32):
    call f20(v0)
    return
}
brillig(inline) fn __debug_fn_exit_inner f20 {
  b0(v0: u32):
    call __debug_fn_exit(v0)
    return
}
brillig(inline) fn __debug_var_drop_inner f21 {
  b0(v0: u32):
    call __debug_var_drop(v0)
    return
}
brillig(inline) fn __debug_var_assign f22 {
  b0(v0: u32, v1: i32):
    call f49(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f23 {
  b0(v0: u32, v1: [i32; 3]):
    call f48(v0, v1)
    return
}
brillig(inline) fn any f24 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = or v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn any f26 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 0 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = or v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v3, v2
    return v4
}
brillig(inline) fn map f28 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v4
    v5 = allocate -> &mut [i32; 3]
    store v4 at v5
    jmp b1(u32 0)
  b1(v6: u32):
    v10 = lt v6, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v5 -> [i32; 3]
    v13 = array_get v0, index v6 -> i32
    v14 = call f67(v2, v1, v13) -> i32
    v15 = array_set v11, index v6, value v14
    v16 = add v6, u32 1
    store v15 at v5
    v17 = add v6, u32 1
    jmp b1(v17)
  b3():
    v18 = load v5 -> [i32; 3]
    return v18
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = mul v2, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v8 = cast v2 as u32
    v9 = cast v3 as u32
    v10 = lt v8, u32 2147483648
    v11 = lt v9, u32 2147483648
    v12 = eq v10, v11
    v14 = not v10
    v15 = cast v2 as Field
    v16 = cast v10 as Field
    v17 = mul v16, v15
    v18 = sub Field 4294967296, v15
    v19 = cast v14 as Field
    v20 = mul v19, v18
    v21 = add v17, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn all f30 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = mul v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn all f32 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 1 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = mul v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v2, v3
    v5 = not v4
    return v5
}
brillig(inline) fn fold f34 {
  b0(v0: [i32; 3], v1: i32, v3: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v2 -> i32
    v12 = call f67(v3, v11, v10) -> i32
    store v12 at v2
    v13 = add v4, u32 1
    jmp b1(v13)
  b3():
    v14 = load v2 -> i32
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn fold f36 {
  b0(v0: [i32; 3], v1: i32, v3: i32, v4: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v2 -> i32
    v13 = call f69(v4, v3, v12, v11) -> i32
    store v13 at v2
    v14 = add v5, u32 1
    jmp b1(v14)
  b3():
    v15 = load v2 -> i32
    return v15
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn reduce f38 {
  b0(v0: [i32; 3], v1: Field):
    v5 = array_get v0, index u32 0 -> i32
    v6 = allocate -> &mut i32
    store v5 at v6
    jmp b1(u32 1)
  b1(v7: u32):
    v10 = lt v7, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v6 -> i32
    v12 = array_get v0, index v7 -> i32
    v13 = call f67(v1, v11, v12) -> i32
    store v13 at v6
    v14 = add v7, u32 1
    jmp b1(v14)
  b3():
    v15 = load v6 -> i32
    return v15
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn reduce f40 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v6 = array_get v0, index u32 0 -> i32
    v7 = allocate -> &mut i32
    store v6 at v7
    jmp b1(u32 1)
  b1(v8: u32):
    v11 = lt v8, u32 3
    jmpif v11 then: b2, else: b3
  b2():
    v12 = load v7 -> i32
    v13 = array_get v0, index v8 -> i32
    v14 = call f69(v2, v1, v12, v13) -> i32
    store v14 at v7
    v15 = add v8, u32 1
    jmp b1(v15)
  b3():
    v16 = load v7 -> i32
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn eq f42 {
  b0(v0: [i32; 3], v1: [i32; 3]):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v9 = load v3 -> u1
    v12 = array_get v0, index v4 -> i32
    v13 = array_get v1, index v4 -> i32
    v14 = call f46(v12, v13) -> u1
    v15 = mul v9, v14
    store v15 at v3
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v3 -> u1
    return v17
}
brillig(inline) fn map f43 {
  b0(v0: [i32; 3], v1: Field):
    v3 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v3
    v4 = allocate -> &mut [i32; 3]
    store v3 at v4
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v10 = load v4 -> [i32; 3]
    v12 = array_get v0, index v5 -> i32
    v13 = call f44(v12) -> i32
    v14 = array_set v10, index v5, value v13
    v15 = add v5, u32 1
    store v14 at v4
    v16 = add v5, u32 1
    jmp b1(v16)
  b3():
    v17 = load v4 -> [i32; 3]
    return v17
}
brillig(inline) fn lambda f44 {
  b0(v0: i32):
    v2 = div v0, i32 2
    return v2
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = div v2, v3
    return v4
}
brillig(inline) fn eq f46 {
  b0(v0: i32, v1: i32):
    v2 = eq v0, v1
    return v2
}
brillig(inline) fn add f47 {
  b0(v0: i32, v1: i32):
    v2 = add v0, v1
    v3 = truncate v2 to 32 bits, max_bit_size: 33
    v4 = cast v3 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v8 = lt v6, u32 2147483648
    v9 = lt v7, u32 2147483648
    v10 = eq v8, v9
    v11 = lt v4, u32 2147483648
    v12 = eq v11, v8
    v13 = mul v12, v10
    constrain v13 == v10, "attempt to add with overflow"
    v14 = cast v3 as i32
    return v14
}
brillig(inline) fn __debug_var_assign_inner f48 {
  b0(v0: u32, v1: [i32; 3]):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f49 {
  b0(v0: u32, v1: i32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f50 {
  b0(v0: u32, v1: u32):
    call f55(v0, v1)
    return
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}
brillig(inline) fn __debug_var_assign f53 {
  b0(v0: u32, v1: u32, v2: Field):
    call f54(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f54 {
  b0(v0: u32, v1: u32, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f55 {
  b0(v0: u32, v1: u32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f56 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f57 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn lambda f58 {
  b0(v0: Field):
    v2 = add v0, Field 2
    return v2
}
brillig(inline) fn add f59 {
  b0(v0: Field, v1: Field):
    v2 = add v0, v1
    return v2
}
brillig(inline) fn __debug_var_assign f60 {
  b0(v0: u32, v1: Field):
    call f61(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f61 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f62 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f63 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_fn_enter_inner f64 {
  b0(v0: u32):
    call __debug_fn_enter(v0)
    return
}
acir(inline) fn apply f65 {
  b0(v0: Field):
    v2 = eq v0, Field 3
    jmpif v2 then: b2, else: b1
  b1():
    constrain v0 == Field 4
    v9 = call f4() -> [u32; 2]
    jmp b4(v9)
  b2():
    v5 = call f3() -> [u32; 2]
    jmp b3(v5)
  b3(v3: [u32; 2]):
    return v3
  b4(v7: [u32; 2]):
    jmp b3(v7)
}
acir(inline) fn apply f66 {
  b0(v0: Field, v1: i32):
    v3 = eq v0, Field 25
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 31
    v10 = call f31(v1) -> u1
    jmp b4(v10)
  b2():
    v6 = call f25(v1) -> u1
    jmp b3(v6)
  b3(v4: u1):
    return v4
  b4(v8: u1):
    jmp b3(v8)
}
acir(inline) fn apply f67 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 29
    jmpif v4 then: b2, else: b1
  b1():
    v9 = eq v0, Field 35
    jmpif v9 then: b5, else: b4
  b2():
    v7 = call f29(v1, v2) -> i32
    jmp b3(v7)
  b3(v5: i32):
    return v5
  b4():
    v14 = eq v0, Field 39
    jmpif v14 then: b8, else: b7
  b5():
    v12 = call f35(v1, v2) -> i32
    jmp b6(v12)
  b6(v10: i32):
    jmp b3(v10)
  b7():
    constrain v0 == Field 45
    v21 = call f45(v1, v2) -> i32
    jmp b10(v21)
  b8():
    v17 = call f39(v1, v2) -> i32
    jmp b9(v17)
  b9(v15: i32):
    jmp b6(v15)
  b10(v19: i32):
    jmp b9(v19)
}
acir(inline) fn apply f68 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 27
    jmpif v4 then: b2, else: b1
  b1():
    constrain v0 == Field 33
    v11 = call f33(v1, v2) -> u1
    jmp b4(v11)
  b2():
    v7 = call f27(v1, v2) -> u1
    jmp b3(v7)
  b3(v5: u1):
    return v5
  b4(v9: u1):
    jmp b3(v9)
}
acir(inline) fn apply f69 {
  b0(v0: Field, v1: i32, v2: i32, v3: i32):
    v5 = eq v0, Field 37
    jmpif v5 then: b2, else: b1
  b1():
    constrain v0 == Field 41
    v12 = call f41(v1, v2, v3) -> i32
    jmp b4(v12)
  b2():
    v8 = call f37(v1, v2, v3) -> i32
    jmp b3(v8)
  b3(v6: i32):
    return v6
  b4(v10: i32):
    jmp b3(v10)
}
acir(inline) fn apply f70 {
  b0(v0: Field, v1: u32):
    v3 = eq v0, Field 51
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 52
    v10 = call f52(v1) -> u32
    jmp b4(v10)
  b2():
    v6 = call f51(v1) -> u32
    jmp b3(v6)
  b3(v4: u32):
    return v4
  b4(v8: u32):
    jmp b3(v8)
}
acir(inline) fn apply f71 {
  b0(v0: Field, v1: Field):
    v3 = eq v0, Field 7
    jmpif v3 then: b2, else: b1
  b1():
    v8 = eq v0, Field 10
    jmpif v8 then: b5, else: b4
  b2():
    v6 = call f7(v1) -> Field
    jmp b3(v6)
  b3(v4: Field):
    return v4
  b4():
    constrain v0 == Field 16
    v15 = call f16(v1) -> Field
    jmp b7(v15)
  b5():
    v11 = call f10(v1) -> Field
    jmp b6(v11)
  b6(v9: Field):
    jmp b3(v9)
  b7(v13: Field):
    jmp b6(v13)
}

After Resolving IsUnconstrained:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call f1(u32 0)
    call f2(Field 0, v0)
    jmpif u1 0 then: b1, else: b2
  b1():
    jmp b3(Field 3)
  b2():
    jmp b3(Field 4)
  b3(v13: Field):
    call f5(Field 1, v13)
    v16 = call f65(v13) -> [u32; 2]
    v18 = array_get v16, index u32 1 -> u32
    v20 = eq v18, u32 2
    constrain v18 == u32 2
    v25 = call f6(Field 7, Field 5) -> Field
    v27 = eq v25, Field 20
    constrain v25 == Field 20
    v31 = call f8(Field 2, Field 3) -> Field
    v33 = eq v31, Field 6
    constrain v31 == Field 6
    v35 = call f9(Field 0, Field 1) -> Field
    v36 = eq v35, Field 3
    constrain v35 == Field 3
    call f2(Field 2, Field 42)
    call f11(Field 3, Field 42, f10)
    v41 = call f10(Field 42) -> Field
    v42 = eq v41, Field 42
    constrain v41 == Field 42
    v43 = allocate -> &mut Field
    store Field 2 at v43
    v46 = load v43 -> Field
    call f2(Field 4, v46)
    v47 = load v43 -> Field
    v48 = allocate -> &mut Field
    store v47 at v48
    v49 = load v48 -> Field
    v50 = add v49, Field 1
    call f2(Field 4, v50)
    store v50 at v48
    v52 = load v48 -> Field
    call f2(Field 5, v52)
    v54 = load v48 -> Field
    v55 = add v54, Field 1
    call f2(Field 4, v55)
    store v55 at v48
    v58 = call f12(v52, Field 1) -> Field
    v59 = eq v58, Field 4
    constrain v58 == Field 4
    v60 = load v48 -> Field
    call f14(Field 6, v60, f13)
    v63 = call f13(v60, Field 1) -> Field
    v64 = eq v63, Field 5
    constrain v63 == Field 5
    v65 = load v48 -> Field
    v66 = add v65, Field 1
    call f2(Field 4, v66)
    store v66 at v48
    v68 = call f13(v60, Field 1) -> Field
    v69 = eq v68, Field 5
    constrain v68 == Field 5
    call f15()
    v73 = call f6(Field 16, Field 3) -> Field
    call f2(Field 7, v73)
    call f17()
    v77 = add v0, v73
    call f18(Field 0)
    call f18(Field 6)
    call f18(Field 2)
    call f18(Field 5)
    call f18(Field 4)
    call f18(Field 7)
    call f18(Field 1)
    call f18(Field 3)
    call f19(u32 0)
    return v77
}
brillig(inline) fn __debug_fn_enter f1 {
  b0(v0: u32):
    call f64(v0)
    return
}
brillig(inline) fn __debug_var_assign f2 {
  b0(v0: u32, v1: Field):
    call f63(v0, v1)
    return
}
brillig(inline) fn foo f3 {
  b0():
    call f1(u32 2)
    v4 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v4
    call f19(u32 2)
    return v4
}
brillig(inline) fn bar f4 {
  b0():
    call f1(u32 3)
    v3 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v3
    call f19(u32 3)
    return v3
}
brillig(inline) fn __debug_var_assign f5 {
  b0(v0: u32, v1: Field):
    call f62(v0, v1)
    return
}
brillig(inline) fn twice f6 {
  b0(v0: Field, v1: Field):
    call f1(u32 5)
    call f60(Field 8, v0)
    call f2(Field 9, v1)
    v8 = call f71(v0, v1) -> Field
    v9 = call f71(v0, v8) -> Field
    call f18(Field 9)
    call f18(Field 8)
    call f19(u32 5)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f8 {
  b0(v0: Field, v1: Field):
    v3 = call f59(v0, v1) -> Field
    v5 = add v3, Field 1
    return v5
}
brillig(inline) fn lambda f9 {
  b0(v0: Field, v1: Field):
    v3 = call f58(v1) -> Field
    v4 = add v0, v3
    return v4
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn __debug_var_assign f11 {
  b0(v0: u32, v1: Field, v2: Field):
    call f57(v0, v1, v2)
    return
}
brillig(inline) fn lambda f12 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn lambda f13 {
  b0(v0: Field, v2: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v3 = load v1 -> Field
    v4 = add v2, v3
    return v4
}
brillig(inline) fn __debug_var_assign f14 {
  b0(v0: u32, v1: Field, v2: Field):
    call f56(v0, v1, v2)
    return
}
brillig(inline) fn regression_2154 f15 {
  b0():
    call f1(u32 6)
    call f50(Field 10, u32 32)
    jmpif u1 1 then: b1, else: b2
  b1():
    jmp b3(u32 32, Field 51)
  b2():
    jmp b3(u32 32, Field 52)
  b3(v9: u32, v10: Field):
    call f53(Field 11, v9, v10)
    v13 = call f70(v10, v9) -> u32
    v14 = eq v13, u32 32
    constrain v13 == u32 32
    call f18(Field 10)
    call f18(Field 11)
    call f19(u32 6)
    return
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call f1(u32 4)
    call f2(Field 12, v0)
    v6 = add v0, Field 1
    call f18(Field 12)
    call f19(u32 4)
    return v6
}
brillig(inline) fn test_array_functions f17 {
  b0():
    call f1(u32 1)
    call f22(Field 13, i32 2)
    v7 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v7
    call f23(Field 14, v7)
    inc_rc v7
    inc_rc v7
    v12 = call f24(v7, Field 25) -> u1
    constrain v12 == u1 1
    v16 = call f26(v7, i32 2, Field 27) -> u1
    constrain v16 == u1 1
    v19 = call f28(v7, i32 2, Field 29) -> [i32; 3]
    inc_rc v19
    call f23(Field 15, v19)
    inc_rc v19
    inc_rc v19
    v24 = call f30(v19, Field 31) -> u1
    constrain v24 == u1 1
    v27 = call f32(v19, i32 2, Field 33) -> u1
    constrain v27 == u1 1
    v31 = call f34(v19, i32 0, Field 35) -> i32
    v33 = eq v31, i32 12
    constrain v31 == i32 12
    v36 = call f36(v19, i32 0, i32 2, Field 37) -> i32
    v38 = eq v36, i32 18
    constrain v36 == i32 18
    v41 = call f38(v19, Field 39) -> i32
    v42 = eq v41, i32 12
    constrain v41 == i32 12
    v45 = call f40(v19, i32 2, Field 41) -> i32
    v47 = eq v45, i32 16
    constrain v45 == i32 16
    v51 = call f43(v19, Field 44) -> [i32; 3]
    v52 = call f42(v51, v7) -> u1
    constrain v52 == u1 1
    v56 = call f28(v19, i32 2, Field 45) -> [i32; 3]
    v57 = call f42(v56, v7) -> u1
    constrain v57 == u1 1
    call f18(Field 15)
    call f18(Field 13)
    call f18(Field 14)
    call f19(u32 1)
    return
}
brillig(inline) fn __debug_var_drop f18 {
  b0(v0: u32):
    call f21(v0)
    return
}
brillig(inline) fn __debug_fn_exit f19 {
  b0(v0: u32):
    call f20(v0)
    return
}
brillig(inline) fn __debug_fn_exit_inner f20 {
  b0(v0: u32):
    call __debug_fn_exit(v0)
    return
}
brillig(inline) fn __debug_var_drop_inner f21 {
  b0(v0: u32):
    call __debug_var_drop(v0)
    return
}
brillig(inline) fn __debug_var_assign f22 {
  b0(v0: u32, v1: i32):
    call f49(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f23 {
  b0(v0: u32, v1: [i32; 3]):
    call f48(v0, v1)
    return
}
brillig(inline) fn any f24 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 0 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = or v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn any f26 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 0 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = or v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v3, v2
    return v4
}
brillig(inline) fn map f28 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v4
    v5 = allocate -> &mut [i32; 3]
    store v4 at v5
    jmp b1(u32 0)
  b1(v6: u32):
    v10 = lt v6, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v5 -> [i32; 3]
    v13 = array_get v0, index v6 -> i32
    v14 = call f67(v2, v1, v13) -> i32
    v15 = array_set v11, index v6, value v14
    v16 = add v6, u32 1
    store v15 at v5
    v17 = add v6, u32 1
    jmp b1(v17)
  b3():
    v18 = load v5 -> [i32; 3]
    return v18
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = mul v2, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v8 = cast v2 as u32
    v9 = cast v3 as u32
    v10 = lt v8, u32 2147483648
    v11 = lt v9, u32 2147483648
    v12 = eq v10, v11
    v14 = not v10
    v15 = cast v2 as Field
    v16 = cast v10 as Field
    v17 = mul v16, v15
    v18 = sub Field 4294967296, v15
    v19 = cast v14 as Field
    v20 = mul v19, v18
    v21 = add v17, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn all f30 {
  b0(v0: [i32; 3], v1: Field):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v3 -> u1
    v12 = call f66(v1, v10) -> u1
    v13 = mul v11, v12
    store v13 at v3
    v14 = add v4, u32 1
    jmp b1(v14)
  b3():
    v15 = load v3 -> u1
    return v15
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn all f32 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v4 = allocate -> &mut u1
    store u1 1 at v4
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v4 -> u1
    v13 = call f68(v2, v1, v11) -> u1
    v14 = mul v12, v13
    store v14 at v4
    v15 = add v5, u32 1
    jmp b1(v15)
  b3():
    v16 = load v4 -> u1
    return v16
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = lt v2, v3
    v5 = not v4
    return v5
}
brillig(inline) fn fold f34 {
  b0(v0: [i32; 3], v1: i32, v3: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v10 = array_get v0, index v4 -> i32
    v11 = load v2 -> i32
    v12 = call f67(v3, v11, v10) -> i32
    store v12 at v2
    v13 = add v4, u32 1
    jmp b1(v13)
  b3():
    v14 = load v2 -> i32
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn fold f36 {
  b0(v0: [i32; 3], v1: i32, v3: i32, v4: Field):
    v2 = allocate -> &mut i32
    store v1 at v2
    inc_rc v0
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v11 = array_get v0, index v5 -> i32
    v12 = load v2 -> i32
    v13 = call f69(v4, v3, v12, v11) -> i32
    store v13 at v2
    v14 = add v5, u32 1
    jmp b1(v14)
  b3():
    v15 = load v2 -> i32
    return v15
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn reduce f38 {
  b0(v0: [i32; 3], v1: Field):
    v5 = array_get v0, index u32 0 -> i32
    v6 = allocate -> &mut i32
    store v5 at v6
    jmp b1(u32 1)
  b1(v7: u32):
    v10 = lt v7, u32 3
    jmpif v10 then: b2, else: b3
  b2():
    v11 = load v6 -> i32
    v12 = array_get v0, index v7 -> i32
    v13 = call f67(v1, v11, v12) -> i32
    store v13 at v6
    v14 = add v7, u32 1
    jmp b1(v14)
  b3():
    v15 = load v6 -> i32
    return v15
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = call f47(v0, v1) -> i32
    return v3
}
brillig(inline) fn reduce f40 {
  b0(v0: [i32; 3], v1: i32, v2: Field):
    v6 = array_get v0, index u32 0 -> i32
    v7 = allocate -> &mut i32
    store v6 at v7
    jmp b1(u32 1)
  b1(v8: u32):
    v11 = lt v8, u32 3
    jmpif v11 then: b2, else: b3
  b2():
    v12 = load v7 -> i32
    v13 = array_get v0, index v8 -> i32
    v14 = call f69(v2, v1, v12, v13) -> i32
    store v14 at v7
    v15 = add v8, u32 1
    jmp b1(v15)
  b3():
    v16 = load v7 -> i32
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v2: i32, v3: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v5 = call f47(v2, v3) -> i32
    v6 = load v1 -> i32
    v7 = add v5, v6
    v8 = truncate v7 to 32 bits, max_bit_size: 33
    v9 = cast v8 as u32
    v11 = cast v5 as u32
    v12 = cast v6 as u32
    v13 = lt v11, u32 2147483648
    v14 = lt v12, u32 2147483648
    v15 = eq v13, v14
    v16 = lt v9, u32 2147483648
    v17 = eq v16, v13
    v18 = mul v17, v15
    constrain v18 == v15, "attempt to add with overflow"
    v19 = cast v8 as i32
    return v19
}
brillig(inline) fn eq f42 {
  b0(v0: [i32; 3], v1: [i32; 3]):
    v3 = allocate -> &mut u1
    store u1 1 at v3
    jmp b1(u32 0)
  b1(v4: u32):
    v8 = lt v4, u32 3
    jmpif v8 then: b2, else: b3
  b2():
    v9 = load v3 -> u1
    v12 = array_get v0, index v4 -> i32
    v13 = array_get v1, index v4 -> i32
    v14 = call f46(v12, v13) -> u1
    v15 = mul v9, v14
    store v15 at v3
    v16 = add v4, u32 1
    jmp b1(v16)
  b3():
    v17 = load v3 -> u1
    return v17
}
brillig(inline) fn map f43 {
  b0(v0: [i32; 3], v1: Field):
    v3 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v3
    v4 = allocate -> &mut [i32; 3]
    store v3 at v4
    jmp b1(u32 0)
  b1(v5: u32):
    v9 = lt v5, u32 3
    jmpif v9 then: b2, else: b3
  b2():
    v10 = load v4 -> [i32; 3]
    v12 = array_get v0, index v5 -> i32
    v13 = call f44(v12) -> i32
    v14 = array_set v10, index v5, value v13
    v15 = add v5, u32 1
    store v14 at v4
    v16 = add v5, u32 1
    jmp b1(v16)
  b3():
    v17 = load v4 -> [i32; 3]
    return v17
}
brillig(inline) fn lambda f44 {
  b0(v0: i32):
    v2 = div v0, i32 2
    return v2
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v2: i32):
    v1 = allocate -> &mut i32
    store v0 at v1
    v3 = load v1 -> i32
    v4 = div v2, v3
    return v4
}
brillig(inline) fn eq f46 {
  b0(v0: i32, v1: i32):
    v2 = eq v0, v1
    return v2
}
brillig(inline) fn add f47 {
  b0(v0: i32, v1: i32):
    v2 = add v0, v1
    v3 = truncate v2 to 32 bits, max_bit_size: 33
    v4 = cast v3 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v8 = lt v6, u32 2147483648
    v9 = lt v7, u32 2147483648
    v10 = eq v8, v9
    v11 = lt v4, u32 2147483648
    v12 = eq v11, v8
    v13 = mul v12, v10
    constrain v13 == v10, "attempt to add with overflow"
    v14 = cast v3 as i32
    return v14
}
brillig(inline) fn __debug_var_assign_inner f48 {
  b0(v0: u32, v1: [i32; 3]):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f49 {
  b0(v0: u32, v1: i32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign f50 {
  b0(v0: u32, v1: u32):
    call f55(v0, v1)
    return
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}
brillig(inline) fn __debug_var_assign f53 {
  b0(v0: u32, v1: u32, v2: Field):
    call f54(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f54 {
  b0(v0: u32, v1: u32, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f55 {
  b0(v0: u32, v1: u32):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f56 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn __debug_var_assign_inner f57 {
  b0(v0: u32, v1: Field, v2: Field):
    call __debug_var_assign(v0, v1, v2)
    return
}
brillig(inline) fn lambda f58 {
  b0(v0: Field):
    v2 = add v0, Field 2
    return v2
}
brillig(inline) fn add f59 {
  b0(v0: Field, v1: Field):
    v2 = add v0, v1
    return v2
}
brillig(inline) fn __debug_var_assign f60 {
  b0(v0: u32, v1: Field):
    call f61(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f61 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f62 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_var_assign_inner f63 {
  b0(v0: u32, v1: Field):
    call __debug_var_assign(v0, v1)
    return
}
brillig(inline) fn __debug_fn_enter_inner f64 {
  b0(v0: u32):
    call __debug_fn_enter(v0)
    return
}
acir(inline) fn apply f65 {
  b0(v0: Field):
    v2 = eq v0, Field 3
    jmpif v2 then: b2, else: b1
  b1():
    constrain v0 == Field 4
    v9 = call f4() -> [u32; 2]
    jmp b4(v9)
  b2():
    v5 = call f3() -> [u32; 2]
    jmp b3(v5)
  b3(v3: [u32; 2]):
    return v3
  b4(v7: [u32; 2]):
    jmp b3(v7)
}
acir(inline) fn apply f66 {
  b0(v0: Field, v1: i32):
    v3 = eq v0, Field 25
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 31
    v10 = call f31(v1) -> u1
    jmp b4(v10)
  b2():
    v6 = call f25(v1) -> u1
    jmp b3(v6)
  b3(v4: u1):
    return v4
  b4(v8: u1):
    jmp b3(v8)
}
acir(inline) fn apply f67 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 29
    jmpif v4 then: b2, else: b1
  b1():
    v9 = eq v0, Field 35
    jmpif v9 then: b5, else: b4
  b2():
    v7 = call f29(v1, v2) -> i32
    jmp b3(v7)
  b3(v5: i32):
    return v5
  b4():
    v14 = eq v0, Field 39
    jmpif v14 then: b8, else: b7
  b5():
    v12 = call f35(v1, v2) -> i32
    jmp b6(v12)
  b6(v10: i32):
    jmp b3(v10)
  b7():
    constrain v0 == Field 45
    v21 = call f45(v1, v2) -> i32
    jmp b10(v21)
  b8():
    v17 = call f39(v1, v2) -> i32
    jmp b9(v17)
  b9(v15: i32):
    jmp b6(v15)
  b10(v19: i32):
    jmp b9(v19)
}
acir(inline) fn apply f68 {
  b0(v0: Field, v1: i32, v2: i32):
    v4 = eq v0, Field 27
    jmpif v4 then: b2, else: b1
  b1():
    constrain v0 == Field 33
    v11 = call f33(v1, v2) -> u1
    jmp b4(v11)
  b2():
    v7 = call f27(v1, v2) -> u1
    jmp b3(v7)
  b3(v5: u1):
    return v5
  b4(v9: u1):
    jmp b3(v9)
}
acir(inline) fn apply f69 {
  b0(v0: Field, v1: i32, v2: i32, v3: i32):
    v5 = eq v0, Field 37
    jmpif v5 then: b2, else: b1
  b1():
    constrain v0 == Field 41
    v12 = call f41(v1, v2, v3) -> i32
    jmp b4(v12)
  b2():
    v8 = call f37(v1, v2, v3) -> i32
    jmp b3(v8)
  b3(v6: i32):
    return v6
  b4(v10: i32):
    jmp b3(v10)
}
acir(inline) fn apply f70 {
  b0(v0: Field, v1: u32):
    v3 = eq v0, Field 51
    jmpif v3 then: b2, else: b1
  b1():
    constrain v0 == Field 52
    v10 = call f52(v1) -> u32
    jmp b4(v10)
  b2():
    v6 = call f51(v1) -> u32
    jmp b3(v6)
  b3(v4: u32):
    return v4
  b4(v8: u32):
    jmp b3(v8)
}
acir(inline) fn apply f71 {
  b0(v0: Field, v1: Field):
    v3 = eq v0, Field 7
    jmpif v3 then: b2, else: b1
  b1():
    v8 = eq v0, Field 10
    jmpif v8 then: b5, else: b4
  b2():
    v6 = call f7(v1) -> Field
    jmp b3(v6)
  b3(v4: Field):
    return v4
  b4():
    constrain v0 == Field 16
    v15 = call f16(v1) -> Field
    jmp b7(v15)
  b5():
    v11 = call f10(v1) -> Field
    jmp b6(v11)
  b6(v9: Field):
    jmp b3(v9)
  b7(v13: Field):
    jmp b6(v13)
}

After Inlining (1st):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    jmp b1()
  b1():
    jmp b2(Field 4)
  b2(v10: Field):
    call __debug_var_assign(Field 1, v10)
    v18 = eq v10, Field 3
    jmpif v18 then: b3, else: b4
  b3():
    v20 = call f3() -> [u32; 2]
    jmp b5(v20)
  b4():
    constrain v10 == Field 4
    v23 = call f4() -> [u32; 2]
    jmp b6(v23)
  b5(v21: [u32; 2]):
    v26 = array_get v21, index u32 1 -> u32
    v28 = eq v26, u32 2
    constrain v26 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    jmp b7()
  b6(v24: [u32; 2]):
    jmp b5(v24)
  b7():
    v47 = call f7(Field 5) -> Field
    jmp b8(v47)
  b8(v48: Field):
    jmp b9()
  b9():
    v51 = call f7(v48) -> Field
    jmp b10(v51)
  b10(v52: Field):
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v63 = eq v52, Field 20
    constrain v52 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v78 = call f10(Field 42) -> Field
    v79 = eq v78, Field 42
    constrain v78 == Field 42
    v80 = allocate -> &mut Field
    store Field 2 at v80
    v81 = load v80 -> Field
    call __debug_var_assign(Field 4, v81)
    v85 = load v80 -> Field
    v86 = allocate -> &mut Field
    store v85 at v86
    v87 = load v86 -> Field
    v88 = add v87, Field 1
    call __debug_var_assign(Field 4, v88)
    store v88 at v86
    v92 = load v86 -> Field
    call __debug_var_assign(Field 5, v92)
    v96 = load v86 -> Field
    v97 = add v96, Field 1
    call __debug_var_assign(Field 4, v97)
    store v97 at v86
    v102 = allocate -> &mut Field
    store v92 at v102
    v103 = load v102 -> Field
    v104 = add Field 1, v103
    v105 = eq v104, Field 4
    constrain v104 == Field 4
    v106 = load v86 -> Field
    call __debug_var_assign(Field 6, v106, f13)
    v111 = allocate -> &mut Field
    store v106 at v111
    v112 = load v111 -> Field
    v113 = add Field 1, v112
    v114 = eq v113, Field 5
    constrain v113 == Field 5
    v115 = load v86 -> Field
    v116 = add v115, Field 1
    call __debug_var_assign(Field 4, v116)
    store v116 at v86
    v120 = allocate -> &mut Field
    store v106 at v120
    v121 = load v120 -> Field
    v122 = add Field 1, v121
    v123 = eq v122, Field 5
    constrain v122 == Field 5
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    jmp b11()
  b11():
    jmp b12(u32 32, Field 51)
  b12(v134: u32, v135: Field):
    call __debug_var_assign(Field 11, v134, v135)
    v142 = eq v135, Field 51
    jmpif v142 then: b13, else: b14
  b13():
    v144 = call f51(v134) -> u32
    jmp b15(v144)
  b14():
    constrain v135 == Field 52
    v148 = call f52(v134) -> u32
    jmp b16(v148)
  b15(v145: u32):
    v150 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    jmp b17()
  b16(v149: u32):
    jmp b15(v149)
  b17():
    jmp b18()
  b18():
    v173 = call f16(Field 3) -> Field
    jmp b19(v173)
  b19(v174: Field):
    jmp b20(v174)
  b20(v175: Field):
    jmp b21(v175)
  b21(v176: Field):
    jmp b22()
  b22():
    jmp b23()
  b23():
    v179 = call f16(v176) -> Field
    jmp b24(v179)
  b24(v180: Field):
    jmp b25(v180)
  b25(v181: Field):
    jmp b26(v181)
  b26(v182: Field):
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v182)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v206 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v206
    call __debug_var_assign(Field 14, v206)
    inc_rc v206
    inc_rc v206
    v213 = allocate -> &mut u1
    store u1 0 at v213
    inc_rc v206
    jmp b27(u32 0)
  b27(v214: u32):
    v216 = lt v214, u32 3
    jmpif v216 then: b28, else: b29
  b28():
    v217 = array_get v206, index v214 -> i32
    v218 = load v213 -> u1
    jmp b30()
  b29():
    v225 = load v213 -> u1
    constrain v225 == u1 1
    v228 = allocate -> &mut u1
    store u1 0 at v228
    inc_rc v206
    jmp b32(u32 0)
  b30():
    v221 = call f25(v217) -> u1
    jmp b31(v221)
  b31(v222: u1):
    v223 = or v218, v222
    store v223 at v213
    v224 = add v214, u32 1
    jmp b27(v224)
  b32(v229: u32):
    v230 = lt v229, u32 3
    jmpif v230 then: b33, else: b34
  b33():
    v231 = array_get v206, index v229 -> i32
    v232 = load v228 -> u1
    jmp b35()
  b34():
    v239 = load v228 -> u1
    constrain v239 == u1 1
    v243 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v243
    v244 = allocate -> &mut [i32; 3]
    store v243 at v244
    jmp b37(u32 0)
  b35():
    v235 = call f27(i32 2, v231) -> u1
    jmp b36(v235)
  b36(v236: u1):
    v237 = or v232, v236
    store v237 at v228
    v238 = add v229, u32 1
    jmp b32(v238)
  b37(v245: u32):
    v246 = lt v245, u32 3
    jmpif v246 then: b38, else: b39
  b38():
    v247 = load v244 -> [i32; 3]
    v248 = array_get v206, index v245 -> i32
    jmp b40()
  b39():
    v256 = load v244 -> [i32; 3]
    inc_rc v256
    call __debug_var_assign(Field 15, v256)
    inc_rc v256
    inc_rc v256
    v263 = allocate -> &mut u1
    store u1 1 at v263
    inc_rc v256
    jmp b42(u32 0)
  b40():
    v251 = call f29(i32 2, v248) -> i32
    jmp b41(v251)
  b41(v252: i32):
    v253 = array_set v247, index v245, value v252
    v254 = add v245, u32 1
    store v253 at v244
    v255 = add v245, u32 1
    jmp b37(v255)
  b42(v264: u32):
    v265 = lt v264, u32 3
    jmpif v265 then: b43, else: b44
  b43():
    v266 = array_get v256, index v264 -> i32
    v267 = load v263 -> u1
    jmp b45()
  b44():
    v275 = load v263 -> u1
    constrain v275 == u1 1
    v278 = allocate -> &mut u1
    store u1 1 at v278
    inc_rc v256
    jmp b48(u32 0)
  b45():
    v270 = call f31(v266) -> u1
    jmp b46(v270)
  b46(v271: u1):
    jmp b47(v271)
  b47(v272: u1):
    v273 = mul v267, v272
    store v273 at v263
    v274 = add v264, u32 1
    jmp b42(v274)
  b48(v279: u32):
    v280 = lt v279, u32 3
    jmpif v280 then: b49, else: b50
  b49():
    v281 = array_get v256, index v279 -> i32
    v282 = load v278 -> u1
    jmp b51()
  b50():
    v290 = load v278 -> u1
    constrain v290 == u1 1
    v293 = allocate -> &mut i32
    store i32 0 at v293
    inc_rc v256
    jmp b54(u32 0)
  b51():
    v285 = call f33(i32 2, v281) -> u1
    jmp b52(v285)
  b52(v286: u1):
    jmp b53(v286)
  b53(v287: u1):
    v288 = mul v282, v287
    store v288 at v278
    v289 = add v279, u32 1
    jmp b48(v289)
  b54(v294: u32):
    v295 = lt v294, u32 3
    jmpif v295 then: b55, else: b56
  b55():
    v296 = array_get v256, index v294 -> i32
    v297 = load v293 -> i32
    jmp b57()
  b56():
    v304 = load v293 -> i32
    v306 = eq v304, i32 12
    constrain v304 == i32 12
    v309 = allocate -> &mut i32
    store i32 0 at v309
    inc_rc v256
    jmp b61(u32 0)
  b57():
    jmp b58()
  b58():
    v300 = call f35(v297, v296) -> i32
    jmp b59(v300)
  b59(v301: i32):
    jmp b60(v301)
  b60(v302: i32):
    store v302 at v293
    v303 = add v294, u32 1
    jmp b54(v303)
  b61(v310: u32):
    v311 = lt v310, u32 3
    jmpif v311 then: b62, else: b63
  b62():
    v312 = array_get v256, index v310 -> i32
    v313 = load v309 -> i32
    jmp b64()
  b63():
    v319 = load v309 -> i32
    v321 = eq v319, i32 18
    constrain v319 == i32 18
    v324 = array_get v256, index u32 0 -> i32
    v325 = allocate -> &mut i32
    store v324 at v325
    jmp b66(u32 1)
  b64():
    v316 = call f37(i32 2, v313, v312) -> i32
    jmp b65(v316)
  b65(v317: i32):
    store v317 at v309
    v318 = add v310, u32 1
    jmp b61(v318)
  b66(v326: u32):
    v327 = lt v326, u32 3
    jmpif v327 then: b67, else: b68
  b67():
    v328 = load v325 -> i32
    v329 = array_get v256, index v326 -> i32
    jmp b69()
  b68():
    v337 = load v325 -> i32
    v338 = eq v337, i32 12
    constrain v337 == i32 12
    v341 = array_get v256, index u32 0 -> i32
    v342 = allocate -> &mut i32
    store v341 at v342
    jmp b75(u32 1)
  b69():
    jmp b70()
  b70():
    jmp b71()
  b71():
    v332 = call f39(v328, v329) -> i32
    jmp b72(v332)
  b72(v333: i32):
    jmp b73(v333)
  b73(v334: i32):
    jmp b74(v334)
  b74(v335: i32):
    store v335 at v325
    v336 = add v326, u32 1
    jmp b66(v336)
  b75(v343: u32):
    v344 = lt v343, u32 3
    jmpif v344 then: b76, else: b77
  b76():
    v345 = load v342 -> i32
    v346 = array_get v256, index v343 -> i32
    jmp b78()
  b77():
    v353 = load v342 -> i32
    v355 = eq v353, i32 16
    constrain v353 == i32 16
    v358 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v358
    v359 = allocate -> &mut [i32; 3]
    store v358 at v359
    jmp b81(u32 0)
  b78():
    v349 = call f41(i32 2, v345, v346) -> i32
    jmp b79(v349)
  b79(v350: i32):
    jmp b80(v350)
  b80(v351: i32):
    store v351 at v342
    v352 = add v343, u32 1
    jmp b75(v352)
  b81(v360: u32):
    v361 = lt v360, u32 3
    jmpif v361 then: b82, else: b83
  b82():
    v362 = load v359 -> [i32; 3]
    v363 = array_get v256, index v360 -> i32
    v365 = div v363, i32 2
    v366 = array_set v362, index v360, value v365
    v367 = add v360, u32 1
    store v366 at v359
    v368 = add v360, u32 1
    jmp b81(v368)
  b83():
    v369 = load v359 -> [i32; 3]
    v371 = allocate -> &mut u1
    store u1 1 at v371
    jmp b84(u32 0)
  b84(v372: u32):
    v373 = lt v372, u32 3
    jmpif v373 then: b85, else: b86
  b85():
    v374 = load v371 -> u1
    v375 = array_get v369, index v372 -> i32
    v376 = array_get v206, index v372 -> i32
    v378 = eq v375, v376
    v379 = mul v374, v378
    store v379 at v371
    v380 = add v372, u32 1
    jmp b84(v380)
  b86():
    v381 = load v371 -> u1
    constrain v381 == u1 1
    v384 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v384
    v385 = allocate -> &mut [i32; 3]
    store v384 at v385
    jmp b87(u32 0)
  b87(v386: u32):
    v387 = lt v386, u32 3
    jmpif v387 then: b88, else: b89
  b88():
    v388 = load v385 -> [i32; 3]
    v389 = array_get v256, index v386 -> i32
    jmp b90()
  b89():
    v400 = load v385 -> [i32; 3]
    v402 = allocate -> &mut u1
    store u1 1 at v402
    jmp b97(u32 0)
  b90():
    jmp b91()
  b91():
    jmp b92()
  b92():
    v392 = call f45(i32 2, v389) -> i32
    jmp b93(v392)
  b93(v393: i32):
    jmp b94(v393)
  b94(v394: i32):
    jmp b95(v394)
  b95(v395: i32):
    jmp b96(v395)
  b96(v396: i32):
    v397 = array_set v388, index v386, value v396
    v398 = add v386, u32 1
    store v397 at v385
    v399 = add v386, u32 1
    jmp b87(v399)
  b97(v403: u32):
    v404 = lt v403, u32 3
    jmpif v404 then: b98, else: b99
  b98():
    v405 = load v402 -> u1
    v406 = array_get v400, index v403 -> i32
    v407 = array_get v206, index v403 -> i32
    v409 = eq v406, v407
    v410 = mul v405, v409
    store v410 at v402
    v411 = add v403, u32 1
    jmp b97(v411)
  b99():
    v412 = load v402 -> u1
    constrain v412 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v425 = add v0, v182
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v425
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v6 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v6
    call __debug_fn_exit(u32 2)
    return v6
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v5 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v5
    call __debug_fn_exit(u32 3)
    return v5
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v2 = mul v0, Field 2
    return v2
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v1 = allocate -> &mut Field
    store v0 at v1
    v2 = load v1 -> Field
    return v2
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v10 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v10
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v2 = lt i32 2, v0
    return v2
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v2 = allocate -> &mut i32
    store v0 at v2
    v3 = load v2 -> i32
    v4 = lt v3, v1
    return v4
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v2 = allocate -> &mut i32
    store v0 at v2
    v3 = load v2 -> i32
    v4 = mul v1, v3
    v5 = cast v4 as u64
    v6 = truncate v5 to 32 bits, max_bit_size: 64
    v7 = cast v1 as u32
    v8 = cast v3 as u32
    v10 = lt v7, u32 2147483648
    v11 = lt v8, u32 2147483648
    v12 = eq v10, v11
    v13 = not v10
    v14 = cast v1 as Field
    v15 = cast v10 as Field
    v16 = mul v15, v14
    v18 = sub Field 4294967296, v14
    v19 = cast v13 as Field
    v20 = mul v19, v18
    v21 = add v16, v20
    v22 = not v11
    v23 = cast v3 as Field
    v24 = cast v11 as Field
    v25 = mul v24, v23
    v26 = sub Field 4294967296, v23
    v27 = cast v22 as Field
    v28 = mul v27, v26
    v29 = add v25, v28
    v30 = mul v21, v29
    range_check v30 to 32 bits
    v31 = cast v30 as u32
    v32 = not v12
    v33 = cast v32 as u32
    v34 = add u32 2147483648, v33
    v35 = lt v31, v34
    constrain v35 == u1 1, "attempt to add with overflow"
    v37 = cast v6 as i32
    return v37
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v2 = lt i32 1, v0
    return v2
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v2 = allocate -> &mut i32
    store v0 at v2
    v3 = load v2 -> i32
    v4 = lt v1, v3
    v5 = not v4
    return v5
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v3 = add v0, v1
    v4 = truncate v3 to 32 bits, max_bit_size: 33
    v5 = cast v4 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v9 = lt v6, u32 2147483648
    v10 = lt v7, u32 2147483648
    v11 = eq v9, v10
    v12 = lt v5, u32 2147483648
    v13 = eq v12, v9
    v14 = mul v13, v11
    constrain v14 == v11, "attempt to add with overflow"
    return v4
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v3 = allocate -> &mut i32
    store v0 at v3
    v5 = add v1, v2
    v6 = truncate v5 to 32 bits, max_bit_size: 33
    v7 = cast v6 as u32
    v8 = cast v1 as u32
    v9 = cast v2 as u32
    v11 = lt v8, u32 2147483648
    v12 = lt v9, u32 2147483648
    v13 = eq v11, v12
    v14 = lt v7, u32 2147483648
    v15 = eq v14, v11
    v16 = mul v15, v13
    constrain v16 == v13, "attempt to add with overflow"
    v17 = load v3 -> i32
    v18 = add v6, v17
    v19 = truncate v18 to 32 bits, max_bit_size: 33
    v20 = cast v19 as u32
    v21 = cast v6 as u32
    v22 = cast v17 as u32
    v23 = lt v21, u32 2147483648
    v24 = lt v22, u32 2147483648
    v25 = eq v23, v24
    v26 = lt v20, u32 2147483648
    v27 = eq v26, v23
    v28 = mul v27, v25
    constrain v28 == v25, "attempt to add with overflow"
    return v19
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v3 = add v0, v1
    v4 = truncate v3 to 32 bits, max_bit_size: 33
    v5 = cast v4 as u32
    v6 = cast v0 as u32
    v7 = cast v1 as u32
    v9 = lt v6, u32 2147483648
    v10 = lt v7, u32 2147483648
    v11 = eq v9, v10
    v12 = lt v5, u32 2147483648
    v13 = eq v12, v9
    v14 = mul v13, v11
    constrain v14 == v11, "attempt to add with overflow"
    return v4
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v3 = allocate -> &mut i32
    store v0 at v3
    v5 = add v1, v2
    v6 = truncate v5 to 32 bits, max_bit_size: 33
    v7 = cast v6 as u32
    v8 = cast v1 as u32
    v9 = cast v2 as u32
    v11 = lt v8, u32 2147483648
    v12 = lt v9, u32 2147483648
    v13 = eq v11, v12
    v14 = lt v7, u32 2147483648
    v15 = eq v14, v11
    v16 = mul v15, v13
    constrain v16 == v13, "attempt to add with overflow"
    v17 = load v3 -> i32
    v18 = add v6, v17
    v19 = truncate v18 to 32 bits, max_bit_size: 33
    v20 = cast v19 as u32
    v21 = cast v6 as u32
    v22 = cast v17 as u32
    v23 = lt v21, u32 2147483648
    v24 = lt v22, u32 2147483648
    v25 = eq v23, v24
    v26 = lt v20, u32 2147483648
    v27 = eq v26, v23
    v28 = mul v27, v25
    constrain v28 == v25, "attempt to add with overflow"
    return v19
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v2 = allocate -> &mut i32
    store v0 at v2
    v3 = load v2 -> i32
    v4 = div v1, v3
    return v4
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    return v2
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v1 = allocate -> &mut u32
    store v0 at v1
    v2 = load v1 -> u32
    v4 = add v2, u32 2342
    return v4
}

After Mem2Reg (1st):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    jmp b1()
  b1():
    jmp b2(Field 4)
  b2(v10: Field):
    call __debug_var_assign(Field 1, v10)
    v453 = eq v10, Field 3
    jmpif v453 then: b3, else: b4
  b3():
    v455 = call f3() -> [u32; 2]
    jmp b5(v455)
  b4():
    constrain v10 == Field 4
    v454 = call f4() -> [u32; 2]
    jmp b6(v454)
  b5(v21: [u32; 2]):
    v456 = array_get v21, index u32 1 -> u32
    v457 = eq v456, u32 2
    constrain v456 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    jmp b7()
  b6(v24: [u32; 2]):
    jmp b5(v24)
  b7():
    v458 = call f7(Field 5) -> Field
    jmp b8(v458)
  b8(v48: Field):
    jmp b9()
  b9():
    v459 = call f7(v48) -> Field
    jmp b10(v459)
  b10(v52: Field):
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v460 = eq v52, Field 20
    constrain v52 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v461 = call f10(Field 42) -> Field
    v462 = eq v461, Field 42
    constrain v461 == Field 42
    v463 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v466 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v470 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v473 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v476 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    jmp b11()
  b11():
    jmp b12(u32 32, Field 51)
  b12(v134: u32, v135: Field):
    call __debug_var_assign(Field 11, v134, v135)
    v478 = eq v135, Field 51
    jmpif v478 then: b13, else: b14
  b13():
    v480 = call f51(v134) -> u32
    jmp b15(v480)
  b14():
    constrain v135 == Field 52
    v479 = call f52(v134) -> u32
    jmp b16(v479)
  b15(v145: u32):
    v481 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    jmp b17()
  b16(v149: u32):
    jmp b15(v149)
  b17():
    jmp b18()
  b18():
    v482 = call f16(Field 3) -> Field
    jmp b19(v482)
  b19(v174: Field):
    jmp b20(v174)
  b20(v175: Field):
    jmp b21(v175)
  b21(v176: Field):
    jmp b22()
  b22():
    jmp b23()
  b23():
    v483 = call f16(v176) -> Field
    jmp b24(v483)
  b24(v180: Field):
    jmp b25(v180)
  b25(v181: Field):
    jmp b26(v181)
  b26(v182: Field):
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v182)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v484 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v484
    call __debug_var_assign(Field 14, v484)
    inc_rc v484
    inc_rc v484
    v485 = allocate -> &mut u1
    store u1 0 at v485
    inc_rc v484
    jmp b27(u32 0)
  b27(v214: u32):
    v486 = lt v214, u32 3
    jmpif v486 then: b28, else: b29
  b28():
    v595 = array_get v484, index v214 -> i32
    v596 = load v485 -> u1
    jmp b30()
  b29():
    v487 = load v485 -> u1
    constrain v487 == u1 1
    v488 = allocate -> &mut u1
    store u1 0 at v488
    inc_rc v484
    jmp b32(u32 0)
  b30():
    v597 = call f25(v595) -> u1
    jmp b31(v597)
  b31(v222: u1):
    v598 = or v596, v222
    store v598 at v485
    v599 = add v214, u32 1
    jmp b27(v599)
  b32(v229: u32):
    v489 = lt v229, u32 3
    jmpif v489 then: b33, else: b34
  b33():
    v590 = array_get v484, index v229 -> i32
    v591 = load v488 -> u1
    jmp b35()
  b34():
    v490 = load v488 -> u1
    constrain v490 == u1 1
    v491 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v491
    v492 = allocate -> &mut [i32; 3]
    store v491 at v492
    jmp b37(u32 0)
  b35():
    v592 = call f27(i32 2, v590) -> u1
    jmp b36(v592)
  b36(v236: u1):
    v593 = or v591, v236
    store v593 at v488
    v594 = add v229, u32 1
    jmp b32(v594)
  b37(v245: u32):
    v493 = lt v245, u32 3
    jmpif v493 then: b38, else: b39
  b38():
    v584 = load v492 -> [i32; 3]
    v585 = array_get v484, index v245 -> i32
    jmp b40()
  b39():
    v494 = load v492 -> [i32; 3]
    inc_rc v494
    call __debug_var_assign(Field 15, v494)
    inc_rc v494
    inc_rc v494
    v495 = allocate -> &mut u1
    store u1 1 at v495
    inc_rc v494
    jmp b42(u32 0)
  b40():
    v586 = call f29(i32 2, v585) -> i32
    jmp b41(v586)
  b41(v252: i32):
    v587 = array_set v584, index v245, value v252
    v588 = add v245, u32 1
    store v587 at v492
    v589 = add v245, u32 1
    jmp b37(v589)
  b42(v264: u32):
    v496 = lt v264, u32 3
    jmpif v496 then: b43, else: b44
  b43():
    v579 = array_get v494, index v264 -> i32
    v580 = load v495 -> u1
    jmp b45()
  b44():
    v497 = load v495 -> u1
    constrain v497 == u1 1
    v498 = allocate -> &mut u1
    store u1 1 at v498
    inc_rc v494
    jmp b48(u32 0)
  b45():
    v581 = call f31(v579) -> u1
    jmp b46(v581)
  b46(v271: u1):
    jmp b47(v271)
  b47(v272: u1):
    v582 = mul v580, v272
    store v582 at v495
    v583 = add v264, u32 1
    jmp b42(v583)
  b48(v279: u32):
    v499 = lt v279, u32 3
    jmpif v499 then: b49, else: b50
  b49():
    v574 = array_get v494, index v279 -> i32
    v575 = load v498 -> u1
    jmp b51()
  b50():
    v500 = load v498 -> u1
    constrain v500 == u1 1
    v501 = allocate -> &mut i32
    store i32 0 at v501
    inc_rc v494
    jmp b54(u32 0)
  b51():
    v576 = call f33(i32 2, v574) -> u1
    jmp b52(v576)
  b52(v286: u1):
    jmp b53(v286)
  b53(v287: u1):
    v577 = mul v575, v287
    store v577 at v498
    v578 = add v279, u32 1
    jmp b48(v578)
  b54(v294: u32):
    v502 = lt v294, u32 3
    jmpif v502 then: b55, else: b56
  b55():
    v570 = array_get v494, index v294 -> i32
    v571 = load v501 -> i32
    jmp b57()
  b56():
    v503 = load v501 -> i32
    v504 = eq v503, i32 12
    constrain v503 == i32 12
    v505 = allocate -> &mut i32
    store i32 0 at v505
    inc_rc v494
    jmp b61(u32 0)
  b57():
    jmp b58()
  b58():
    v572 = call f35(v571, v570) -> i32
    jmp b59(v572)
  b59(v301: i32):
    jmp b60(v301)
  b60(v302: i32):
    store v302 at v501
    v573 = add v294, u32 1
    jmp b54(v573)
  b61(v310: u32):
    v506 = lt v310, u32 3
    jmpif v506 then: b62, else: b63
  b62():
    v566 = array_get v494, index v310 -> i32
    v567 = load v505 -> i32
    jmp b64()
  b63():
    v507 = load v505 -> i32
    v508 = eq v507, i32 18
    constrain v507 == i32 18
    v509 = array_get v494, index u32 0 -> i32
    v510 = allocate -> &mut i32
    store v509 at v510
    jmp b66(u32 1)
  b64():
    v568 = call f37(i32 2, v567, v566) -> i32
    jmp b65(v568)
  b65(v317: i32):
    store v317 at v505
    v569 = add v310, u32 1
    jmp b61(v569)
  b66(v326: u32):
    v511 = lt v326, u32 3
    jmpif v511 then: b67, else: b68
  b67():
    v562 = load v510 -> i32
    v563 = array_get v494, index v326 -> i32
    jmp b69()
  b68():
    v512 = load v510 -> i32
    v513 = eq v512, i32 12
    constrain v512 == i32 12
    v514 = array_get v494, index u32 0 -> i32
    v515 = allocate -> &mut i32
    store v514 at v515
    jmp b75(u32 1)
  b69():
    jmp b70()
  b70():
    jmp b71()
  b71():
    v564 = call f39(v562, v563) -> i32
    jmp b72(v564)
  b72(v333: i32):
    jmp b73(v333)
  b73(v334: i32):
    jmp b74(v334)
  b74(v335: i32):
    store v335 at v510
    v565 = add v326, u32 1
    jmp b66(v565)
  b75(v343: u32):
    v516 = lt v343, u32 3
    jmpif v516 then: b76, else: b77
  b76():
    v558 = load v515 -> i32
    v559 = array_get v494, index v343 -> i32
    jmp b78()
  b77():
    v517 = load v515 -> i32
    v518 = eq v517, i32 16
    constrain v517 == i32 16
    v519 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v519
    v520 = allocate -> &mut [i32; 3]
    store v519 at v520
    jmp b81(u32 0)
  b78():
    v560 = call f41(i32 2, v558, v559) -> i32
    jmp b79(v560)
  b79(v350: i32):
    jmp b80(v350)
  b80(v351: i32):
    store v351 at v515
    v561 = add v343, u32 1
    jmp b75(v561)
  b81(v360: u32):
    v521 = lt v360, u32 3
    jmpif v521 then: b82, else: b83
  b82():
    v552 = load v520 -> [i32; 3]
    v553 = array_get v494, index v360 -> i32
    v554 = div v553, i32 2
    v555 = array_set v552, index v360, value v554
    v556 = add v360, u32 1
    store v555 at v520
    v557 = add v360, u32 1
    jmp b81(v557)
  b83():
    v522 = load v520 -> [i32; 3]
    v523 = allocate -> &mut u1
    store u1 1 at v523
    jmp b84(u32 0)
  b84(v372: u32):
    v524 = lt v372, u32 3
    jmpif v524 then: b85, else: b86
  b85():
    v546 = load v523 -> u1
    v547 = array_get v522, index v372 -> i32
    v548 = array_get v484, index v372 -> i32
    v549 = eq v547, v548
    v550 = mul v546, v549
    store v550 at v523
    v551 = add v372, u32 1
    jmp b84(v551)
  b86():
    v525 = load v523 -> u1
    constrain v525 == u1 1
    v526 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v526
    v527 = allocate -> &mut [i32; 3]
    store v526 at v527
    jmp b87(u32 0)
  b87(v386: u32):
    v528 = lt v386, u32 3
    jmpif v528 then: b88, else: b89
  b88():
    v540 = load v527 -> [i32; 3]
    v541 = array_get v494, index v386 -> i32
    jmp b90()
  b89():
    v529 = load v527 -> [i32; 3]
    v530 = allocate -> &mut u1
    store u1 1 at v530
    jmp b97(u32 0)
  b90():
    jmp b91()
  b91():
    jmp b92()
  b92():
    v542 = call f45(i32 2, v541) -> i32
    jmp b93(v542)
  b93(v393: i32):
    jmp b94(v393)
  b94(v394: i32):
    jmp b95(v394)
  b95(v395: i32):
    jmp b96(v395)
  b96(v396: i32):
    v543 = array_set v540, index v386, value v396
    v544 = add v386, u32 1
    store v543 at v527
    v545 = add v386, u32 1
    jmp b87(v545)
  b97(v403: u32):
    v531 = lt v403, u32 3
    jmpif v531 then: b98, else: b99
  b98():
    v534 = load v530 -> u1
    v535 = array_get v529, index v403 -> i32
    v536 = array_get v484, index v403 -> i32
    v537 = eq v535, v536
    v538 = mul v534, v537
    store v538 at v530
    v539 = add v403, u32 1
    jmp b97(v539)
  b99():
    v532 = load v530 -> u1
    constrain v532 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v533 = add v0, v182
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v533
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v10 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v10
    call __debug_fn_exit(u32 2)
    return v10
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v9 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v9
    call __debug_fn_exit(u32 3)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v3 = mul v0, Field 2
    return v3
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v3 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v17 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v17
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v3 = lt i32 2, v0
    return v3
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = lt v0, v1
    return v7
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v38 = allocate -> &mut i32
    v40 = mul v1, v0
    v41 = cast v40 as u64
    v42 = truncate v41 to 32 bits, max_bit_size: 64
    v43 = cast v1 as u32
    v44 = cast v0 as u32
    v45 = lt v43, u32 2147483648
    v46 = lt v44, u32 2147483648
    v47 = eq v45, v46
    v48 = not v45
    v49 = cast v1 as Field
    v50 = cast v45 as Field
    v51 = mul v50, v49
    v52 = sub Field 4294967296, v49
    v53 = cast v48 as Field
    v54 = mul v53, v52
    v55 = add v51, v54
    v56 = not v46
    v57 = cast v0 as Field
    v58 = cast v46 as Field
    v59 = mul v58, v57
    v60 = sub Field 4294967296, v57
    v61 = cast v56 as Field
    v62 = mul v61, v60
    v63 = add v59, v62
    v64 = mul v55, v63
    range_check v64 to 32 bits
    v65 = cast v64 as u32
    v66 = not v47
    v67 = cast v66 as u32
    v68 = add u32 2147483648, v67
    v69 = lt v65, v68
    constrain v69 == u1 1, "attempt to add with overflow"
    v70 = cast v42 as i32
    return v70
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v3 = lt i32 1, v0
    return v3
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v6 = allocate -> &mut i32
    v8 = lt v1, v0
    v9 = not v8
    return v9
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = div v1, v0
    return v7
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v3 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v5 = allocate -> &mut u32
    v7 = add v0, u32 2342
    return v7
}

After Simplifying (1st):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v453 = eq Field 4, Field 3
    jmpif v453 then: b3, else: b4
  b3():
    v455 = call f3() -> [u32; 2]
    jmp b5(v455)
  b4():
    constrain Field 4 == Field 4
    v454 = call f4() -> [u32; 2]
    jmp b5(v454)
  b5(v21: [u32; 2]):
    v456 = array_get v21, index u32 1 -> u32
    v457 = eq v456, u32 2
    constrain v456 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v458 = call f7(Field 5) -> Field
    v459 = call f7(v458) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v460 = eq v459, Field 20
    constrain v459 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v461 = call f10(Field 42) -> Field
    v462 = eq v461, Field 42
    constrain v461 == Field 42
    v463 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v466 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v470 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v473 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v476 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v478 = eq Field 51, Field 51
    jmpif v478 then: b13, else: b14
  b13():
    v480 = call f51(u32 32) -> u32
    jmp b15(v480)
  b14():
    constrain Field 51 == Field 52
    v479 = call f52(u32 32) -> u32
    jmp b15(v479)
  b15(v145: u32):
    v481 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v482 = call f16(Field 3) -> Field
    v483 = call f16(v482) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v483)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v484 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v484
    call __debug_var_assign(Field 14, v484)
    inc_rc v484
    inc_rc v484
    v485 = allocate -> &mut u1
    store u1 0 at v485
    inc_rc v484
    jmp b27(u32 0)
  b27(v214: u32):
    v486 = lt v214, u32 3
    jmpif v486 then: b28, else: b29
  b28():
    v595 = array_get v484, index v214 -> i32
    v596 = load v485 -> u1
    v597 = call f25(v595) -> u1
    v598 = or v596, v597
    store v598 at v485
    v599 = add v214, u32 1
    jmp b27(v599)
  b29():
    v487 = load v485 -> u1
    constrain v487 == u1 1
    v488 = allocate -> &mut u1
    store u1 0 at v488
    inc_rc v484
    jmp b32(u32 0)
  b32(v229: u32):
    v489 = lt v229, u32 3
    jmpif v489 then: b33, else: b34
  b33():
    v590 = array_get v484, index v229 -> i32
    v591 = load v488 -> u1
    v592 = call f27(i32 2, v590) -> u1
    v593 = or v591, v592
    store v593 at v488
    v594 = add v229, u32 1
    jmp b32(v594)
  b34():
    v490 = load v488 -> u1
    constrain v490 == u1 1
    v491 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v491
    v492 = allocate -> &mut [i32; 3]
    store v491 at v492
    jmp b37(u32 0)
  b37(v245: u32):
    v493 = lt v245, u32 3
    jmpif v493 then: b38, else: b39
  b38():
    v584 = load v492 -> [i32; 3]
    v585 = array_get v484, index v245 -> i32
    v586 = call f29(i32 2, v585) -> i32
    v587 = array_set v584, index v245, value v586
    v588 = add v245, u32 1
    store v587 at v492
    v589 = add v245, u32 1
    jmp b37(v589)
  b39():
    v494 = load v492 -> [i32; 3]
    inc_rc v494
    call __debug_var_assign(Field 15, v494)
    inc_rc v494
    inc_rc v494
    v495 = allocate -> &mut u1
    store u1 1 at v495
    inc_rc v494
    jmp b42(u32 0)
  b42(v264: u32):
    v496 = lt v264, u32 3
    jmpif v496 then: b43, else: b44
  b43():
    v579 = array_get v494, index v264 -> i32
    v580 = load v495 -> u1
    v581 = call f31(v579) -> u1
    v582 = mul v580, v581
    store v582 at v495
    v583 = add v264, u32 1
    jmp b42(v583)
  b44():
    v497 = load v495 -> u1
    constrain v497 == u1 1
    v498 = allocate -> &mut u1
    store u1 1 at v498
    inc_rc v494
    jmp b48(u32 0)
  b48(v279: u32):
    v499 = lt v279, u32 3
    jmpif v499 then: b49, else: b50
  b49():
    v574 = array_get v494, index v279 -> i32
    v575 = load v498 -> u1
    v576 = call f33(i32 2, v574) -> u1
    v577 = mul v575, v576
    store v577 at v498
    v578 = add v279, u32 1
    jmp b48(v578)
  b50():
    v500 = load v498 -> u1
    constrain v500 == u1 1
    v501 = allocate -> &mut i32
    store i32 0 at v501
    inc_rc v494
    jmp b54(u32 0)
  b54(v294: u32):
    v502 = lt v294, u32 3
    jmpif v502 then: b55, else: b56
  b55():
    v570 = array_get v494, index v294 -> i32
    v571 = load v501 -> i32
    v572 = call f35(v571, v570) -> i32
    store v572 at v501
    v573 = add v294, u32 1
    jmp b54(v573)
  b56():
    v503 = load v501 -> i32
    v504 = eq v503, i32 12
    constrain v503 == i32 12
    v505 = allocate -> &mut i32
    store i32 0 at v505
    inc_rc v494
    jmp b61(u32 0)
  b61(v310: u32):
    v506 = lt v310, u32 3
    jmpif v506 then: b62, else: b63
  b62():
    v566 = array_get v494, index v310 -> i32
    v567 = load v505 -> i32
    v568 = call f37(i32 2, v567, v566) -> i32
    store v568 at v505
    v569 = add v310, u32 1
    jmp b61(v569)
  b63():
    v507 = load v505 -> i32
    v508 = eq v507, i32 18
    constrain v507 == i32 18
    v509 = array_get v494, index u32 0 -> i32
    v510 = allocate -> &mut i32
    store v509 at v510
    jmp b66(u32 1)
  b66(v326: u32):
    v511 = lt v326, u32 3
    jmpif v511 then: b67, else: b68
  b67():
    v562 = load v510 -> i32
    v563 = array_get v494, index v326 -> i32
    v564 = call f39(v562, v563) -> i32
    store v564 at v510
    v565 = add v326, u32 1
    jmp b66(v565)
  b68():
    v512 = load v510 -> i32
    v513 = eq v512, i32 12
    constrain v512 == i32 12
    v514 = array_get v494, index u32 0 -> i32
    v515 = allocate -> &mut i32
    store v514 at v515
    jmp b75(u32 1)
  b75(v343: u32):
    v516 = lt v343, u32 3
    jmpif v516 then: b76, else: b77
  b76():
    v558 = load v515 -> i32
    v559 = array_get v494, index v343 -> i32
    v560 = call f41(i32 2, v558, v559) -> i32
    store v560 at v515
    v561 = add v343, u32 1
    jmp b75(v561)
  b77():
    v517 = load v515 -> i32
    v518 = eq v517, i32 16
    constrain v517 == i32 16
    v519 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v519
    v520 = allocate -> &mut [i32; 3]
    store v519 at v520
    jmp b81(u32 0)
  b81(v360: u32):
    v521 = lt v360, u32 3
    jmpif v521 then: b82, else: b83
  b82():
    v552 = load v520 -> [i32; 3]
    v553 = array_get v494, index v360 -> i32
    v554 = div v553, i32 2
    v555 = array_set v552, index v360, value v554
    v556 = add v360, u32 1
    store v555 at v520
    v557 = add v360, u32 1
    jmp b81(v557)
  b83():
    v522 = load v520 -> [i32; 3]
    v523 = allocate -> &mut u1
    store u1 1 at v523
    jmp b84(u32 0)
  b84(v372: u32):
    v524 = lt v372, u32 3
    jmpif v524 then: b85, else: b86
  b85():
    v546 = load v523 -> u1
    v547 = array_get v522, index v372 -> i32
    v548 = array_get v484, index v372 -> i32
    v549 = eq v547, v548
    v550 = mul v546, v549
    store v550 at v523
    v551 = add v372, u32 1
    jmp b84(v551)
  b86():
    v525 = load v523 -> u1
    constrain v525 == u1 1
    v526 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v526
    v527 = allocate -> &mut [i32; 3]
    store v526 at v527
    jmp b87(u32 0)
  b87(v386: u32):
    v528 = lt v386, u32 3
    jmpif v528 then: b88, else: b89
  b88():
    v540 = load v527 -> [i32; 3]
    v541 = array_get v494, index v386 -> i32
    v542 = call f45(i32 2, v541) -> i32
    v543 = array_set v540, index v386, value v542
    v544 = add v386, u32 1
    store v543 at v527
    v545 = add v386, u32 1
    jmp b87(v545)
  b89():
    v529 = load v527 -> [i32; 3]
    v530 = allocate -> &mut u1
    store u1 1 at v530
    jmp b97(u32 0)
  b97(v403: u32):
    v531 = lt v403, u32 3
    jmpif v531 then: b98, else: b99
  b98():
    v534 = load v530 -> u1
    v535 = array_get v529, index v403 -> i32
    v536 = array_get v484, index v403 -> i32
    v537 = eq v535, v536
    v538 = mul v534, v537
    store v538 at v530
    v539 = add v403, u32 1
    jmp b97(v539)
  b99():
    v532 = load v530 -> u1
    constrain v532 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v533 = add v0, v483
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v533
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v10 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v10
    call __debug_fn_exit(u32 2)
    return v10
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v9 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v9
    call __debug_fn_exit(u32 3)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v3 = mul v0, Field 2
    return v3
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v3 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v17 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v17
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v3 = lt i32 2, v0
    return v3
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = lt v0, v1
    return v7
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v38 = allocate -> &mut i32
    v40 = mul v1, v0
    v41 = cast v40 as u64
    v42 = truncate v41 to 32 bits, max_bit_size: 64
    v43 = cast v1 as u32
    v44 = cast v0 as u32
    v45 = lt v43, u32 2147483648
    v46 = lt v44, u32 2147483648
    v47 = eq v45, v46
    v48 = not v45
    v49 = cast v1 as Field
    v50 = cast v45 as Field
    v51 = mul v50, v49
    v52 = sub Field 4294967296, v49
    v53 = cast v48 as Field
    v54 = mul v53, v52
    v55 = add v51, v54
    v56 = not v46
    v57 = cast v0 as Field
    v58 = cast v46 as Field
    v59 = mul v58, v57
    v60 = sub Field 4294967296, v57
    v61 = cast v56 as Field
    v62 = mul v61, v60
    v63 = add v59, v62
    v64 = mul v55, v63
    range_check v64 to 32 bits
    v65 = cast v64 as u32
    v66 = not v47
    v67 = cast v66 as u32
    v68 = add u32 2147483648, v67
    v69 = lt v65, v68
    constrain v69 == u1 1, "attempt to add with overflow"
    v70 = cast v42 as i32
    return v70
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v3 = lt i32 1, v0
    return v3
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v6 = allocate -> &mut i32
    v8 = lt v1, v0
    v9 = not v8
    return v9
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = div v1, v0
    return v7
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v3 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v5 = allocate -> &mut u32
    v7 = add v0, u32 2342
    return v7
}

After `as_slice` optimization:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v453 = eq Field 4, Field 3
    jmpif v453 then: b3, else: b4
  b3():
    v455 = call f3() -> [u32; 2]
    jmp b5(v455)
  b4():
    constrain Field 4 == Field 4
    v454 = call f4() -> [u32; 2]
    jmp b5(v454)
  b5(v21: [u32; 2]):
    v456 = array_get v21, index u32 1 -> u32
    v457 = eq v456, u32 2
    constrain v456 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v458 = call f7(Field 5) -> Field
    v459 = call f7(v458) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v460 = eq v459, Field 20
    constrain v459 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v461 = call f10(Field 42) -> Field
    v462 = eq v461, Field 42
    constrain v461 == Field 42
    v463 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v466 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v470 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v473 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v476 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v478 = eq Field 51, Field 51
    jmpif v478 then: b13, else: b14
  b13():
    v480 = call f51(u32 32) -> u32
    jmp b15(v480)
  b14():
    constrain Field 51 == Field 52
    v479 = call f52(u32 32) -> u32
    jmp b15(v479)
  b15(v145: u32):
    v481 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v482 = call f16(Field 3) -> Field
    v483 = call f16(v482) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v483)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v484 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v484
    call __debug_var_assign(Field 14, v484)
    inc_rc v484
    inc_rc v484
    v485 = allocate -> &mut u1
    store u1 0 at v485
    inc_rc v484
    jmp b27(u32 0)
  b27(v214: u32):
    v486 = lt v214, u32 3
    jmpif v486 then: b28, else: b29
  b28():
    v595 = array_get v484, index v214 -> i32
    v596 = load v485 -> u1
    v597 = call f25(v595) -> u1
    v598 = or v596, v597
    store v598 at v485
    v599 = add v214, u32 1
    jmp b27(v599)
  b29():
    v487 = load v485 -> u1
    constrain v487 == u1 1
    v488 = allocate -> &mut u1
    store u1 0 at v488
    inc_rc v484
    jmp b32(u32 0)
  b32(v229: u32):
    v489 = lt v229, u32 3
    jmpif v489 then: b33, else: b34
  b33():
    v590 = array_get v484, index v229 -> i32
    v591 = load v488 -> u1
    v592 = call f27(i32 2, v590) -> u1
    v593 = or v591, v592
    store v593 at v488
    v594 = add v229, u32 1
    jmp b32(v594)
  b34():
    v490 = load v488 -> u1
    constrain v490 == u1 1
    v491 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v491
    v492 = allocate -> &mut [i32; 3]
    store v491 at v492
    jmp b37(u32 0)
  b37(v245: u32):
    v493 = lt v245, u32 3
    jmpif v493 then: b38, else: b39
  b38():
    v584 = load v492 -> [i32; 3]
    v585 = array_get v484, index v245 -> i32
    v586 = call f29(i32 2, v585) -> i32
    v587 = array_set v584, index v245, value v586
    v588 = add v245, u32 1
    store v587 at v492
    v589 = add v245, u32 1
    jmp b37(v589)
  b39():
    v494 = load v492 -> [i32; 3]
    inc_rc v494
    call __debug_var_assign(Field 15, v494)
    inc_rc v494
    inc_rc v494
    v495 = allocate -> &mut u1
    store u1 1 at v495
    inc_rc v494
    jmp b42(u32 0)
  b42(v264: u32):
    v496 = lt v264, u32 3
    jmpif v496 then: b43, else: b44
  b43():
    v579 = array_get v494, index v264 -> i32
    v580 = load v495 -> u1
    v581 = call f31(v579) -> u1
    v582 = mul v580, v581
    store v582 at v495
    v583 = add v264, u32 1
    jmp b42(v583)
  b44():
    v497 = load v495 -> u1
    constrain v497 == u1 1
    v498 = allocate -> &mut u1
    store u1 1 at v498
    inc_rc v494
    jmp b48(u32 0)
  b48(v279: u32):
    v499 = lt v279, u32 3
    jmpif v499 then: b49, else: b50
  b49():
    v574 = array_get v494, index v279 -> i32
    v575 = load v498 -> u1
    v576 = call f33(i32 2, v574) -> u1
    v577 = mul v575, v576
    store v577 at v498
    v578 = add v279, u32 1
    jmp b48(v578)
  b50():
    v500 = load v498 -> u1
    constrain v500 == u1 1
    v501 = allocate -> &mut i32
    store i32 0 at v501
    inc_rc v494
    jmp b54(u32 0)
  b54(v294: u32):
    v502 = lt v294, u32 3
    jmpif v502 then: b55, else: b56
  b55():
    v570 = array_get v494, index v294 -> i32
    v571 = load v501 -> i32
    v572 = call f35(v571, v570) -> i32
    store v572 at v501
    v573 = add v294, u32 1
    jmp b54(v573)
  b56():
    v503 = load v501 -> i32
    v504 = eq v503, i32 12
    constrain v503 == i32 12
    v505 = allocate -> &mut i32
    store i32 0 at v505
    inc_rc v494
    jmp b61(u32 0)
  b61(v310: u32):
    v506 = lt v310, u32 3
    jmpif v506 then: b62, else: b63
  b62():
    v566 = array_get v494, index v310 -> i32
    v567 = load v505 -> i32
    v568 = call f37(i32 2, v567, v566) -> i32
    store v568 at v505
    v569 = add v310, u32 1
    jmp b61(v569)
  b63():
    v507 = load v505 -> i32
    v508 = eq v507, i32 18
    constrain v507 == i32 18
    v509 = array_get v494, index u32 0 -> i32
    v510 = allocate -> &mut i32
    store v509 at v510
    jmp b66(u32 1)
  b66(v326: u32):
    v511 = lt v326, u32 3
    jmpif v511 then: b67, else: b68
  b67():
    v562 = load v510 -> i32
    v563 = array_get v494, index v326 -> i32
    v564 = call f39(v562, v563) -> i32
    store v564 at v510
    v565 = add v326, u32 1
    jmp b66(v565)
  b68():
    v512 = load v510 -> i32
    v513 = eq v512, i32 12
    constrain v512 == i32 12
    v514 = array_get v494, index u32 0 -> i32
    v515 = allocate -> &mut i32
    store v514 at v515
    jmp b75(u32 1)
  b75(v343: u32):
    v516 = lt v343, u32 3
    jmpif v516 then: b76, else: b77
  b76():
    v558 = load v515 -> i32
    v559 = array_get v494, index v343 -> i32
    v560 = call f41(i32 2, v558, v559) -> i32
    store v560 at v515
    v561 = add v343, u32 1
    jmp b75(v561)
  b77():
    v517 = load v515 -> i32
    v518 = eq v517, i32 16
    constrain v517 == i32 16
    v519 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v519
    v520 = allocate -> &mut [i32; 3]
    store v519 at v520
    jmp b81(u32 0)
  b81(v360: u32):
    v521 = lt v360, u32 3
    jmpif v521 then: b82, else: b83
  b82():
    v552 = load v520 -> [i32; 3]
    v553 = array_get v494, index v360 -> i32
    v554 = div v553, i32 2
    v555 = array_set v552, index v360, value v554
    v556 = add v360, u32 1
    store v555 at v520
    v557 = add v360, u32 1
    jmp b81(v557)
  b83():
    v522 = load v520 -> [i32; 3]
    v523 = allocate -> &mut u1
    store u1 1 at v523
    jmp b84(u32 0)
  b84(v372: u32):
    v524 = lt v372, u32 3
    jmpif v524 then: b85, else: b86
  b85():
    v546 = load v523 -> u1
    v547 = array_get v522, index v372 -> i32
    v548 = array_get v484, index v372 -> i32
    v549 = eq v547, v548
    v550 = mul v546, v549
    store v550 at v523
    v551 = add v372, u32 1
    jmp b84(v551)
  b86():
    v525 = load v523 -> u1
    constrain v525 == u1 1
    v526 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v526
    v527 = allocate -> &mut [i32; 3]
    store v526 at v527
    jmp b87(u32 0)
  b87(v386: u32):
    v528 = lt v386, u32 3
    jmpif v528 then: b88, else: b89
  b88():
    v540 = load v527 -> [i32; 3]
    v541 = array_get v494, index v386 -> i32
    v542 = call f45(i32 2, v541) -> i32
    v543 = array_set v540, index v386, value v542
    v544 = add v386, u32 1
    store v543 at v527
    v545 = add v386, u32 1
    jmp b87(v545)
  b89():
    v529 = load v527 -> [i32; 3]
    v530 = allocate -> &mut u1
    store u1 1 at v530
    jmp b97(u32 0)
  b97(v403: u32):
    v531 = lt v403, u32 3
    jmpif v531 then: b98, else: b99
  b98():
    v534 = load v530 -> u1
    v535 = array_get v529, index v403 -> i32
    v536 = array_get v484, index v403 -> i32
    v537 = eq v535, v536
    v538 = mul v534, v537
    store v538 at v530
    v539 = add v403, u32 1
    jmp b97(v539)
  b99():
    v532 = load v530 -> u1
    constrain v532 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v533 = add v0, v483
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v533
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v10 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v10
    call __debug_fn_exit(u32 2)
    return v10
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v9 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v9
    call __debug_fn_exit(u32 3)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v3 = mul v0, Field 2
    return v3
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v3 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v17 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v17
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v3 = lt i32 2, v0
    return v3
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = lt v0, v1
    return v7
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v38 = allocate -> &mut i32
    v40 = mul v1, v0
    v41 = cast v40 as u64
    v42 = truncate v41 to 32 bits, max_bit_size: 64
    v43 = cast v1 as u32
    v44 = cast v0 as u32
    v45 = lt v43, u32 2147483648
    v46 = lt v44, u32 2147483648
    v47 = eq v45, v46
    v48 = not v45
    v49 = cast v1 as Field
    v50 = cast v45 as Field
    v51 = mul v50, v49
    v52 = sub Field 4294967296, v49
    v53 = cast v48 as Field
    v54 = mul v53, v52
    v55 = add v51, v54
    v56 = not v46
    v57 = cast v0 as Field
    v58 = cast v46 as Field
    v59 = mul v58, v57
    v60 = sub Field 4294967296, v57
    v61 = cast v56 as Field
    v62 = mul v61, v60
    v63 = add v59, v62
    v64 = mul v55, v63
    range_check v64 to 32 bits
    v65 = cast v64 as u32
    v66 = not v47
    v67 = cast v66 as u32
    v68 = add u32 2147483648, v67
    v69 = lt v65, v68
    constrain v69 == u1 1, "attempt to add with overflow"
    v70 = cast v42 as i32
    return v70
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v3 = lt i32 1, v0
    return v3
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v6 = allocate -> &mut i32
    v8 = lt v1, v0
    v9 = not v8
    return v9
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = div v1, v0
    return v7
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v3 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v5 = allocate -> &mut u32
    v7 = add v0, u32 2342
    return v7
}

After Removing Unreachable Functions:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v453 = eq Field 4, Field 3
    jmpif v453 then: b3, else: b4
  b3():
    v455 = call f3() -> [u32; 2]
    jmp b5(v455)
  b4():
    constrain Field 4 == Field 4
    v454 = call f4() -> [u32; 2]
    jmp b5(v454)
  b5(v21: [u32; 2]):
    v456 = array_get v21, index u32 1 -> u32
    v457 = eq v456, u32 2
    constrain v456 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v458 = call f7(Field 5) -> Field
    v459 = call f7(v458) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v460 = eq v459, Field 20
    constrain v459 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v461 = call f10(Field 42) -> Field
    v462 = eq v461, Field 42
    constrain v461 == Field 42
    v463 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v466 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v470 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v473 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v476 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v478 = eq Field 51, Field 51
    jmpif v478 then: b13, else: b14
  b13():
    v480 = call f51(u32 32) -> u32
    jmp b15(v480)
  b14():
    constrain Field 51 == Field 52
    v479 = call f52(u32 32) -> u32
    jmp b15(v479)
  b15(v145: u32):
    v481 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v482 = call f16(Field 3) -> Field
    v483 = call f16(v482) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v483)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v484 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v484
    call __debug_var_assign(Field 14, v484)
    inc_rc v484
    inc_rc v484
    v485 = allocate -> &mut u1
    store u1 0 at v485
    inc_rc v484
    jmp b27(u32 0)
  b27(v214: u32):
    v486 = lt v214, u32 3
    jmpif v486 then: b28, else: b29
  b28():
    v595 = array_get v484, index v214 -> i32
    v596 = load v485 -> u1
    v597 = call f25(v595) -> u1
    v598 = or v596, v597
    store v598 at v485
    v599 = add v214, u32 1
    jmp b27(v599)
  b29():
    v487 = load v485 -> u1
    constrain v487 == u1 1
    v488 = allocate -> &mut u1
    store u1 0 at v488
    inc_rc v484
    jmp b32(u32 0)
  b32(v229: u32):
    v489 = lt v229, u32 3
    jmpif v489 then: b33, else: b34
  b33():
    v590 = array_get v484, index v229 -> i32
    v591 = load v488 -> u1
    v592 = call f27(i32 2, v590) -> u1
    v593 = or v591, v592
    store v593 at v488
    v594 = add v229, u32 1
    jmp b32(v594)
  b34():
    v490 = load v488 -> u1
    constrain v490 == u1 1
    v491 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v491
    v492 = allocate -> &mut [i32; 3]
    store v491 at v492
    jmp b37(u32 0)
  b37(v245: u32):
    v493 = lt v245, u32 3
    jmpif v493 then: b38, else: b39
  b38():
    v584 = load v492 -> [i32; 3]
    v585 = array_get v484, index v245 -> i32
    v586 = call f29(i32 2, v585) -> i32
    v587 = array_set v584, index v245, value v586
    v588 = add v245, u32 1
    store v587 at v492
    v589 = add v245, u32 1
    jmp b37(v589)
  b39():
    v494 = load v492 -> [i32; 3]
    inc_rc v494
    call __debug_var_assign(Field 15, v494)
    inc_rc v494
    inc_rc v494
    v495 = allocate -> &mut u1
    store u1 1 at v495
    inc_rc v494
    jmp b42(u32 0)
  b42(v264: u32):
    v496 = lt v264, u32 3
    jmpif v496 then: b43, else: b44
  b43():
    v579 = array_get v494, index v264 -> i32
    v580 = load v495 -> u1
    v581 = call f31(v579) -> u1
    v582 = mul v580, v581
    store v582 at v495
    v583 = add v264, u32 1
    jmp b42(v583)
  b44():
    v497 = load v495 -> u1
    constrain v497 == u1 1
    v498 = allocate -> &mut u1
    store u1 1 at v498
    inc_rc v494
    jmp b48(u32 0)
  b48(v279: u32):
    v499 = lt v279, u32 3
    jmpif v499 then: b49, else: b50
  b49():
    v574 = array_get v494, index v279 -> i32
    v575 = load v498 -> u1
    v576 = call f33(i32 2, v574) -> u1
    v577 = mul v575, v576
    store v577 at v498
    v578 = add v279, u32 1
    jmp b48(v578)
  b50():
    v500 = load v498 -> u1
    constrain v500 == u1 1
    v501 = allocate -> &mut i32
    store i32 0 at v501
    inc_rc v494
    jmp b54(u32 0)
  b54(v294: u32):
    v502 = lt v294, u32 3
    jmpif v502 then: b55, else: b56
  b55():
    v570 = array_get v494, index v294 -> i32
    v571 = load v501 -> i32
    v572 = call f35(v571, v570) -> i32
    store v572 at v501
    v573 = add v294, u32 1
    jmp b54(v573)
  b56():
    v503 = load v501 -> i32
    v504 = eq v503, i32 12
    constrain v503 == i32 12
    v505 = allocate -> &mut i32
    store i32 0 at v505
    inc_rc v494
    jmp b61(u32 0)
  b61(v310: u32):
    v506 = lt v310, u32 3
    jmpif v506 then: b62, else: b63
  b62():
    v566 = array_get v494, index v310 -> i32
    v567 = load v505 -> i32
    v568 = call f37(i32 2, v567, v566) -> i32
    store v568 at v505
    v569 = add v310, u32 1
    jmp b61(v569)
  b63():
    v507 = load v505 -> i32
    v508 = eq v507, i32 18
    constrain v507 == i32 18
    v509 = array_get v494, index u32 0 -> i32
    v510 = allocate -> &mut i32
    store v509 at v510
    jmp b66(u32 1)
  b66(v326: u32):
    v511 = lt v326, u32 3
    jmpif v511 then: b67, else: b68
  b67():
    v562 = load v510 -> i32
    v563 = array_get v494, index v326 -> i32
    v564 = call f39(v562, v563) -> i32
    store v564 at v510
    v565 = add v326, u32 1
    jmp b66(v565)
  b68():
    v512 = load v510 -> i32
    v513 = eq v512, i32 12
    constrain v512 == i32 12
    v514 = array_get v494, index u32 0 -> i32
    v515 = allocate -> &mut i32
    store v514 at v515
    jmp b75(u32 1)
  b75(v343: u32):
    v516 = lt v343, u32 3
    jmpif v516 then: b76, else: b77
  b76():
    v558 = load v515 -> i32
    v559 = array_get v494, index v343 -> i32
    v560 = call f41(i32 2, v558, v559) -> i32
    store v560 at v515
    v561 = add v343, u32 1
    jmp b75(v561)
  b77():
    v517 = load v515 -> i32
    v518 = eq v517, i32 16
    constrain v517 == i32 16
    v519 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v519
    v520 = allocate -> &mut [i32; 3]
    store v519 at v520
    jmp b81(u32 0)
  b81(v360: u32):
    v521 = lt v360, u32 3
    jmpif v521 then: b82, else: b83
  b82():
    v552 = load v520 -> [i32; 3]
    v553 = array_get v494, index v360 -> i32
    v554 = div v553, i32 2
    v555 = array_set v552, index v360, value v554
    v556 = add v360, u32 1
    store v555 at v520
    v557 = add v360, u32 1
    jmp b81(v557)
  b83():
    v522 = load v520 -> [i32; 3]
    v523 = allocate -> &mut u1
    store u1 1 at v523
    jmp b84(u32 0)
  b84(v372: u32):
    v524 = lt v372, u32 3
    jmpif v524 then: b85, else: b86
  b85():
    v546 = load v523 -> u1
    v547 = array_get v522, index v372 -> i32
    v548 = array_get v484, index v372 -> i32
    v549 = eq v547, v548
    v550 = mul v546, v549
    store v550 at v523
    v551 = add v372, u32 1
    jmp b84(v551)
  b86():
    v525 = load v523 -> u1
    constrain v525 == u1 1
    v526 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v526
    v527 = allocate -> &mut [i32; 3]
    store v526 at v527
    jmp b87(u32 0)
  b87(v386: u32):
    v528 = lt v386, u32 3
    jmpif v528 then: b88, else: b89
  b88():
    v540 = load v527 -> [i32; 3]
    v541 = array_get v494, index v386 -> i32
    v542 = call f45(i32 2, v541) -> i32
    v543 = array_set v540, index v386, value v542
    v544 = add v386, u32 1
    store v543 at v527
    v545 = add v386, u32 1
    jmp b87(v545)
  b89():
    v529 = load v527 -> [i32; 3]
    v530 = allocate -> &mut u1
    store u1 1 at v530
    jmp b97(u32 0)
  b97(v403: u32):
    v531 = lt v403, u32 3
    jmpif v531 then: b98, else: b99
  b98():
    v534 = load v530 -> u1
    v535 = array_get v529, index v403 -> i32
    v536 = array_get v484, index v403 -> i32
    v537 = eq v535, v536
    v538 = mul v534, v537
    store v538 at v530
    v539 = add v403, u32 1
    jmp b97(v539)
  b99():
    v532 = load v530 -> u1
    constrain v532 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v533 = add v0, v483
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v533
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v10 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v10
    call __debug_fn_exit(u32 2)
    return v10
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v9 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v9
    call __debug_fn_exit(u32 3)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v3 = mul v0, Field 2
    return v3
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v3 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v17 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v17
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v3 = lt i32 2, v0
    return v3
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = lt v0, v1
    return v7
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v38 = allocate -> &mut i32
    v40 = mul v1, v0
    v41 = cast v40 as u64
    v42 = truncate v41 to 32 bits, max_bit_size: 64
    v43 = cast v1 as u32
    v44 = cast v0 as u32
    v45 = lt v43, u32 2147483648
    v46 = lt v44, u32 2147483648
    v47 = eq v45, v46
    v48 = not v45
    v49 = cast v1 as Field
    v50 = cast v45 as Field
    v51 = mul v50, v49
    v52 = sub Field 4294967296, v49
    v53 = cast v48 as Field
    v54 = mul v53, v52
    v55 = add v51, v54
    v56 = not v46
    v57 = cast v0 as Field
    v58 = cast v46 as Field
    v59 = mul v58, v57
    v60 = sub Field 4294967296, v57
    v61 = cast v56 as Field
    v62 = mul v61, v60
    v63 = add v59, v62
    v64 = mul v55, v63
    range_check v64 to 32 bits
    v65 = cast v64 as u32
    v66 = not v47
    v67 = cast v66 as u32
    v68 = add u32 2147483648, v67
    v69 = lt v65, v68
    constrain v69 == u1 1, "attempt to add with overflow"
    v70 = cast v42 as i32
    return v70
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v3 = lt i32 1, v0
    return v3
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v6 = allocate -> &mut i32
    v8 = lt v1, v0
    v9 = not v8
    return v9
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = div v1, v0
    return v7
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v3 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v5 = allocate -> &mut u32
    v7 = add v0, u32 2342
    return v7
}

After `static_assert` and `assert_constant`:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v453 = eq Field 4, Field 3
    jmpif v453 then: b3, else: b4
  b3():
    v455 = call f3() -> [u32; 2]
    jmp b5(v455)
  b4():
    constrain Field 4 == Field 4
    v454 = call f4() -> [u32; 2]
    jmp b5(v454)
  b5(v21: [u32; 2]):
    v456 = array_get v21, index u32 1 -> u32
    v457 = eq v456, u32 2
    constrain v456 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v458 = call f7(Field 5) -> Field
    v459 = call f7(v458) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v460 = eq v459, Field 20
    constrain v459 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v461 = call f10(Field 42) -> Field
    v462 = eq v461, Field 42
    constrain v461 == Field 42
    v463 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v466 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v470 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v473 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v476 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v478 = eq Field 51, Field 51
    jmpif v478 then: b13, else: b14
  b13():
    v480 = call f51(u32 32) -> u32
    jmp b15(v480)
  b14():
    constrain Field 51 == Field 52
    v479 = call f52(u32 32) -> u32
    jmp b15(v479)
  b15(v145: u32):
    v481 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v482 = call f16(Field 3) -> Field
    v483 = call f16(v482) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v483)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v484 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v484
    call __debug_var_assign(Field 14, v484)
    inc_rc v484
    inc_rc v484
    v485 = allocate -> &mut u1
    store u1 0 at v485
    inc_rc v484
    jmp b27(u32 0)
  b27(v214: u32):
    v486 = lt v214, u32 3
    jmpif v486 then: b28, else: b29
  b28():
    v595 = array_get v484, index v214 -> i32
    v596 = load v485 -> u1
    v597 = call f25(v595) -> u1
    v598 = or v596, v597
    store v598 at v485
    v599 = add v214, u32 1
    jmp b27(v599)
  b29():
    v487 = load v485 -> u1
    constrain v487 == u1 1
    v488 = allocate -> &mut u1
    store u1 0 at v488
    inc_rc v484
    jmp b32(u32 0)
  b32(v229: u32):
    v489 = lt v229, u32 3
    jmpif v489 then: b33, else: b34
  b33():
    v590 = array_get v484, index v229 -> i32
    v591 = load v488 -> u1
    v592 = call f27(i32 2, v590) -> u1
    v593 = or v591, v592
    store v593 at v488
    v594 = add v229, u32 1
    jmp b32(v594)
  b34():
    v490 = load v488 -> u1
    constrain v490 == u1 1
    v491 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v491
    v492 = allocate -> &mut [i32; 3]
    store v491 at v492
    jmp b37(u32 0)
  b37(v245: u32):
    v493 = lt v245, u32 3
    jmpif v493 then: b38, else: b39
  b38():
    v584 = load v492 -> [i32; 3]
    v585 = array_get v484, index v245 -> i32
    v586 = call f29(i32 2, v585) -> i32
    v587 = array_set v584, index v245, value v586
    v588 = add v245, u32 1
    store v587 at v492
    v589 = add v245, u32 1
    jmp b37(v589)
  b39():
    v494 = load v492 -> [i32; 3]
    inc_rc v494
    call __debug_var_assign(Field 15, v494)
    inc_rc v494
    inc_rc v494
    v495 = allocate -> &mut u1
    store u1 1 at v495
    inc_rc v494
    jmp b42(u32 0)
  b42(v264: u32):
    v496 = lt v264, u32 3
    jmpif v496 then: b43, else: b44
  b43():
    v579 = array_get v494, index v264 -> i32
    v580 = load v495 -> u1
    v581 = call f31(v579) -> u1
    v582 = mul v580, v581
    store v582 at v495
    v583 = add v264, u32 1
    jmp b42(v583)
  b44():
    v497 = load v495 -> u1
    constrain v497 == u1 1
    v498 = allocate -> &mut u1
    store u1 1 at v498
    inc_rc v494
    jmp b48(u32 0)
  b48(v279: u32):
    v499 = lt v279, u32 3
    jmpif v499 then: b49, else: b50
  b49():
    v574 = array_get v494, index v279 -> i32
    v575 = load v498 -> u1
    v576 = call f33(i32 2, v574) -> u1
    v577 = mul v575, v576
    store v577 at v498
    v578 = add v279, u32 1
    jmp b48(v578)
  b50():
    v500 = load v498 -> u1
    constrain v500 == u1 1
    v501 = allocate -> &mut i32
    store i32 0 at v501
    inc_rc v494
    jmp b54(u32 0)
  b54(v294: u32):
    v502 = lt v294, u32 3
    jmpif v502 then: b55, else: b56
  b55():
    v570 = array_get v494, index v294 -> i32
    v571 = load v501 -> i32
    v572 = call f35(v571, v570) -> i32
    store v572 at v501
    v573 = add v294, u32 1
    jmp b54(v573)
  b56():
    v503 = load v501 -> i32
    v504 = eq v503, i32 12
    constrain v503 == i32 12
    v505 = allocate -> &mut i32
    store i32 0 at v505
    inc_rc v494
    jmp b61(u32 0)
  b61(v310: u32):
    v506 = lt v310, u32 3
    jmpif v506 then: b62, else: b63
  b62():
    v566 = array_get v494, index v310 -> i32
    v567 = load v505 -> i32
    v568 = call f37(i32 2, v567, v566) -> i32
    store v568 at v505
    v569 = add v310, u32 1
    jmp b61(v569)
  b63():
    v507 = load v505 -> i32
    v508 = eq v507, i32 18
    constrain v507 == i32 18
    v509 = array_get v494, index u32 0 -> i32
    v510 = allocate -> &mut i32
    store v509 at v510
    jmp b66(u32 1)
  b66(v326: u32):
    v511 = lt v326, u32 3
    jmpif v511 then: b67, else: b68
  b67():
    v562 = load v510 -> i32
    v563 = array_get v494, index v326 -> i32
    v564 = call f39(v562, v563) -> i32
    store v564 at v510
    v565 = add v326, u32 1
    jmp b66(v565)
  b68():
    v512 = load v510 -> i32
    v513 = eq v512, i32 12
    constrain v512 == i32 12
    v514 = array_get v494, index u32 0 -> i32
    v515 = allocate -> &mut i32
    store v514 at v515
    jmp b75(u32 1)
  b75(v343: u32):
    v516 = lt v343, u32 3
    jmpif v516 then: b76, else: b77
  b76():
    v558 = load v515 -> i32
    v559 = array_get v494, index v343 -> i32
    v560 = call f41(i32 2, v558, v559) -> i32
    store v560 at v515
    v561 = add v343, u32 1
    jmp b75(v561)
  b77():
    v517 = load v515 -> i32
    v518 = eq v517, i32 16
    constrain v517 == i32 16
    v519 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v519
    v520 = allocate -> &mut [i32; 3]
    store v519 at v520
    jmp b81(u32 0)
  b81(v360: u32):
    v521 = lt v360, u32 3
    jmpif v521 then: b82, else: b83
  b82():
    v552 = load v520 -> [i32; 3]
    v553 = array_get v494, index v360 -> i32
    v554 = div v553, i32 2
    v555 = array_set v552, index v360, value v554
    v556 = add v360, u32 1
    store v555 at v520
    v557 = add v360, u32 1
    jmp b81(v557)
  b83():
    v522 = load v520 -> [i32; 3]
    v523 = allocate -> &mut u1
    store u1 1 at v523
    jmp b84(u32 0)
  b84(v372: u32):
    v524 = lt v372, u32 3
    jmpif v524 then: b85, else: b86
  b85():
    v546 = load v523 -> u1
    v547 = array_get v522, index v372 -> i32
    v548 = array_get v484, index v372 -> i32
    v549 = eq v547, v548
    v550 = mul v546, v549
    store v550 at v523
    v551 = add v372, u32 1
    jmp b84(v551)
  b86():
    v525 = load v523 -> u1
    constrain v525 == u1 1
    v526 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v526
    v527 = allocate -> &mut [i32; 3]
    store v526 at v527
    jmp b87(u32 0)
  b87(v386: u32):
    v528 = lt v386, u32 3
    jmpif v528 then: b88, else: b89
  b88():
    v540 = load v527 -> [i32; 3]
    v541 = array_get v494, index v386 -> i32
    v542 = call f45(i32 2, v541) -> i32
    v543 = array_set v540, index v386, value v542
    v544 = add v386, u32 1
    store v543 at v527
    v545 = add v386, u32 1
    jmp b87(v545)
  b89():
    v529 = load v527 -> [i32; 3]
    v530 = allocate -> &mut u1
    store u1 1 at v530
    jmp b97(u32 0)
  b97(v403: u32):
    v531 = lt v403, u32 3
    jmpif v531 then: b98, else: b99
  b98():
    v534 = load v530 -> u1
    v535 = array_get v529, index v403 -> i32
    v536 = array_get v484, index v403 -> i32
    v537 = eq v535, v536
    v538 = mul v534, v537
    store v538 at v530
    v539 = add v403, u32 1
    jmp b97(v539)
  b99():
    v532 = load v530 -> u1
    constrain v532 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v533 = add v0, v483
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v533
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v10 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v10
    call __debug_fn_exit(u32 2)
    return v10
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v9 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v9
    call __debug_fn_exit(u32 3)
    return v9
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v3 = mul v0, Field 2
    return v3
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v3 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v17 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v17
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v3 = lt i32 2, v0
    return v3
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = lt v0, v1
    return v7
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v38 = allocate -> &mut i32
    v40 = mul v1, v0
    v41 = cast v40 as u64
    v42 = truncate v41 to 32 bits, max_bit_size: 64
    v43 = cast v1 as u32
    v44 = cast v0 as u32
    v45 = lt v43, u32 2147483648
    v46 = lt v44, u32 2147483648
    v47 = eq v45, v46
    v48 = not v45
    v49 = cast v1 as Field
    v50 = cast v45 as Field
    v51 = mul v50, v49
    v52 = sub Field 4294967296, v49
    v53 = cast v48 as Field
    v54 = mul v53, v52
    v55 = add v51, v54
    v56 = not v46
    v57 = cast v0 as Field
    v58 = cast v46 as Field
    v59 = mul v58, v57
    v60 = sub Field 4294967296, v57
    v61 = cast v56 as Field
    v62 = mul v61, v60
    v63 = add v59, v62
    v64 = mul v55, v63
    range_check v64 to 32 bits
    v65 = cast v64 as u32
    v66 = not v47
    v67 = cast v66 as u32
    v68 = add u32 2147483648, v67
    v69 = lt v65, v68
    constrain v69 == u1 1, "attempt to add with overflow"
    v70 = cast v42 as i32
    return v70
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v3 = lt i32 1, v0
    return v3
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v6 = allocate -> &mut i32
    v8 = lt v1, v0
    v9 = not v8
    return v9
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v15 = add v0, v1
    v16 = truncate v15 to 32 bits, max_bit_size: 33
    v17 = cast v16 as u32
    v18 = cast v0 as u32
    v19 = cast v1 as u32
    v20 = lt v18, u32 2147483648
    v21 = lt v19, u32 2147483648
    v22 = eq v20, v21
    v23 = lt v17, u32 2147483648
    v24 = eq v23, v20
    v25 = mul v24, v22
    constrain v25 == v22, "attempt to add with overflow"
    return v16
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v29 = allocate -> &mut i32
    v30 = add v1, v2
    v31 = truncate v30 to 32 bits, max_bit_size: 33
    v32 = cast v31 as u32
    v33 = cast v1 as u32
    v34 = cast v2 as u32
    v35 = lt v33, u32 2147483648
    v36 = lt v34, u32 2147483648
    v37 = eq v35, v36
    v38 = lt v32, u32 2147483648
    v39 = eq v38, v35
    v40 = mul v39, v37
    constrain v40 == v37, "attempt to add with overflow"
    v42 = add v31, v0
    v43 = truncate v42 to 32 bits, max_bit_size: 33
    v44 = cast v43 as u32
    v45 = cast v31 as u32
    v46 = cast v0 as u32
    v47 = lt v45, u32 2147483648
    v48 = lt v46, u32 2147483648
    v49 = eq v47, v48
    v50 = lt v44, u32 2147483648
    v51 = eq v50, v47
    v52 = mul v51, v49
    constrain v52 == v49, "attempt to add with overflow"
    return v43
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v5 = allocate -> &mut i32
    v7 = div v1, v0
    return v7
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v3 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v5 = allocate -> &mut u32
    v7 = add v0, u32 2342
    return v7
}

After Loop Invariant Code Motion:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    jmpif u1 0 then: b3, else: b4
  b3():
    v681 = call f3() -> [u32; 2]
    jmp b5(v681)
  b4():
    v682 = call f4() -> [u32; 2]
    jmp b5(v682)
  b5(v21: [u32; 2]):
    v683 = array_get v21, index u32 1 -> u32
    v684 = eq v683, u32 2
    constrain v683 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v685 = call f7(Field 5) -> Field
    v686 = call f7(v685) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v687 = eq v686, Field 20
    constrain v686 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v688 = call f10(Field 42) -> Field
    v689 = eq v688, Field 42
    constrain v688 == Field 42
    v690 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v691 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v692 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v693 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v694 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    jmpif u1 1 then: b13, else: b14
  b13():
    v695 = call f51(u32 32) -> u32
    jmp b15(v695)
  b14():
    constrain Field 51 == Field 52
    v696 = call f52(u32 32) -> u32
    jmp b15(v696)
  b15(v145: u32):
    v697 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v698 = call f16(Field 3) -> Field
    v699 = call f16(v698) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v699)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v700 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v700
    call __debug_var_assign(Field 14, v700)
    inc_rc v700
    inc_rc v700
    v701 = allocate -> &mut u1
    store u1 0 at v701
    inc_rc v700
    jmp b27(u32 0)
  b27(v214: u32):
    v702 = lt v214, u32 3
    jmpif v702 then: b28, else: b29
  b28():
    v703 = array_get v700, index v214 -> i32
    v704 = load v701 -> u1
    v705 = call f25(v703) -> u1
    v706 = or v704, v705
    store v706 at v701
    v707 = add v214, u32 1
    jmp b27(v707)
  b29():
    v708 = load v701 -> u1
    constrain v708 == u1 1
    v709 = allocate -> &mut u1
    store u1 0 at v709
    inc_rc v700
    jmp b32(u32 0)
  b32(v229: u32):
    v710 = lt v229, u32 3
    jmpif v710 then: b33, else: b34
  b33():
    v711 = array_get v700, index v229 -> i32
    v712 = load v709 -> u1
    v713 = call f27(i32 2, v711) -> u1
    v714 = or v712, v713
    store v714 at v709
    v715 = add v229, u32 1
    jmp b32(v715)
  b34():
    v716 = load v709 -> u1
    constrain v716 == u1 1
    v717 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v717
    v718 = allocate -> &mut [i32; 3]
    store v717 at v718
    jmp b37(u32 0)
  b37(v245: u32):
    v719 = lt v245, u32 3
    jmpif v719 then: b38, else: b39
  b38():
    v720 = load v718 -> [i32; 3]
    v721 = array_get v700, index v245 -> i32
    v722 = call f29(i32 2, v721) -> i32
    v723 = array_set v720, index v245, value v722
    v724 = add v245, u32 1
    store v723 at v718
    v725 = add v245, u32 1
    jmp b37(v725)
  b39():
    v726 = load v718 -> [i32; 3]
    inc_rc v726
    call __debug_var_assign(Field 15, v726)
    inc_rc v726
    inc_rc v726
    v727 = allocate -> &mut u1
    store u1 1 at v727
    inc_rc v726
    jmp b42(u32 0)
  b42(v264: u32):
    v728 = lt v264, u32 3
    jmpif v728 then: b43, else: b44
  b43():
    v729 = array_get v726, index v264 -> i32
    v730 = load v727 -> u1
    v731 = call f31(v729) -> u1
    v732 = mul v730, v731
    store v732 at v727
    v733 = add v264, u32 1
    jmp b42(v733)
  b44():
    v734 = load v727 -> u1
    constrain v734 == u1 1
    v735 = allocate -> &mut u1
    store u1 1 at v735
    inc_rc v726
    jmp b48(u32 0)
  b48(v279: u32):
    v736 = lt v279, u32 3
    jmpif v736 then: b49, else: b50
  b49():
    v737 = array_get v726, index v279 -> i32
    v738 = load v735 -> u1
    v739 = call f33(i32 2, v737) -> u1
    v740 = mul v738, v739
    store v740 at v735
    v741 = add v279, u32 1
    jmp b48(v741)
  b50():
    v742 = load v735 -> u1
    constrain v742 == u1 1
    v743 = allocate -> &mut i32
    store i32 0 at v743
    inc_rc v726
    jmp b54(u32 0)
  b54(v294: u32):
    v744 = lt v294, u32 3
    jmpif v744 then: b55, else: b56
  b55():
    v745 = array_get v726, index v294 -> i32
    v746 = load v743 -> i32
    v747 = call f35(v746, v745) -> i32
    store v747 at v743
    v748 = add v294, u32 1
    jmp b54(v748)
  b56():
    v749 = load v743 -> i32
    v750 = eq v749, i32 12
    constrain v749 == i32 12
    v751 = allocate -> &mut i32
    store i32 0 at v751
    inc_rc v726
    jmp b61(u32 0)
  b61(v310: u32):
    v752 = lt v310, u32 3
    jmpif v752 then: b62, else: b63
  b62():
    v753 = array_get v726, index v310 -> i32
    v754 = load v751 -> i32
    v755 = call f37(i32 2, v754, v753) -> i32
    store v755 at v751
    v756 = add v310, u32 1
    jmp b61(v756)
  b63():
    v757 = load v751 -> i32
    v758 = eq v757, i32 18
    constrain v757 == i32 18
    v759 = array_get v726, index u32 0 -> i32
    v760 = allocate -> &mut i32
    store v759 at v760
    jmp b66(u32 1)
  b66(v326: u32):
    v761 = lt v326, u32 3
    jmpif v761 then: b67, else: b68
  b67():
    v762 = load v760 -> i32
    v763 = array_get v726, index v326 -> i32
    v764 = call f39(v762, v763) -> i32
    store v764 at v760
    v765 = add v326, u32 1
    jmp b66(v765)
  b68():
    v766 = load v760 -> i32
    v767 = eq v766, i32 12
    constrain v766 == i32 12
    v768 = array_get v726, index u32 0 -> i32
    v769 = allocate -> &mut i32
    store v768 at v769
    jmp b75(u32 1)
  b75(v343: u32):
    v770 = lt v343, u32 3
    jmpif v770 then: b76, else: b77
  b76():
    v771 = load v769 -> i32
    v772 = array_get v726, index v343 -> i32
    v773 = call f41(i32 2, v771, v772) -> i32
    store v773 at v769
    v774 = add v343, u32 1
    jmp b75(v774)
  b77():
    v775 = load v769 -> i32
    v776 = eq v775, i32 16
    constrain v775 == i32 16
    v777 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v777
    v778 = allocate -> &mut [i32; 3]
    store v777 at v778
    jmp b81(u32 0)
  b81(v360: u32):
    v779 = lt v360, u32 3
    jmpif v779 then: b82, else: b83
  b82():
    v780 = load v778 -> [i32; 3]
    v781 = array_get v726, index v360 -> i32
    v782 = div v781, i32 2
    v783 = array_set v780, index v360, value v782
    v784 = add v360, u32 1
    store v783 at v778
    v785 = add v360, u32 1
    jmp b81(v785)
  b83():
    v786 = load v778 -> [i32; 3]
    v787 = allocate -> &mut u1
    store u1 1 at v787
    jmp b84(u32 0)
  b84(v372: u32):
    v788 = lt v372, u32 3
    jmpif v788 then: b85, else: b86
  b85():
    v789 = load v787 -> u1
    v790 = array_get v786, index v372 -> i32
    v791 = array_get v700, index v372 -> i32
    v792 = eq v790, v791
    v793 = mul v789, v792
    store v793 at v787
    v794 = add v372, u32 1
    jmp b84(v794)
  b86():
    v795 = load v787 -> u1
    constrain v795 == u1 1
    v796 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v796
    v797 = allocate -> &mut [i32; 3]
    store v796 at v797
    jmp b87(u32 0)
  b87(v386: u32):
    v798 = lt v386, u32 3
    jmpif v798 then: b88, else: b89
  b88():
    v799 = load v797 -> [i32; 3]
    v800 = array_get v726, index v386 -> i32
    v801 = call f45(i32 2, v800) -> i32
    v802 = array_set v799, index v386, value v801
    v803 = add v386, u32 1
    store v802 at v797
    v804 = add v386, u32 1
    jmp b87(v804)
  b89():
    v805 = load v797 -> [i32; 3]
    v806 = allocate -> &mut u1
    store u1 1 at v806
    jmp b97(u32 0)
  b97(v403: u32):
    v807 = lt v403, u32 3
    jmpif v807 then: b98, else: b99
  b98():
    v808 = load v806 -> u1
    v809 = array_get v805, index v403 -> i32
    v810 = array_get v700, index v403 -> i32
    v811 = eq v809, v810
    v812 = mul v808, v811
    store v812 at v806
    v813 = add v403, u32 1
    jmp b97(v813)
  b99():
    v814 = load v806 -> u1
    constrain v814 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v815 = add v0, v699
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v815
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v13 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 2)
    return v13
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    return v12
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v6 = mul v0, Field 2
    return v6
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v7 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v20 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v20
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v6 = lt i32 2, v0
    return v6
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = lt v0, v1
    return v11
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v73 = allocate -> &mut i32
    v74 = mul v1, v0
    v75 = cast v74 as u64
    v76 = truncate v75 to 32 bits, max_bit_size: 64
    v77 = cast v1 as u32
    v78 = cast v0 as u32
    v79 = lt v77, u32 2147483648
    v80 = lt v78, u32 2147483648
    v81 = eq v79, v80
    v82 = not v79
    v83 = cast v1 as Field
    v84 = cast v79 as Field
    v85 = mul v84, v83
    v86 = sub Field 4294967296, v83
    v87 = cast v82 as Field
    v88 = mul v87, v86
    v89 = add v85, v88
    v90 = not v80
    v91 = cast v0 as Field
    v92 = cast v80 as Field
    v93 = mul v92, v91
    v94 = sub Field 4294967296, v91
    v95 = cast v90 as Field
    v96 = mul v95, v94
    v97 = add v93, v96
    v98 = mul v89, v97
    range_check v98 to 32 bits
    v99 = cast v98 as u32
    v100 = not v81
    v101 = cast v100 as u32
    v102 = add u32 2147483648, v101
    v103 = lt v99, v102
    constrain v103 == u1 1, "attempt to add with overflow"
    v104 = cast v76 as i32
    return v104
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v6 = lt i32 1, v0
    return v6
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v1, v0
    v14 = not v13
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = div v1, v0
    return v11
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v7 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v10 = allocate -> &mut u32
    v11 = add v0, u32 2342
    return v11
}

After Unrolling:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    jmpif u1 0 then: b3, else: b4
  b3():
    v681 = call f3() -> [u32; 2]
    jmp b5(v681)
  b4():
    v682 = call f4() -> [u32; 2]
    jmp b5(v682)
  b5(v21: [u32; 2]):
    v683 = array_get v21, index u32 1 -> u32
    v684 = eq v683, u32 2
    constrain v683 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v685 = call f7(Field 5) -> Field
    v686 = call f7(v685) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v687 = eq v686, Field 20
    constrain v686 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v688 = call f10(Field 42) -> Field
    v689 = eq v688, Field 42
    constrain v688 == Field 42
    v690 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v691 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v692 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v693 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v694 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    jmpif u1 1 then: b13, else: b14
  b13():
    v695 = call f51(u32 32) -> u32
    jmp b15(v695)
  b14():
    constrain Field 51 == Field 52
    v696 = call f52(u32 32) -> u32
    jmp b15(v696)
  b15(v145: u32):
    v697 = eq v145, u32 32
    constrain v145 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v698 = call f16(Field 3) -> Field
    v699 = call f16(v698) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v699)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v700 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v700
    call __debug_var_assign(Field 14, v700)
    inc_rc v700
    inc_rc v700
    v701 = allocate -> &mut u1
    store u1 0 at v701
    inc_rc v700
    v940 = load v701 -> u1
    v941 = call f25(i32 1) -> u1
    v942 = or v940, v941
    store v942 at v701
    v944 = load v701 -> u1
    v945 = call f25(i32 2) -> u1
    v946 = or v944, v945
    store v946 at v701
    v948 = load v701 -> u1
    v949 = call f25(i32 3) -> u1
    v950 = or v948, v949
    store v950 at v701
    jmp b29()
  b29():
    v708 = load v701 -> u1
    constrain v708 == u1 1
    v709 = allocate -> &mut u1
    store u1 0 at v709
    inc_rc v700
    v928 = load v709 -> u1
    v929 = call f27(i32 2, i32 1) -> u1
    v930 = or v928, v929
    store v930 at v709
    v932 = load v709 -> u1
    v933 = call f27(i32 2, i32 2) -> u1
    v934 = or v932, v933
    store v934 at v709
    v936 = load v709 -> u1
    v937 = call f27(i32 2, i32 3) -> u1
    v938 = or v936, v937
    store v938 at v709
    jmp b34()
  b34():
    v716 = load v709 -> u1
    constrain v716 == u1 1
    v717 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v717
    v718 = allocate -> &mut [i32; 3]
    store v717 at v718
    v916 = load v718 -> [i32; 3]
    v917 = call f29(i32 2, i32 1) -> i32
    v918 = array_set v916, index u32 0, value v917
    store v918 at v718
    v920 = load v718 -> [i32; 3]
    v921 = call f29(i32 2, i32 2) -> i32
    v922 = array_set v920, index u32 1, value v921
    store v922 at v718
    v924 = load v718 -> [i32; 3]
    v925 = call f29(i32 2, i32 3) -> i32
    v926 = array_set v924, index u32 2, value v925
    store v926 at v718
    jmp b39()
  b39():
    v726 = load v718 -> [i32; 3]
    inc_rc v726
    call __debug_var_assign(Field 15, v726)
    inc_rc v726
    inc_rc v726
    v727 = allocate -> &mut u1
    store u1 1 at v727
    inc_rc v726
    v901 = array_get v726, index u32 0 -> i32
    v902 = load v727 -> u1
    v903 = call f31(v901) -> u1
    v904 = mul v902, v903
    store v904 at v727
    v906 = array_get v726, index u32 1 -> i32
    v907 = load v727 -> u1
    v908 = call f31(v906) -> u1
    v909 = mul v907, v908
    store v909 at v727
    v911 = array_get v726, index u32 2 -> i32
    v912 = load v727 -> u1
    v913 = call f31(v911) -> u1
    v914 = mul v912, v913
    store v914 at v727
    jmp b44()
  b44():
    v734 = load v727 -> u1
    constrain v734 == u1 1
    v735 = allocate -> &mut u1
    store u1 1 at v735
    inc_rc v726
    v886 = array_get v726, index u32 0 -> i32
    v887 = load v735 -> u1
    v888 = call f33(i32 2, v886) -> u1
    v889 = mul v887, v888
    store v889 at v735
    v891 = array_get v726, index u32 1 -> i32
    v892 = load v735 -> u1
    v893 = call f33(i32 2, v891) -> u1
    v894 = mul v892, v893
    store v894 at v735
    v896 = array_get v726, index u32 2 -> i32
    v897 = load v735 -> u1
    v898 = call f33(i32 2, v896) -> u1
    v899 = mul v897, v898
    store v899 at v735
    jmp b50()
  b50():
    v742 = load v735 -> u1
    constrain v742 == u1 1
    v743 = allocate -> &mut i32
    store i32 0 at v743
    inc_rc v726
    v874 = array_get v726, index u32 0 -> i32
    v875 = load v743 -> i32
    v876 = call f35(v875, v874) -> i32
    store v876 at v743
    v878 = array_get v726, index u32 1 -> i32
    v879 = load v743 -> i32
    v880 = call f35(v879, v878) -> i32
    store v880 at v743
    v882 = array_get v726, index u32 2 -> i32
    v883 = load v743 -> i32
    v884 = call f35(v883, v882) -> i32
    store v884 at v743
    jmp b56()
  b56():
    v749 = load v743 -> i32
    v750 = eq v749, i32 12
    constrain v749 == i32 12
    v751 = allocate -> &mut i32
    store i32 0 at v751
    inc_rc v726
    v862 = array_get v726, index u32 0 -> i32
    v863 = load v751 -> i32
    v864 = call f37(i32 2, v863, v862) -> i32
    store v864 at v751
    v866 = array_get v726, index u32 1 -> i32
    v867 = load v751 -> i32
    v868 = call f37(i32 2, v867, v866) -> i32
    store v868 at v751
    v870 = array_get v726, index u32 2 -> i32
    v871 = load v751 -> i32
    v872 = call f37(i32 2, v871, v870) -> i32
    store v872 at v751
    jmp b63()
  b63():
    v757 = load v751 -> i32
    v758 = eq v757, i32 18
    constrain v757 == i32 18
    v759 = array_get v726, index u32 0 -> i32
    v760 = allocate -> &mut i32
    store v759 at v760
    v854 = load v760 -> i32
    v855 = array_get v726, index u32 1 -> i32
    v856 = call f39(v854, v855) -> i32
    store v856 at v760
    v858 = load v760 -> i32
    v859 = array_get v726, index u32 2 -> i32
    v860 = call f39(v858, v859) -> i32
    store v860 at v760
    jmp b68()
  b68():
    v766 = load v760 -> i32
    v767 = eq v766, i32 12
    constrain v766 == i32 12
    v768 = array_get v726, index u32 0 -> i32
    v769 = allocate -> &mut i32
    store v768 at v769
    v846 = load v769 -> i32
    v847 = array_get v726, index u32 1 -> i32
    v848 = call f41(i32 2, v846, v847) -> i32
    store v848 at v769
    v850 = load v769 -> i32
    v851 = array_get v726, index u32 2 -> i32
    v852 = call f41(i32 2, v850, v851) -> i32
    store v852 at v769
    jmp b77()
  b77():
    v775 = load v769 -> i32
    v776 = eq v775, i32 16
    constrain v775 == i32 16
    v777 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v777
    v778 = allocate -> &mut [i32; 3]
    store v777 at v778
    v831 = load v778 -> [i32; 3]
    v832 = array_get v726, index u32 0 -> i32
    v833 = div v832, i32 2
    v834 = array_set v831, index u32 0, value v833
    store v834 at v778
    v836 = load v778 -> [i32; 3]
    v837 = array_get v726, index u32 1 -> i32
    v838 = div v837, i32 2
    v839 = array_set v836, index u32 1, value v838
    store v839 at v778
    v841 = load v778 -> [i32; 3]
    v842 = array_get v726, index u32 2 -> i32
    v843 = div v842, i32 2
    v844 = array_set v841, index u32 2, value v843
    store v844 at v778
    jmp b83()
  b83():
    v786 = load v778 -> [i32; 3]
    v787 = allocate -> &mut u1
    store u1 1 at v787
    jmp b84(u32 0)
  b84(v372: u32):
    v788 = lt v372, u32 3
    jmpif v788 then: b85, else: b86
  b85():
    v789 = load v787 -> u1
    v790 = array_get v786, index v372 -> i32
    v791 = array_get v700, index v372 -> i32
    v792 = eq v790, v791
    v793 = mul v789, v792
    store v793 at v787
    v794 = add v372, u32 1
    jmp b84(v794)
  b86():
    v795 = load v787 -> u1
    constrain v795 == u1 1
    v796 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v796
    v797 = allocate -> &mut [i32; 3]
    store v796 at v797
    v816 = load v797 -> [i32; 3]
    v817 = array_get v726, index u32 0 -> i32
    v818 = call f45(i32 2, v817) -> i32
    v819 = array_set v816, index u32 0, value v818
    store v819 at v797
    v821 = load v797 -> [i32; 3]
    v822 = array_get v726, index u32 1 -> i32
    v823 = call f45(i32 2, v822) -> i32
    v824 = array_set v821, index u32 1, value v823
    store v824 at v797
    v826 = load v797 -> [i32; 3]
    v827 = array_get v726, index u32 2 -> i32
    v828 = call f45(i32 2, v827) -> i32
    v829 = array_set v826, index u32 2, value v828
    store v829 at v797
    jmp b89()
  b89():
    v805 = load v797 -> [i32; 3]
    v806 = allocate -> &mut u1
    store u1 1 at v806
    jmp b97(u32 0)
  b97(v403: u32):
    v807 = lt v403, u32 3
    jmpif v807 then: b98, else: b99
  b98():
    v808 = load v806 -> u1
    v809 = array_get v805, index v403 -> i32
    v810 = array_get v700, index v403 -> i32
    v811 = eq v809, v810
    v812 = mul v808, v811
    store v812 at v806
    v813 = add v403, u32 1
    jmp b97(v813)
  b99():
    v814 = load v806 -> u1
    constrain v814 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v815 = add v0, v699
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v815
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v13 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 2)
    return v13
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    return v12
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v6 = mul v0, Field 2
    return v6
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v7 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v20 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v20
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v6 = lt i32 2, v0
    return v6
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = lt v0, v1
    return v11
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v73 = allocate -> &mut i32
    v74 = mul v1, v0
    v75 = cast v74 as u64
    v76 = truncate v75 to 32 bits, max_bit_size: 64
    v77 = cast v1 as u32
    v78 = cast v0 as u32
    v79 = lt v77, u32 2147483648
    v80 = lt v78, u32 2147483648
    v81 = eq v79, v80
    v82 = not v79
    v83 = cast v1 as Field
    v84 = cast v79 as Field
    v85 = mul v84, v83
    v86 = sub Field 4294967296, v83
    v87 = cast v82 as Field
    v88 = mul v87, v86
    v89 = add v85, v88
    v90 = not v80
    v91 = cast v0 as Field
    v92 = cast v80 as Field
    v93 = mul v92, v91
    v94 = sub Field 4294967296, v91
    v95 = cast v90 as Field
    v96 = mul v95, v94
    v97 = add v93, v96
    v98 = mul v89, v97
    range_check v98 to 32 bits
    v99 = cast v98 as u32
    v100 = not v81
    v101 = cast v100 as u32
    v102 = add u32 2147483648, v101
    v103 = lt v99, v102
    constrain v103 == u1 1, "attempt to add with overflow"
    v104 = cast v76 as i32
    return v104
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v6 = lt i32 1, v0
    return v6
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v1, v0
    v14 = not v13
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = div v1, v0
    return v11
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v7 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v10 = allocate -> &mut u32
    v11 = add v0, u32 2342
    return v11
}

After Simplifying (2nd):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v682 = call f4() -> [u32; 2]
    v683 = array_get v682, index u32 1 -> u32
    v684 = eq v683, u32 2
    constrain v683 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v685 = call f7(Field 5) -> Field
    v686 = call f7(v685) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v687 = eq v686, Field 20
    constrain v686 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v688 = call f10(Field 42) -> Field
    v689 = eq v688, Field 42
    constrain v688 == Field 42
    v690 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v691 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v692 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v693 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v694 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v695 = call f51(u32 32) -> u32
    v697 = eq v695, u32 32
    constrain v695 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v698 = call f16(Field 3) -> Field
    v699 = call f16(v698) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v699)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v700 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v700
    call __debug_var_assign(Field 14, v700)
    inc_rc v700
    inc_rc v700
    v701 = allocate -> &mut u1
    store u1 0 at v701
    inc_rc v700
    v940 = load v701 -> u1
    v941 = call f25(i32 1) -> u1
    v942 = or v940, v941
    store v942 at v701
    v944 = load v701 -> u1
    v945 = call f25(i32 2) -> u1
    v946 = or v944, v945
    store v946 at v701
    v948 = load v701 -> u1
    v949 = call f25(i32 3) -> u1
    v950 = or v948, v949
    store v950 at v701
    v708 = load v701 -> u1
    constrain v708 == u1 1
    v709 = allocate -> &mut u1
    store u1 0 at v709
    inc_rc v700
    v928 = load v709 -> u1
    v929 = call f27(i32 2, i32 1) -> u1
    v930 = or v928, v929
    store v930 at v709
    v932 = load v709 -> u1
    v933 = call f27(i32 2, i32 2) -> u1
    v934 = or v932, v933
    store v934 at v709
    v936 = load v709 -> u1
    v937 = call f27(i32 2, i32 3) -> u1
    v938 = or v936, v937
    store v938 at v709
    v716 = load v709 -> u1
    constrain v716 == u1 1
    v717 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v717
    v718 = allocate -> &mut [i32; 3]
    store v717 at v718
    v916 = load v718 -> [i32; 3]
    v917 = call f29(i32 2, i32 1) -> i32
    v918 = array_set v916, index u32 0, value v917
    store v918 at v718
    v920 = load v718 -> [i32; 3]
    v921 = call f29(i32 2, i32 2) -> i32
    v922 = array_set v920, index u32 1, value v921
    store v922 at v718
    v924 = load v718 -> [i32; 3]
    v925 = call f29(i32 2, i32 3) -> i32
    v926 = array_set v924, index u32 2, value v925
    store v926 at v718
    v726 = load v718 -> [i32; 3]
    inc_rc v726
    call __debug_var_assign(Field 15, v726)
    inc_rc v726
    inc_rc v726
    v727 = allocate -> &mut u1
    store u1 1 at v727
    inc_rc v726
    v901 = array_get v726, index u32 0 -> i32
    v902 = load v727 -> u1
    v903 = call f31(v901) -> u1
    v904 = mul v902, v903
    store v904 at v727
    v906 = array_get v726, index u32 1 -> i32
    v907 = load v727 -> u1
    v908 = call f31(v906) -> u1
    v909 = mul v907, v908
    store v909 at v727
    v911 = array_get v726, index u32 2 -> i32
    v912 = load v727 -> u1
    v913 = call f31(v911) -> u1
    v914 = mul v912, v913
    store v914 at v727
    v734 = load v727 -> u1
    constrain v734 == u1 1
    v735 = allocate -> &mut u1
    store u1 1 at v735
    inc_rc v726
    v886 = array_get v726, index u32 0 -> i32
    v887 = load v735 -> u1
    v888 = call f33(i32 2, v886) -> u1
    v889 = mul v887, v888
    store v889 at v735
    v891 = array_get v726, index u32 1 -> i32
    v892 = load v735 -> u1
    v893 = call f33(i32 2, v891) -> u1
    v894 = mul v892, v893
    store v894 at v735
    v896 = array_get v726, index u32 2 -> i32
    v897 = load v735 -> u1
    v898 = call f33(i32 2, v896) -> u1
    v899 = mul v897, v898
    store v899 at v735
    v742 = load v735 -> u1
    constrain v742 == u1 1
    v743 = allocate -> &mut i32
    store i32 0 at v743
    inc_rc v726
    v874 = array_get v726, index u32 0 -> i32
    v875 = load v743 -> i32
    v876 = call f35(v875, v874) -> i32
    store v876 at v743
    v878 = array_get v726, index u32 1 -> i32
    v879 = load v743 -> i32
    v880 = call f35(v879, v878) -> i32
    store v880 at v743
    v882 = array_get v726, index u32 2 -> i32
    v883 = load v743 -> i32
    v884 = call f35(v883, v882) -> i32
    store v884 at v743
    v749 = load v743 -> i32
    v750 = eq v749, i32 12
    constrain v749 == i32 12
    v751 = allocate -> &mut i32
    store i32 0 at v751
    inc_rc v726
    v862 = array_get v726, index u32 0 -> i32
    v863 = load v751 -> i32
    v864 = call f37(i32 2, v863, v862) -> i32
    store v864 at v751
    v866 = array_get v726, index u32 1 -> i32
    v867 = load v751 -> i32
    v868 = call f37(i32 2, v867, v866) -> i32
    store v868 at v751
    v870 = array_get v726, index u32 2 -> i32
    v871 = load v751 -> i32
    v872 = call f37(i32 2, v871, v870) -> i32
    store v872 at v751
    v757 = load v751 -> i32
    v758 = eq v757, i32 18
    constrain v757 == i32 18
    v759 = array_get v726, index u32 0 -> i32
    v760 = allocate -> &mut i32
    store v759 at v760
    v854 = load v760 -> i32
    v855 = array_get v726, index u32 1 -> i32
    v856 = call f39(v854, v855) -> i32
    store v856 at v760
    v858 = load v760 -> i32
    v859 = array_get v726, index u32 2 -> i32
    v860 = call f39(v858, v859) -> i32
    store v860 at v760
    v766 = load v760 -> i32
    v767 = eq v766, i32 12
    constrain v766 == i32 12
    v768 = array_get v726, index u32 0 -> i32
    v769 = allocate -> &mut i32
    store v768 at v769
    v846 = load v769 -> i32
    v847 = array_get v726, index u32 1 -> i32
    v848 = call f41(i32 2, v846, v847) -> i32
    store v848 at v769
    v850 = load v769 -> i32
    v851 = array_get v726, index u32 2 -> i32
    v852 = call f41(i32 2, v850, v851) -> i32
    store v852 at v769
    v775 = load v769 -> i32
    v776 = eq v775, i32 16
    constrain v775 == i32 16
    v777 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v777
    v778 = allocate -> &mut [i32; 3]
    store v777 at v778
    v831 = load v778 -> [i32; 3]
    v832 = array_get v726, index u32 0 -> i32
    v833 = div v832, i32 2
    v834 = array_set v831, index u32 0, value v833
    store v834 at v778
    v836 = load v778 -> [i32; 3]
    v837 = array_get v726, index u32 1 -> i32
    v838 = div v837, i32 2
    v839 = array_set v836, index u32 1, value v838
    store v839 at v778
    v841 = load v778 -> [i32; 3]
    v842 = array_get v726, index u32 2 -> i32
    v843 = div v842, i32 2
    v844 = array_set v841, index u32 2, value v843
    store v844 at v778
    v786 = load v778 -> [i32; 3]
    v787 = allocate -> &mut u1
    store u1 1 at v787
    jmp b84(u32 0)
  b84(v372: u32):
    v788 = lt v372, u32 3
    jmpif v788 then: b85, else: b86
  b85():
    v789 = load v787 -> u1
    v790 = array_get v786, index v372 -> i32
    v791 = array_get v700, index v372 -> i32
    v792 = eq v790, v791
    v793 = mul v789, v792
    store v793 at v787
    v794 = add v372, u32 1
    jmp b84(v794)
  b86():
    v795 = load v787 -> u1
    constrain v795 == u1 1
    v796 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v796
    v797 = allocate -> &mut [i32; 3]
    store v796 at v797
    v816 = load v797 -> [i32; 3]
    v817 = array_get v726, index u32 0 -> i32
    v818 = call f45(i32 2, v817) -> i32
    v819 = array_set v816, index u32 0, value v818
    store v819 at v797
    v821 = load v797 -> [i32; 3]
    v822 = array_get v726, index u32 1 -> i32
    v823 = call f45(i32 2, v822) -> i32
    v824 = array_set v821, index u32 1, value v823
    store v824 at v797
    v826 = load v797 -> [i32; 3]
    v827 = array_get v726, index u32 2 -> i32
    v828 = call f45(i32 2, v827) -> i32
    v829 = array_set v826, index u32 2, value v828
    store v829 at v797
    v805 = load v797 -> [i32; 3]
    v806 = allocate -> &mut u1
    store u1 1 at v806
    jmp b97(u32 0)
  b97(v403: u32):
    v807 = lt v403, u32 3
    jmpif v807 then: b98, else: b99
  b98():
    v808 = load v806 -> u1
    v809 = array_get v805, index v403 -> i32
    v810 = array_get v700, index v403 -> i32
    v811 = eq v809, v810
    v812 = mul v808, v811
    store v812 at v806
    v813 = add v403, u32 1
    jmp b97(v813)
  b99():
    v814 = load v806 -> u1
    constrain v814 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v815 = add v0, v699
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v815
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v13 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 2)
    return v13
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    return v12
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v6 = mul v0, Field 2
    return v6
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v7 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v20 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v20
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v6 = lt i32 2, v0
    return v6
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = lt v0, v1
    return v11
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v73 = allocate -> &mut i32
    v74 = mul v1, v0
    v75 = cast v74 as u64
    v76 = truncate v75 to 32 bits, max_bit_size: 64
    v77 = cast v1 as u32
    v78 = cast v0 as u32
    v79 = lt v77, u32 2147483648
    v80 = lt v78, u32 2147483648
    v81 = eq v79, v80
    v82 = not v79
    v83 = cast v1 as Field
    v84 = cast v79 as Field
    v85 = mul v84, v83
    v86 = sub Field 4294967296, v83
    v87 = cast v82 as Field
    v88 = mul v87, v86
    v89 = add v85, v88
    v90 = not v80
    v91 = cast v0 as Field
    v92 = cast v80 as Field
    v93 = mul v92, v91
    v94 = sub Field 4294967296, v91
    v95 = cast v90 as Field
    v96 = mul v95, v94
    v97 = add v93, v96
    v98 = mul v89, v97
    range_check v98 to 32 bits
    v99 = cast v98 as u32
    v100 = not v81
    v101 = cast v100 as u32
    v102 = add u32 2147483648, v101
    v103 = lt v99, v102
    constrain v103 == u1 1, "attempt to add with overflow"
    v104 = cast v76 as i32
    return v104
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v6 = lt i32 1, v0
    return v6
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v1, v0
    v14 = not v13
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = div v1, v0
    return v11
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v7 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v10 = allocate -> &mut u32
    v11 = add v0, u32 2342
    return v11
}

After Flattening:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v682 = call f4() -> [u32; 2]
    v683 = array_get v682, index u32 1 -> u32
    v684 = eq v683, u32 2
    constrain v683 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v685 = call f7(Field 5) -> Field
    v686 = call f7(v685) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v687 = eq v686, Field 20
    constrain v686 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v688 = call f10(Field 42) -> Field
    v689 = eq v688, Field 42
    constrain v688 == Field 42
    v690 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v691 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v692 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v693 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v694 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v695 = call f51(u32 32) -> u32
    v697 = eq v695, u32 32
    constrain v695 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v698 = call f16(Field 3) -> Field
    v699 = call f16(v698) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v699)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v700 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v700
    call __debug_var_assign(Field 14, v700)
    inc_rc v700
    inc_rc v700
    v701 = allocate -> &mut u1
    store u1 0 at v701
    inc_rc v700
    v940 = load v701 -> u1
    v941 = call f25(i32 1) -> u1
    v942 = or v940, v941
    store v942 at v701
    v944 = load v701 -> u1
    v945 = call f25(i32 2) -> u1
    v946 = or v944, v945
    store v946 at v701
    v948 = load v701 -> u1
    v949 = call f25(i32 3) -> u1
    v950 = or v948, v949
    store v950 at v701
    v708 = load v701 -> u1
    constrain v708 == u1 1
    v709 = allocate -> &mut u1
    store u1 0 at v709
    inc_rc v700
    v928 = load v709 -> u1
    v929 = call f27(i32 2, i32 1) -> u1
    v930 = or v928, v929
    store v930 at v709
    v932 = load v709 -> u1
    v933 = call f27(i32 2, i32 2) -> u1
    v934 = or v932, v933
    store v934 at v709
    v936 = load v709 -> u1
    v937 = call f27(i32 2, i32 3) -> u1
    v938 = or v936, v937
    store v938 at v709
    v716 = load v709 -> u1
    constrain v716 == u1 1
    v717 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v717
    v718 = allocate -> &mut [i32; 3]
    store v717 at v718
    v916 = load v718 -> [i32; 3]
    v917 = call f29(i32 2, i32 1) -> i32
    v918 = array_set v916, index u32 0, value v917
    store v918 at v718
    v920 = load v718 -> [i32; 3]
    v921 = call f29(i32 2, i32 2) -> i32
    v922 = array_set v920, index u32 1, value v921
    store v922 at v718
    v924 = load v718 -> [i32; 3]
    v925 = call f29(i32 2, i32 3) -> i32
    v926 = array_set v924, index u32 2, value v925
    store v926 at v718
    v726 = load v718 -> [i32; 3]
    inc_rc v726
    call __debug_var_assign(Field 15, v726)
    inc_rc v726
    inc_rc v726
    v727 = allocate -> &mut u1
    store u1 1 at v727
    inc_rc v726
    v901 = array_get v726, index u32 0 -> i32
    v902 = load v727 -> u1
    v903 = call f31(v901) -> u1
    v904 = mul v902, v903
    store v904 at v727
    v906 = array_get v726, index u32 1 -> i32
    v907 = load v727 -> u1
    v908 = call f31(v906) -> u1
    v909 = mul v907, v908
    store v909 at v727
    v911 = array_get v726, index u32 2 -> i32
    v912 = load v727 -> u1
    v913 = call f31(v911) -> u1
    v914 = mul v912, v913
    store v914 at v727
    v734 = load v727 -> u1
    constrain v734 == u1 1
    v735 = allocate -> &mut u1
    store u1 1 at v735
    inc_rc v726
    v886 = array_get v726, index u32 0 -> i32
    v887 = load v735 -> u1
    v888 = call f33(i32 2, v886) -> u1
    v889 = mul v887, v888
    store v889 at v735
    v891 = array_get v726, index u32 1 -> i32
    v892 = load v735 -> u1
    v893 = call f33(i32 2, v891) -> u1
    v894 = mul v892, v893
    store v894 at v735
    v896 = array_get v726, index u32 2 -> i32
    v897 = load v735 -> u1
    v898 = call f33(i32 2, v896) -> u1
    v899 = mul v897, v898
    store v899 at v735
    v742 = load v735 -> u1
    constrain v742 == u1 1
    v743 = allocate -> &mut i32
    store i32 0 at v743
    inc_rc v726
    v874 = array_get v726, index u32 0 -> i32
    v875 = load v743 -> i32
    v876 = call f35(v875, v874) -> i32
    store v876 at v743
    v878 = array_get v726, index u32 1 -> i32
    v879 = load v743 -> i32
    v880 = call f35(v879, v878) -> i32
    store v880 at v743
    v882 = array_get v726, index u32 2 -> i32
    v883 = load v743 -> i32
    v884 = call f35(v883, v882) -> i32
    store v884 at v743
    v749 = load v743 -> i32
    v750 = eq v749, i32 12
    constrain v749 == i32 12
    v751 = allocate -> &mut i32
    store i32 0 at v751
    inc_rc v726
    v862 = array_get v726, index u32 0 -> i32
    v863 = load v751 -> i32
    v864 = call f37(i32 2, v863, v862) -> i32
    store v864 at v751
    v866 = array_get v726, index u32 1 -> i32
    v867 = load v751 -> i32
    v868 = call f37(i32 2, v867, v866) -> i32
    store v868 at v751
    v870 = array_get v726, index u32 2 -> i32
    v871 = load v751 -> i32
    v872 = call f37(i32 2, v871, v870) -> i32
    store v872 at v751
    v757 = load v751 -> i32
    v758 = eq v757, i32 18
    constrain v757 == i32 18
    v759 = array_get v726, index u32 0 -> i32
    v760 = allocate -> &mut i32
    store v759 at v760
    v854 = load v760 -> i32
    v855 = array_get v726, index u32 1 -> i32
    v856 = call f39(v854, v855) -> i32
    store v856 at v760
    v858 = load v760 -> i32
    v859 = array_get v726, index u32 2 -> i32
    v860 = call f39(v858, v859) -> i32
    store v860 at v760
    v766 = load v760 -> i32
    v767 = eq v766, i32 12
    constrain v766 == i32 12
    v768 = array_get v726, index u32 0 -> i32
    v769 = allocate -> &mut i32
    store v768 at v769
    v846 = load v769 -> i32
    v847 = array_get v726, index u32 1 -> i32
    v848 = call f41(i32 2, v846, v847) -> i32
    store v848 at v769
    v850 = load v769 -> i32
    v851 = array_get v726, index u32 2 -> i32
    v852 = call f41(i32 2, v850, v851) -> i32
    store v852 at v769
    v775 = load v769 -> i32
    v776 = eq v775, i32 16
    constrain v775 == i32 16
    v777 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v777
    v778 = allocate -> &mut [i32; 3]
    store v777 at v778
    v831 = load v778 -> [i32; 3]
    v832 = array_get v726, index u32 0 -> i32
    v833 = div v832, i32 2
    v834 = array_set v831, index u32 0, value v833
    store v834 at v778
    v836 = load v778 -> [i32; 3]
    v837 = array_get v726, index u32 1 -> i32
    v838 = div v837, i32 2
    v839 = array_set v836, index u32 1, value v838
    store v839 at v778
    v841 = load v778 -> [i32; 3]
    v842 = array_get v726, index u32 2 -> i32
    v843 = div v842, i32 2
    v844 = array_set v841, index u32 2, value v843
    store v844 at v778
    v786 = load v778 -> [i32; 3]
    v787 = allocate -> &mut u1
    store u1 1 at v787
    jmp b84(u32 0)
  b84(v372: u32):
    v788 = lt v372, u32 3
    jmpif v788 then: b85, else: b86
  b85():
    v789 = load v787 -> u1
    v790 = array_get v786, index v372 -> i32
    v791 = array_get v700, index v372 -> i32
    v792 = eq v790, v791
    v793 = mul v789, v792
    store v793 at v787
    v794 = add v372, u32 1
    jmp b84(v794)
  b86():
    v795 = load v787 -> u1
    constrain v795 == u1 1
    v796 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v796
    v797 = allocate -> &mut [i32; 3]
    store v796 at v797
    v816 = load v797 -> [i32; 3]
    v817 = array_get v726, index u32 0 -> i32
    v818 = call f45(i32 2, v817) -> i32
    v819 = array_set v816, index u32 0, value v818
    store v819 at v797
    v821 = load v797 -> [i32; 3]
    v822 = array_get v726, index u32 1 -> i32
    v823 = call f45(i32 2, v822) -> i32
    v824 = array_set v821, index u32 1, value v823
    store v824 at v797
    v826 = load v797 -> [i32; 3]
    v827 = array_get v726, index u32 2 -> i32
    v828 = call f45(i32 2, v827) -> i32
    v829 = array_set v826, index u32 2, value v828
    store v829 at v797
    v805 = load v797 -> [i32; 3]
    v806 = allocate -> &mut u1
    store u1 1 at v806
    jmp b97(u32 0)
  b97(v403: u32):
    v807 = lt v403, u32 3
    jmpif v807 then: b98, else: b99
  b98():
    v808 = load v806 -> u1
    v809 = array_get v805, index v403 -> i32
    v810 = array_get v700, index v403 -> i32
    v811 = eq v809, v810
    v812 = mul v808, v811
    store v812 at v806
    v813 = add v403, u32 1
    jmp b97(v813)
  b99():
    v814 = load v806 -> u1
    constrain v814 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v815 = add v0, v699
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v815
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v13 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 2)
    return v13
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    return v12
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v6 = mul v0, Field 2
    return v6
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v7 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v20 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v20
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v6 = lt i32 2, v0
    return v6
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = lt v0, v1
    return v11
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v73 = allocate -> &mut i32
    v74 = mul v1, v0
    v75 = cast v74 as u64
    v76 = truncate v75 to 32 bits, max_bit_size: 64
    v77 = cast v1 as u32
    v78 = cast v0 as u32
    v79 = lt v77, u32 2147483648
    v80 = lt v78, u32 2147483648
    v81 = eq v79, v80
    v82 = not v79
    v83 = cast v1 as Field
    v84 = cast v79 as Field
    v85 = mul v84, v83
    v86 = sub Field 4294967296, v83
    v87 = cast v82 as Field
    v88 = mul v87, v86
    v89 = add v85, v88
    v90 = not v80
    v91 = cast v0 as Field
    v92 = cast v80 as Field
    v93 = mul v92, v91
    v94 = sub Field 4294967296, v91
    v95 = cast v90 as Field
    v96 = mul v95, v94
    v97 = add v93, v96
    v98 = mul v89, v97
    range_check v98 to 32 bits
    v99 = cast v98 as u32
    v100 = not v81
    v101 = cast v100 as u32
    v102 = add u32 2147483648, v101
    v103 = lt v99, v102
    constrain v103 == u1 1, "attempt to add with overflow"
    v104 = cast v76 as i32
    return v104
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v6 = lt i32 1, v0
    return v6
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v1, v0
    v14 = not v13
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = div v1, v0
    return v11
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v7 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v10 = allocate -> &mut u32
    v11 = add v0, u32 2342
    return v11
}

After After Removing Bit Shifts:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v682 = call f4() -> [u32; 2]
    v683 = array_get v682, index u32 1 -> u32
    v684 = eq v683, u32 2
    constrain v683 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v685 = call f7(Field 5) -> Field
    v686 = call f7(v685) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v687 = eq v686, Field 20
    constrain v686 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v688 = call f10(Field 42) -> Field
    v689 = eq v688, Field 42
    constrain v688 == Field 42
    v690 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v691 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v692 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v693 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v694 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v695 = call f51(u32 32) -> u32
    v697 = eq v695, u32 32
    constrain v695 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v698 = call f16(Field 3) -> Field
    v699 = call f16(v698) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v699)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v700 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v700
    call __debug_var_assign(Field 14, v700)
    inc_rc v700
    inc_rc v700
    v701 = allocate -> &mut u1
    store u1 0 at v701
    inc_rc v700
    v940 = load v701 -> u1
    v941 = call f25(i32 1) -> u1
    v942 = or v940, v941
    store v942 at v701
    v944 = load v701 -> u1
    v945 = call f25(i32 2) -> u1
    v946 = or v944, v945
    store v946 at v701
    v948 = load v701 -> u1
    v949 = call f25(i32 3) -> u1
    v950 = or v948, v949
    store v950 at v701
    v708 = load v701 -> u1
    constrain v708 == u1 1
    v709 = allocate -> &mut u1
    store u1 0 at v709
    inc_rc v700
    v928 = load v709 -> u1
    v929 = call f27(i32 2, i32 1) -> u1
    v930 = or v928, v929
    store v930 at v709
    v932 = load v709 -> u1
    v933 = call f27(i32 2, i32 2) -> u1
    v934 = or v932, v933
    store v934 at v709
    v936 = load v709 -> u1
    v937 = call f27(i32 2, i32 3) -> u1
    v938 = or v936, v937
    store v938 at v709
    v716 = load v709 -> u1
    constrain v716 == u1 1
    v717 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v717
    v718 = allocate -> &mut [i32; 3]
    store v717 at v718
    v916 = load v718 -> [i32; 3]
    v917 = call f29(i32 2, i32 1) -> i32
    v918 = array_set v916, index u32 0, value v917
    store v918 at v718
    v920 = load v718 -> [i32; 3]
    v921 = call f29(i32 2, i32 2) -> i32
    v922 = array_set v920, index u32 1, value v921
    store v922 at v718
    v924 = load v718 -> [i32; 3]
    v925 = call f29(i32 2, i32 3) -> i32
    v926 = array_set v924, index u32 2, value v925
    store v926 at v718
    v726 = load v718 -> [i32; 3]
    inc_rc v726
    call __debug_var_assign(Field 15, v726)
    inc_rc v726
    inc_rc v726
    v727 = allocate -> &mut u1
    store u1 1 at v727
    inc_rc v726
    v901 = array_get v726, index u32 0 -> i32
    v902 = load v727 -> u1
    v903 = call f31(v901) -> u1
    v904 = mul v902, v903
    store v904 at v727
    v906 = array_get v726, index u32 1 -> i32
    v907 = load v727 -> u1
    v908 = call f31(v906) -> u1
    v909 = mul v907, v908
    store v909 at v727
    v911 = array_get v726, index u32 2 -> i32
    v912 = load v727 -> u1
    v913 = call f31(v911) -> u1
    v914 = mul v912, v913
    store v914 at v727
    v734 = load v727 -> u1
    constrain v734 == u1 1
    v735 = allocate -> &mut u1
    store u1 1 at v735
    inc_rc v726
    v886 = array_get v726, index u32 0 -> i32
    v887 = load v735 -> u1
    v888 = call f33(i32 2, v886) -> u1
    v889 = mul v887, v888
    store v889 at v735
    v891 = array_get v726, index u32 1 -> i32
    v892 = load v735 -> u1
    v893 = call f33(i32 2, v891) -> u1
    v894 = mul v892, v893
    store v894 at v735
    v896 = array_get v726, index u32 2 -> i32
    v897 = load v735 -> u1
    v898 = call f33(i32 2, v896) -> u1
    v899 = mul v897, v898
    store v899 at v735
    v742 = load v735 -> u1
    constrain v742 == u1 1
    v743 = allocate -> &mut i32
    store i32 0 at v743
    inc_rc v726
    v874 = array_get v726, index u32 0 -> i32
    v875 = load v743 -> i32
    v876 = call f35(v875, v874) -> i32
    store v876 at v743
    v878 = array_get v726, index u32 1 -> i32
    v879 = load v743 -> i32
    v880 = call f35(v879, v878) -> i32
    store v880 at v743
    v882 = array_get v726, index u32 2 -> i32
    v883 = load v743 -> i32
    v884 = call f35(v883, v882) -> i32
    store v884 at v743
    v749 = load v743 -> i32
    v750 = eq v749, i32 12
    constrain v749 == i32 12
    v751 = allocate -> &mut i32
    store i32 0 at v751
    inc_rc v726
    v862 = array_get v726, index u32 0 -> i32
    v863 = load v751 -> i32
    v864 = call f37(i32 2, v863, v862) -> i32
    store v864 at v751
    v866 = array_get v726, index u32 1 -> i32
    v867 = load v751 -> i32
    v868 = call f37(i32 2, v867, v866) -> i32
    store v868 at v751
    v870 = array_get v726, index u32 2 -> i32
    v871 = load v751 -> i32
    v872 = call f37(i32 2, v871, v870) -> i32
    store v872 at v751
    v757 = load v751 -> i32
    v758 = eq v757, i32 18
    constrain v757 == i32 18
    v759 = array_get v726, index u32 0 -> i32
    v760 = allocate -> &mut i32
    store v759 at v760
    v854 = load v760 -> i32
    v855 = array_get v726, index u32 1 -> i32
    v856 = call f39(v854, v855) -> i32
    store v856 at v760
    v858 = load v760 -> i32
    v859 = array_get v726, index u32 2 -> i32
    v860 = call f39(v858, v859) -> i32
    store v860 at v760
    v766 = load v760 -> i32
    v767 = eq v766, i32 12
    constrain v766 == i32 12
    v768 = array_get v726, index u32 0 -> i32
    v769 = allocate -> &mut i32
    store v768 at v769
    v846 = load v769 -> i32
    v847 = array_get v726, index u32 1 -> i32
    v848 = call f41(i32 2, v846, v847) -> i32
    store v848 at v769
    v850 = load v769 -> i32
    v851 = array_get v726, index u32 2 -> i32
    v852 = call f41(i32 2, v850, v851) -> i32
    store v852 at v769
    v775 = load v769 -> i32
    v776 = eq v775, i32 16
    constrain v775 == i32 16
    v777 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v777
    v778 = allocate -> &mut [i32; 3]
    store v777 at v778
    v831 = load v778 -> [i32; 3]
    v832 = array_get v726, index u32 0 -> i32
    v833 = div v832, i32 2
    v834 = array_set v831, index u32 0, value v833
    store v834 at v778
    v836 = load v778 -> [i32; 3]
    v837 = array_get v726, index u32 1 -> i32
    v838 = div v837, i32 2
    v839 = array_set v836, index u32 1, value v838
    store v839 at v778
    v841 = load v778 -> [i32; 3]
    v842 = array_get v726, index u32 2 -> i32
    v843 = div v842, i32 2
    v844 = array_set v841, index u32 2, value v843
    store v844 at v778
    v786 = load v778 -> [i32; 3]
    v787 = allocate -> &mut u1
    store u1 1 at v787
    jmp b84(u32 0)
  b84(v372: u32):
    v788 = lt v372, u32 3
    jmpif v788 then: b85, else: b86
  b85():
    v789 = load v787 -> u1
    v790 = array_get v786, index v372 -> i32
    v791 = array_get v700, index v372 -> i32
    v792 = eq v790, v791
    v793 = mul v789, v792
    store v793 at v787
    v794 = add v372, u32 1
    jmp b84(v794)
  b86():
    v795 = load v787 -> u1
    constrain v795 == u1 1
    v796 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v796
    v797 = allocate -> &mut [i32; 3]
    store v796 at v797
    v816 = load v797 -> [i32; 3]
    v817 = array_get v726, index u32 0 -> i32
    v818 = call f45(i32 2, v817) -> i32
    v819 = array_set v816, index u32 0, value v818
    store v819 at v797
    v821 = load v797 -> [i32; 3]
    v822 = array_get v726, index u32 1 -> i32
    v823 = call f45(i32 2, v822) -> i32
    v824 = array_set v821, index u32 1, value v823
    store v824 at v797
    v826 = load v797 -> [i32; 3]
    v827 = array_get v726, index u32 2 -> i32
    v828 = call f45(i32 2, v827) -> i32
    v829 = array_set v826, index u32 2, value v828
    store v829 at v797
    v805 = load v797 -> [i32; 3]
    v806 = allocate -> &mut u1
    store u1 1 at v806
    jmp b97(u32 0)
  b97(v403: u32):
    v807 = lt v403, u32 3
    jmpif v807 then: b98, else: b99
  b98():
    v808 = load v806 -> u1
    v809 = array_get v805, index v403 -> i32
    v810 = array_get v700, index v403 -> i32
    v811 = eq v809, v810
    v812 = mul v808, v811
    store v812 at v806
    v813 = add v403, u32 1
    jmp b97(v813)
  b99():
    v814 = load v806 -> u1
    constrain v814 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v815 = add v0, v699
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v815
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v13 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 2)
    return v13
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    return v12
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v6 = mul v0, Field 2
    return v6
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v7 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v20 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v20
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v6 = lt i32 2, v0
    return v6
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = lt v0, v1
    return v11
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v73 = allocate -> &mut i32
    v74 = mul v1, v0
    v75 = cast v74 as u64
    v76 = truncate v75 to 32 bits, max_bit_size: 64
    v77 = cast v1 as u32
    v78 = cast v0 as u32
    v79 = lt v77, u32 2147483648
    v80 = lt v78, u32 2147483648
    v81 = eq v79, v80
    v82 = not v79
    v83 = cast v1 as Field
    v84 = cast v79 as Field
    v85 = mul v84, v83
    v86 = sub Field 4294967296, v83
    v87 = cast v82 as Field
    v88 = mul v87, v86
    v89 = add v85, v88
    v90 = not v80
    v91 = cast v0 as Field
    v92 = cast v80 as Field
    v93 = mul v92, v91
    v94 = sub Field 4294967296, v91
    v95 = cast v90 as Field
    v96 = mul v95, v94
    v97 = add v93, v96
    v98 = mul v89, v97
    range_check v98 to 32 bits
    v99 = cast v98 as u32
    v100 = not v81
    v101 = cast v100 as u32
    v102 = add u32 2147483648, v101
    v103 = lt v99, v102
    constrain v103 == u1 1, "attempt to add with overflow"
    v104 = cast v76 as i32
    return v104
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v6 = lt i32 1, v0
    return v6
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v1, v0
    v14 = not v13
    return v14
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v28 = add v0, v1
    v29 = truncate v28 to 32 bits, max_bit_size: 33
    v30 = cast v29 as u32
    v31 = cast v0 as u32
    v32 = cast v1 as u32
    v33 = lt v31, u32 2147483648
    v34 = lt v32, u32 2147483648
    v35 = eq v33, v34
    v36 = lt v30, u32 2147483648
    v37 = eq v36, v33
    v38 = mul v37, v35
    constrain v38 == v35, "attempt to add with overflow"
    return v29
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v55 = allocate -> &mut i32
    v56 = add v1, v2
    v57 = truncate v56 to 32 bits, max_bit_size: 33
    v58 = cast v57 as u32
    v59 = cast v1 as u32
    v60 = cast v2 as u32
    v61 = lt v59, u32 2147483648
    v62 = lt v60, u32 2147483648
    v63 = eq v61, v62
    v64 = lt v58, u32 2147483648
    v65 = eq v64, v61
    v66 = mul v65, v63
    constrain v66 == v63, "attempt to add with overflow"
    v67 = add v57, v0
    v68 = truncate v67 to 32 bits, max_bit_size: 33
    v69 = cast v68 as u32
    v70 = cast v57 as u32
    v71 = cast v0 as u32
    v72 = lt v70, u32 2147483648
    v73 = lt v71, u32 2147483648
    v74 = eq v72, v73
    v75 = lt v69, u32 2147483648
    v76 = eq v75, v72
    v77 = mul v76, v74
    constrain v77 == v74, "attempt to add with overflow"
    return v68
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v10 = allocate -> &mut i32
    v11 = div v1, v0
    return v11
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v7 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v10 = allocate -> &mut u32
    v11 = add v0, u32 2342
    return v11
}

After Mem2Reg (2nd):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    v952 = call f4() -> [u32; 2]
    v953 = array_get v952, index u32 1 -> u32
    v954 = eq v953, u32 2
    constrain v953 == u32 2
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    v955 = call f7(Field 5) -> Field
    v956 = call f7(v955) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    v957 = eq v956, Field 20
    constrain v956 == Field 20
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v958 = call f10(Field 42) -> Field
    v959 = eq v958, Field 42
    constrain v958 == Field 42
    v960 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v961 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v962 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v963 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v964 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v965 = call f51(u32 32) -> u32
    v966 = eq v965, u32 32
    constrain v965 == u32 32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    v967 = call f16(Field 3) -> Field
    v968 = call f16(v967) -> Field
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, v968)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v969 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v969
    call __debug_var_assign(Field 14, v969)
    inc_rc v969
    inc_rc v969
    v970 = allocate -> &mut u1
    inc_rc v969
    v972 = call f25(i32 1) -> u1
    v974 = call f25(i32 2) -> u1
    v975 = or v972, v974
    v977 = call f25(i32 3) -> u1
    v978 = or v975, v977
    constrain v978 == u1 1
    v980 = allocate -> &mut u1
    inc_rc v969
    v982 = call f27(i32 2, i32 1) -> u1
    v984 = call f27(i32 2, i32 2) -> u1
    v985 = or v982, v984
    v987 = call f27(i32 2, i32 3) -> u1
    v988 = or v985, v987
    constrain v988 == u1 1
    v990 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v990
    v991 = allocate -> &mut [i32; 3]
    v993 = call f29(i32 2, i32 1) -> i32
    v994 = make_array [v993, i32 0, i32 0] : [i32; 3]
    v996 = call f29(i32 2, i32 2) -> i32
    v997 = make_array [v993, v996, i32 0] : [i32; 3]
    v999 = call f29(i32 2, i32 3) -> i32
    v1000 = make_array [v993, v996, v999] : [i32; 3]
    inc_rc v1000
    call __debug_var_assign(Field 15, v1000)
    inc_rc v1000
    inc_rc v1000
    v1002 = allocate -> &mut u1
    inc_rc v1000
    v1004 = call f31(v993) -> u1
    v1006 = call f31(v996) -> u1
    v1007 = mul v1004, v1006
    v1009 = call f31(v999) -> u1
    v1010 = mul v1007, v1009
    constrain v1004 == u1 1
    constrain v1006 == u1 1
    constrain v1009 == u1 1
    v1012 = allocate -> &mut u1
    inc_rc v1000
    v1014 = call f33(i32 2, v993) -> u1
    v1016 = call f33(i32 2, v996) -> u1
    v1017 = mul v1014, v1016
    v1019 = call f33(i32 2, v999) -> u1
    v1020 = mul v1017, v1019
    constrain v1014 == u1 1
    constrain v1016 == u1 1
    constrain v1019 == u1 1
    v1022 = allocate -> &mut i32
    inc_rc v1000
    v1024 = call f35(i32 0, v993) -> i32
    v1026 = call f35(v1024, v996) -> i32
    v1028 = call f35(v1026, v999) -> i32
    v1030 = eq v1028, i32 12
    constrain v1028 == i32 12
    v1031 = allocate -> &mut i32
    inc_rc v1000
    v1033 = call f37(i32 2, i32 0, v993) -> i32
    v1035 = call f37(i32 2, v1033, v996) -> i32
    v1037 = call f37(i32 2, v1035, v999) -> i32
    v1039 = eq v1037, i32 18
    constrain v1037 == i32 18
    v1040 = allocate -> &mut i32
    v1042 = call f39(v993, v996) -> i32
    v1044 = call f39(v1042, v999) -> i32
    v1046 = eq v1044, i32 12
    constrain v1044 == i32 12
    v1047 = allocate -> &mut i32
    v1049 = call f41(i32 2, v993, v996) -> i32
    v1051 = call f41(i32 2, v1049, v999) -> i32
    v1053 = eq v1051, i32 16
    constrain v1051 == i32 16
    v1054 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v1054
    v1055 = allocate -> &mut [i32; 3]
    v1057 = div v993, i32 2
    v1058 = make_array [v1057, i32 0, i32 0] : [i32; 3]
    v1060 = div v996, i32 2
    v1061 = make_array [v1057, v1060, i32 0] : [i32; 3]
    v1063 = div v999, i32 2
    v1064 = make_array [v1057, v1060, v1063] : [i32; 3]
    v1066 = allocate -> &mut u1
    store u1 1 at v1066
    jmp b84(u32 0)
  b84(v372: u32):
    v1067 = lt v372, u32 3
    jmpif v1067 then: b85, else: b86
  b85():
    v1091 = load v1066 -> u1
    v1092 = array_get v1064, index v372 -> i32
    v1093 = array_get v969, index v372 -> i32
    v1094 = eq v1092, v1093
    v1095 = mul v1091, v1094
    store v1095 at v1066
    v1096 = add v372, u32 1
    jmp b84(v1096)
  b86():
    v1068 = load v1066 -> u1
    constrain v1068 == u1 1
    v1069 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v1069
    v1070 = allocate -> &mut [i32; 3]
    v1072 = call f45(i32 2, v993) -> i32
    v1073 = make_array [v1072, i32 0, i32 0] : [i32; 3]
    v1075 = call f45(i32 2, v996) -> i32
    v1076 = make_array [v1072, v1075, i32 0] : [i32; 3]
    v1078 = call f45(i32 2, v999) -> i32
    v1079 = make_array [v1072, v1075, v1078] : [i32; 3]
    v1081 = allocate -> &mut u1
    store u1 1 at v1081
    jmp b97(u32 0)
  b97(v403: u32):
    v1082 = lt v403, u32 3
    jmpif v1082 then: b98, else: b99
  b98():
    v1085 = load v1081 -> u1
    v1086 = array_get v1079, index v403 -> i32
    v1087 = array_get v969, index v403 -> i32
    v1088 = eq v1086, v1087
    v1089 = mul v1085, v1088
    store v1089 at v1081
    v1090 = add v403, u32 1
    jmp b97(v1090)
  b99():
    v1083 = load v1081 -> u1
    constrain v1083 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v1084 = add v0, v968
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v1084
}
brillig(inline) fn foo f3 {
  b0():
    call __debug_fn_enter(u32 2)
    v14 = make_array [u32 1, u32 3] : [u32; 2]
    inc_rc v14
    call __debug_fn_exit(u32 2)
    return v14
}
brillig(inline) fn bar f4 {
  b0():
    call __debug_fn_enter(u32 3)
    v13 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v13
    call __debug_fn_exit(u32 3)
    return v13
}
brillig(inline) fn lambda f7 {
  b0(v0: Field):
    v7 = mul v0, Field 2
    return v7
}
brillig(inline) fn lambda f10 {
  b0(v0: Field):
    v8 = allocate -> &mut Field
    return v0
}
brillig(inline) fn add1 f16 {
  b0(v0: Field):
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, v0)
    v21 = add v0, Field 1
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    return v21
}
brillig(inline) fn lambda f25 {
  b0(v0: i32):
    v7 = lt i32 2, v0
    return v7
}
brillig(inline) fn lambda f27 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = lt v0, v1
    return v13
}
brillig(inline) fn lambda f29 {
  b0(v0: i32, v1: i32):
    v105 = allocate -> &mut i32
    v106 = mul v1, v0
    v107 = cast v106 as u64
    v108 = truncate v107 to 32 bits, max_bit_size: 64
    v109 = cast v1 as u32
    v110 = cast v0 as u32
    v111 = lt v109, u32 2147483648
    v112 = lt v110, u32 2147483648
    v113 = eq v111, v112
    v114 = not v111
    v115 = cast v1 as Field
    v116 = cast v111 as Field
    v117 = mul v116, v115
    v118 = sub Field 4294967296, v115
    v119 = cast v114 as Field
    v120 = mul v119, v118
    v121 = add v117, v120
    v122 = not v112
    v123 = cast v0 as Field
    v124 = cast v112 as Field
    v125 = mul v124, v123
    v126 = sub Field 4294967296, v123
    v127 = cast v122 as Field
    v128 = mul v127, v126
    v129 = add v125, v128
    v130 = mul v121, v129
    range_check v130 to 32 bits
    v131 = cast v130 as u32
    v132 = not v113
    v133 = cast v132 as u32
    v134 = add u32 2147483648, v133
    v135 = lt v131, v134
    constrain v135 == u1 1, "attempt to add with overflow"
    v136 = cast v108 as i32
    return v136
}
brillig(inline) fn lambda f31 {
  b0(v0: i32):
    v7 = lt i32 1, v0
    return v7
}
brillig(inline) fn lambda f33 {
  b0(v0: i32, v1: i32):
    v15 = allocate -> &mut i32
    v16 = lt v1, v0
    v17 = not v16
    return v17
}
brillig(inline) fn lambda f35 {
  b0(v0: i32, v1: i32):
    v39 = add v0, v1
    v40 = truncate v39 to 32 bits, max_bit_size: 33
    v41 = cast v40 as u32
    v42 = cast v0 as u32
    v43 = cast v1 as u32
    v44 = lt v42, u32 2147483648
    v45 = lt v43, u32 2147483648
    v46 = eq v44, v45
    v47 = lt v41, u32 2147483648
    v48 = eq v47, v44
    v49 = mul v48, v46
    constrain v49 == v46, "attempt to add with overflow"
    return v40
}
brillig(inline) fn lambda f37 {
  b0(v0: i32, v1: i32, v2: i32):
    v78 = allocate -> &mut i32
    v79 = add v1, v2
    v80 = truncate v79 to 32 bits, max_bit_size: 33
    v81 = cast v80 as u32
    v82 = cast v1 as u32
    v83 = cast v2 as u32
    v84 = lt v82, u32 2147483648
    v85 = lt v83, u32 2147483648
    v86 = eq v84, v85
    v87 = lt v81, u32 2147483648
    v88 = eq v87, v84
    v89 = mul v88, v86
    constrain v89 == v86, "attempt to add with overflow"
    v90 = add v80, v0
    v91 = truncate v90 to 32 bits, max_bit_size: 33
    v92 = cast v91 as u32
    v93 = cast v80 as u32
    v94 = cast v0 as u32
    v95 = lt v93, u32 2147483648
    v96 = lt v94, u32 2147483648
    v97 = eq v95, v96
    v98 = lt v92, u32 2147483648
    v99 = eq v98, v95
    v100 = mul v99, v97
    constrain v100 == v97, "attempt to add with overflow"
    return v91
}
brillig(inline) fn lambda f39 {
  b0(v0: i32, v1: i32):
    v39 = add v0, v1
    v40 = truncate v39 to 32 bits, max_bit_size: 33
    v41 = cast v40 as u32
    v42 = cast v0 as u32
    v43 = cast v1 as u32
    v44 = lt v42, u32 2147483648
    v45 = lt v43, u32 2147483648
    v46 = eq v44, v45
    v47 = lt v41, u32 2147483648
    v48 = eq v47, v44
    v49 = mul v48, v46
    constrain v49 == v46, "attempt to add with overflow"
    return v40
}
brillig(inline) fn lambda f41 {
  b0(v0: i32, v1: i32, v2: i32):
    v78 = allocate -> &mut i32
    v79 = add v1, v2
    v80 = truncate v79 to 32 bits, max_bit_size: 33
    v81 = cast v80 as u32
    v82 = cast v1 as u32
    v83 = cast v2 as u32
    v84 = lt v82, u32 2147483648
    v85 = lt v83, u32 2147483648
    v86 = eq v84, v85
    v87 = lt v81, u32 2147483648
    v88 = eq v87, v84
    v89 = mul v88, v86
    constrain v89 == v86, "attempt to add with overflow"
    v90 = add v80, v0
    v91 = truncate v90 to 32 bits, max_bit_size: 33
    v92 = cast v91 as u32
    v93 = cast v80 as u32
    v94 = cast v0 as u32
    v95 = lt v93, u32 2147483648
    v96 = lt v94, u32 2147483648
    v97 = eq v95, v96
    v98 = lt v92, u32 2147483648
    v99 = eq v98, v95
    v100 = mul v99, v97
    constrain v100 == v97, "attempt to add with overflow"
    return v91
}
brillig(inline) fn lambda f45 {
  b0(v0: i32, v1: i32):
    v12 = allocate -> &mut i32
    v13 = div v1, v0
    return v13
}
brillig(inline) fn lambda f51 {
  b0(v0: u32):
    v8 = allocate -> &mut u32
    return v0
}
brillig(inline) fn lambda f52 {
  b0(v0: u32):
    v12 = allocate -> &mut u32
    v13 = add v0, u32 2342
    return v13
}

After Inlining (2nd):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v37 = allocate -> &mut Field
    v38 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v40 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v44 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v48 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v50 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v59 = allocate -> &mut u32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v89 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v89
    call __debug_var_assign(Field 14, v89)
    inc_rc v89
    inc_rc v89
    v92 = allocate -> &mut u1
    inc_rc v89
    v95 = allocate -> &mut u1
    inc_rc v89
    v97 = allocate -> &mut i32
    v98 = allocate -> &mut i32
    v99 = allocate -> &mut i32
    v101 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v101
    v102 = allocate -> &mut [i32; 3]
    v104 = allocate -> &mut i32
    v110 = make_array [i32 2, i32 0, i32 0] : [i32; 3]
    v111 = allocate -> &mut i32
    v114 = make_array [i32 2, i32 4, i32 0] : [i32; 3]
    v115 = allocate -> &mut i32
    v119 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v119
    call __debug_var_assign(Field 15, v119)
    inc_rc v119
    inc_rc v119
    v122 = allocate -> &mut u1
    inc_rc v119
    v124 = allocate -> &mut u1
    inc_rc v119
    v126 = allocate -> &mut i32
    v127 = allocate -> &mut i32
    v128 = allocate -> &mut i32
    v129 = allocate -> &mut i32
    inc_rc v119
    v133 = allocate -> &mut i32
    inc_rc v119
    v135 = allocate -> &mut i32
    v136 = allocate -> &mut i32
    v141 = allocate -> &mut i32
    v146 = allocate -> &mut i32
    v148 = allocate -> &mut i32
    v150 = allocate -> &mut i32
    v151 = allocate -> &mut i32
    v154 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v154
    v155 = allocate -> &mut [i32; 3]
    v156 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v157 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    v158 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    v159 = allocate -> &mut u1
    store u1 1 at v159
    jmp b1(u32 0)
  b1(v160: u32):
    v161 = lt v160, u32 3
    jmpif v161 then: b2, else: b3
  b2():
    v162 = load v159 -> u1
    v163 = array_get v158, index v160 -> i32
    v164 = array_get v89, index v160 -> i32
    v165 = eq v163, v164
    v166 = mul v162, v165
    store v166 at v159
    v167 = add v160, u32 1
    jmp b1(v167)
  b3():
    v168 = load v159 -> u1
    constrain v168 == u1 1
    v169 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v169
    v170 = allocate -> &mut [i32; 3]
    v172 = allocate -> &mut i32
    v173 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v174 = allocate -> &mut i32
    v175 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    v176 = allocate -> &mut i32
    v177 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    v178 = allocate -> &mut u1
    store u1 1 at v178
    jmp b4(u32 0)
  b4(v179: u32):
    v180 = lt v179, u32 3
    jmpif v180 then: b5, else: b6
  b5():
    v181 = load v178 -> u1
    v182 = array_get v177, index v179 -> i32
    v183 = array_get v89, index v179 -> i32
    v184 = eq v182, v183
    v185 = mul v181, v184
    store v185 at v178
    v186 = add v179, u32 1
    jmp b4(v186)
  b6():
    v187 = load v178 -> u1
    constrain v187 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v192 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v192
}

After Remove IfElse:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    v12 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v12
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v37 = allocate -> &mut Field
    v38 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v40 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v44 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v48 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v50 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v59 = allocate -> &mut u32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v89 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v89
    call __debug_var_assign(Field 14, v89)
    inc_rc v89
    inc_rc v89
    v92 = allocate -> &mut u1
    inc_rc v89
    v95 = allocate -> &mut u1
    inc_rc v89
    v97 = allocate -> &mut i32
    v98 = allocate -> &mut i32
    v99 = allocate -> &mut i32
    v101 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v101
    v102 = allocate -> &mut [i32; 3]
    v104 = allocate -> &mut i32
    v110 = make_array [i32 2, i32 0, i32 0] : [i32; 3]
    v111 = allocate -> &mut i32
    v114 = make_array [i32 2, i32 4, i32 0] : [i32; 3]
    v115 = allocate -> &mut i32
    v119 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v119
    call __debug_var_assign(Field 15, v119)
    inc_rc v119
    inc_rc v119
    v122 = allocate -> &mut u1
    inc_rc v119
    v124 = allocate -> &mut u1
    inc_rc v119
    v126 = allocate -> &mut i32
    v127 = allocate -> &mut i32
    v128 = allocate -> &mut i32
    v129 = allocate -> &mut i32
    inc_rc v119
    v133 = allocate -> &mut i32
    inc_rc v119
    v135 = allocate -> &mut i32
    v136 = allocate -> &mut i32
    v141 = allocate -> &mut i32
    v146 = allocate -> &mut i32
    v148 = allocate -> &mut i32
    v150 = allocate -> &mut i32
    v151 = allocate -> &mut i32
    v154 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v154
    v155 = allocate -> &mut [i32; 3]
    v156 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v157 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    v158 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    v159 = allocate -> &mut u1
    store u1 1 at v159
    jmp b1(u32 0)
  b1(v160: u32):
    v161 = lt v160, u32 3
    jmpif v161 then: b2, else: b3
  b2():
    v162 = load v159 -> u1
    v163 = array_get v158, index v160 -> i32
    v164 = array_get v89, index v160 -> i32
    v165 = eq v163, v164
    v166 = mul v162, v165
    store v166 at v159
    v167 = add v160, u32 1
    jmp b1(v167)
  b3():
    v168 = load v159 -> u1
    constrain v168 == u1 1
    v169 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v169
    v170 = allocate -> &mut [i32; 3]
    v172 = allocate -> &mut i32
    v173 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v174 = allocate -> &mut i32
    v175 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    v176 = allocate -> &mut i32
    v177 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    v178 = allocate -> &mut u1
    store u1 1 at v178
    jmp b4(u32 0)
  b4(v179: u32):
    v180 = lt v179, u32 3
    jmpif v180 then: b5, else: b6
  b5():
    v181 = load v178 -> u1
    v182 = array_get v177, index v179 -> i32
    v183 = array_get v89, index v179 -> i32
    v184 = eq v182, v183
    v185 = mul v181, v184
    store v185 at v178
    v186 = add v179, u32 1
    jmp b4(v186)
  b6():
    v187 = load v178 -> u1
    constrain v187 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v192 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v192
}

After Constant Folding:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    v202 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v202
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v203 = allocate -> &mut Field
    v204 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v205 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v206 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v207 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v208 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v209 = allocate -> &mut u32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v210 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v210
    call __debug_var_assign(Field 14, v210)
    inc_rc v210
    inc_rc v210
    v211 = allocate -> &mut u1
    inc_rc v210
    v212 = allocate -> &mut u1
    inc_rc v210
    v213 = allocate -> &mut i32
    v214 = allocate -> &mut i32
    v215 = allocate -> &mut i32
    v216 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v216
    v217 = allocate -> &mut [i32; 3]
    v218 = allocate -> &mut i32
    v219 = make_array [i32 2, i32 0, i32 0] : [i32; 3]
    v220 = allocate -> &mut i32
    v221 = make_array [i32 2, i32 4, i32 0] : [i32; 3]
    v222 = allocate -> &mut i32
    v223 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v223
    call __debug_var_assign(Field 15, v223)
    inc_rc v223
    inc_rc v223
    v224 = allocate -> &mut u1
    inc_rc v223
    v225 = allocate -> &mut u1
    inc_rc v223
    v226 = allocate -> &mut i32
    v227 = allocate -> &mut i32
    v228 = allocate -> &mut i32
    v229 = allocate -> &mut i32
    inc_rc v223
    v230 = allocate -> &mut i32
    inc_rc v223
    v231 = allocate -> &mut i32
    v232 = allocate -> &mut i32
    v233 = allocate -> &mut i32
    v234 = allocate -> &mut i32
    v235 = allocate -> &mut i32
    v236 = allocate -> &mut i32
    v237 = allocate -> &mut i32
    inc_rc v216
    inc_rc v216
    v238 = allocate -> &mut [i32; 3]
    v239 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v240 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    inc_rc v210
    v241 = allocate -> &mut u1
    store u1 1 at v241
    jmp b1(u32 0)
  b1(v160: u32):
    v242 = lt v160, u32 3
    jmpif v242 then: b2, else: b3
  b2():
    v243 = load v241 -> u1
    v244 = array_get v210, index v160 -> i32
    v245 = array_get v210, index v160 -> i32
    v246 = eq v244, v245
    v247 = mul v243, v246
    store v247 at v241
    v248 = add v160, u32 1
    jmp b1(v248)
  b3():
    v249 = load v241 -> u1
    constrain v249 == u1 1
    inc_rc v216
    inc_rc v216
    v250 = allocate -> &mut [i32; 3]
    v251 = allocate -> &mut i32
    inc_rc v239
    v252 = allocate -> &mut i32
    inc_rc v240
    v253 = allocate -> &mut i32
    inc_rc v210
    v254 = allocate -> &mut u1
    store u1 1 at v254
    jmp b4(u32 0)
  b4(v179: u32):
    v255 = lt v179, u32 3
    jmpif v255 then: b5, else: b6
  b5():
    v256 = load v254 -> u1
    v257 = array_get v210, index v179 -> i32
    v258 = array_get v210, index v179 -> i32
    v259 = eq v257, v258
    v260 = mul v256, v259
    store v260 at v254
    v261 = add v179, u32 1
    jmp b4(v261)
  b6():
    v262 = load v254 -> u1
    constrain v262 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v263 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v263
}

After EnableSideEffectsIf removal:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    v202 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v202
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v203 = allocate -> &mut Field
    v204 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v205 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v206 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v207 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v208 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v209 = allocate -> &mut u32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v210 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v210
    call __debug_var_assign(Field 14, v210)
    inc_rc v210
    inc_rc v210
    v211 = allocate -> &mut u1
    inc_rc v210
    v212 = allocate -> &mut u1
    inc_rc v210
    v213 = allocate -> &mut i32
    v214 = allocate -> &mut i32
    v215 = allocate -> &mut i32
    v216 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v216
    v217 = allocate -> &mut [i32; 3]
    v218 = allocate -> &mut i32
    v219 = make_array [i32 2, i32 0, i32 0] : [i32; 3]
    v220 = allocate -> &mut i32
    v221 = make_array [i32 2, i32 4, i32 0] : [i32; 3]
    v222 = allocate -> &mut i32
    v223 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v223
    call __debug_var_assign(Field 15, v223)
    inc_rc v223
    inc_rc v223
    v224 = allocate -> &mut u1
    inc_rc v223
    v225 = allocate -> &mut u1
    inc_rc v223
    v226 = allocate -> &mut i32
    v227 = allocate -> &mut i32
    v228 = allocate -> &mut i32
    v229 = allocate -> &mut i32
    inc_rc v223
    v230 = allocate -> &mut i32
    inc_rc v223
    v231 = allocate -> &mut i32
    v232 = allocate -> &mut i32
    v233 = allocate -> &mut i32
    v234 = allocate -> &mut i32
    v235 = allocate -> &mut i32
    v236 = allocate -> &mut i32
    v237 = allocate -> &mut i32
    inc_rc v216
    inc_rc v216
    v238 = allocate -> &mut [i32; 3]
    v239 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v240 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    inc_rc v210
    v241 = allocate -> &mut u1
    store u1 1 at v241
    jmp b1(u32 0)
  b1(v160: u32):
    v242 = lt v160, u32 3
    jmpif v242 then: b2, else: b3
  b2():
    v243 = load v241 -> u1
    v244 = array_get v210, index v160 -> i32
    v245 = array_get v210, index v160 -> i32
    v246 = eq v244, v245
    v247 = mul v243, v246
    store v247 at v241
    v248 = add v160, u32 1
    jmp b1(v248)
  b3():
    v249 = load v241 -> u1
    constrain v249 == u1 1
    inc_rc v216
    inc_rc v216
    v250 = allocate -> &mut [i32; 3]
    v251 = allocate -> &mut i32
    inc_rc v239
    v252 = allocate -> &mut i32
    inc_rc v240
    v253 = allocate -> &mut i32
    inc_rc v210
    v254 = allocate -> &mut u1
    store u1 1 at v254
    jmp b4(u32 0)
  b4(v179: u32):
    v255 = lt v179, u32 3
    jmpif v255 then: b5, else: b6
  b5():
    v256 = load v254 -> u1
    v257 = array_get v210, index v179 -> i32
    v258 = array_get v210, index v179 -> i32
    v259 = eq v257, v258
    v260 = mul v256, v259
    store v260 at v254
    v261 = add v179, u32 1
    jmp b4(v261)
  b6():
    v262 = load v254 -> u1
    constrain v262 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v263 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v263
}

After Constraint Folding:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    v264 = make_array [u32 3, u32 2] : [u32; 2]
    inc_rc v264
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    v265 = allocate -> &mut Field
    v266 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 2)
    v267 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    v268 = allocate -> &mut Field
    call __debug_var_assign(Field 6, Field 4, f13)
    v269 = allocate -> &mut Field
    call __debug_var_assign(Field 4, Field 5)
    v270 = allocate -> &mut Field
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    v271 = allocate -> &mut u32
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v272 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v272
    call __debug_var_assign(Field 14, v272)
    inc_rc v272
    inc_rc v272
    v273 = allocate -> &mut u1
    inc_rc v272
    v274 = allocate -> &mut u1
    inc_rc v272
    v275 = allocate -> &mut i32
    v276 = allocate -> &mut i32
    v277 = allocate -> &mut i32
    v278 = make_array [i32 0, i32 0, i32 0] : [i32; 3]
    inc_rc v278
    v279 = allocate -> &mut [i32; 3]
    v280 = allocate -> &mut i32
    v281 = make_array [i32 2, i32 0, i32 0] : [i32; 3]
    v282 = allocate -> &mut i32
    v283 = make_array [i32 2, i32 4, i32 0] : [i32; 3]
    v284 = allocate -> &mut i32
    v285 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v285
    call __debug_var_assign(Field 15, v285)
    inc_rc v285
    inc_rc v285
    v286 = allocate -> &mut u1
    inc_rc v285
    v287 = allocate -> &mut u1
    inc_rc v285
    v288 = allocate -> &mut i32
    v289 = allocate -> &mut i32
    v290 = allocate -> &mut i32
    v291 = allocate -> &mut i32
    inc_rc v285
    v292 = allocate -> &mut i32
    inc_rc v285
    v293 = allocate -> &mut i32
    v294 = allocate -> &mut i32
    v295 = allocate -> &mut i32
    v296 = allocate -> &mut i32
    v297 = allocate -> &mut i32
    v298 = allocate -> &mut i32
    v299 = allocate -> &mut i32
    inc_rc v278
    inc_rc v278
    v300 = allocate -> &mut [i32; 3]
    v301 = make_array [i32 1, i32 0, i32 0] : [i32; 3]
    v302 = make_array [i32 1, i32 2, i32 0] : [i32; 3]
    inc_rc v272
    v303 = allocate -> &mut u1
    store u1 1 at v303
    jmp b1(u32 0)
  b1(v160: u32):
    v304 = lt v160, u32 3
    jmpif v304 then: b2, else: b3
  b2():
    v305 = load v303 -> u1
    v306 = array_get v272, index v160 -> i32
    store v305 at v303
    v307 = add v160, u32 1
    jmp b1(v307)
  b3():
    v308 = load v303 -> u1
    constrain v308 == u1 1
    inc_rc v278
    inc_rc v278
    v309 = allocate -> &mut [i32; 3]
    v310 = allocate -> &mut i32
    inc_rc v301
    v311 = allocate -> &mut i32
    inc_rc v302
    v312 = allocate -> &mut i32
    inc_rc v272
    v313 = allocate -> &mut u1
    store u1 1 at v313
    jmp b4(u32 0)
  b4(v179: u32):
    v314 = lt v179, u32 3
    jmpif v314 then: b5, else: b6
  b5():
    v315 = load v313 -> u1
    v316 = array_get v272, index v179 -> i32
    store v315 at v313
    v317 = add v179, u32 1
    jmp b4(v317)
  b6():
    v318 = load v313 -> u1
    constrain v318 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v319 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v319
}

After Dead Instruction Elimination (1st):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    call __debug_var_assign(Field 4, Field 2)
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    call __debug_var_assign(Field 6, Field 4, f13)
    call __debug_var_assign(Field 4, Field 5)
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v272 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v272
    call __debug_var_assign(Field 14, v272)
    inc_rc v272
    v285 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v285
    call __debug_var_assign(Field 15, v285)
    inc_rc v285
    inc_rc v272
    v303 = allocate -> &mut u1
    store u1 1 at v303
    jmp b1(u32 0)
  b1(v160: u32):
    v304 = lt v160, u32 3
    jmpif v304 then: b2, else: b3
  b2():
    v305 = load v303 -> u1
    v320 = lt v160, u32 3
    constrain v320 == u1 1, "Index out of bounds"
    store v305 at v303
    v307 = add v160, u32 1
    jmp b1(v307)
  b3():
    v308 = load v303 -> u1
    constrain v308 == u1 1
    v313 = allocate -> &mut u1
    store u1 1 at v313
    jmp b4(u32 0)
  b4(v179: u32):
    v314 = lt v179, u32 3
    jmpif v314 then: b5, else: b6
  b5():
    v315 = load v313 -> u1
    v321 = lt v179, u32 3
    constrain v321 == u1 1, "Index out of bounds"
    store v315 at v313
    v317 = add v179, u32 1
    jmp b4(v317)
  b6():
    v318 = load v313 -> u1
    constrain v318 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v319 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v319
}

After Simplifying::
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    call __debug_var_assign(Field 4, Field 2)
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    call __debug_var_assign(Field 6, Field 4, f13)
    call __debug_var_assign(Field 4, Field 5)
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v272 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v272
    call __debug_var_assign(Field 14, v272)
    inc_rc v272
    v285 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v285
    call __debug_var_assign(Field 15, v285)
    inc_rc v285
    inc_rc v272
    v303 = allocate -> &mut u1
    store u1 1 at v303
    jmp b1(u32 0)
  b1(v160: u32):
    v304 = lt v160, u32 3
    jmpif v304 then: b2, else: b3
  b2():
    v305 = load v303 -> u1
    v320 = lt v160, u32 3
    constrain v320 == u1 1, "Index out of bounds"
    store v305 at v303
    v307 = add v160, u32 1
    jmp b1(v307)
  b3():
    v308 = load v303 -> u1
    constrain v308 == u1 1
    v313 = allocate -> &mut u1
    store u1 1 at v313
    jmp b4(u32 0)
  b4(v179: u32):
    v314 = lt v179, u32 3
    jmpif v314 then: b5, else: b6
  b5():
    v315 = load v313 -> u1
    v321 = lt v179, u32 3
    constrain v321 == u1 1, "Index out of bounds"
    store v315 at v313
    v317 = add v179, u32 1
    jmp b4(v317)
  b6():
    v318 = load v313 -> u1
    constrain v318 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v319 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v319
}

After Array Set Optimizations:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    call __debug_var_assign(Field 4, Field 2)
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    call __debug_var_assign(Field 6, Field 4, f13)
    call __debug_var_assign(Field 4, Field 5)
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v272 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v272
    call __debug_var_assign(Field 14, v272)
    inc_rc v272
    v285 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v285
    call __debug_var_assign(Field 15, v285)
    inc_rc v285
    inc_rc v272
    v303 = allocate -> &mut u1
    store u1 1 at v303
    jmp b1(u32 0)
  b1(v160: u32):
    v304 = lt v160, u32 3
    jmpif v304 then: b2, else: b3
  b2():
    v305 = load v303 -> u1
    v320 = lt v160, u32 3
    constrain v320 == u1 1, "Index out of bounds"
    store v305 at v303
    v307 = add v160, u32 1
    jmp b1(v307)
  b3():
    v308 = load v303 -> u1
    constrain v308 == u1 1
    v313 = allocate -> &mut u1
    store u1 1 at v313
    jmp b4(u32 0)
  b4(v179: u32):
    v314 = lt v179, u32 3
    jmpif v314 then: b5, else: b6
  b5():
    v315 = load v313 -> u1
    v321 = lt v179, u32 3
    constrain v321 == u1 1, "Index out of bounds"
    store v315 at v313
    v317 = add v179, u32 1
    jmp b4(v317)
  b6():
    v318 = load v313 -> u1
    constrain v318 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v319 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v319
}

After Inlining Brillig Calls Inlining:
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    call __debug_var_assign(Field 4, Field 2)
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    call __debug_var_assign(Field 6, Field 4, f13)
    call __debug_var_assign(Field 4, Field 5)
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v322 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v322
    call __debug_var_assign(Field 14, v322)
    inc_rc v322
    v323 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v323
    call __debug_var_assign(Field 15, v323)
    inc_rc v323
    inc_rc v322
    v324 = allocate -> &mut u1
    store u1 1 at v324
    jmp b1(u32 0)
  b1(v160: u32):
    v325 = lt v160, u32 3
    jmpif v325 then: b2, else: b3
  b2():
    v326 = load v324 -> u1
    constrain v325 == u1 1, "Index out of bounds"
    store v326 at v324
    v327 = add v160, u32 1
    jmp b1(v327)
  b3():
    v328 = load v324 -> u1
    constrain v328 == u1 1
    v329 = allocate -> &mut u1
    store u1 1 at v329
    jmp b4(u32 0)
  b4(v179: u32):
    v330 = lt v179, u32 3
    jmpif v330 then: b5, else: b6
  b5():
    v331 = load v329 -> u1
    constrain v330 == u1 1, "Index out of bounds"
    store v331 at v329
    v332 = add v179, u32 1
    jmp b4(v332)
  b6():
    v333 = load v329 -> u1
    constrain v333 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v334 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v334
}

After Dead Instruction Elimination (2nd):
brillig(inline) fn main f0 {
  b0(v0: Field):
    call __debug_fn_enter(u32 0)
    call __debug_var_assign(Field 0, v0)
    call __debug_var_assign(Field 1, Field 4)
    call __debug_fn_enter(u32 3)
    call __debug_fn_exit(u32 3)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 7)
    call __debug_var_assign(Field 9, Field 5)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 2, Field 42)
    call __debug_var_assign(Field 3, Field 42, f10)
    call __debug_var_assign(Field 4, Field 2)
    call __debug_var_assign(Field 4, Field 3)
    call __debug_var_assign(Field 5, Field 3)
    call __debug_var_assign(Field 4, Field 4)
    call __debug_var_assign(Field 6, Field 4, f13)
    call __debug_var_assign(Field 4, Field 5)
    call __debug_fn_enter(u32 6)
    call __debug_var_assign(Field 10, u32 32)
    call __debug_var_assign(Field 11, u32 32, Field 51)
    call __debug_var_drop(Field 10)
    call __debug_var_drop(Field 11)
    call __debug_fn_exit(u32 6)
    call __debug_fn_enter(u32 5)
    call __debug_var_assign(Field 8, Field 16)
    call __debug_var_assign(Field 9, Field 3)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 3)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_fn_enter(u32 4)
    call __debug_var_assign(Field 12, Field 4)
    call __debug_var_drop(Field 12)
    call __debug_fn_exit(u32 4)
    call __debug_var_drop(Field 9)
    call __debug_var_drop(Field 8)
    call __debug_fn_exit(u32 5)
    call __debug_var_assign(Field 7, Field 5)
    call __debug_fn_enter(u32 1)
    call __debug_var_assign(Field 13, i32 2)
    v322 = make_array [i32 1, i32 2, i32 3] : [i32; 3]
    inc_rc v322
    call __debug_var_assign(Field 14, v322)
    inc_rc v322
    v323 = make_array [i32 2, i32 4, i32 6] : [i32; 3]
    inc_rc v323
    call __debug_var_assign(Field 15, v323)
    inc_rc v323
    inc_rc v322
    v324 = allocate -> &mut u1
    store u1 1 at v324
    jmp b1(u32 0)
  b1(v160: u32):
    v325 = lt v160, u32 3
    jmpif v325 then: b2, else: b3
  b2():
    v326 = load v324 -> u1
    constrain v325 == u1 1, "Index out of bounds"
    store v326 at v324
    v327 = add v160, u32 1
    jmp b1(v327)
  b3():
    v328 = load v324 -> u1
    constrain v328 == u1 1
    v329 = allocate -> &mut u1
    store u1 1 at v329
    jmp b4(u32 0)
  b4(v179: u32):
    v330 = lt v179, u32 3
    jmpif v330 then: b5, else: b6
  b5():
    v331 = load v329 -> u1
    constrain v330 == u1 1, "Index out of bounds"
    store v331 at v329
    v332 = add v179, u32 1
    jmp b4(v332)
  b6():
    v333 = load v329 -> u1
    constrain v333 == u1 1
    call __debug_var_drop(Field 15)
    call __debug_var_drop(Field 13)
    call __debug_var_drop(Field 14)
    call __debug_fn_exit(u32 1)
    v334 = add v0, Field 5
    call __debug_var_drop(Field 0)
    call __debug_var_drop(Field 6)
    call __debug_var_drop(Field 2)
    call __debug_var_drop(Field 5)
    call __debug_var_drop(Field 4)
    call __debug_var_drop(Field 7)
    call __debug_var_drop(Field 1)
    call __debug_var_drop(Field 3)
    call __debug_fn_exit(u32 0)
    return v334
}

[higher_order_functions] Starting debugger
At opcode 0:0 :: BRILLIG CALL func 0: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(0))], q_c: 0 })], outputs: [Simple(Witness(1))]
Debugger execution halted.
