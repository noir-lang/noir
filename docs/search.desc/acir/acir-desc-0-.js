searchState.loadedDescShard("acir", 0, "C++ code generation for ACIR format, to be used by …\nThis trait is extremely unstable and WILL have breaking …\nMsgpack with named structs.\nMsgpack with tuple structs.\nA marker byte for the serialization format.\nThe Abstract Circuit Intermediate Representation (ACIR)\nReturns the closest number of bytes to the bits specified …\nReturns the argument unchanged.\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes in little-endian order into a FieldElement …\nCalls <code>U::from(self)</code>.\nComputes the inverse or returns zero if the inverse does …\nMaximum number of bits needed to represent a field element …\nMaximum numbers of bytes needed to represent a field …\nLow-level native types used within the crate::circuit …\nThis is the number of bits required to represent this …\nSerialization formats we consider using for the bytecode …\nReturns the vale of this field as a hex string without the …\nDowncast the field into a <code>i128</code>. Panic if the value does …\nConverts the field element to a vector of bytes in …\nReturns the value of this field as a hex string with …\nDowncast the field into a <code>u128</code>. Panic if the value does …\nDowncast the field into a <code>u128</code> if it fits into 128 bits, …\nOpcodes are locatable so that callers can map opcodes to …\nPayload tied to an assertion failure. This data allows …\nIndex of Brillig opcode within a list of Brillig opcodes. …\nRepresentation of a single ACIR circuit. The execution …\nValue for differentiating error types. Used internally by …\nEnumeration of either an expression or a memory identifier.\nSpecifies the maximum width of the expressions which will …\nOpcodes are locatable so that callers can map opcodes to …\nA program represented by multiple ACIR circuit’s. The …\nMaps opcode locations to failed assertion payloads. The …\nBlack box functions are ACIR opcodes which rely on …\nThis module contains Brillig structures for integration …\nReturns all witnesses which are required to execute the …\nCompress a serialized Program.\nThe current highest witness index in the circuit.\nDeserialize bytecode.\nDeserialize and base64 decode program\nSelector that maps a hash of either a constant string or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a Program object from the given string.\nCreates a Circuit object from the given string.\nName of the function represented by this circuit.\nReturns the witness index of each public input\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nACIR opcodes\nThe circuit opcodes representing the relationship between …\nThe dynamic payload data.\nThe set of private inputs to the circuit.\nReturns all public inputs. This includes those provided as …\nThe set of public inputs provided by the prover.\nDecompress and deserialize bytes into a Program.\nThe set of public inputs calculated within the circuit.\nSerialize and compress a Program into bytes, using the …\nSerialize, compress then base64 encode a Program, using …\nSerialize and compress a Program into bytes, using the …\nMore details can be found at …\nMore details can be found at …\nRepresentation of available black box function names. This …\nAn iterator over the variants of Self\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nMore details can be found at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is purely a wrapper struct around a list of Brillig …\nId for the function being called. Indexes into the table …\nInputs for the Brillig VM. These are the initial inputs …\nOutputs for the Brillig VM. Once the VM has completed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCiphers (encrypts) the provided plaintext using AES128 in …\nPerforms the bitwise AND of <code>lhs</code> and <code>rhs</code>. <code>bit_size</code> must be …\nAn <code>AssertZero</code> opcode adds the constraint that <code>P(w) = 0</code>, …\nThese opcodes represent a specialized computation. Even if …\nCalls to “gadgets” which rely on backends implementing …\nComputes the Blake2s hash of the inputs, as specified in …\nComputes the Blake3 hash of the inputs\nIdentifier for a block of memory\nType for a memory block\nCalls to unconstrained functions. Unconstrained functions …\nCalls to functions represented as a separate circuit. A …\nIndicate to the backend that this memory comes from a …\nA constant field element\nVerifies a ECDSA signature over the secp256k1 curve.\nVerifies a ECDSA signature over the secp256r1 curve.\nAddition over the embedded curve on which the witness is …\nEnumeration for black box function inputs\nKeccak Permutation function of width 1600\nOperation on a block of memory We can either write or read …\nThe default type of memory block. Virtually all user …\nInitialize an ACIR array from a vector of witnesses.\nAtomic operation on a block of memory\nMultiple scalar multiplication (MSM) with a variable …\nDefines an operation within an ACIR circuit\nApplies the Poseidon2 permutation function to the given …\nRange constraint to ensure that a witness can be …\nComputes a recursive aggregation object when verifying a …\nSimilar to calldata except it states that this memory is …\nApplies the SHA-256 compression function to the input …\nA witness element, representing dynamic inputs\nPerforms the bitwise XOR of <code>lhs</code> and <code>rhs</code>. <code>bit_size</code> must be …\nBlack box functions are ACIR opcodes which rely on …\nDisplays an opcode, optionally using the provided return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\narray index, it must be less than the array length\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA constant expression that can be 0 (read) or 1 (write)\nthe value we are reading, when operation is 0, or the …\nVector of 8 u32s used to compress the input\nInput state for the permutation of Poseidon2\n512 bits of the input message, represented by 16 u32s\nA key hash is used to check the validity of the …\nPermuted state\nOutput of the compression, represented by 8 u32s\nA predicate (true or false) to disable the recursive …\nBackend-specific proof type constant. The proof field is …\nThese represent the public inputs of the proof we are …\nVerification key of the circuit being verified\nIdentifier of the array\nIdentifier of the array\nSpecify what type of memory we should initialize\nId for the function being called. It is the responsibility …\nId for the function being called. It is the responsibility …\nVector of witnesses specifying the initial value of the …\nInputs to the function call\nInputs to the function call\nDescribe the memory operation to perform\nOutputs to the function call\nOutputs of the function call\nPredicate of the Brillig execution - when the predicate …\nPredicate of the circuit execution - when the predicate …\nCiphers (encrypts) the provided plaintext using AES128 in …\nPerforms the bitwise AND of <code>lhs</code> and <code>rhs</code>. <code>bit_size</code> must be …\nThese opcodes represent a specialized computation. Even if …\nComputes the Blake2s hash of the inputs, as specified in …\nComputes the Blake3 hash of the inputs\nA constant field element\nVerifies a ECDSA signature over the secp256k1 curve.\nVerifies a ECDSA signature over the secp256r1 curve.\nAddition over the embedded curve on which the witness is …\nEnumeration for black box function inputs\nKeccak Permutation function of width 1600\nMultiple scalar multiplication (MSM) with a variable …\nApplies the Poseidon2 permutation function to the given …\nRange constraint to ensure that a witness can be …\nComputes a recursive aggregation object when verifying a …\nApplies the SHA-256 compression function to the input …\nA witness element, representing dynamic inputs\nPerforms the bitwise XOR of <code>lhs</code> and <code>rhs</code>. <code>bit_size</code> must be …\nVector of 8 u32s used to compress the input\nInput state for the permutation of Poseidon2\n512 bits of the input message, represented by 16 u32s\nA key hash is used to check the validity of the …\nPermuted state\nOutput of the compression, represented by 8 u32s\nA predicate (true or false) to disable the recursive …\nBackend-specific proof type constant. The proof field is …\nThese represent the public inputs of the proof we are …\nVerification key of the circuit being verified\nId for the function being called. Indexes into the table …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifier for a block of memory\nOperation on a block of memory We can either write or read …\narray index, it must be less than the array length\nA constant expression that can be 0 (read) or 1 (write)\nCreates a <code>MemOp</code> which reads from memory at <code>index</code> and …\nthe value we are reading, when operation is 0, or the …\nCreates a <code>MemOp</code> which writes the <code>Expression</code> <code>value</code> into …\nAn expression representing a quadratic polynomial.\nAn index that represents the position a witness value will …\nA map from the witnesses in a constraint system to the …\nAn ordered set of witness maps for separate circuits\nNative error for serializing/deserializing a witness stack.\nReturns the argument unchanged.\nCreates an Expression from a Witness.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a Expression object from the given string.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollection of linear terms in the expression.\nCollection of multiplication terms.\nA constant term in the expression\nAn expression representing a quadratic polynomial.\nReturns <code>self + k*b</code>\nDisplays an expression as a quadratic polynomial. If …\nReturns <code>true</code> if the expression represents a constant …\nReturns <code>true</code> if the expression can be seen as a degree-1 …\nReturns <code>true</code> if highest degree term in the expression is …\nCollection of linear terms in the expression.\nCollection of multiplication terms.\nReturns the number of multiplication terms\nAdds a new linear term to the <code>Expression</code>.\nAdds a new quadratic term to the <code>Expression</code>.\nA constant term in the expression\nSorts opcode in a deterministic order XXX: We can probably …\nReturns a <code>FieldElement</code> if the expression represents a …\nReturns a <code>Witness</code> if the <code>Expression</code> can be represented as …\nDetermine the width of this expression. The width meaning …\nReturns <code>w*b.linear_combinations</code>\nAn index that represents the position a witness value will …\nA map from the witnesses in a constraint system to the …\nDecompress and deserialize.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialize and compress.\nSerialize and compress with a given format.\nAn ordered set of witness maps for separate circuits\nNative error for serializing/deserializing a witness stack.\nDecompress and deserialize.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIndex into a crate::circuit::Program function list for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the size of the stack\nReturns the top element of the stack, or <code>None</code> if it is …\nRemoves the top element from the stack and return its\nAppend an element to the top of the stack\nSerialize and compress.\nSerialize and compress with a given format.\nA full witness for the respective constraint system …\nContains the error value\nContains the success value\nReturns true if the token is eaten and bumps to the next …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse multiple Circuit blocks and return a Program.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nASSERT\nbits\nBLACKBOX\nBlock index, like <code>b42</code>\nBRILLIG\nCALL\nCALLDATA\n:\n,\n=\nfunc\nhash_values\nhashed_message\nIdentifier such as <code>RANGE</code>, <code>AND</code>, etc.\ninput\ninput1\ninput2\ninputs\nInteger value represented using the underlying native …\niv\nkey\nkey_hash\nACIR human readable text format keywords\nReserved identifiers such as <code>CONSTRAIN</code>. Most words in ACIR…\n[\n(\nlhs\nINIT\nREAD\nWRITE\noutput\noutputs\nparameters\npoints\npredicate\nprivate\nproof\nproof_type\npublic\npublic_inputs\npublic_key_x\npublic_key_y\nreturn\nRETURNDATA\nrhs\n]\n)\nscalars\n;\nsignature\nToken types used in the ACIR text format.\nvalue\nvalues\nverification_key\nWitness index, like <code>w42</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA marker byte for the serialization format.\nMsgpack with named structs.\nMsgpack with tuple structs.\nDeserialize any of the supported formats.\nLook for a <code>NOIR_SERIALIZATION_FORMAT</code> env var to turn on …\nDeserialize a value using MessagePack, based on <code>serde</code>.\nSerialize a value using MessagePack, based on <code>serde</code>.")