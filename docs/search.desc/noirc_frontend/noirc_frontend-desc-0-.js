searchState.loadedDescShard("noirc_frontend", 0, "The noir compiler is separated into the following passes …\nThe submodules of this module define the various data …\nNoir’s Hir is the result of the name resolution step …\nThe lexer is the first pass of the noir compiler. Its goal …\nComing after type checking, monomorphization is the last …\nThis module implements the “ownership analysis” …\nThe parser is the second pass of the noir compiler. The …\nThe <code>shared</code> module contains simple types which are using in …\nThis crate represents utility methods which can be useful …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nAn “as Trait” path leading to an associated type. E.g. …\nAn iterator over the variants of Self\nThis statement should be executed at compile-time\nReturns type is not specified.\nIf implicitly_added is true, this operation was implicitly …\nThis is used when an identifier fails to parse in the …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nCurrently, we support four types of functions:\nAn argument to a generic type or trait.\nAn iterator over the variants of Self\nInterned statements are allowed to be parsed as …\nRepresents whether the definition can be referenced …\nRepresents an Ast form that can be assigned to\nA Named UnresolvedType can be a struct type or a type …\nA named argument, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nAst node for an enum\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nAst node for type aliases\nAn ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\n&amp;T and &amp;mut T\nAlready-resolved generics can be parsed as generics when a …\nThis path is a Crate or Dep path which always points to …\nAn already resolved type. These can only be parsed if they …\nAst node for statements in noir. Statements are always …\nA Trait as return type or parameter of function, including …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nEverything else.\nAst node for an impl of a concrete type …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nA Vec of unresolved names for type variables. For …\nRepresents a simple trait constraint such as …\nThe parser parses types as ’UnresolvedType’s which …\nThe precursor to TypeExpression, this is the type that the …\nImplements the Visitor pattern for Noir’s AST.\nThis is used to represent an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function was defined with the ‘comptime’ …\ntrue if generated at compile-time, e.g. from a trait alias\nTrue if this function was defined with the ‘unconstrained…\nThe kind of each argument, in order (in case traversing …\nAll named arguments, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nEach ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nThis is None for tag variants without parameters. A value …\nIndicate if this function was defined with the ‘pub’ …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nAst node for an enum\nThis is None for tag variants without parameters. A value …\nAn iterator over the variants of Self\nReturns type is not specified.\nIf implicitly_added is true, this operation was implicitly …\nInterned statements are allowed to be parsed as …\nAlready-resolved generics can be parsed as generics when a …\nEverything else.\nA Vec of unresolved names for type variables. For …\nConverts a token to a unary operator If you want the …\nMethod calls have an optional list of generics if the …\n<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>\nComparator operators return a 0 or 1 When seen in the …\nTrue if this function was defined with the ‘comptime’ …\n<code>==</code> and <code>!=</code>\nTrue if this function was defined with the ‘unconstrained…\nReturns the innermost location that gives this expression …\nIndicate if this function was defined with the ‘pub’ …\nCurrently, we support four types of functions:\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nThis statement should be executed at compile-time\nThis is used when an identifier fails to parse in the …\nRepresents an Ast form that can be assigned to\nThis path is a Crate or Dep path which always points to …\nAst node for statements in noir. Statements are always …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nThis is used to represent an …\nConstruct a PathKind::Plain from this single\nGets the underlying identifier without its location.\nCreate a ‘for’ expression taking care of desugaring a …\nCreate a half-open range bounded inclusively below and …\nCreate a half-open range, bounded inclusively below and …\nReturns the span where turbofish happen. For example:\nReturns the innermost location that gives this statement …\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nAst node for an impl of a concrete type …\nRepresents a simple trait constraint such as …\nMoves trait bounds from generics into where clauses. For …\ntrue if generated at compile-time, e.g. from a trait alias\nAst node for type aliases\nImplements the Visitor pattern for Noir’s AST.\nThis structure is used to collect information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluating a comptime call like <code>Module::add_item</code>\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nResolverMetas are tagged onto each definition to track how …\nA function attribute generated an item that’s being …\nDetermines whether we are in an unsafe block and, if so, …\nAdd the given generics to scope. Each generic will have a …\nFor each associated type that isn’t mentioned in a trait …\nHandles the TypeVariable case for checking binary …\nCall a macro function and inlines its code at the call …\nDefaults all type variables used in this function context …\nType checks a field access, adding dereference operators …\nCheck that all the generics show up in <code>self_type</code> (if they …\nOnly sized types are valid to be used as main’s …\nCheck that an item such as a struct field or type alias is …\nIssue an error if the impl is stricter than the trait.\nResolve an attribute to the function it refers to and add …\nThe current dependency item we’re resolving. Used to …\nThe trait  we’re currently resolving, if we are …\nIf we’re currently resolving methods within a trait …\nThe scope of –debug-comptime, or None if unset\nDefines the value of an enum variant that we resolve an …\nExtract metadata from a NoirFunction to be used in …\nThis turns function parameters of the form: …\nExpands any traits in a where clause to mention all …\nElaborates an expression knowing that it has to match a …\nIf the given global is unresolved, elaborate it and return …\nPerform the given function in a comptime context. This …\nElaborate an expression from the middle of a comptime …\nFor elaborating a lambda we might get <code>parameters_type_hints</code>…\nElaborate a local or global let statement. If this is a …\nElaborates an lvalue returning:\nCompiles the rows of a match expression, outputting a …\nTo elaborate the rules of a match we need to go through …\nEquivalent to <code>elaborate_pattern</code>, this version just also …\nSometimes items are elaborated because a function …\nChecks whether <code>variable</code> is <code>Self::method_name</code> or …\nUnstable compiler features that were explicitly enabled. …\nRun the given function using the resolver and return true …\nConvert an expression into a Pattern, defining any …\nFind the struct in the parent module so we can know its …\nGo through the given tokens looking for a ‘$’ token …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis is a stack of function contexts. Most of the time, …\nContains a mapping of the current struct or functions’s …\nTrue if we’re currently within a <code>comptime</code> block, …\nTrue if we’re elaborating a comptime item such as a …\nTrue if we’re currently within a constrained function. …\nReturns <code>true</code> if the current module is a contract.\nInsert as many dereference operations as necessary to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhen resolving lambda expressions, we need to keep track …\nThe current module this elaborator is in. Initially empty, …\nLookup a given trait by name/path.\nLooks up a given type by name. This will also instantiate …\nOptions from the nargo cli\nConvert a PathResolutionItem - usually an enum variant or …\nTrue if we should use pedantic ACVM solving\nUse pedantic ACVM solving\nReturn a fresh integer type variable and log it in …\nReturn a fresh integer or field type variable and log it …\nTrue if the <code>pub</code> keyword is allowed on parameters in this …\nPush a type variable into the current FunctionContext to …\nPush an <code>ExprId</code> that corresponds to an integer literal. At …\nPush a type variable (its ID and type) as a required type …\nPush a trait constraint into the current FunctionContext …\nRuns <code>f</code> and if it modifies <code>self.generics</code>, <code>self.generics</code> is …\nResolve all the fields of a struct constructor expression. …\nResolve all the fields of a struct constructor expression. …\nResolve generics using the expected kinds of the function …\nReturn the kind of an unresolved generic. If a numeric …\nTranslates a (possibly Unspecified) UnresolvedType to a …\nSolve any generics that are part of the path before the …\nResolves a Path assuming we are inside <code>starting_module</code>. …\nResolves a path in <code>current_module</code>. <code>importing_module</code> is the …\nResolves a path in the current module. If the referenced …\nIdentical to <code>resolve_type_args</code> but does not allow …\nResolves a trait constraint and adds it to scope as an …\nResolve the given trait constraints and add them to scope …\nTranslates an UnresolvedType to a Type with a …\nThis resolves a method in the form <code>Type::method</code> where …\nTranslates an UnresolvedType into a Type and appends any …\nIn-resolution names\nGiven a list of functions and the trait they belong to, …\nRun all the attributes on each item in the crate in …\nthe index in the scope tree (sometimes being filled by …\nSet to the current type if we’re resolving an impl\nCheck whether a functions return value and args should be …\nIf greater than 0, field visibility errors won’t be …\nEach constraint in the <code>where</code> clause of the function …\nCheck if the given method type requires a mutable …\nGiven a method object: <code>(*foo).bar</code> of a method call …\nPrerequisite: verify_trait_constraint of the operator’s …\nReturn a fresh integer type variable and log it in …\nWrapper of Type::unify_with_coercions using self.errors\nDo not apply type bindings even after a successful …\nThese are the globals that have yet to be elaborated. This …\nRegister a use of the given unstable feature. Errors if …\nLookup and use the specified variable. This will increment …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA pattern binding a variable such as <code>a</code> or <code>_</code>\nA pattern checking for a tag and possibly binding …\nAn error occurred while translating this pattern. This …\nAn integer literal pattern such as <code>4</code>, <code>12345</code>, or <code>-56</code>\nMultiple patterns combined with <code>|</code> where we should match …\nA Pattern is anything that can appear before the <code>=&gt;</code> in a …\nAn integer range pattern such as <code>1..20</code> which will match …\nReturn the variable that was referred to the most in <code>rows</code>\nCompiles the cases and sub cases for the constructor …\nCompiles the cases and fallback cases for integer and …\nMove any cases with duplicate branches into a shared ‘…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTraverse the resulting HirMatch to build counter-examples …\nIssue a missing cases error if necessary for the given …\nAny case that isn’t branched to when the match is …\nCreates: <code>{ let &lt;variable&gt; = &lt;rhs&gt;; &lt;body&gt; }</code>\nThe type variable corresponds to the type of an array …\nThe kind of required type variable.\nThe type variable corresponds to an identifier, whose …\nA type variable that is required to be bound after …\nThe type variable corresponds to a struct generic, in a …\nAll type variables created in the current function. This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll ExprId in a function that correspond to integer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType variables that must be bound at the end of the …\nTrait constraints are collected during type checking until …\nCheck if an expression will end up calling a specific …\nChecks if an ExprId, which has to be an integer literal, …\nInline attributes are only relevant for constrained …\nAttempting to define new low level (<code>#[builtin]</code> or …\n<code>pub</code> is required on return types for entry point functions\nOracle functions may not be called by constrained …\nOracle definitions (functions with the <code>#[oracle]</code> …\nCheck that a recursive function <em>can</em> return without …\nCheck that we are not passing a mutable reference from a …\nCheck that we are not passing a slice from an …\nOnly arguments to entrypoint functions may have a …\nOnly entrypoint functions require a <code>pub</code> visibility …\nOptions from nargo_cli that need to be passed down to the …\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nGeneric options struct meant to resolve to …\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nA sane default of frontend options for running tests\nContains the error value\nFound a method.\nMultiple trait method matches were found and they are all …\nThere’s only one trait method that matches, but it’s …\nFound a trait method and it’s currently in scope.\nA reference to a global value.\nAny item that can appear before the last segment in a path.\nA function call on a module, for example …\nThe method could not be found. There might be trait …\nContains the success value\nAll possible items that result from resolving a Path. Note …\nDetermines whether datatypes found along a path are to be …\nDepenending on where a path appears in the source code it …\nA function call on a primitive type, for example …\nA function call on <code>Self</code>, for example <code>Self::function()</code>. …\nA function call on a trait, for example <code>Trait::function()</code> …\nA function call on a type alias, for example …\nA function call on a type that resolves to a trait method, …\nLike a <code>crate::ast::Path</code> but each segment has resolved …\nLike a <code>crate::ast::PathSegment</code> but with resolved turbofish …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a PathKind::Plain from this single\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the span where turbofish happen. For example:\nAn iterator over the variants of Self\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe possible errors of interpreting given code into a …\nReturns the argument unchanged.\nInterpret source code using the elaborator, without …\nCalls <code>U::from(self)</code>.\nChecks that the type of a function in a trait impl matches …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nXXX: This is bare-bone for two reasons:\nA dependency is a crate name and a crate_id This means …\nThe special case of running the compiler against the …\nTries to find the requested crate in the current one’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper object which groups together several useful context …\nActivates LSP mode, which will track references for all …\nThe comptime interpreter is used to execute Noir code …\nReturn the CrateId for each crate that has been compiled …\nThis set of modules implements the name resolution pass …\nReturns the CrateDefMap for a given CrateId. It is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a fully-qualified path to the given TypeId from …\nReturns a list of all functions in the current crate …\nReturns a list of all functions in the current crate …\nReturns the FuncId of the ‘main’ function in a crate.\nWriter for comptime prints.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis set of modules implements the second half of the name …\nGenerics need to be resolved before elaboration to …\nA map of each file that already has been visited from a …\nComptime errors always wrap another error to show it …\nThe possible errors that can halt the interpreter.\nStateful bigint calculator.\nMaps each bound generic to each binding it has in the …\nTo expand macros the Interpreter needs access to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluates any expressions within UnquoteMarkers in the …\nTries to print tokens in a way that it’ll be easier for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines whether the last outputted byte was …\nComptime errors always wrap another error to show it …\nContains the error value\nThe possible errors that can halt the interpreter.\nContains the success value\nStateful bigint calculator.\nMaps each bound generic to each binding it has in the …\nBounds check the given array and index pair. This will …\nCall a non-builtin function\nDefine a new variable in the current scope\nTo expand macros the Interpreter needs access to the …\nEnters a function, pushing a new scope and resetting any …\nEvaluate an expression and return the result. This will …\nEvaluating a mutable variable will dereference it …\nEvaluates a numeric generic with the value <code>value</code> (expected …\nGiven the result of a <code>cmp</code> operation, convert it into the …\nTry to retrieve a function’s body. If the function has …\nMutate an existing variable, potentially from a prior scope\nGiven a type, assert that it’s an <code>Option&lt;T&gt;</code> and return …\nCreates a value that holds an <code>Option</code>. <code>option_type</code> must be …\nfn as_type(self) -&gt; Type\nfn fields(self, generic_args: Type) -&gt; [(Quoted, Type, …\nfn fields_as_written(self) -&gt; [(Quoted, Type, Quoted)] …\nfn generics(self) -&gt; [(Type, <code>Option&lt;Type&gt;</code>)]\nfn set_fields(self, new_fields: [(Quoted, Type, Quoted)]) …\nType to be used in <code>Value::Array(&lt;values&gt;, &lt;array-type&gt;)</code>.\nType to be used in <code>Value::Slice(&lt;values&gt;, &lt;slice-type&gt;)</code>.\nInterpret the input as an array, then map each element. …\nGet an array and convert it to a fixed size. Returns the …\nInterpret the input as a slice, then map each element. …\nGet a specific field of a struct and apply a decoder …\nGet the fields if the value is a <code>Value::Struct</code>, otherwise …\nCreate a <code>Value::Array</code> from bytes.\nCreate a <code>Value::Slice</code> from bytes.\nCreate a <code>Value::Struct</code> from fields and the expected return …\nNo-op also covers the zero-extend case since we convert …\nConvert the input value to a (field, sign) pair. …\nevaluate_cast without recursion\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n<code>fn from_le_bytes(bytes: [u8], modulus: [u8]) -&gt; BigInt</code>\n<code>fn bigint_add(self, other: BigInt) -&gt; BigInt</code>\n<code>fn to_le_bytes(self) -&gt; [u8; 32]</code>\nRun one of the Blake hash functions.\nRun one of the Secp256 signature verifications.\nDecode a <code>BigInt</code> struct.\nDecode an <code>EmbeddedCurvePoint</code> struct.\nDecode an <code>EmbeddedCurveScalar</code> struct.\n<code>fn keccakf1600(input: [u64; 25]) -&gt; [u64; 25] {}</code>\n…\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns false for non-integral <code>Value</code>s.\nConverts any non-negative <code>Value</code> into a <code>FieldElement</code>. …\nUnwraps an Rc value without cloning the inner value if the …\nGiven a Crate root, collect all definitions in that crate\nMaps the type and the module id in which the impl is …\nStores all of the unresolved functions in a particular …\nCollect all of the definitions in a given crate into a …\nSeparate the globals Vec into two. The first element in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the primary location where this error happened.\nGiven a module collect all definitions into ModuleData\nWalk a module and collect its definitions.\nCollect any enum definitions declared within the ast. …\nCollect any struct definitions declared within the ast. …\nReturns a tuple of (methods, associated types, associated …\nCollect any traits definitions declared within the ast. …\nCollect any type aliases definitions declared within the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSearch for a module named <code>mod_name</code> Parse it, add it as a …\nAdd a child module to the current def_map. On error this …\nAdd a child module to the current def_map. On error this …\nReturns true if a module’s child modules are expected to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap of all modules and scopes defined within a crate.\nLets first check if this is offered by any external crate …\nThe name that is used for a non-contract program’s …\nContains the actual contents of a module: its parent (if …\nA generic ID that references either a module, function, …\nGets the index that underlies this local module ID.\nEach child in the order they were declared in the parent …\nCollect all definitions in the crate\nContains only the definitions directly defined in the …\nMaps an external dependency’s name to its root module id.\nReturns the reason for the test function to fail if …\nReturns the reason for the fuzzing harness to fail if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the ModuleData stored at …\nReturns an iterator over all contract modules within the …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nFind a child module’s name by inspecting its parent. …\nReturn a topological ordering of each module such that any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nFind the main function for this crate\nConstructs a new <code>CrateDefMap</code>, containing only the crate’…\nReturns true if the fuzzing harness has been specified to …\nReturns this module’s parent, if there’s any.\nGiven a FileId, fetch the File, from the FileManager and …\nContains all definitions visible to the current module. …\nReturns true if the test function has been specified to …\nReturns true if the fuzzing harness has been specified to …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nReturns an Err if there is already an item in the …\nContains the actual contents of a module: its parent (if …\nEach child in the order they were declared in the parent …\nContains only the definitions directly defined in the …\nFinds a trait in scope and returns its name (either the …\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nContains all definitions visible to the current module. …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nReturn an iterator over all definitions defined within …\nA generic ID that references either a module, function, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if any point of <code>self</code> intersects a point of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the name that’s brought into scope: either the …\nResolves a Path in a <code>use</code> statement, assuming it’s …\nGiven a Path and a ModuleId it’s being used in, this …\nReturns true if an item with the given visibility in the …\nReturns true if <code>target</code> is a struct and its parent is …\nThis implementation uses the terminology Scope and …\nScopeTree allows one to specify that maps within the same …\nEnding a function requires that we removes it’s whole …\nEnds the current scope - this should correspond with the …\nReturns an iterator over all of the elements which satisfy …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the last pushed scope from the current scope tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarting a function requires a new scope tree, as you do …\nThe beginning of a scope always correlates with the start …\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nRepresents something that can be generic over type …\nTraitGenerics are different from regular generics in that …\nTrue if this item kind can ever accept named type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach ordered generic kind on this type, excluding any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of this kind of item, for error messages. E.g. “…\nThe name of this item, usually named by a user. E.g. “Foo…\nA Failure node in the match. <code>missing_case</code> is true if this …\nA method can be defined in a regular <code>impl</code> block, in which …\nRun <code>body</code> if the given expression is true. Otherwise …\nA variable captured inside a closure\nCorresponds to <code>assert</code> and <code>assert_eq</code> in the source code. …\nAn enum constructor is an expression such as …\nA HirExpression is the result of an Expression in the AST …\nCorresponds to a variable in the source code\nIndexing, as in <code>array[index]</code>\nThis is always a struct field access <code>my_struct.field</code> and …\nThese nodes are temporary, they’re lowered into …\nThis ident is not a trait method\nJump directly to ExprId\nSwitch on the given variable with the given cases to test. …\nA method or constant defined in a trait\nThis ident refers to a trait method and its impl needs to …\nOr a method can come from a Trait impl block, in which case\nReturn all the constructors of this type from one …\nThis refers to just the arguments that are passed. E.g. …\nNote that this <em>must</em> be the id of the function or constant …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics provided by …\nIf this HirIdent refers to a trait method, this field …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this constructor constructs an enum value. Enums …\nTrue if we should return an offset of the field rather …\nTrue if this constructor constructs a tuple or struct …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nThe trait method id for the operator trait method that …\nThe trait method id for the operator trait method that …\nThis will be None when the capture refers to a local …\nA FuncMeta contains the signature of the function and any …\nA Hir function is a block expression with a list of …\nAn interned function parameter from a function definition\nAll the generics used by this function, which includes any …\nThe set of generics that are declared directly on this …\nIf this function is the one related to an enum variant, …\nTrait constraints that came either from a parent item (for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrue if this function is marked with an attribute that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function is an entry point to the program. …\nA stub function does not have a body. This includes …\nThe HirIdent of each identifier within the parameter list. …\nGives the (uninstantiated) return type of this function.\nIf this function is from an impl (trait or regular impl), …\nThe crate this function was defined in\nTHe file this function was defined in\nThe module this function was defined in\nTake this function body, returning an owned version while …\nTrait constraints that were specifiied directly on this …\nThe trait impl this function belongs to, if any\nThe type of this function. Either a Type::Function or a …\nThe type this method belongs to, if any\nCorresponds to <code>lvalue = expression;</code> in the source code\nRepresents an Ast form that can be assigned to. These can …\nA HirStatement is the result of performing name resolution …\nCreates a new ‘basic’ let statement with no attributes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the fields of this pattern. Panics if the …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\n<code>index</code> is required to be an identifier to simplify …\nRepresents a trait in the type system. Each instance of …\nReturns a TraitConstraint for this trait using Self as the …\nMap from each associated constant’s name to a unique …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns both the ordered generics of this type, and its …\nA unique id representing this trait type. Used to check if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps method_name -&gt; method id. This map is separate from …\nWhen resolving the types of Trait elements, all references …\nThe resolved trait bounds (for example in …\nAny ordered type arguments on the trait this impl is for. …\nThe where clause, if present, contains each trait …\nA user-defined alias to another type. Similar to a Struct, …\nCan bind to any type\nArray(N, E) is an array of N elements of type E. It is …\nA restricted subset of binary operators useable on type …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nRepresents a struct or enum type in the type system. Each …\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> in the source …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> with additional\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nA generic integer type. This is a more specific kind of …\nA generic integer or field type. This is a more specific …\nA Kind is the type of a Type. These are used since only …\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nA type with no body is still in the process of being …\nCan bind to any type, except Type::Constant and …\nCan bind to a Type::Constant or Type::InfixExpr of the …\nThe type of quoted code in macros. This is always a …\n&amp;T\nA shared, mutable reference to some T. Wrapper is required …\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nWrap around an unsolved type\nTypeBindings are the mutable insides of a TypeVariable. …\nA list of (TypeVariableId, Kind)’s to bind to a type. …\nA TypeVariable is a mutable reference that is either bound …\nTypeVariables are stand-in variables for some type which …\nA unique ID used to differentiate different type variables\nThe unit type <code>()</code>.\nApply the given type bindings, making them permanently …\nReturn the operator that will “undo” this operation if …\nEmpty arrays and strings (which are arrays under the hood) …\nReturn the corresponding IntegerTypeSuffix if this is a …\nReturn this type as a monomorphic type - without a …\nBind this type variable to a value.\nA type’s body is private to force struct fields or enum …\nBorrows this TypeVariable to (e.g.) manually match on the …\nTry to canonicalize the representation of this type. …\nOnly simplify constants and drop/skip any CheckedCast’s\nOnly simplify constants and drop/skip any CheckedCast’s\nIf <code>found_checked_cast</code>, then drop additional CheckedCast’s\nRun all simplifications and drop/skip any CheckedCast’s\nReturns the default type this type variable should be …\nEnsure the given value fits in self.integral_maximum_size()\nevaluate_to_field_element with optional generic arithmetic …\nIf this type is a Type::Constant (used in array lengths), …\nReturns the field at the given index. Panics if no field …\nReturns the number of field elements required to represent …\nReturns each of this type’s field names. Returns None if …\nRetrieve the fields of this type with no modifications. …\nFollow any TypeVariable bindings within this type. Doing …\nFollow bindings if this is a type variable or generic to …\nForcibly bind a type variable to a new type - even if the …\nForcibly substitute any type variables found within this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform the actual rust numeric operation associated with …\nTakes a monomorphic type and generalizes it over each of …\nReturns the number of <code>Forall</code>-quantified type variables on …\nReturn the generics on this type as a vector of types\nReturns the field matching the given field name, as well …\nRetrieves the type of the given field name Panics if the …\nRetrieve the fields of this type. Returns None if this is …\nReturns the name and raw types of each field of this type. …\nReturns all the fields of this type, after being applied …\nRetrieve the given variant at the given variant index of …\nReturns the name and raw parameters of the variant at the …\nRetrieve the variants of this type. Returns None if this …\nReturns the name and raw parameters of each variant of …\nA unique id representing this type. Used to check if two …\nWas this named generic implicitly added?\nCreates an <code>InfixExpr</code>.\nUnifies self and other kinds or fails with a Kind error\nInstantiate this struct type, returning a Vec of the new …\nInstantiate this type, replacing any type variables it is …\nInstantiates a type with the given types. This differs …\nInstantiate this type with the given type bindings. If any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the operator that will “undo” this operation if …\nCreates an <code>InfixExpr</code> that results from the compiler trying …\nA bit of an awkward name for this function - this function …\nIf value_level, only check for Type::FieldElement, else …\nIf value_level, only check for Type::FieldElement, else …\nIf value_level, only check for Type::FieldElement, else …\nTrue if this variant was declared as a function. Required …\nCheck that if bound, it’s an integer and if unbound, …\nCheck that if bound, it’s an integer or field and if …\nWhile Kind::is_numeric refers to numeric <em>types</em>, this …\nCheck that if bound, it’s a signed integer\nCheck that if bound, it’s an unsigned integer\nTrue if this type can be used as a parameter to <code>main</code> or a …\nReturns true if a value of this type can safely pass …\nTrue if this type can be used as a parameter to an ACIR …\nTrue if the given TypeVariableId is free anywhere within …\nGiven: lhs = <code>N op C1</code> rhs = C2 Returns: <code>(N, op, C1, C2)</code> if …\nReplace any <code>Type::NamedGeneric</code> in this type with a …\nTo account for cyclic references between structs, a struct…\nSubstitute any type variables found within this type with …\nThis helper function only differs in the additional …\nSubstitute any <code>Kind::Any</code> in this type, for types that hold …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nTry to apply the array to slice coercion to this given …\nTry to bind the given type variable to self. Although the …\nTry to bind a PolymorphicInt variable to self, succeeding …\nAttempt to coerce <code>&amp;mut T</code> to <code>&amp;T</code>, returning true if this is …\nTry to simplify non-constant expressions in the form …\nTry to simplify non-constant expressions in the form …\nTry to simplify partially constant expressions in the form …\n<code>try_unify</code> is a bit of a misnomer since although errors are …\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify a type variable to <code>self</code>. This is a helper …\nUnbind this type variable, setting it to Unbound(id).\nUnifies this kind with the other. Returns true on success\nTry to unify this type with another, setting any type …\nSimilar to <code>unify</code> but if the check fails this will attempt …\nReturn the generics and type within this <code>Type::Forall</code>. …\nReturns the enum variant at the given index. Panics if no …\nReturns the function type of the variant at the given …\nReturns the function type of the variant at the given …\nRetrieve the variants of this type with no modifications. …\nIf the right-hand side is <code>expr op constant</code>, don’t try to …\nNothing special to do.\nWhen unifying types we sometimes need to adjust the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps a given <code>expression</code> in <code>expression.method()</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the error value\nThe job of the lexer is to transform an iterator of …\nContains the success value\nContains the success value\nCheck for and return the type suffix on the integer string …\nKeeps consuming tokens as long as the predicate is …\nSkips white space. They are not significant in the source …\nReturns the argument unchanged.\nGiven that some tokens can contain two characters, such as …\nCalls <code>U::from(self)</code>.\nGiven a source file of noir code, return all the tokens in …\nLex the next word in the input stream. Returns (start …\nIterates the cursor and returns the char at the new cursor …\nReads the next token, which might be a comment token …\nPeeks at the character two positions ahead. Does not …\nPeeks at the character two positions ahead and returns …\nPeeks at the next char. Does not iterate the cursor\nPeeks at the next char and returns true if it is equal to …\nIf <code>single</code> is followed by <code>character</code> then extend it as <code>double</code>…\nAllow chosen warnings to happen so they are silenced.\n&amp;\n&amp;\n-&gt;\n-&gt;\n=\n=\nAn Attribute can be either a Primary Attribute or a …\n!\n!\nRepresents a token in noir’s grammar - a word, number, …\n^\n^\n:\n:\n,\n,\n$\n$\n.\n.\n::\n::\n..\n..\n..=\n..=\n==\n==\n=&gt;\n=&gt;\nPrimary Attributes are those which a function can only …\nPrimary Attributes are those which a function can only …\nFuzzingScopr is used to specify additional annotations for …\n=\n=\nA reference to an existing crate. This is a result of …\nA reference to an interned <code>ExpressionKind</code>.\nA reference to an interned <code>LValue</code>.\nA reference to an interned <code>Pattern</code>.\nA reference to an interned <code>StatementKind</code>.\nA reference to an interned <code>UnresolvedTypeData</code>.\nAn invalid character is one that is not in noir’s …\nAn invalid character is one that is not in noir’s …\nNote that <code>self</code> is not present - it is a contextual keyword …\nAn iterator over the variants of Self\n{\n{\n[\n[\n(\n(\n&lt;\n&lt;\n&lt;=\n&lt;=\n&amp;&amp;\n&amp;&amp;\nAn attribute expected to run a comptime function of the …\nNo scope is applied and so the test must pass\n!=\n!=\nIf a test has a scope of OnlyFailWith, then it can only …\nIf a fuzzing harness has a scope of OnlyFailWith, then it …\nFor example <code>foo::bar</code> in <code>#[foo::bar(...)]</code>\n%\n%\n|\n|\nA quoted type resulting from a <code>Type</code> object in noir code …\nthe u8 is the number of hashes, i.e. r###..\nthe u8 is the number of hashes, i.e. r###..\nFor example <code>$expr</code> in <code>#[$expr(...)]</code> inside a <code>quote { ... }</code> …\n}\n}\n]\n]\n)\n)\nSecondary attributes are those which a function can have …\n;\n;\n&lt;&lt;\n&lt;&lt;\nIf a test has a scope of ShouldFailWith, then it can only …\nIf the fuzzing harness has a scope of ShouldFailWith, then …\n/\n/\n&amp; followed immediately by ‘[’ This is a lexer hack to …\nA custom tag attribute: <code>#[&#39;foo]</code>\nTestScope is used to specify additional annotations for …\nThe different kinds of tokens that are possible in the …\nThis is an implementation detail on how macros are …\nThis is an implementation detail on how macros are …\nTreat any metaprogramming functions within this one as …\nA variable-argument comptime function.\nThese are all the operators allowed as part of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns note if a deprecated secondary attribute is found\nReturns true if one of the secondary attributes is …\nTrue if the function is marked with an <code>#[export]</code> attribute.\nCheck if secondary attributes contain a specific instance.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if these attributes mean the given function is an …\nCheck whether we have an <code>inline_always</code> attribute This is …\nCheck whether we have an <code>inline</code> attribute Although we also …\nLooks up a word in the source program and returns the …\nA <code>ModuleDefId</code> captured to be offered in LSP’s …\nIf the item is available via a re-export, this contains …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item to import.\nThe item’s visibility.\nReturns true if the given ModuleDefId is visible from the …\nReturns the relative path to reach <code>module_def_id</code> named <code>name</code>…\nReturns the fully-qualified path of the given <code>ModuleDefId</code> …\nReturns the path to reach an item inside <code>target_module_id</code> …\nA user-defined alias to another type. Similar to a Struct, …\nArray(N, E) is an array of N elements of type E. It is …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nUsing nested HashMaps here lets us avoid cloning HirTypes …\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nThe context struct for the monomorphization pass.\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nThe type of quoted code in macros. This is always a …\n&amp;T\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nTypeVariables are stand-in variables for some type which …\nThe unit type <code>()</code>.\nAdds a function argument that contains type metadata that …\nExtend the arguments to <code>print</code> (which is a <code>bool</code> to show if …\nCheck that the ‘from’ and to’ sides of a CheckedCast …\nConvert a non-tuple/struct type to a monomorphized type\nCall an infix operator overloading method for the given …\nCall an operator overloading method for the given prefix …\nPrerequisite: typ = typ.follow_bindings() and: …\nFor an enum like: enum Foo { A(i32, u32), B(Field), C }\nWhen a function finishes being monomorphized, the …\nFollow any type variable links within the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunctions are keyed by their unique ID, whether they’re …\nGlobals are keyed by their unique ID because they are …\nUsed to reference existing definitions in the HIR\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA local (ie non-function) ident only\nUnlike functions, locals are only keyed by their unique ID …\nFind a captured variable in the innermost closure, and …\nFind a captured variable in the innermost closure …\nStarting from the given <code>main</code> function, monomorphize the …\nMonomorphize a numeric generic as a numeric constant. …\nMonomorphize each parameter, expanding tuple/struct …\nPatch instrumentation calls inserted for debugging. This …\nUpdate instrumentation code inserted when assigning to a …\nUpdate instrumentation code inserted on variable …\nUpdate instrumentation code for a variable being dropped …\nCall sites are instantiated against the trait method, but …\nThis module implements printing of the monomorphized AST, …\nQueue of functions to monomorphize next each item in the …\nResolve a trait item to a particular impl\nTry to evaluate certain builtin functions (currently only …\nImplements std::unsafe_func::zeroed by returning an …\nA definition is either a local (variable), function, or is …\nThe monomorphized AST is expression-based, all statements …\nFunctions marked as foldable will not be inlined and …\nA function ID corresponds directly to an index of …\nA function ID corresponds directly to an index of …\nEach identifier is given a unique ID to distinguish …\nThe most basic entry point can expect all its functions to …\nFunctions marked as inline always will always be inlined, …\nRepresents how an Acir function should be inlined. This …\nRepresents an Ast form that can be assigned to\nRather than a Pattern containing possibly several …\nID of a local definition, e.g. from a let binding or …\nFunctions marked to have no predicates will not be inlined …\nCompared to hir_def::types::Type, this monomorphized Type …\nReturns the element type of this array or slice\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobals are expected to be generated within a different …\nPerform “ownership analysis”.\nPerform “ownership analysis”.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the expression will need to have its type deduced …\nThe return type of an expression, if it has an obvious one.\nTakes a function body by replacing it with <code>false</code> and …\nWe keep a collection of the debug variables and their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMarks function as comptime. Used in fuzzing.\nWraps function body in a <code>comptime</code> block. Used to make …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint an expression, but expect that we’ve already …\nInstead of printing a call to the print oracle as a …\nAssumed impls don’t have an impl id since they don’t …\nA dependency in the dependency graph may be a type or a …\nFields and integers share methods for ease of use. These …\nAll the information from a function that is filled out …\nAn ID for a global value\nAn arbitrary number to limit the recursion depth when …\nWhen searching for a trait impl, these are the types of …\nLocals may be defined in let statements or parameters, in …\nRepresents the methods on a given type that each share the …\nA Definition enum specifies anything that we can intern in …\nThe node interner is the central storage location of all …\nGeneric types in functions (T, U in <code>fn foo&lt;T, U&gt;(...)</code> are …\nCaptures a reexport that happens inside a module. For …\nA reference to a module, struct, trait, etc., mainly used …\nA trait implementation is either a normal implementation …\nThese are the primitive type variants that we support …\nAdds an “assumed” trait implementation to the …\nAdds a non-trait method to a type.\nAdds a trait implementation to the list of known …\nAdds TypeAliasId and Location to the type_alias_ref vector …\nRegister that <code>dependent</code> depends on <code>dependency</code>. This is …\nEach value currently in scope in the comptime interpreter. …\nRetrieves the definition where the given id was defined. …\nRetrieves the definition where the given id was defined. …\nReturns the name of the definition\nReturns the type of the definition or <code>Type::Error</code> if it …\nGets the dependency graph from the node interner.\nThis graph tracks dependencies between different global …\nTo keep track of where each DependencyId is in …\nCaptures the documentation comments for each module, …\nReturns the interned expression corresponding to <code>expr_id</code>\nRemembers the field index a given HirMemberAccess …\nScans the interner for the item which is located at that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the interned HIR function corresponding to <code>func_id</code>\nReturns the interned meta data corresponding to <code>func_id</code>\nReturns the module this function was defined within\nReturns the visibility of the given function.\nReturns the associated types for the given trait impl. The …\nBuild up a string starting from the given item containing …\nReturns the Location of the definition of the given Ident …\nTry to get the <code>HirLetStatement</code> which defines a given …\nReturns the type of an operator (which is always a …\nRetrieves the trait id for a given binary operator. All …\nRetrieves the trait id for a given unary operator. Only …\nReturns the type of a prefix operator (which is always a …\nRetrieves the impl selected for a given ExprId during name …\nReturns the definition id for the associated constant of …\nReturns the definition id and trait id for a given trait …\nReturns the span of an item stored in the Interner\nReturns the type of an item stored in the Interner or …\nHolds the trait ids of the traits used for infix operator …\nMap from ExprId (referring to a Function/Method call) to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this definition is for a global variable. Note …\nTrue if this definition is for a global variable. Note …\nThis is the definition id of the method or associated …\nIterate through each method, starting with the direct …\nStore the location of the references in the graph\nLooks up a method that’s directly defined in the given …\nReturns the <code>FuncId</code> corresponding to the function referred …\nLooks up methods at impls for all types <code>T</code>, e.g. …\nGiven a <code>ObjectType: TraitId</code> pair, try to find an existing …\nReturns the trait implementation if found along with the …\nLooks up a methods that apply to the given type but are …\nDetermins whether to run in LSP mode. In LSP mode …\nA map from a type and method name to a function id for the …\nThe location of the function’s name rather than the …\nCreates a new struct or enum type with no fields or …\nReturns what the next trait impl id is expected to be.\nThe <code>Ordering</code> type is a semi-builtin type that is the …\nReturns the module where this struct is defined.\nThis function is needed when creating a NodeInterner for …\nHolds the trait ids of the traits used for prefix operator …\nStore the type for a definition\nIntern an empty function.\nIntern an empty global. Used for collecting globals before …\nInterns a HIR expression.\nIntern an expression with everything needed for it …\nStores the span for an interned expression.\nStore the type for an interned expression\nInterns a HIR Function.\nInterns a function’s metadata.\nInterns a HIR statement.\nStore Location of Type reference\nIn Noir’s metaprogramming, a noir type has the type <code>Type</code>…\nOnly for LSP: a map of ModuleDefId to each module that pub …\nStore the location of the references in the graph. Edges …\nTracks the index of the references in the graph\nRemoves all TraitImplKind::Assumed from the list of known …\nReplaces the HirExpression at the given ExprId with a new …\nReplaces the HirStatement at the given StmtId with a new …\nResolves the Location of the definition for a given …\nFor a given Index we return Location to which we resolved …\nResolves the Location of the definition for a given …\nTags the given identifier with the selected trait_impl so …\nWhen impls are found during type checking, we tag the …\nSets the associated types for the given trait impl. Each …\nReturns the interned statement corresponding to <code>stmt_id</code>\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nThe associated types for each trait impl. This is stored …\nTrait implementations on each type. This is expected to …\nGets the trait implementations from the node interner.\nReturn a set of TypeBindings to bind types from the parent …\nAdd the given trait as an operator trait if its name …\nAdd the given trait as an operator trait if its name …\nTries to retrieve the given id’s definition. This …\nReturns the span of an item stored in the Interner, if …\nSimilar to <code>lookup_trait_implementation</code> but does not apply …\nAttempts to resolve Location of Trait based on Location of …\nAttempts to resolve Location of Trait’s TraitFunction …\nAttempts to resolve Location of Type based on Location of …\nA list of all type aliases that are referenced in the …\nReturns the Type of the expression that exists at the …\nStores the Location of a Type reference\nUpdates the interned expression corresponding to <code>expr_id</code>\nUpdates the underlying interned Function.\nReturns the interned statement corresponding to <code>stmt_id</code>\nVerifies that each constraint in the given where clause is …\nWhether the function is <code>pub</code> or not.\nThe trait generics to use - if specified. This is allowed …\nAdds a <code>.clone()</code> to the given expression. Note that this …\nTraverse the given function and return the last use(s) of …\nReturns the argument unchanged.\nTraverse an expression comprised of only identifiers, …\nHandle the rhs of a <code>&amp;expr</code> unary expression. Variables and …\nCalls <code>U::from(self)</code>.\nThis module contains the last use analysis pass which is …\nWhenever an ident is used it is always cloned unless it is …\nThis contains each instance of a variable we should move …\nThe Id for a single branch of an if or match\nA variable’s last use may be split into several …\nA single path through a <code>Branches</code> enum.\nThe Id of an <code>if</code> or <code>match</code>, used to distinguish multiple …\nNo use in this branch or there is no branch\nThe outer <code>Vec</code> is each loop we’re currently in, while the …\nCollect all IdentIds from this tree\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStores the location of each variable’s last use\nRemember a new use of the given variable, possibly …\nA variable in an lvalue position is never moved (otherwise …\nA ParsedModule contains an entire Ast for one file.\nA submodule defined via <code>mod name { contents }</code> in some …\nRepresents a parsing error, or a parsing error in the …\nSkips any outer doc comments but produces an error saying …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModule declarations like <code>mod foo;</code>\nAddOrSubtractExpression = …\nAddOrSubtractTypeExpression = …\nAndExpression = XorExpression ( ‘&amp;’ XorExpression )*\nArguments = ‘(’ ArgumentsList? ‘)’\nArrayLiteral = StandardArrayLiteral | RepeatedArrayLiteral\nAsTraitPath = ‘&lt;’ Type ‘as’ PathNoTurbofish …\nAtom = Quark AtomRhs*\nAtomRhs = CallExpression | …\nAtomTypeExpression = ConstantTypeExpression | …\nAttribute = ‘#[’ (FunctionAttribute | …\nAttributes = Attribute*\nBlock = ‘{’ Statement* ‘}’\nParses an expression that looks like a block (ends with ‘…\nCallExpression = Quark CallArguments\nCallArguments = ‘!’? Arguments\nCastExpression = UnaryExpression ‘as’ Type\nComptimeExpression = ‘comptime’ Block\nComptimeStatement = ComptimeBlock | ComptimeLet | …\nConstantTypeExpression = int\nConstrainExpression = ‘constrain’ Expression | ‘…\nConstructorExpression = Type ‘{’ ConstructorFields? ‘…\nEnum = ‘enum’ identifier Generics ‘{’ EnumVariant* …\nEqualOrNotEqualExpression = OrExpression ( ( ‘==’ | ‘…\nExpression = EqualOrNotEqualExpression\nWhen parsing <code>if</code> conditions we don’t allow constructors. …\nForStatement = ‘for’ identifier ‘in’ ForRange Block\nForRange = ExpressionExceptConstructor | …\nFunction = ‘fn’ identifier Generics FunctionParameters …\nFunctionParameters = ‘(’ FunctionParametersList? ‘)…\nGeneric = VariableGeneric | NumericGeneric | …\nGenericTypeArgs = ( ‘&lt;’ GenericTypeArgsList? ‘&gt;’ )\nGenerics = ( ‘&lt;’ GenericsList? ‘&gt;’ )?\nGlobal = ‘global’ identifier OptionalTypeAnnotation ‘…\nIfExpression = ‘if’ ExpressionExceptConstructor Block …\nImpl = TypeImpl | TraitImpl\nIndexExpression = Quark ‘[’ Expression ‘]’\nInnerAttribute = ‘#![’ SecondaryAttribute ‘]’\nInnerDocComments = inner_doc_comment*\nInternedExpression = interned_expr\nInternedPattern = interned_pattern\nInternedStatementExpression = interned_statement\nItem = ( Attribute | OuterDocComments )* ItemKind\nParses an item inside an impl or trait, with good recovery:\nThis method returns one ‘ItemKind’ in the majority of …\nItemVisibility = ‘pub’                 // …\nLambda = ‘|’ LambdaParameters? ‘|’ ( ‘-&gt;’ Type …\nLessOrGreaterExpression = ShiftExpression ( ( ‘&lt;’ | ‘…\nLetStatement = ‘let’ pattern OptionalTypeAnnotation ‘…\nLiteral = bool | int | str | rawstr | fmtstr | …\nLoopStatement = ‘loop’ Block\nParses a list of items separated by a token, optionally …\nSame as parse_many, but returns a bool indicating whether …\nparse_many, where the given function <code>f</code> may return multiple …\nSame as parse_many, but returns a bool indicating whether …\nMatchExpression = ‘match’ ExpressionExceptConstructor …\nMatchRule = Expression ‘-&gt;’ (Block ‘,’?) | …\nMemberAccessOrMethodCallExpression = MemberAccessExpression\nModOrContract = ( ‘mod’ | ‘contract’ ) identifier …\nModifiers = ItemVisibility ‘unconstrained’? ‘comptime…\nMultiplyOrDivideOrModuloExpression = Term ( ( ‘<em>’ | ‘/</em>…\nMultiplyOrDivideOrModuloTypeExpression = …\nNamelessTypePathExpression = ‘&lt;’ Type ‘&gt;’ ‘::’ …\nNumericGeneric = ‘let’ identifier ‘:’ Type\nOptionalTypeAnnotation = ( ‘:’ Type )?\nOrExpression = AndExpression ( ‘|’ AndExpression )*\nOuterDocComment = outer_doc_comment\nOuterDocComments = OuterDocComment*\nParenthesesExpression = UnitLiteral | …\nParenthesizedPattern = ‘(’ Pattern ‘)’ …\nParenthesizedTypeExpression = ‘(’ TypeExpression ‘)…\nTries to parse a Path. Note that <code>crate::</code>, <code>super::</code>, etc., …\nParses a path assuming the path’s kind (plain, <code>crate::</code>, …\nPathExpression = VariableExpression | ConstructorExpression\nPathGenerics = GenericTypeArgs\nPathKind | ‘crate’ ‘::’ | ‘dep’ ‘::’ | ‘…\nPathNoTurbofish = PathKind identifier ( ‘::’ …\nPattern = ‘mut’ PatternNoMut\nPatternNoMut = InternedPattern | ParenthesizedPattern | …\nPatternOrSelf = Pattern | SelfPattern\nEntry function for the parser - also handles lexing …\nQuark = Literal | ParenthesesExpression | UnsafeExpression …\nResolvedExpression = unquote_marker\nResolvedGeneric = quoted_type\nShiftExpression = AddOrSubtractExpression ( ( ‘&lt;&lt;’ | …\nSliceExpression = ‘&amp;’ ArrayLiteral\nStatement = Attributes StatementKind ‘;’?\nStatementKind = BreakStatement | ContinueStatement | …\nParses either a statement, an expression or an LValue. …\nStruct = ‘struct’ identifier Generics ‘{’ …\nStructPattern = Path ‘{’ StructPatternFields? ‘}’\nTerm = UnaryExpression | CastExpression\nTermTypeExpression = ’- TermTypeExpression | …\nTrait = ‘trait’ identifier Generics ( ‘:’ …\nTraitBody = ‘{’ ( OuterDocComments TraitItem )* ‘}’\nTraitBound = PathNoTurbofish GenericTypeArgs\nTraitBounds = TraitBound ( ‘+’ TraitBound )? ‘+’?\nTraitConstant = ‘let’ identifier ‘:’ Type ( ‘=’…\nTraitFunction = Modifiers Function\nTraitImpl = ‘impl’ Generics Type ‘for’ Type …\nTraitImplBody = ‘{’ TraitImplItem* ‘}’\nTraitImplConstant = ‘let’ identifier …\nTraitImplFunction = Attributes Modifiers Function\nTraitImplItem = TraitImplType | TraitImplConstant | …\nTraitImplType = ‘type’ identifier ( ‘:’ Type )? ‘…\nTraitItem = TraitType | TraitConstant | TraitFunction\nTraitType = ‘type’ identifier ( ‘:’ TraitBounds ) …\nTypeAlias = ‘type’ identifier Generics ‘=’ Type ‘…\nTypeExpression= AddOrSubtractTypeExpression\nTypeImpl = ‘impl’ Generics Type TypeImplBody\nTypeImplBody = ‘{’ TypeImplItem* ‘}’\nTries to parse a type. If the current token doesn’t …\nTypeOrTypeExpression = Type | TypeExpression\nTypePathExpression = PrimitiveType ‘::’ identifier ( …\nUnaryExpression = UnaryOp* Atom\nUnaryOp = ‘&amp;’ ‘mut’ | ‘-’ | ‘!’ | ‘*’\nUnquoteExpression = ‘$’ identifier | ‘$’ ‘(’ …\nUnsafeExpression = ‘unsafe’ Block\nUse = ‘use’ PathKind PathNoTurbofish UseTree\nVariableGeneric = identifier ( ‘:’ TraitBounds ) ?\nVariableTypeExpression = Path\nVisibility = ‘pub’ | ‘return_data’ | ‘call_data…\nWhereClause = ‘where’ WhereClauseItems?\nWhileStatement = ‘while’ ExpressionExceptConstructor …\nXorExpression = LessOrGreaterExpression ( ‘^’ …\nThe current statement’s comments. This is used to …\nFull submodules as in <code>mod foo { ... definitions ... }</code>\nSkips any outer doc comments but produces a warning saying …\nRepresents a parsing error, or a parsing error in the …\nUsed to annotate parsing rules with extra context that can …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBumps this parser by one token. Returns the token that was …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nModule = InnerDocComments Item*\nEntry function for the parser - also handles lexing …\nProgram = Module\nInvokes <code>parsing_function</code> (<code>parsing_function</code> must be some …\nThe current statement’s comments. This is used to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhen parsing an array literal we might bump into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelfPattern is guaranteed to be <code>self</code>, <code>&amp;self</code> or <code>&amp;mut self</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether the parameter is public or known only …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether the parameter is public or known only …\nNecessary to handle casting to unsigned generically …\nReturns the inner FieldElement which will always be …\nReturns the argument unchanged.\nConvert a signed integer to a SignedField, carefully …\nCalls <code>U::from(self)</code>.\nConvert a SignedField into a signed integer type (up to …\nConvert a SignedField into an unsigned integer type (up to …\nReturns the argument unchanged.\nCompile a program.\nCalls <code>U::from(self)</code>.\nRegister an item as unused, waiting to be marked as used …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks an item as being referenced. This doesn’t always …\nMarks an item as being used.\nGet all the unused items per module.")