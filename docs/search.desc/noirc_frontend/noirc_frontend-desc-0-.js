searchState.loadedDescShard("noirc_frontend", 0, "The noir compiler is separated into the following passes …\nThe submodules of this module define the various data …\nThe Elaborator\nNoir’s HIR (High-Level Intermediate Representation) is …\nThe lexer is the first pass of the noir compiler. Its goal …\nComing after type checking, monomorphization is the last …\nThis module implements the “ownership analysis” …\nThe parser is the second pass of the noir compiler. The …\nThe <code>shared</code> module contains simple types which are using in …\nThis crate represents utility methods which can be useful …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nAn “as Trait” path leading to an associated type. E.g. …\nAn iterator over the variants of Self\nThis statement should be executed at compile-time\nReturns type is not specified.\nIf implicitly_added is true, this operation was implicitly …\nThis is used when an identifier fails to parse in the …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nCurrently, we support four types of functions:\nAn argument to a generic type or trait.\nAn iterator over the variants of Self\nInterned statements are allowed to be parsed as …\nRepresents whether the definition can be referenced …\nRepresents an Ast form that can be assigned to\nA Named UnresolvedType can be a struct type or a type …\nA named argument, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nAst node for an enum\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nAn ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nAlready-resolved generics can be parsed as generics when a …\n&amp;T and &amp;mut T\nThis path is a Crate or Dep path which always points to …\nAn already resolved type. These can only be parsed if they …\nAst node for statements in noir. Statements are always …\nA Trait as return type or parameter of function, including …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nEverything else.\nAst node for type aliases Depending on ‘numeric_type’, …\nAst node for an impl of a concrete type …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nA Vec of unresolved names for type variables. For …\nRepresents a simple trait constraint such as …\nThe parser parses types as ’UnresolvedType’s which …\nThe precursor to TypeExpression, this is the type that the …\nImplements the Visitor pattern for Noir’s AST.\nThis is used to represent an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function was defined with the ‘comptime’ …\ntrue if generated at compile-time, e.g. from a trait alias\nTrue if this function was defined with the ‘unconstrained…\nThe kind of each argument, in order (in case traversing …\nAll named arguments, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nEach ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nThis is None for tag variants without parameters. A value …\nIndicate if this function was defined with the ‘pub’ …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nAst node for an enum\nThis is None for tag variants without parameters. A value …\nAn iterator over the variants of Self\nReturns type is not specified.\nIf implicitly_added is true, this operation was implicitly …\nInterned statements are allowed to be parsed as …\nAlready-resolved generics can be parsed as generics when a …\nEverything else.\nA Vec of unresolved names for type variables. For …\nConverts a token to a unary operator If you want the …\nMethod calls have an optional list of generics if the …\n<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>\nComparator operators return a 0 or 1 When seen in the …\nTrue if this function was defined with the ‘comptime’ …\n<code>==</code> and <code>!=</code>\nTrue if this function was defined with the ‘unconstrained…\nReturns the innermost location that gives this expression …\nIndicate if this function was defined with the ‘pub’ …\nCurrently, we support four types of functions:\nBoth the <code>#[fold]</code> and <code>#[no_predicates]</code> alter a function’s …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nThis statement should be executed at compile-time\nThis is used when an identifier fails to parse in the …\nRepresents an Ast form that can be assigned to\nThis path is a Crate or Dep path which always points to …\nAst node for statements in noir. Statements are always …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nThis is used to represent an …\nConstruct a PathKind::Plain from this single\nGets the underlying identifier without its location.\nCreate a ‘for’ expression taking care of desugaring a …\nCreate a half-open range bounded inclusively below and …\nCreate a half-open range, bounded inclusively below and …\nReturns the span where turbofish happen. For example:\nReturns the innermost location that gives this statement …\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nAst node for an impl of a concrete type …\nRepresents a simple trait constraint such as …\nMoves trait bounds from generics into where clauses. For …\nDoes both <code>desugar_generic_trait_bounds</code> and …\ntrue if generated at compile-time, e.g. from a trait alias\nReorders a where clause in-place so that simpler …\nAst node for type aliases Depending on ‘numeric_type’, …\nImplements the Visitor pattern for Noir’s AST.\nThis structure is used to collect information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluating a comptime call like <code>Module::add_item</code>\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nResolverMetas are tagged onto each definition to track how …\nA function attribute generated an item that’s being …\nDetermines whether we are in an unsafe block and, if so, …\nAdds function generics and associated generics (from where …\nAdd the given generics to scope. Each generic will have a …\nAdd a generated item to the collected items (unquoting) …\nFor each associated type that isn’t mentioned in a trait …\nAdds the given trait constraints to scope as assumed trait …\nHandles the TypeVariable case for checking binary …\nCall a macro function and inlines its code at the call …\nDefaults all type variables used in this function context …\nType checks a field access, adding dereference operators …\nChecks all resolved structs for nested slice types, which …\nCheck that all the generics show up in any of <code>types</code> (if …\nOnly sized types are valid to be used as main’s …\nChecks whether calling the method <code>func_id</code> on an object of …\nChecks that a public struct does not have fields with more …\nChecks whether accessing the struct field <code>field_name</code> of …\nCheck that an item such as a struct field or type alias is …\nIssue an error if the impl is stricter than the trait.\nCollect all attributes to run from traits, types, …\nResolve an attribute to the function it refers to and add …\nCollect all comptime attributes from an item’s attribute …\nCollects all impl blocks for a given type, declaring their …\nCollects and resolves all struct definitions.\nResolve the methods of each trait in an environment where …\nFor each trait:\nComptime expression evaluation and macro expansion via the …\nThe current dependency item we’re resolving. Used to …\nThe trait  we’re currently resolving, if we are …\nIf we’re currently resolving methods within a trait …\nDebug helper to print comptime evaluation results.\nThe scope of –debug-comptime, or None if unset\nRegisters methods in the interner’s method table for …\nDeclares methods in the appropriate module and registers …\nDefines the value of an enum variant that we resolve an …\nExtracts and stores metadata from a function definition.\nDefines function metadata for all functions, impl methods, …\nDefines function metadata for a set of functions with …\nDefines function metadata for all methods within an impl …\nDefines function metadata for all methods within a trait …\nThis turns function parameters of the form: …\nExpands any traits in a where clause to mention all …\nDeny crates from requiring unstable features.\nEvaluates the global’s initializer expression at compile …\nElaborates an expression knowing that it has to match a …\nElaborates a function’s body and performs type checking.\nElaborates a global constant definition, performing name …\nIf the given global is unresolved, elaborate it and return …\nPerform the given function in a comptime context.\nElaborate an expression from the middle of a comptime …\nElaborate an expression from the middle of a comptime …\nFor elaborating a lambda we might get <code>parameters_type_hints</code>…\nElaborate a local or global let statement. If this is a …\nElaborates an lvalue returning:\nCompiles the rows of a match expression, outputting a …\nTo elaborate the rules of a match we need to go through …\nThis method also returns whether or not its lhs still …\nEquivalent to <code>elaborate_pattern</code>, this version just also …\nSometimes items are elaborated because a function …\nElaborate a member access expression without adding the …\nElaborate any globals which were not brought into scope by …\nElaborates a type path used in an expression, e.g. …\nChecks whether <code>variable</code> is <code>Self::method_name</code> or …\nUnstable compiler features that were explicitly enabled. …\nEnum definition collection and variant resolution.\nRun the given function using the resolver and return true …\nConvert an expression into a Pattern, defining any …\nExpression elaboration, covering all expression kinds.\nReturns a struct’s visibility.\nGo through the given tokens looking for a ‘$’ token …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction metadata and function body elaboration.\nFunction-local context management for type variables and …\nThis is a stack of function contexts. Most of the time, …\nGeneric parameter resolution and type parameter handling.\nContains a mapping of the current struct or functions’s …\nGlobal constant definition elaboration and comptime …\nElaborate and type-check arguments passed to an attribute …\nInherent type implementations collection and method …\nTrue if we’re currently within a <code>comptime</code> block, …\nTrue if we’re elaborating a comptime item such as a …\nTrue if we’re currently within a constrained function. …\nReturns <code>true</code> if the current module is a contract.\nInsert as many dereference operations as necessary to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhen resolving lambda expressions, we need to keep track …\nLint checks for function attributes, visibility, and usage …\nThe current module this elaborator is in. Initially empty, …\nLookup a given trait by name/path.\nLooks up a given type by name. This will also instantiate …\nCompiler frontend options and unstable feature flags.\nOptions from the nargo cli\nPath resolution for types, values, and trait methods …\nConvert a PathResolutionItem - usually an enum variant or …\nPattern elaboration, variable binding, and turbofish …\nTrue if we should use pedantic ACVM solving\nUse pedantic ACVM solving\nReturn a fresh integer type variable and log it in …\nReturn a fresh integer or field type variable and log it …\nPopulate the elaborator’s scope with all comptime …\nPrepares a trait impl for function metadata definition.\nPrimitive type definitions\nTrue if the <code>pub</code> keyword is allowed on parameters in this …\nPush a type variable into the current FunctionContext to …\nPush an <code>ExprId</code> that corresponds to an integer literal. At …\nPush a type variable (its ID and type) as a required type …\nPush a trait constraint into the current FunctionContext …\nRuns <code>f</code> and if it modifies <code>self.generics</code>, <code>self.generics</code> is …\nThe removing counterpart for …\nResolve all the fields of a struct constructor expression. …\nResolve all the fields of a struct constructor expression. …\nResolves function parameters and validates their types for …\nResolve generics using the expected kinds of the function …\nReturn the kind of an unresolved generic. If a numeric …\nTranslates a (possibly Unspecified) UnresolvedType to a …\nSolve any generics that are part of the path before the …\nResolves a Path assuming we are inside <code>starting_module</code>. …\nResolves a path in <code>current_module</code>. <code>importing_module</code> is the …\nResolves a path in the current module. If the referenced …\nResolves the field types for a single struct definition.\nIdentical to <code>resolve_type_args</code> but does not allow …\nResolve the given TraitBound, pushing error(s) if the path …\nResolves a trait constraint and adds it to scope as an …\nResolve the given trait constraints and add them to scope …\nDefines the FuncMeta for this trait function.\nResolves associated types for a trait impl and checks for …\nResolves the trait path from a trait impl declaration. …\nResolves a trait’s methods, but does not elaborate their …\nTranslates an UnresolvedType to a Type with a …\nThis resolves a method in the form <code>Type::method</code> where …\nTranslates an UnresolvedType into a Type and appends any …\nIn-resolution names\nGiven a list of functions and the trait they belong to, …\nExecute an attribute function on an item.\nRun all the attributes on each item in the crate in …\nLexical scoping, variable lookup, and closure capture …\nthe index in the scope tree (sometimes being filled by …\nSet to the current type if we’re resolving an impl\nOrder the set of unresolved globals by their GlobalId. …\nCreate a new interpreter for evaluating comptime code.\nSets up generics for a trait impl and processes trait …\nCheck whether a function’s args and return value should …\nIf greater than 0, field visibility errors won’t be …\nStatement elaboration including let bindings, assignments, …\nStruct definition collection and field resolution.\nEach constraint in the <code>where</code> clause of the function …\nTrait implementation collection, method matching, and …\nTrait definition collection, bounds resolution, and …\nCheck if the given method type requires a mutable …\nGiven a method object: <code>(*foo).bar</code> of a method call …\nPrerequisite: verify_trait_constraint of the operator’s …\nIf the given type was declared as:\nReturn a fresh integer type variable and log it in …\nType resolution, unification, and method resolution (for …\nWrapper of Type::unify_with_coercions using self.errors\nDo not apply type bindings even after a successful …\nToken stream processing for macro unquoting and variable …\nThese are the globals that have yet to be elaborated. This …\nRegister a use of the given unstable feature. Errors if …\nLookup and use the specified variable. This will increment …\nEverything to do with elaboration of variables. Notably, …\nVisibility checking for functions, struct fields, and type …\nContext information for the module that an attribute is …\nA collected attribute ready to be executed.\nA collection of attributes ready to be executed.\nArguments passed to the attribute\nThe module where the attribute is located. This is needed …\nModule context for the attribute\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe attribute function to call\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item being attributed (struct, function, etc.)\nLocation of the attribute in source code\nThe module where generated items should be added\nA pattern binding a variable such as <code>a</code> or <code>_</code>\nA pattern checking for a tag and possibly binding …\nAn error occurred while translating this pattern. This …\nAn integer literal pattern such as <code>4</code>, <code>12345</code>, or <code>-56</code>\nMultiple patterns combined with <code>|</code> where we should match …\nA Pattern is anything that can appear before the <code>=&gt;</code> in a …\nAn integer range pattern such as <code>1..20</code> which will match …\nReturn the variable that was referred to the most in <code>rows</code>\nCompiles the cases and sub cases for the constructor …\nCompiles the cases and fallback cases for integer and …\nMove any cases with duplicate branches into a shared ‘…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTraverse the resulting HirMatch to build counter-examples …\nIssue a missing cases error if necessary for the given …\nAny case that isn’t branched to when the match is …\nCreates: <code>{ let &lt;variable&gt; = &lt;rhs&gt;; &lt;body&gt; }</code>\nThe type variable corresponds to the type of an array …\nThe kind of required type variable.\nThe type variable corresponds to an identifier, whose …\nA type variable that is required to be bound after …\nThe type variable corresponds to a struct generic, in a …\nAll type variables created in the current function. This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll ExprId in a function that correspond to integer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType variables that must be bound at the end of the …\nTrait constraints are collected during type checking until …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if an expression will end up calling a specific …\nChecks if an ExprId, which has to be an integer literal, …\nInline attributes are only relevant for constrained …\nAttempting to define new low level (<code>#[builtin]</code> or …\n<code>pub</code> is required on return types for entry point functions\nOracle functions may not be called by constrained …\nOracle definitions (functions with the <code>#[oracle]</code> …\nCheck that a recursive function <em>can</em> return without …\nCheck that we are not passing a mutable reference from a …\nCheck that we are not passing a slice from an …\nOnly arguments to entrypoint functions may have a …\nOnly entrypoint functions require a <code>pub</code> visibility …\nOptions from nargo_cli that need to be passed down to the …\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nGeneric options struct meant to resolve to …\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nDeny crates from requiring unstable features.\nDeny crates from requiring unstable features.\nDeny crates from requiring unstable features.\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nA sane default of frontend options for running tests\nContains the error value\nFound a method.\nMultiple trait method matches were found and they are all …\nThere’s only one trait method that matches, but it’s …\nFound a trait method and it’s currently in scope.\nA reference to a global value.\nAny item that can appear before the last segment in a path.\nA function call on a module, for example …\nThe method could not be found. There might be trait …\nContains the success value\nAll possible items that result from resolving a Path. Note …\nDetermines whether data-types found along a path are to be …\nDepending on where a path appears in the source code it …\nA function call on a primitive type, for example …\nA function call on <code>Self</code>, for example <code>Self::function()</code>. …\nA function call on a trait, for example <code>Trait::function()</code> …\nA function call on a type alias, for example …\nA function call on a type that resolves to a trait method, …\nLike a <code>crate::ast::Path</code> but each segment has resolved …\nLike a <code>crate::ast::PathSegment</code> but with resolved turbofish …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a PathKind::Plain from this single\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the span where turbofish happen. For example:\nAn iterator over the variants of Self\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe possible errors of interpreting given code into a …\nReturns the argument unchanged.\nInterpret source code using the elaborator, without …\nCalls <code>U::from(self)</code>.\nCheck the given function type matches the expected one.\nChecks that the type of a function in a trait impl matches …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nXXX: This is bare-bone for two reasons:\nA dependency is a crate name and a crate_id This means …\nThe special case of running the compiler against the …\nTries to find the requested crate in the current one’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper object which groups together several useful context …\nActivates LSP mode, which will track references for all …\nThe comptime interpreter is used to execute Noir code …\nReturn the CrateId for each crate that has been compiled …\nThis set of modules implements the name resolution pass …\nReturns the CrateDefMap for a given CrateId. It is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a fully-qualified path to the given TypeId from …\nReturns a list of all functions in the current crate …\nReturns a list of all functions in the current crate …\nReturns the FuncId of the ‘main’ function in a crate.\nWriter for comptime prints.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAny unstable features required by the current package or …\nThis set of modules implements the second half of the name …\nGenerics need to be resolved before elaboration to …\nA map of each file that already has been visited from a …\nComptime errors always wrap another error to show it …\nThe possible errors that can halt the interpreter.\nStruct elements are automatically shared to support …\nTuple elements are automatically shared to support …\nMaps each bound generic to each binding it has in the …\nTo expand macros the Interpreter needs access to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluates any expressions within UnquoteMarkers in the …\nTries to print tokens in a way that it’ll be easier for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines whether the last outputted byte was …\nComptime errors always wrap another error to show it …\nContains the error value\nThe possible errors that can halt the interpreter.\nContains the success value\nMaps each bound generic to each binding it has in the …\nBounds check the given array and index pair. This will …\nCall a non-builtin function\nDefine a new variable in the current scope\nTo expand macros the Interpreter needs access to the …\nEnters a function, pushing a new scope and resetting any …\nEvaluate an expression and return the result. This will …\nEvaluating a mutable variable will dereference it …\nEvaluates a numeric generic with the value <code>value</code> (expected …\nGiven the result of a <code>cmp</code> operation, convert it into the …\nTry to retrieve a function’s body. If the function has …\nMutate an existing variable, potentially from a prior scope\nWhen we store to a struct such as in\nGiven a type, assert that it’s an <code>Option&lt;T&gt;</code> and return …\nCreates a value that holds an <code>Option</code>. <code>option_type</code> must be …\nfn as_type(self) -&gt; Type\nfn fields(self, generic_args: Type) -&gt; [(Quoted, Type, …\nfn fields_as_written(self) -&gt; [(Quoted, Type, Quoted)] …\nfn generics(self) -&gt; [(Type, <code>Option&lt;Type&gt;</code>)]\nfn set_fields(self, new_fields: [(Quoted, Type, Quoted)]) …\nType to be used in <code>Value::Array(&lt;values&gt;, &lt;array-type&gt;)</code>.\nType to be used in <code>Value::Slice(&lt;values&gt;, &lt;slice-type&gt;)</code>.\nInterpret the input as an array, then map each element. …\nGet an array and convert it to a fixed size. Returns the …\nGet a specific field of a struct and apply a decoder …\nGet the fields if the value is a <code>Value::Struct</code>, otherwise …\nCreate a <code>Value::Array</code> from bytes.\nCreate a <code>Value::Slice</code> from bytes.\nCreate a <code>Value::Struct</code> from fields and the expected return …\nNo-op also covers the zero-extend case since we convert …\nConvert the input value to a (field, sign) pair. …\nevaluate_cast without recursion\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\nRun one of the Blake hash functions.\nRun one of the Secp256 signature verifications.\nDecode an <code>EmbeddedCurvePoint</code> struct.\nDecode an <code>EmbeddedCurveScalar</code> struct.\n<code>fn keccakf1600(input: [u64; 25]) -&gt; [u64; 25] {}</code>\n…\n…\nStruct elements are automatically shared to support …\nTuple elements are automatically shared to support …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns false for non-integral <code>Value</code>s.\nStructs and tuples store references to their fields …\nConverts any integral <code>Value</code> into a <code>SignedField</code>. Returns …\nUnwraps an Rc value without cloning the inner value if the …\nGiven a Crate root, collect all definitions in that crate\nMaps the type and the module id in which the impl is …\nStores all of the unresolved functions in a particular …\nCollect all of the definitions in a given crate into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the primary location where this error happened.\nGiven a module collect all definitions into ModuleData\nWalk a module and collect its definitions.\nCollect any enum definitions declared within the ast. …\nCollect any struct definitions declared within the ast. …\nReturns a tuple of (methods, associated types, associated …\nCollect any traits definitions declared within the ast. …\nCollect any type aliases definitions declared within the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSearch for a module named <code>mod_name</code> Parse it, add it as a …\nAdd a child module to the current def_map. On error this …\nAdd a child module to the current def_map. On error this …\nReturns true if a module’s child modules are expected to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap of all modules and scopes defined within a crate.\nLets first check if this is offered by any external crate …\nThe name that is used for a non-contract program’s …\nContains the actual contents of a module: its parent (if …\nA generic ID that references either a module, function, …\nGets the index that underlies this local module ID.\nEach child in the order they were declared in the parent …\nCollect all definitions in the crate\nContains only the definitions directly defined in the …\nMaps an external dependency’s name to its root module id.\nReturns the reason for the test function to fail if …\nReturns the reason for the fuzzing harness to fail if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the ModuleData stored at …\nReturns an iterator over all contract modules within the …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nFind a child module’s name by inspecting its parent. …\nReturn a topological ordering of each module such that any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nFind the main function for this crate\nConstructs a new <code>CrateDefMap</code>, containing only the crate’…\nReturns true if the fuzzing harness has been specified to …\nReturns this module’s parent, if there’s any.\nGiven a FileId, fetch the File, from the FileManager and …\nContains all definitions visible to the current module. …\nReturns true if the test function has been specified to …\nReturns true if the fuzzing harness has been specified to …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nReturns an Err if there is already an item in the …\nContains the actual contents of a module: its parent (if …\nEach child in the order they were declared in the parent …\nContains only the definitions directly defined in the …\nFinds a trait in scope and returns its name (either the …\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nContains all definitions visible to the current module. …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nReturn an iterator over all definitions defined within …\nA generic ID that references either a module, function, …\nReturns the HIR as human-readable code for the given crate.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module is responsible for building a list of items …\nTrait constraints in scope. These are set when a trait, …\nBuilds trait impls for traits, but only when those impls …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis set is initially created with all the trait impls in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUnlike Span::empty, Span::initial always starts at index 0\nReturns <code>true</code> if any point of <code>self</code> intersects a point of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the name that’s brought into scope: either the …\nResolves a Path in a <code>use</code> statement, assuming it’s …\nGiven a Path and a ModuleId it’s being used in, this …\nReturns whether two types are the same disregarding their …\nReturns true if an item with the given visibility in the …\nReturns whether a method call <code>func_id</code> on an object of type …\nReturns true if <code>target</code> is a struct and its parent is …\nReturns whether a struct member with the given visibility …\nReturns whether a trait member with the given visibility …\nReturns whether a struct or trait member with the given …\nThis implementation uses the terminology Scope and …\nScopeTree allows one to specify that maps within the same …\nEnding a function requires that we removes it’s whole …\nEnds the current scope - this should correspond with the …\nReturns an iterator over all of the elements which satisfy …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the last pushed scope from the current scope tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarting a function requires a new scope tree, as you do …\nThe beginning of a scope always correlates with the start …\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nRepresents something that can be generic over type …\nTraitGenerics are different from regular generics in that …\nTrue if this item kind can ever accept named type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach ordered generic kind on this type, excluding any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of this kind of item, for error messages. E.g. “…\nThe name of this item, usually named by a user. E.g. “Foo…\nA Failure node in the match. <code>missing_case</code> is true if this …\nA method can be defined in a regular <code>impl</code> block, in which …\nRun <code>body</code> if the given expression is true. Otherwise …\nA variable captured inside a closure\nCorresponds to <code>assert</code> and <code>assert_eq</code> in the source code. …\nAn enum constructor is an expression such as …\nA HirExpression is the result of an Expression in the AST …\nCorresponds to a variable in the source code\nIndexing, as in <code>array[index]</code>\nThis is always a struct field access <code>my_struct.field</code> and …\nThese nodes are temporary, they’re lowered into …\nThis ident is not a trait method\nJump directly to ExprId\nSwitch on the given variable with the given cases to test. …\nA method or constant defined in a trait\nThis ident refers to a trait method and its impl needs to …\nOr a method can come from a Trait impl block, in which case\nReturn all the constructors of this type from one …\nThis refers to just the arguments that are passed. E.g. …\nNote that this <em>must</em> be the id of the function or constant …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics provided by …\nIf this HirIdent refers to a trait method, this field …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this constructor constructs an enum value. Enums …\nTrue if we should return an offset of the field rather …\nTrue if this constructor constructs a tuple or struct …\nCreates a basic HirPrefixExpression with …\nIf this is true we should skip this operation and directly …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nThe trait method id for the operator trait method that …\nThe trait method id for the operator trait method that …\nThis will be None when the capture refers to a local …\nA FuncMeta contains the signature of the function and any …\nA Hir function is a block expression with a list of …\nAn interned function parameter from a function definition\nAll the generics used by this function, which includes any …\nThe set of generics that are declared directly on this …\nIf this function is the one related to an enum variant, …\nTrait constraints that came either from a parent item (for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrue if this function is marked with an attribute that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function is an entry point to the program. …\nA stub function does not have a body. This includes …\nThe HirIdent of each identifier within the parameter list. …\nGives the (uninstantiated) return type of this function.\nIf this function is from an impl (trait or regular impl), …\nThe crate this function was defined in\nTHe file this function was defined in\nThe module this function was defined in\nTake this function body, returning an owned version while …\nTrait constraints that were specified directly on this …\nThe trait impl this function belongs to, if any\nThe type of this function. Either a Type::Function or a …\nThe type this method belongs to, if any\nCorresponds to <code>lvalue = expression;</code> in the source code\nRepresents an Ast form that can be assigned to. These can …\nA HirStatement is the result of performing name resolution …\nCreates a new ‘basic’ let statement with no attributes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the fields of this pattern. Panics if the …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\n<code>index</code> is required to be an identifier to simplify …\nRepresents a trait in the type system. Each instance of …\nReturns a TraitConstraint for this trait using Self as the …\nMap from each associated constant’s name to a unique …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns both the ordered generics of this type, and its …\nA unique id representing this trait type. Used to check if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps method_name -&gt; method id. This map is separate from …\nWhen resolving the types of Trait elements, all references …\nThe resolved trait bounds (for example in …\nAny ordered type arguments on the trait this impl is for. …\nThe where clause, if present, contains each trait …\nA user-defined alias to another type. Similar to a Struct, …\nCan bind to any type\nArray(N, E) is an array of N elements of type E. It is …\nA restricted subset of binary operators useable on type …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nRepresents a struct or enum type in the type system. Each …\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> in the source …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> with additional\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nA generic integer type. This is a more specific kind of …\nA generic integer or field type. This is a more specific …\nA Kind is the type of a Type. These are used since only …\nConvenience enum to avoid using <code>Option&lt;Option&lt;String&gt;&gt;</code> to …\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nA type with no body is still in the process of being …\nCan bind to any type, except Type::Constant and …\nCan bind to a Type::Constant or Type::InfixExpr of the …\nThe type of quoted code in macros. This is always a …\n&amp;T\nA shared, mutable reference to some T. Wrapper is required …\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nWrap around an unsolved type\nTypeBindings are the mutable insides of a TypeVariable. …\nA list of (TypeVariableId, Kind)’s to bind to a type. …\nA TypeVariable is a mutable reference that is either bound …\nTypeVariables are stand-in variables for some type which …\nA unique ID used to differentiate different type variables\nThe unit type <code>()</code>.\nApply the given type bindings, making them permanently …\nReturn the operator that will “undo” this operation if …\nReturn the corresponding IntegerTypeSuffix if this is a …\nReturn this type as a monomorphic type - without a …\nBind this type variable to a value.\nA type’s body is private to force struct fields or enum …\nBorrows this TypeVariable to (e.g.) manually match on the …\nTry to canonicalize the representation of this type. …\nOnly simplify constants and drop/skip any CheckedCast’s\nOnly simplify constants and drop/skip any CheckedCast’s\nIf <code>found_checked_cast</code>, then drop additional CheckedCast’s\nRun all simplifications and drop/skip any CheckedCast’s\nReturns the default type this type variable should be …\nEnsure the given value fits in self.integral_maximum_size()\nevaluate_to_field_element with optional generic arithmetic …\nIf this type is a Type::Constant (used in array lengths), …\nReturns the field at the given index. Panics if no field …\nReturns the number of field elements required to represent …\nReturns each of this type’s field names. Returns None if …\nRetrieve the fields of this type with no modifications. …\nFollow any TypeVariable bindings within this type. Doing …\nFollow bindings if this is a type variable or generic to …\nForcibly bind a type variable to a new type - even if the …\nForcibly substitute any type variables found within this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform the actual rust numeric operation associated with …\nTakes a monomorphic type and generalizes it over each of …\nReturns the number of <code>Forall</code>-quantified type variables on …\nReturn the generics on this type as a vector of types\nReturns the field matching the given field name, as well …\nRetrieves the type of the given field name Panics if the …\nRetrieve the fields of this type. Returns None if this is …\nReturns the name and raw types of each field of this type. …\nReturns all the fields of this type, after being applied …\nRetrieve the given variant at the given variant index of …\nReturns the name and raw parameters of the variant at the …\nRetrieve the variants of this type. Returns None if this …\nReturns the name and raw parameters of each variant of …\nDetermines if a type contains a self referring alias by …\nA unique id representing this type. Used to check if two …\nWas this named generic implicitly added?\nCreates an <code>InfixExpr</code>.\nUnifies self and other kinds or fails with a Kind error\nInstantiate this struct type, returning a Vec of the new …\nInstantiate this type, replacing any type variables it is …\nInstantiate this type with the given type bindings. If any …\nInstantiates a type with the given types. This differs …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the operator that will “undo” this operation if …\nCreates an <code>InfixExpr</code> that results from the compiler trying …\nA bit of an awkward name for this function - this function …\nIf value_level, only check for Type::FieldElement, else …\nIf value_level, only check for Type::FieldElement, else …\nIf value_level, only check for Type::FieldElement, else …\nTrue if this variant was declared as a function. Required …\nCheck that if bound, it’s an integer and if unbound, …\nCheck that if bound, it’s an integer or field and if …\nWhile Kind::is_numeric refers to numeric <em>types</em>, this …\nCheck that if bound, it’s a signed integer\nCheck that if bound, it’s an unsigned integer\nReturns true if a value of this type can safely pass …\nReturns this type, or a nested one, if this type can be …\nOptional expression, used by type aliases to numeric …\nTrue if the given TypeVariableId is free anywhere within …\nGiven: lhs = <code>N op C1</code> rhs = C2 Returns: <code>(N, op, C1, C2)</code> if …\nReturns this type, or a nested one, that cannot be used as …\nReplace any <code>Type::NamedGeneric</code> in this type with a …\nTo account for cyclic references between structs, a struct…\nSubstitute any type variables found within this type with …\nThis helper function only differs in the additional …\nSubstitute any <code>Kind::Any</code> in this type, for types that hold …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nTry to apply the array to slice coercion to this given …\nTry to bind the given type variable to self. Although the …\nTry to bind a PolymorphicInt variable to self, succeeding …\nAttempt to coerce <code>&amp;mut T</code> to <code>&amp;T</code>, returning true if this is …\nTry to simplify non-constant expressions in the form …\nTry to simplify non-constant expressions in the form …\nTry to simplify partially constant expressions in the form …\n<code>try_unify</code> is a bit of a misnomer since although errors are …\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify a type variable to <code>self</code>. This is a helper …\nPretty print type bindings for debugging\nUnbind this type variable, setting it to Unbound(id).\nUnifies this kind with the other. Returns true on success\nTry to unify this type with another, setting any type …\nSimilar to <code>unify</code> but if the check fails this will attempt …\nReturn the generics and type within this <code>Type::Forall</code>. …\nReturns the enum variant at the given index. Panics if no …\nReturns the function type of the variant at the given …\nReturns the function type of the variant at the given …\nRetrieve the variants of this type with no modifications. …\nIf the right-hand side is <code>expr op constant</code>, don’t try to …\nNothing special to do.\nWhen unifying types we sometimes need to adjust the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps a given <code>expression</code> in <code>expression.method()</code>\nAn type incorrectly used as a program input.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the error value\nThe job of the lexer is to transform an iterator of …\nContains the success value\nContains the success value\nCheck for and return the type suffix on the integer string …\nKeeps consuming tokens as long as the predicate is …\nSkips white space. They are not significant in the source …\nReturns the argument unchanged.\nGiven that some tokens can contain two characters, such as …\nCalls <code>U::from(self)</code>.\nGiven a source file of noir code, return all the tokens in …\nLex the next word in the input stream. Returns (start …\nIterates the cursor and returns the char at the new cursor …\nReads the next token, which might be a comment token …\nPeeks at the character two positions ahead. Does not …\nPeeks at the character two positions ahead and returns …\nPeeks at the next char. Does not iterate the cursor\nPeeks at the next char and returns true if it is equal to …\nIf <code>single</code> is followed by <code>character</code> then extend it as <code>double</code>…\nAllow chosen warnings to happen so they are silenced.\n&amp;\n&amp;\n-&gt;\n-&gt;\n=\n=\nAn Attribute can be either a Primary Attribute or a …\n!\n!\nRepresents a token in noir’s grammar - a word, number, …\n^\n^\n:\n:\n,\n,\n$\n$\n.\n.\n::\n::\n..\n..\n..=\n..=\n==\n==\n=&gt;\n=&gt;\nPrimary Attributes are those which a function can only …\nPrimary Attributes are those which a function can only …\nFuzzingScope is used to specify additional annotations for …\n=\n=\nA reference to an existing crate. This is a result of …\nA reference to an interned <code>ExpressionKind</code>.\nA reference to an interned <code>LValue</code>.\nA reference to an interned <code>Pattern</code>.\nA reference to an interned <code>StatementKind</code>.\nA reference to an interned <code>UnresolvedTypeData</code>.\nAn invalid character is one that is not in noir’s …\nAn invalid character is one that is not in noir’s …\nNote that <code>self</code> is not present - it is a contextual keyword …\nAn iterator over the variants of Self\n{\n{\n[\n[\n(\n(\n&lt;\n&lt;\n&lt;=\n&lt;=\n&amp;&amp;\n&amp;&amp;\nAn attribute expected to run a comptime function of the …\nUnlike Rust, all values in Noir already warn if they are …\nNo scope is applied and so the test must pass\n!=\n!=\nIf a test has a scope of OnlyFailWith, then it can only …\nIf a fuzzing harness has a scope of OnlyFailWith, then it …\nFor example <code>foo::bar</code> in <code>#[foo::bar(...)]</code>\n%\n%\n|\n|\nA quoted type resulting from a <code>Type</code> object in noir code …\nthe u8 is the number of hashes, i.e. r###..\nthe u8 is the number of hashes, i.e. r###..\nFor example <code>$expr</code> in <code>#[$expr(...)]</code> inside a <code>quote { ... }</code> …\n}\n}\n]\n]\n)\n)\nSecondary attributes are those which a function can have …\n;\n;\n&lt;&lt;\n&lt;&lt;\nIf a test has a scope of ShouldFailWith, then it can only …\nIf the fuzzing harness has a scope of ShouldFailWith, then …\n/\n/\n&amp; followed immediately by ‘[’ This is a lexer hack to …\nA custom tag attribute: <code>#[&#39;foo]</code>\nTestScope is used to specify additional annotations for …\nThe different kinds of tokens that are possible in the …\nThis is an implementation detail on how macros are …\nThis is an implementation detail on how macros are …\nTreat any metaprogramming functions within this one as …\nA variable-argument comptime function.\nThese are all the operators allowed as part of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns note if a deprecated secondary attribute is found\nReturns true if one of the secondary attributes is …\nTrue if the function is marked with an <code>#[export]</code> attribute.\nCheck if secondary attributes contain a specific instance.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if these attributes mean the given function is an …\nCheck whether we have an <code>inline_always</code> attribute This is …\nCheck whether we have an <code>inline</code> attribute Although we also …\nLooks up a word in the source program and returns the …\nIf this is a <code>#[must_use]</code> attribute, return <code>Some(message)</code> …\nA <code>ModuleDefId</code> captured to be offered in LSP’s …\nIf the item is available via a re-export, this contains …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item to import.\nThe item’s visibility.\nFinds a visible reexport for any ancestor module of the …\nReturns the ModuleId a ModuleDefId is in.\nReturns true if the given ModuleDefId is visible from the …\nReturns the relative path to reach <code>module_def_id</code> named <code>name</code>…\nReturns the fully-qualified path of the given <code>ModuleDefId</code> …\nReturns the path to reach an item inside <code>target_module_id</code> …\nA user-defined alias to another type. Similar to a Struct, …\nArray(N, E) is an array of N elements of type E. It is …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nUsing nested HashMaps here lets us avoid cloning HirTypes …\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nThe context struct for the monomorphization pass.\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nThe type of quoted code in macros. This is always a …\n&amp;T\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nTypeVariables are stand-in variables for some type which …\nThe unit type <code>()</code>.\nAdds a function argument that contains type metadata that …\nExtend the arguments to <code>print</code> (which is a <code>bool</code> to show if …\nBinds direct generics on a trait impl function to those on …\nCheck that the ‘from’ and to’ sides of a CheckedCast …\nConvert a non-tuple/struct type to a monomorphized type\nCall an infix operator overloading method for the given …\nCall an operator overloading method for the given prefix …\nPrerequisite: typ = typ.follow_bindings() and: …\nFor an enum like: enum Foo { A(i32, u32), B(Field), C }\nWhen a function finishes being monomorphized, the …\nFollow any type variable links within the given …\nSet to true to force every function to be unconstrained. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a function value for the given function (not an …\nFunctions are keyed by their unique ID, whether they’re …\nGlobals are keyed by their unique ID because they are …\nUsed to reference existing definitions in the HIR\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if a given function type is a closure. Note …\nA local (ie non-function) ident only\nUnlike functions, locals are only keyed by their unique ID …\nFind a captured variable in the innermost closure, and …\nFind a captured variable in the innermost closure …\nStarting from the given <code>main</code> function, monomorphize the …\nCall the same function with <code>self.in_unconstrained_fn = true</code>…\nMonomorphize a numeric generic as a numeric constant. …\nMonomorphize each parameter, expanding tuple/struct …\nPatch instrumentation calls inserted for debugging. This …\nUpdate instrumentation code inserted when assigning to a …\nUpdate instrumentation code inserted on variable …\nUpdate instrumentation code for a variable being dropped …\nCall sites are instantiated against the trait method, but …\nThis module implements printing of the monomorphized AST, …\nQueue of functions to monomorphize next each item in the …\nResolve a trait item to a particular impl\nTry to evaluate certain builtin functions (currently only …\nImplements std::unsafe_func::zeroed by returning an …\nAnalogous to Expression::Clone. Clone the resulting lvalue …\nA definition is either a local (variable), function, or is …\nThe monomorphized AST is expression-based, all statements …\nFunctions marked as foldable will not be inlined and …\nA function ID corresponds directly to an index of …\nA function ID corresponds directly to an index of …\nEach identifier is given a unique ID to distinguish …\nThe most basic entry point can expect all its functions to …\nFunctions marked as inline always will always be inlined, …\nRepresents how an Acir function should be inlined. This …\nRepresents an Ast form that can be assigned to\nRather than a Pattern containing possibly several …\nID of a local definition, e.g. from a let binding or …\nFunctions marked to have no predicates will not be inlined …\nCompared to hir_def::types::Type, this monomorphized Type …\nReturns the element type of this array or slice\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobals are expected to be generated within a different …\nPerform “ownership analysis”.\nPerform “ownership analysis”.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProduce an <code>InlineType</code> which we can use with an …\nCheck if the expression will need to have its type deduced …\nThe return type of an expression, if it has an obvious one.\nCarried over from <code>HirPrefixExpression::skip</code>. This also …\nTakes a function body by replacing it with <code>false</code> and …\nWe keep a collection of the debug variables and their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSome calls can be printed with the intention of parsing …\nMarks function as comptime. Used in fuzzing.\nWraps function body in a <code>comptime</code> block. Used to make …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint an expression, but expect that we’ve already …\nCheck if we have a tuple of (constrained, unconstrained) …\nSpecial method for printing builtin array method calls, …\nInstead of printing a call to the print oracle as a …\nTry to display a special call as Noir.\nAssumed impls don’t have an impl id since they don’t …\nA dependency in the dependency graph may be a type or a …\nFields and integers share methods for ease of use. These …\nAll the information from a function that is filled out …\nAn ID for a global value\nWhen searching for a trait impl, these are the types of …\nLocals may be defined in let statements or parameters, in …\nRepresents the methods on a given type that each share the …\nA Definition enum specifies anything that we can intern in …\nThe node interner is the central storage location of all …\nGeneric types in functions (T, U in <code>fn foo&lt;T, U&gt;(...)</code> are …\nCaptures a reexport that happens inside a module. For …\nA reference to a module, struct, trait, etc., mainly used …\nA trait implementation is either a normal implementation …\nThese are the primitive type variants that we support …\nAdds an “assumed” trait implementation to the …\nAdds a non-trait method to a type.\nAdds a trait implementation to the list of known …\nAdds TypeAliasId and Location to the type_alias_ref vector …\nRegister that <code>dependent</code> depends on <code>dependency</code>. This is …\nEach value currently in scope in the comptime interpreter. …\nRetrieves the definition where the given id was defined. …\nRetrieves the definition where the given id was defined. …\nReturns the name of the definition\nReturns the type of the definition or <code>Type::Error</code> if it …\nGets the dependency graph from the node interner.\nThis graph tracks dependencies between different global …\nTo keep track of where each DependencyId is in …\nCaptures the documentation comments for each module, …\nReturns the interned expression corresponding to <code>expr_id</code>\nRemembers the field index a given HirMemberAccess …\nScans the interner for the item which is located at that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the interned HIR function corresponding to <code>func_id</code>\nReturns the interned meta data corresponding to <code>func_id</code>\nReturns the module this function was defined within\nReturns the visibility of the given function.\nReturns the associated types for the given trait impl. The …\nBuild up a string starting from the given item containing …\nReturns the Location of the definition of the given Ident …\nTry to get the <code>HirLetStatement</code> which defines a given …\nReturns the type of an operator (which is always a …\nRetrieves the trait id for a given binary operator. All …\nRetrieves the trait id for a given unary operator. Only …\nReturns the type of a prefix operator (which is always a …\nRetrieves the impl selected for a given ExprId during name …\nReturns the definition id for the associated constant of …\nReturns the definition id and trait id for a given trait …\nReturns the span of an item stored in the Interner\nReturns the type of an item stored in the Interner or …\nHolds the trait ids of the traits used for infix operator …\nMap from ExprId (referring to a Function/Method call) to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this definition is for a global variable. Note …\nTrue if this definition is for a global variable. Note …\nThis is the definition id of the method or associated …\nStore the location of the references in the graph\nLooks up a method that’s directly defined in the given …\nReturns the <code>FuncId</code> corresponding to the function referred …\nLooks up methods at impls for all types <code>T</code>, e.g. …\nGiven a <code>ObjectType: TraitId</code> pair, try to find an existing …\nReturns the trait implementation if found along with the …\nLooks up a methods that apply to the given type but are …\nDetermines whether to run in LSP mode. In LSP mode …\nA map from a type and method name to a function id for the …\nThe location of the function’s name rather than the …\nCreates a new struct or enum type with no fields or …\nReturns what the next trait impl id is expected to be.\nThe <code>Ordering</code> type is a semi-builtin type that is the …\nThis function is needed when creating a NodeInterner for …\nHolds the trait ids of the traits used for prefix operator …\nStore the type for a definition\nIntern an empty function.\nIntern an empty global. Used for collecting globals before …\nInterns a HIR expression.\nIntern an expression with everything needed for it …\nStores the span for an interned expression.\nStore the type for an interned expression\nInterns a HIR Function.\nInterns a function’s metadata.\nInterns a HIR statement.\nStore Location of Type reference\nIn Noir’s metaprogramming, a noir type has the type <code>Type</code>…\nA map of ModuleDefId to each module that pub or pub(crate) …\nStore the location of the references in the graph. Edges …\nTracks the index of the references in the graph\nRemoves all TraitImplKind::Assumed from the list of known …\nReplaces the HirExpression at the given ExprId with a new …\nReplaces the HirStatement at the given StmtId with a new …\nResolves the Location of the definition for a given …\nFor a given Index we return Location to which we resolved …\nResolves the Location of the definition for a given …\nTags the given identifier with the selected trait_impl so …\nWhen impls are found during type checking, we tag the …\nSets the associated types for the given trait impl. Each …\nReturns the interned statement corresponding to <code>stmt_id</code>\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nEach trait associated type. These are tracked so that we …\nThe associated types for each trait impl. This is stored …\nTrait implementations on each type. This is expected to …\nGets the trait implementations from the node interner.\nReturn a set of TypeBindings to bind types from the parent …\nAdd the given trait as an operator trait if its name …\nAdd the given trait as an operator trait if its name …\nTries to retrieve the given id’s definition. This …\nReturns the span of an item stored in the Interner, if …\nSimilar to <code>lookup_trait_implementation</code> but does not apply …\nAttempts to resolve Location of Trait based on Location of …\nAttempts to resolve Location of Trait’s TraitFunction …\nAttempts to resolve Location of Type based on Location of …\nA list of all type aliases that are referenced in the …\nReturns the Type of the expression that exists at the …\nStores the Location of a Type reference\nUpdates the interned expression corresponding to <code>expr_id</code>\nUpdates the underlying interned Function.\nReturns the interned statement corresponding to <code>stmt_id</code>\nVerifies that each constraint in the given where clause is …\nWhether the function is <code>pub</code> or not.\nThe trait generics to use - if specified. This is allowed …\nA dependency in the dependency graph may be a type or a …\nAn ID for a global value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA reference to a module, struct, trait, etc., mainly used …\nThis is the definition id of the method or associated …\nReturns the module where this struct is defined.\nRepresents the methods on a given type that each share the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIterate through each method, starting with the direct …\nCaptures a reexport that happens inside a module. For …\nAn arbitrary number to limit the recursion depth when …\nAdds a <code>.clone()</code> to the given expression. Note that this …\nTraverse the given function and return the last use(s) of …\nReturns the argument unchanged.\nTraverse an expression comprised of only identifiers, …\nHandle the rhs of a <code>&amp;expr</code> unary expression. Variables and …\nCalls <code>U::from(self)</code>.\nThis module contains the last use analysis pass which is …\nWhenever an ident is used it is always cloned unless it is …\nThis contains each instance of a variable we should move …\nThe Id for a single branch of an if or match\nA variable’s last use may be split into several …\nA single path through a <code>Branches</code> enum.\nThe Id of an <code>if</code> or <code>match</code>, used to distinguish multiple …\nNo use in this branch or there is no branch\nThe outer <code>Vec</code> is each loop we’re currently in, while the …\nCollect all IdentIds from this tree\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStores the location of each variable’s last use\nRemember a new use of the given variable, possibly …\nA variable in an lvalue position is never moved (otherwise …\nA ParsedModule contains an entire Ast for one file.\nA submodule defined via <code>mod name { contents }</code> in some …\nRepresents a parsing error, or a parsing error in the …\nSkips any outer doc comments but produces an error saying …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModule declarations like <code>mod foo;</code>\nAddOrSubtractExpression = …\nAddOrSubtractTypeExpression = …\nAndExpression = XorExpression ( ‘&amp;’ XorExpression )*\nArguments = ‘(’ ArgumentsList? ‘)’\nArrayLiteral = StandardArrayLiteral | RepeatedArrayLiteral\nAsTraitPath = ‘&lt;’ Type ‘as’ PathNoTurbofish …\nAtom = Quark AtomRhs*\nAtomRhs = CallExpression | …\nAtomTypeExpression = ConstantTypeExpression | …\nAttribute = ‘#[’ (FunctionAttribute | …\nAttributes = Attribute*\nBlock = ‘{’ Statement* ‘}’\nParses an expression that looks like a block (ends with ‘…\nCallExpression = Quark CallArguments\nCallArguments = ‘!’? Arguments\nCastExpression = UnaryExpression ‘as’ Type\nComptimeExpression = ‘comptime’ Block\nComptimeStatement = ComptimeBlock | ComptimeLet | …\nConstantTypeExpression = int\nConstrainExpression = ‘constrain’ Expression | ‘…\nConstructorExpression = Type ‘{’ ConstructorFields? ‘…\nEnum = ‘enum’ identifier Generics ‘{’ EnumVariant* …\nEqualOrNotEqualExpression = OrExpression ( ( ‘==’ | ‘…\nExpression = EqualOrNotEqualExpression\nWhen parsing <code>if</code> conditions we don’t allow constructors. …\nForStatement = ‘for’ identifier ‘in’ ForRange Block\nForRange = ExpressionExceptConstructor | …\nFunction = ‘fn’ identifier Generics FunctionParameters …\nFunctionParameters = ‘(’ FunctionParametersList? ‘)…\nGeneric = VariableGeneric | NumericGeneric | …\nGenericTypeArgs = ( ‘&lt;’ GenericTypeArgsList? ‘&gt;’ )\nGenerics = ( ‘&lt;’ GenericsList? ‘&gt;’ )?\nGlobal = ‘global’ identifier OptionalTypeAnnotation ‘…\nIfExpression = ‘if’ ExpressionExceptConstructor Block …\nImpl = TypeImpl | TraitImpl\nIndexExpression = Quark ‘[’ Expression ‘]’\nInnerAttribute = ‘#![’ SecondaryAttribute ‘]’\nInnerDocComments = inner_doc_comment*\nInternedExpression = interned_expr\nInternedPattern = interned_pattern\nInternedStatementExpression = interned_statement\nItem = ( Attribute | OuterDocComments )* ItemKind\nParses an item inside an impl or trait, with good recovery:\nThis method returns one ‘ItemKind’ in the majority of …\nItemVisibility = ‘pub’                 // …\nLambda = ‘|’ LambdaParameters? ‘|’ ( ‘-&gt;’ Type …\nLessOrGreaterExpression = ShiftExpression ( ( ‘&lt;’ | ‘…\nLetStatement = ‘let’ pattern OptionalTypeAnnotation ‘…\nLiteral = bool | int | str | rawstr | fmtstr | …\nLoopStatement = ‘loop’ Block\nParses a list of items separated by a token, optionally …\nSame as parse_many, but returns a bool indicating whether …\nparse_many, where the given function <code>f</code> may return multiple …\nSame as parse_many, but returns a bool indicating whether …\nMatchExpression = ‘match’ ExpressionExceptConstructor …\nMatchRule = Expression ‘=&gt;’ (Block ‘,’?) | …\nMemberAccessOrMethodCallExpression = MemberAccessExpression\nModOrContract = ( ‘mod’ | ‘contract’ ) identifier …\nModifiers = ItemVisibility ‘unconstrained’? ‘comptime…\nMultiplyOrDivideOrModuloExpression = Term ( ( ‘<em>’ | ‘/</em>…\nMultiplyOrDivideOrModuloTypeExpression = …\nNamelessTypePathExpression = ‘&lt;’ Type ‘&gt;’ ‘::’ …\nNumericGeneric = ‘let’ identifier ‘:’ Type\nOptionalTypeAnnotation = ( ‘:’ Type )?\nOrExpression = AndExpression ( ‘|’ AndExpression )*\nOuterDocComment = outer_doc_comment\nOuterDocComments = OuterDocComment*\nParenthesesExpression = UnitLiteral | …\nParenthesizedPattern = ‘(’ Pattern ‘)’ …\nParenthesizedTypeExpression = ‘(’ TypeExpression ‘)…\nTries to parse a Path. Note that <code>crate::</code>, <code>super::</code>, etc., …\nParses a path assuming the path’s kind (plain, <code>crate::</code>, …\nPathExpression = VariableExpression | ConstructorExpression\nPathGenerics = GenericTypeArgs\nPathKind | ‘crate’ ‘::’ | ‘dep’ ‘::’ | ‘…\nPathNoTurbofish = PathKind identifier ( ‘::’ …\nPattern = ‘mut’ PatternNoMut\nPatternNoMut = InternedPattern | ParenthesizedPattern | …\nPatternOrSelf = Pattern | SelfPattern\nEntry function for the parser - also handles lexing …\nQuark = Literal | ParenthesesExpression | UnsafeExpression …\nResolvedExpression = unquote_marker\nShiftExpression = AddOrSubtractExpression ( ( ‘&lt;&lt;’ | …\nSliceExpression = ‘&amp;’ ArrayLiteral\nStatement = Attributes StatementKind ‘;’?\nStatementKind = BreakStatement | ContinueStatement | …\nParses either a statement, an expression or an LValue. …\nStruct = ‘struct’ identifier Generics ‘{’ …\nStructPattern = Path ‘{’ StructPatternFields? ‘}’\nTerm = UnaryExpression | CastExpression\nTermTypeExpression = ’- TermTypeExpression | …\nTrait = ‘trait’ identifier Generics ( ‘:’ …\nTraitBody = ‘{’ ( OuterDocComments TraitItem )* ‘}’\nTraitBound = PathNoTurbofish GenericTypeArgs\nTraitBounds = TraitBound ( ‘+’ TraitBound )? ‘+’?\nTraitConstant = ‘let’ identifier ‘:’ Type ( ‘=’…\nTraitFunction = Modifiers Function\nTraitImpl = ‘impl’ Generics Type ‘for’ Type …\nTraitImplBody = ‘{’ TraitImplItem* ‘}’\nTraitImplConstant = ‘let’ identifier …\nTraitImplFunction = Attributes Modifiers Function\nTraitImplItem = TraitImplType | TraitImplConstant | …\nTraitImplType = ‘type’ identifier ( ‘:’ Type )? ‘…\nTraitItem = TraitType | TraitConstant | TraitFunction\nTraitType = ‘type’ identifier ( ‘:’ TraitBounds ) …\nTypeAlias = ‘type’ identifier Generics ‘=’ Type ‘…\nTypeExpression= AddOrSubtractTypeExpression\nTypeImpl = ‘impl’ Generics Type TypeImplBody\nTypeImplBody = ‘{’ TypeImplItem* ‘}’\nTries to parse a type. If the current token doesn’t …\nTypeOrTypeExpression = Type | TypeExpression\nTypePathExpression = PrimitiveType ‘::’ identifier ( …\nUnaryExpression = UnaryOp* Atom\nUnaryOp = ‘&amp;’ ‘mut’ | ‘-’ | ‘!’ | ‘*’\nUnquoteExpression = ‘$’ identifier | ‘$’ ‘(’ …\nUnsafeExpression = ‘unsafe’ Block\nUse = ‘use’ PathKind PathNoTurbofish UseTree\nVariableGeneric = identifier ( ‘:’ TraitBounds ) ?\nVariableTypeExpression = Path\nVisibility = ‘pub’ | ‘return_data’ | ‘call_data…\nWhereClause = ‘where’ WhereClauseItems?\nWhileStatement = ‘while’ ExpressionExceptConstructor …\nXorExpression = LessOrGreaterExpression ( ‘^’ …\nThe current statement’s comments. This is used to …\nFull submodules as in <code>mod foo { ... definitions ... }</code>\nSkips any outer doc comments but produces a warning saying …\nRepresents a parsing error, or a parsing error in the …\nUsed to annotate parsing rules with extra context that can …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBumps this parser by one token. Returns the token that was …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nModule = InnerDocComments Item*\nEntry function for the parser - also handles lexing …\nProgram = Module\nInvokes <code>parsing_function</code> (<code>parsing_function</code> must be some …\nThe current statement’s comments. This is used to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStrips leading ‘*’ from a block comment if all …\nStrips leading ’ ’ from a line comment.\nWhen parsing an array literal we might bump into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelfPattern is guaranteed to be <code>self</code>, <code>&amp;self</code> or <code>&amp;mut self</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether a parameter or return value is public …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether a parameter or return value is public …\nNecessary to handle casting to unsigned generically …\nReturns the inner FieldElement which will always be …\nReturns the argument unchanged.\nConvert a signed integer to a SignedField, carefully …\nCalls <code>U::from(self)</code>.\nConvert a SignedField into a signed integer type (up to …\nConvert a SignedField into an unsigned integer type (up to …\nReturns the argument unchanged.\nCompile a program.\nCalls <code>U::from(self)</code>.\nRegister an item as unused, waiting to be marked as used …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks an item as being referenced. This doesn’t always …\nMarks an item as being used.\nGet all the unused items per module.")