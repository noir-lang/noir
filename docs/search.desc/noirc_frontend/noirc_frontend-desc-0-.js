searchState.loadedDescShard("noirc_frontend", 0, "The noir compiler is separated into the following passes …\nThe submodules of this module define the various data …\nThe Elaborator\nNoir’s HIR (High-Level Intermediate Representation) is …\nThe lexer is the first pass of the noir compiler. Its goal …\nComing after elaboration, monomorphization is the last …\nThis module implements the “ownership analysis” …\nThe parser is the second pass of the noir compiler. The …\nThe <code>shared</code> module contains simple types which are using in …\nThis crate represents utility methods which can be useful …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nAn “as Trait” path leading to an associated type. E.g. …\nAn iterator over the variants of Self\nThis statement should be executed at compile-time\nReturns type is not specified.\nIf <code>implicitly_added</code> is true, this operation was implicitly …\nThis is used when an identifier fails to parse in the …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nThis statement is the result of a recovered parse error. …\nCurrently, we support four types of functions:\nAn argument to a generic type or trait.\nAn iterator over the variants of Self\nThis is an interned StatementKind during comptime code. …\nInterned statements are allowed to be parsed as …\nRepresents whether the definition can be referenced …\nRepresents an Ast form that can be assigned to\nA Named UnresolvedType can be a struct type or a type …\nA named argument, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nAst node for an enum\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nAn ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nAlready-resolved generics can be parsed as generics when a …\n&amp;T and &amp;mut T\nThis path is a Crate or Dep path which always points to …\nAn already resolved type. These can only be parsed if they …\nThis is an expression with a trailing semi-colon\nAst node for statements in noir. Statements are always …\nA Trait as return type or parameter of function, including …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nEverything else.\nAst node for type aliases Depending on ‘numeric_type’, …\nAst node for an impl of a concrete type …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nA Vec of unresolved names for type variables. For …\nRepresents a simple trait constraint such as …\nThe parser parses types as ’UnresolvedType’s which …\nThe precursor to TypeExpression, this is the type that the …\nImplements the Visitor pattern for Noir’s AST.\nThis is used to represent an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMethod calls have an optional list of generics if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function was defined with the ‘comptime’ …\ntrue if generated at compile-time, e.g. from a trait alias\nTrue if this function was defined with the ‘unconstrained…\nThe location of <code>kind</code> (this is the same as <code>location</code> for …\nThe kind of each argument, in order (in case traversing …\nAll named arguments, e.g. <code>&lt;A = B, C = D, E = F&gt;</code>. Used for …\nEach ordered argument, e.g. <code>&lt;A, B, C&gt;</code>\nThis is None for tag variants without parameters. A value …\nIndicate if this function was defined with the ‘pub’ …\nWe only support  variants of the form <code>Name(A, B, ...)</code> …\nAst node for an enum\nThis is None for tag variants without parameters. A value …\nAn iterator over the variants of Self\nReturns type is not specified.\nIf <code>implicitly_added</code> is true, this operation was implicitly …\nInterned statements are allowed to be parsed as …\nAlready-resolved generics can be parsed as generics when a …\nEverything else.\nA Vec of unresolved names for type variables. For …\nConverts a token to a unary operator If you want the …\nMethod calls have an optional list of generics if the …\n<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>\nComparator operators return a 0 or 1 When seen in the …\nTrue if this function was defined with the ‘comptime’ …\n<code>==</code> and <code>!=</code>\nTrue if this function was defined with the ‘unconstrained…\nThe number of arguments expected by the constraint, not …\nReturns the innermost location that gives this expression …\nIndicate if this function was defined with the ‘pub’ …\nCurrently, we support four types of functions:\nBoth the <code>#[fold]</code> and <code>#[no_predicates]</code> alter a function’s …\nA special kind of path in the form <code>&lt;MyType as Trait&gt;::ident</code>…\nThis statement should be executed at compile-time\nThis is used when an identifier fails to parse in the …\nThis statement is the result of a recovered parse error. …\nThis is an interned StatementKind during comptime code. …\nRepresents an Ast form that can be assigned to\nThis path is a Crate or Dep path which always points to …\nThis is an expression with a trailing semi-colon\nAst node for statements in noir. Statements are always …\nA special kind of path in the form <code>Type::ident::&lt;turbofish&gt;</code>\nThis is used to represent an …\nConstruct a PathKind::Plain from a single Ident.\nConstruct a PathKind::Plain from a single identifier name.\nGets the underlying identifier without its location.\nCreate a ‘for’ expression taking care of desugaring a …\nCreate a half-open range bounded inclusively below and …\nThe location of <code>kind</code> (this is the same as <code>location</code> for …\nCreate a half-open range, bounded inclusively below and …\nReturns the span where turbofish happen. For example:\nReturns the innermost location that gives this statement …\nAst node for a struct\nAST node for trait definitions: …\nAst node for an implementation of a trait for a particular …\nRepresents a single trait bound, such as <code>TraitX</code> or …\nAny declaration inside the body of a trait that a user is …\nAst node for an impl of a concrete type …\nRepresents a simple trait constraint such as …\nMoves trait bounds from generics into where clauses. For …\nDoes both <code>desugar_generic_trait_bounds</code> and …\ntrue if generated at compile-time, e.g. from a trait alias\nReorders a where clause in-place so that simpler …\nAst node for type aliases Depending on ‘numeric_type’, …\nImplements the Visitor pattern for Noir’s AST.\nThis structure is used to collect information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluating a comptime call like <code>Module::add_item</code>\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nResolverMetas are tagged onto each definition to track how …\nA function attribute generated an item that’s being …\nDetermines whether we are in an unsafe block and, if so, …\nAdd a ResolverMeta to the last scope for a given HirIdent, …\nAdds function generics and associated generics (from where …\nAdd the given generics to scope. Each generic will have a …\nAdd a generated item to the collected items (unquoting) …\nFor each associated type that isn’t mentioned in a trait …\nAdds the given trait constraints to scope as assumed trait …\nAdd a local or const numeric variable declaration to the …\nHandles the TypeVariable case for checking binary …\nCall a macro function and inlines its code at the call …\nDefaults all type variables used in this function context …\nCheck whether we can create a mutable reference over an …\nWe must check whether the mutable variable we are …\nType checks a field access, adding dereference operators …\nChecks all resolved structs for nested slice types, which …\nCheck that all the generics show up in any of <code>types</code> (if …\nOnly sized types are valid to be used as main’s …\nChecks that <code>expr_kind</code> matches <code>expected_kind</code>, issuing an …\nChecks whether calling the method <code>func_id</code> on an object of …\nChecks that a public struct does not have fields with more …\nChecks whether accessing the struct field <code>field_name</code> of …\nCheck that an item such as a struct field or type alias is …\nChecks that the type’s Kind matches the expected kind, …\nIssue an error if the impl is stricter than the trait.\nCollect all attributes to run from traits, types, …\nResolve an attribute to the function it refers to and add …\nCollect all comptime attributes from an item’s attribute …\nCollects all impl blocks for a given type, declaring their …\nCollects and resolves all struct definitions.\nResolve the methods of each trait in an environment where …\nFor each trait:\nGiven a binary comparison operator and another type. This …\nComptime expression evaluation and macro expansion via the …\nThe current dependency item we’re resolving. Used to …\nThe trait  we’re currently resolving, if we are …\nIf we’re currently resolving methods within a trait …\nDebug helper to print comptime evaluation results.\nThe scope of –debug-comptime, or None if unset\nRegisters methods in the interner’s method table for …\nDeclares methods in the appropriate module and registers …\nDefines the value of an enum variant that we resolve an …\nExtracts and stores metadata from a function definition.\nDefines function metadata for all functions, impl methods, …\nDefines function metadata for a set of functions with …\nDefines function metadata for all methods within an impl …\nDefines function metadata for all methods within a trait …\nThis turns function parameters of the form: …\nExpands any traits in a where clause to mention all …\nDeny crates from requiring unstable features.\nElaborate the expression, resolve the target type, then …\nEvaluates the global’s initializer expression at compile …\nElaborate a struct constructor.\nKnowing the Type being constructed, elaborate all field …\nElaborates a function’s body and performs type checking.\nElaborates a global constant definition, performing name …\nIf the given global is unresolved, elaborate it and return …\nPerform the given function in a comptime context.\nGiven its ID, retrieve and elaborate an interned …\nElaborate an expression from the middle of a comptime …\nElaborate an expression from the middle of a comptime …\nFor elaborating a lambda we might get <code>parameters_type_hints</code>…\nElaborate a local or global let statement. If this is a …\nElaborates an lvalue returning:\nElaborate a <code>match &lt;expr&gt; { &lt;rules&gt; }</code> expression by …\nCompiles the rows of a match expression, outputting a …\nTo elaborate the rules of a match we need to go through …\nThis method also returns whether or not its lhs still …\nElaborate the target of the method call and try to look up …\nElaborate a pattern, which can appear in a …\nEquivalent to <code>elaborate_pattern</code>, this version just also …\nElaborate the (potentially mutable) pattern and add the …\nSometimes items are elaborated because a function …\nElaborate a member access expression without adding the …\nElaborate any globals which were not brought into scope by …\nElaborates a type path used in an expression, e.g. …\nChecks whether <code>variable</code> is <code>Self::method_name</code> or …\nUnstable compiler features that were explicitly enabled. …\nEnum definition collection and variant resolution.\nRun the given function using the resolver and return true …\nConvert an expression into a Pattern, defining any …\nExpression elaboration, covering all expression kinds.\nReturns a struct’s visibility.\nGo through the given tokens looking for a ‘$’ token …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction metadata and function body elaboration.\nFunction-local context management for type variables and …\nThis is a stack of function contexts. Most of the time, …\nGeneric parameter resolution and type parameter handling.\nContains a mapping of the current struct or functions’s …\nResolve a TypedPath into a local or global HirIdent.\nResolve a TypedPath into a local or global HirIdent, or …\nGlobal constant definition elaboration and comptime …\nElaborate and type-check arguments passed to an attribute …\nGiven an HirIdent, look up its definition, and:\nHandles the results of Self::prefix_operand_type_rules and …\nInherent type implementations collection and method …\nTrue if we’re currently within a <code>comptime</code> block, …\nTrue if we’re elaborating a comptime item such as a …\nTrue if we’re currently within a constrained function or …\nReturns <code>true</code> if the current module is a contract.\nTrue if we are elaborating arguments of a function call to …\nGiven a binary operator and another type, this method will …\nInsert as many dereference operations as necessary to …\nInstantiate a Type with the given TypeBindings, returning …\nInstantiates a primitive type with turbofish generics.\nPush a HirExpression with its Location, with the Type to …\nFollow up Self::intern_expr with the Type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the current local module is the crate root,\nCheck if the callee is an unconstrained function, or a …\nWhen resolving lambda expressions, we need to keep track …\nLint checks for function attributes, visibility, and usage …\nThe current module this elaborator is in. Initially None, …\nResolve Self::Foo to an associated type on the current …\nTry to look up a TypedPath in the globals.\nTry to look up a method on a Type by name:\nAssuming that we are currently elaborating a function, try …\nLooks up a method in the given trait and its parent …\nLookup a given trait by name/path.\nLooks up a given Type by name.\nGiven:\nMark a struct as used in the UsageTracker.\nCompiler frontend options and unstable feature flags.\nOptions from the nargo cli\nPath resolution for types, values, and trait methods …\nConvert a PathResolutionItem - usually an enum variant or …\nPattern elaboration, variable binding, and turbofish …\nTrue if we should use pedantic ACVM solving\nUse pedantic ACVM solving\nTransform a result from PerNs into a PathResolutionItem, …\nReturn a fresh integer type variable and log it in …\nReturn a fresh integer or field type variable and log it …\nPopulate the elaborator’s scope with all comptime …\nGiven a unary operator and a type, this method will …\nPrepares a trait impl for function metadata definition.\nPrimitive type definitions\nTrue if the <code>pub</code> keyword is allowed on parameters in this …\nPush a type variable into the current FunctionContext to …\nPush an <code>ExprId</code> that corresponds to an integer literal. At …\nPush a type variable (its ID and type) as a required type …\nPush a trait constraint into the current FunctionContext …\nRuns <code>f</code> and if it modifies <code>self.generics</code>, <code>self.generics</code> is …\nThe removing counterpart for …\nResolve generics using the generic and generic kinds of a …\nAssuming that a Generic type accepts named type arguments, …\nResolve all the fields of a struct constructor expression. …\nResolve all the fields of a struct constructor expression. …\nResolves function parameters and validates their types for …\nResolve generics using the expected kinds of the function …\nReturn the kind of an unresolved generic. If a numeric …\nTranslates a (possibly Unspecified) UnresolvedType to a …\nSolve any generics that are part of the path before the …\nGiven the generic Kinds of a type and its own declared …\nFor each crate::elaborator::LambdaContext on the lambda …\nAssuming that the current path segment is a type or type …\nResolves a TypedPath assuming it is inside <code>starting_module</code>.\nTry to resolve a TypedPath into a PathResolution with …\nResolves a TypedPath.\nResolves a path in the current module.\nTry to resolve a TypedPath into a PathResolutionItem, …\nTry to resolve a TypedPath into a PathResolutionItem.\nTry to resolve a path with 1 or 2 segments as a …\nResolves the field types for a single struct definition.\nGet the DataType of a TypeId and call …\nResolve generics using the generic kinds of a struct …\nIdentical to Self::resolve_type_or_trait_args_inner but …\nResolve the given TraitBound, pushing error(s) if the path …\nResolves a trait constraint and adds it to scope as an …\nResolve the given trait constraints and add them to scope …\nDefines the FuncMeta for this trait function.\nTry to resolve a TypedPath to a trait method path.\nResolves associated types for a trait impl and checks for …\nResolves the trait path from a trait impl declaration. …\nThis resolves a static trait method T::trait_method by …\nResolves a trait’s methods, but does not elaborate their …\nThis resolves <code>TraitName::some_static_method</code>\nThis resolves <code>Self::some_static_method</code>, inside an impl …\nResolve generics using the generics and generic kinds of a …\nGiven the generic Kinds of a type, and the list of generic …\nResolves an UnresolvedType to a Type with Kind::Normal and …\nGet the TypeAlias of a TypeAliasId and call …\nResolves the ordered and named GenericTypeArgs into Types …\nTranslates an UnresolvedType to a Type with a given Kind …\nMatches GenericTypeArgs::ordered_args to the …\nThis resolves a method in the form <code>Type::method</code> where …\nResolves an UnresolvedType to a Type with a given Kind and …\nTranslates an UnresolvedType into a Type with a given Kind …\nResolve a TypedPath to a HirIdent of either some trait …\nIn-resolution names\nGiven a list of functions and the trait they belong to, …\nExecute an attribute function on an item.\nRun all the attributes on each item in the crate in …\nLexical scoping, variable lookup, and closure capture …\nthe index in the scope tree (sometimes being filled by …\nSet to the current type if we’re resolving an impl\nOrder the set of unresolved globals by their GlobalId. …\nCreate a new interpreter for evaluating comptime code.\nSets up generics for a trait impl and processes trait …\nCheck whether a function’s args and return value should …\nIf greater than 0, field visibility errors won’t be …\nStatement elaboration including let bindings, assignments, …\nStruct definition collection and field resolution.\nEach constraint in the <code>where</code> clause of the function …\nTrait implementation collection, method matching, and …\nTrait definition collection, bounds resolution, and …\nCheck if the given method type requires a mutable …\nGiven a method object: <code>(*foo).bar</code> of a method call …\nPrerequisite: verify_trait_constraint of the operator’s …\nStarting with empty bindings, perform the type checking of …\nPerform the type checking of an interned expression and a …\nIf the given type was declared as:\nReturn a fresh integer type variable and log it in …\nType resolution, unification, and method resolution (for …\nIf we know this lambda to be unconstrained.\nUnify two types, modifying both in the process.\nWrapper of Type::unify_with_coercions, pushing any …\nToken stream processing for macro unquoting and variable …\nThese are the globals that have yet to be elaborated. This …\nTry to resolve a TypedPath into a PathResolution with …\nTry to resolve a TypedPath into a PathResolutionItem, …\nResolves an UnresolvedType to a Type with Kind::Normal and …\nResolves the ordered and named GenericTypeArgs into Types …\nResolves an UnresolvedType to a Type and marks it, and any …\nRegister a use of the given unstable feature. Errors if …\nLookup and use the specified local variable. This will …\nCreate a validated TypedPath from a Path by resolving all …\nCreate a validated TypedPathSegment from a PathSegment by …\nEverything to do with elaboration of variables. Notably, …\nVisibility checking for functions, struct fields, and type …\nIntroduce an internal variable in order to be able to …\nContext information for the module that an attribute is …\nA collected attribute ready to be executed.\nA collection of attributes ready to be executed.\nArguments passed to the attribute\nThe module where the attribute is located. This is needed …\nModule context for the attribute\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe attribute function to call\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item being attributed (struct, function, etc.)\nLocation of the attribute in source code\nThe module where generated items should be added\nA pattern binding a variable such as <code>a</code> or <code>_</code>\nA pattern checking for a tag and possibly binding …\nAn error occurred while translating this pattern. This …\nAn integer literal pattern such as <code>4</code>, <code>12345</code>, or <code>-56</code>\nMultiple patterns combined with <code>|</code> where we should match …\nA Pattern is anything that can appear before the <code>=&gt;</code> in a …\nAn integer range pattern such as <code>1..20</code> which will match …\nReturn the variable that was referred to the most in <code>rows</code>\nCompiles the cases and sub cases for the constructor …\nCompiles the cases and fallback cases for integer and …\nMove any cases with duplicate branches into a shared ‘…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTraverse the resulting HirMatch to build counter-examples …\nIssue a missing cases error if necessary for the given …\nAny case that isn’t branched to when the match is …\nCreates: <code>{ let &lt;variable&gt; = &lt;rhs&gt;; &lt;body&gt; }</code>\nThe type variable corresponds to the type of an array …\nThe kind of required type variable.\nThe type variable corresponds to an identifier, whose …\nA type variable that is required to be bound after …\nThe type variable corresponds to a struct generic, in a …\nAll type variables created in the current function. This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAll ExprId in a function that correspond to integer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType variables that must be bound at the end of the …\nTrait constraints are collected during type checking until …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if an expression will end up calling a specific …\nChecks if an ExprId, which has to be an integer literal, …\ncall_data and return_data visibility modifiers are only …\nInline attributes are only relevant for constrained …\nAttempting to define new low level (<code>#[builtin]</code> or …\n<code>pub</code> is required on return types for entry point functions\nThe <code>#[no_predicates]</code> attribute is not allowed on entry …\nOracle definitions (functions with the <code>#[oracle]</code> …\nOracle functions cannot return more than 1 slice in their …\nCheck that a recursive function <em>can</em> return without …\nCheck that we are not passing a mutable reference from a …\nCheck that that a type returned from an unconstrained to a …\nOnly arguments to entrypoint functions may have a …\nOnly entrypoint functions require a <code>pub</code> visibility …\nOptions from nargo_cli that need to be passed down to the …\nThis is the unresolved version of <code>ElaboratorOptions</code> CLI …\nGeneric options struct meant to resolve to …\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nThe scope of –debug-comptime, or None if unset\nDeny crates from requiring unstable features.\nDeny crates from requiring unstable features.\nDeny crates from requiring unstable features.\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nUnstable compiler features that were explicitly enabled. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nUse pedantic ACVM solving\nA sane default of frontend options for running tests\nContains the error value\nFound a method.\nMultiple (ambiguous) trait method matches were found and …\nThere’s only one trait method that matches, but it’s …\nFound a trait method and it’s currently in scope.\nA reference to a global value.\nAny item that can appear before the last segment in a path.\nA function call on a module, for example …\nThe method could not be found. There might be trait …\nContains the success value\nAll possible items that result from resolving a Path. Note …\nDetermines whether data-types found along a path are to be …\nDepending on where a path appears in the source code it …\nA function call on a primitive type, for example …\nA function call on <code>Self</code>, for example <code>Self::function()</code>. …\nA function call on a trait, for example <code>Trait::function()</code> …\nA function call on a type alias, for example …\nA function call on a type that resolves to a trait method, …\nLike a <code>crate::ast::Path</code> but each segment has resolved …\nLike a <code>crate::ast::PathSegment</code> but with resolved turbofish …\nReturns <code>Some</code> if the TypedPath consists of a single …\nThe name of the Ident in the first segment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a PathKind::Plain from a single identifier …\nConstruct a PathKind::Plain from a single identifier name.\nReturn a FuncId if the item refers to some kind of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe location of <code>kind</code> (this is the same as <code>location</code> for …\nThe Ident of the last segment.\nThe name of the Ident in the last segment.\nReturns a clone of the last segment.\nTransform a ModuleDefId into a PathResolutionItem.\nConstruct a PathKind::Plain from a number of segments.\nRemoves and returns the last segment.\nReturns the turbofish if there are generics in the path.\nLocation of any turbofish in the segment.\nReturns the span where turbofish can happen. For example:\nAn iterator over the variants of Self\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe possible errors of interpreting given code into a …\nReturns the argument unchanged.\nInterpret source code using the elaborator, without …\nCalls <code>U::from(self)</code>.\nCheck the given function type matches the expected one.\nChecks that the type of a function in a trait impl matches …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBind the generics of the Type aliased by the TypeAlias to …\nXXX: This is bare-bone for two reasons:\nA dependency is a crate name and a crate_id This means …\nThe special case of running the compiler against the …\nTries to find the requested crate in the current one’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper object which groups together several useful context …\nActivates LSP mode, which will track references for all …\nThe comptime interpreter is used to execute Noir code …\nReturn the CrateId for each crate that has been compiled …\nThis set of modules implements the name resolution pass …\nReturns the CrateDefMap for a given CrateId. It is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a fully-qualified path to the given TypeId from …\nReturns a list of all functions in the current crate …\nReturns a list of all functions in the current crate …\nReturns the FuncId of the ‘main’ function in a crate.\nInterprets (as comptime code) the given function in the …\nWriter for comptime prints.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAny unstable features required by the current package or …\nThis set of modules implements the second half of the name …\nGenerics need to be resolved before elaboration to …\nA map of each file that already has been visited from a …\nComptime errors always wrap another error to show it …\nThe possible errors that can halt the interpreter.\nStruct elements are automatically shared to support …\nTuple elements are automatically shared to support …\nA value representing the result of evaluating a Noir …\nMaps each generic to the binding it has in the current …\nThe current function being interpreted. This may be <code>None</code> …\nTo expand macros the Interpreter needs access to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrue if the interpreter is currently in a loop (in the …\nThe comptime interpreter is a tree-walking interpreter …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEvaluates any expressions within UnquoteMarkers in the …\nDefines the Value type, representing a compile-time value, …\nTries to print tokens in a way that it’ll be easier for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermines whether the last outputted byte was …\nComptime errors always wrap another error to show it …\nContains the error value\nThe possible errors that can halt the interpreter.\nContains the success value\nMaps each generic to the binding it has in the current …\nBounds check the given array and index pair. This will …\nLarge file containing implementations of all the various …\nCall a closure value with the given arguments and …\nPerforms the bulk of the work for calling a closure …\nCall the given function with the given arguments and …\nHelper to check parameter count and dispatch on the …\nCalls a builtin, foreign, or oracle function (not all …\nCall a non-builtin function\nThe current function being interpreted. This may be <code>None</code> …\nReturns the current scope to define comptime variables in. …\nDefine a new variable in the current scope\nDefines a pattern, putting all variables contained within …\nHelper to elaborate the given item in the given function’…\nRun the given function with an elaborator in the context …\nTo expand macros the Interpreter needs access to the …\nEnters a function, pushing a new scope and resetting any …\nEvaluate an expression and return the result. This will …\nEvaluates a call expression, deferring to …\nUnlike a struct constructor, an enum constructor inserts a …\nEvaluates a format string. Note that in doing so, the …\nEvaluates a variable\nSince integers are polymorphic, evaluating one requires …\nReturns the current value held by <code>lvalue</code>\nEvaluating a mutable variable will dereference it …\nEvaluates a numeric generic with the value <code>value</code> (expected …\nGiven the result of a <code>cmp</code> operation, convert it into the …\nResets the per-function state to the value previously …\nThe foreign function counterpart to <code>interpreter/builtin.rs</code>…\nGiven a value, return the struct/tuple field with the …\nTry to retrieve a function’s body. If the function has …\nTrue if the interpreter is currently in a loop (in the …\nLookup the comptime value of the given variable\nLookup the comptime value of the given definition\nMutate an existing variable, potentially from a prior scope\nPops the topmost scope.\nPushes a new scope to define any variables in.\nPops the top of <code>self.bound_generics</code> then takes the new …\nAdds all of the given <code>main_bindings</code> and <code>impl_bindings</code> to …\nWhen we store to a struct such as in\nStores <code>rhs</code> at the location determined by <code>lvalue</code>\nUnbinds all of the generics at the top of …\nThis function is used by the interpreter for some comptime …\nVarious helpers for implementing built-in functions in the …\nGiven a type, assert that it’s an <code>Option&lt;T&gt;</code> and return …\nCreates a value that holds an <code>Option</code>. <code>option_type</code> must be …\nfn as_type(self) -&gt; Type\n…\nfn fields(self, generic_args: Type) -&gt; [(Quoted, Type, …\nfn fields_as_written(self) -&gt; [(Quoted, Type, Quoted)] …\nfn generics(self) -&gt; [(Type, <code>Option&lt;Type&gt;</code>)]\nfn set_fields(self, new_fields: [(Quoted, Type, Quoted)]) …\nType to be used in <code>Value::Array(&lt;values&gt;, &lt;array-type&gt;)</code>.\nType to be used in <code>Value::Slice(&lt;values&gt;, &lt;slice-type&gt;)</code>.\nInterpret the input as an array, then map each element. …\nGet an array and convert it to a fixed size. Returns the …\nGet a specific field of a struct and apply a decoder …\nGet the fields if the value is a <code>Value::Struct</code>, otherwise …\nCreate a <code>Value::Array</code> from bytes.\nCreate a <code>Value::Slice</code> from bytes.\nCreate a <code>Value::Struct</code> from fields and the expected return …\nNo-op also covers the zero-extend case since we convert …\nConvert the input value to a (field, sign) pair. …\nevaluate_cast without recursion\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\nRun one of the Blake hash functions.\nCalls the given foreign function.\nRun one of the Secp256 signature verifications.\nDecode an <code>EmbeddedCurvePoint</code> struct.\nDecode an <code>EmbeddedCurveScalar</code> struct.\n<code>fn keccakf1600(input: [u64; 25]) -&gt; [u64; 25] {}</code>\n…\n…\nStruct elements are automatically shared to support …\nTuple elements are automatically shared to support …\nA value representing the result of evaluating a Noir …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the type of this value. Types can always be …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLowers this value into a runtime expression.\nLowers this compile-time value into a HIR expression. This …\nAttempt to convert this value into a Vec of tokens …\nSimilar to Self::into_expression or …\nReturns false for non-integral <code>Value</code>s.\nStructs and tuples store references to their fields …\nHelper to parse the given tokens using the given parse …\nConverts any integral <code>Value</code> into a <code>SignedField</code>. Returns …\nUnwraps an Rc value without cloning the inner value if the …\nGiven a Crate root, collect all definitions in that crate\nMaps the type and the module id in which the impl is …\nStores all of the unresolved functions in a particular …\nCollect all of the definitions in a given crate into a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the primary location where this error happened.\nGiven a module collect all definitions into ModuleData\nIf this submodule is an stdlib module that’s tagged with …\nWalk a module and collect its definitions.\nCollect any enum definitions declared within the ast. …\nCollect any struct definitions declared within the ast. …\nReturns a tuple of (methods, associated types, associated …\nCollect any traits definitions declared within the ast. …\nCollect any type aliases definitions declared within the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSearch for a module named <code>mod_name</code> Parse it, add it as a …\nAdd a child module to the current def_map. On error this …\nAdd a child module to the current def_map. On error this …\nReturns true if a module’s child modules are expected to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap of all modules and scopes defined within a crate.\nAll the definitions of Idents in scope, either as <code>types</code> or …\nLets first check if this is offered by any external crate …\nThe name that is used for a non-contract program’s …\nContains the actual contents of a module: its parent (if …\nA generic ID that references either a module, function, …\nResult of looking up a name in type and value definitions …\nGets the index that underlies this local module ID.\nEach child in the order they were declared in the parent …\nCollect all definitions in the crate\nContains only the definitions directly defined in the …\nMaps an external dependency’s name to its root module id.\nReturns the reason for the test function to fail if …\nReturns the reason for the fuzzing harness to fail if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the ModuleData stored at …\nReturns an iterator over all contract modules within the …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nGo through all modules in this crate, and find all …\nFind a child module’s name by inspecting its parent. …\nReturn a topological ordering of each module such that any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nFind the main function for this crate\nConstructs a new <code>CrateDefMap</code>, containing only the crate’…\nReturns true if the fuzzing harness has been specified to …\nReturns this module’s parent, if there’s any.\nGiven a FileId, fetch the File, from the FileManager and …\nContains all definitions visible to the current module. …\nReturns true if the test function has been specified to …\nReturns true if the fuzzing harness has been specified to …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nAll the definitions of Idents in scope, either as <code>types</code> or …\nDefinitions of an Ident: it can be a standalone without a …\nAdd an Ident and its ModuleDefId to the namespace, and …\nAdd an Ident and its ModuleDefId to either <code>types</code> or <code>values</code>,\nLook up an Ident in <code>values</code>, then return the FuncId if the …\nLook up an Ident in <code>types</code> with no TraitId, and return it …\nLook for an Ident in both <code>types</code> and <code>values</code>.\nLook for an Ident in both <code>types</code> and <code>values</code>,\nLook up an Ident in <code>types</code> or <code>values</code>:\nAll Idents in <code>types</code> and <code>values</code>.\nContains the actual contents of a module: its parent (if …\nEach child in the order they were declared in the parent …\nContains only the definitions directly defined in the …\nFind an Ident in the types and values in scope.\nFinds a trait in scope and returns its name (either the …\nTrue if this module is a <code>contract Foo { ... }</code> module …\nTrue if this module is actually a type\nContains all definitions visible to the current module. …\nAll traits in scope, either from <code>use</code> imports or <code>trait</code> …\nReturn an iterator over all definitions defined within …\nA generic ID that references either a module, function, …\nResult of looking up a name in type and value definitions …\nReturns <code>true</code> if both <code>types</code> and <code>values</code> are empty.\nIterate the ModuleDefIds in both <code>types</code> and <code>values</code>.\nIterate the results in both <code>types</code> and <code>values</code>.\nCreates a PerNs with a public ModuleDefId in <code>types</code>, and no …\nReturns the HIR as human-readable code for the given crate.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module is responsible for building a list of items …\nTrait constraints in scope. These are set when a trait, …\nKeep track of trait impls that have been printed so we don…\nTrue if the trait impl only mentions types from external …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll trait implementations in the current crate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUnlike Span::empty, Span::initial always starts at index 0\nReturns <code>true</code> if any point of <code>self</code> intersects a point of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns <code>true</code> if the first segment of a <code>TypedPath</code> in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the name that’s brought into scope: either the …\nResolve a <code>TypedPath</code> based on its PathKind to the target …\nResolve a path such as <code>crate::foo::bar</code> or <code>$crate::foo::bar</code>.\nResolve a path such as <code>dep::foo:bar::baz</code>:\nResolves a Path in a <code>use</code> statement, assuming it’s …\nResolves a TypedPath assuming it is inside <code>starting_module</code>.\nGiven a <code>TypedPath</code> and a ModuleId it’s being used in, …\nResolve a path such as <code>foo::bar</code>:\nResolve a path such as <code>super::foo::bar</code>:\nReturns whether two types are the same disregarding their …\nReturns true if an item with the given visibility in the …\nReturns whether a method call <code>func_id</code> on an object of type …\nReturns true if <code>current</code> is a (potentially nested) child …\nReturns true if <code>target</code> is a struct and its parent is …\nReturns whether a struct member with the given visibility …\nReturns whether a trait member with the given visibility …\nReturns whether a struct or trait member with the given …\nThis implementation uses the terminology Scope and …\nScopeTree allows one to specify that maps within the same …\nEnding a function requires that we removes it’s whole …\nEnds the current scope - this should correspond with the …\nReturns an iterator over all of the elements which satisfy …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the last pushed scope from the current scope tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarting a function requires a new scope tree, as you do …\nThe beginning of a scope always correlates with the start …\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRust also only shows 3 maximum, even for short patterns.\nThis error is used for types like integers which have too …\nRepresents something that can be generic over type …\nTraitGenerics are different from regular generics in that …\nTrue if this item kind can ever accept named type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach ordered generic kind on this type, excluding any …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of this kind of item, for error messages. E.g. “…\nThe name of this item, usually named by a user. E.g. “Foo…\nA Failure node in the match. <code>missing_case</code> is true if this …\nA method can be defined in a regular <code>impl</code> block, in which …\nRun <code>body</code> if the given expression is true. Otherwise …\nA variable captured inside a closure\nCorresponds to <code>assert</code> and <code>assert_eq</code> in the source code. …\nAn enum constructor is an expression such as …\nA HirExpression is the result of an Expression in the AST …\nCorresponds to a variable in the source code\nIndexing, as in <code>array[index]</code>\nThis is always a struct field access <code>my_struct.field</code> and …\nThese nodes are temporary, they’re lowered into …\nThis ident is not a trait method\nJump directly to ExprId\nSwitch on the given variable with the given cases to test. …\nA method or constant defined in a trait\nThis ident refers to a trait method and its impl needs to …\nOr a method can come from a Trait impl block, in which case\nReturn all the constructors of this type from one …\nThis refers to just the arguments that are passed. E.g. …\nNote that this <em>must</em> be the id of the function or constant …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the FuncId of a method if it’s known.\nMethod calls have an optional list of generics provided by …\nIf this HirIdent refers to a trait method, this field …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up definition of a function and its implementation …\nTrue if this constructor constructs an enum value. Enums …\nTrue if we should return an offset of the field rather …\nTrue if this constructor constructs a tuple or struct …\nCreates a basic HirPrefixExpression with …\nCreate a HirIdent with ImplKind::NotATraitMethod.\nIf this is true we should skip this operation and directly …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nThe trait method id for the operator trait method that …\nThe trait method id for the operator trait method that …\nThis will be None when the capture refers to a local …\nA FuncMeta contains the signature of the function and any …\nA Hir function is a block expression with a list of …\nAn interned function parameter from a function definition\nAll the generics used by this function, which includes any …\nThe set of generics that are declared directly on this …\nIf this function is the one related to an enum variant, …\nTrait constraints that came either from a parent item (for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrue if this function is marked with an attribute that …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this function is an entry point to the program. …\nA stub function does not have a body. This includes …\nThe HirIdent of each identifier within the parameter list. …\nGives the (uninstantiated) return type of this function.\nIf this function is from an impl (trait or regular impl), …\nThe crate this function was defined in\nTHe file this function was defined in\nThe module this function was defined in\nTake this function body, returning an owned version while …\nTrait constraints that were specified directly on this …\nThe trait impl this function belongs to, if any\nThe type of this function. Either a Type::Function or a …\nThe type this method belongs to, if any\nCorresponds to <code>lvalue = expression;</code> in the source code\nRepresents an Ast form that can be assigned to. These can …\nA HirStatement is the result of performing name resolution …\nCreates a new ‘basic’ let statement with no attributes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over the fields of this pattern. Panics if the …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\n<code>index</code> is required to be an identifier to simplify …\nRepresents a trait in the type system. Each instance of …\nUpdate the type in the constraint by substituting the …\nUpdate all Types in the bound generics by substituting …\nReturns a TraitConstraint for this trait using Self as the …\nMap from each associated constant’s name to a unique …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns both the ordered generics of this type, and its …\nA unique id representing this trait type. Used to check if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps method_name -&gt; method id. This map is separate from …\nWhen resolving the types of Trait elements, all references …\nThe resolved trait bounds (for example in …\nAny ordered type arguments on the trait this impl is for. …\nThe where clause, if present, contains each trait …\nA user-defined alias to another type. Similar to a Struct, …\nCan bind to any type\nArray(N, E) is an array of N elements of type E. It is …\nA restricted subset of binary operators useable on type …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nRepresents a struct or enum type in the type system. Each …\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> in the source …\nCorresponds to generic lists such as <code>&lt;T, U&gt;</code> with additional\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nA generic integer type. This is a more specific kind of …\nA generic integer or field type. This is a more specific …\nA Kind is the type of a Type. These are used since only …\nConvenience enum to avoid using <code>Option&lt;Option&lt;String&gt;&gt;</code> to …\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nA type with no body is still in the process of being …\nCan bind to any type, except Type::Constant and …\nCan bind to a Type::Constant or Type::InfixExpr of the …\nThe type of quoted code in macros. This is always a …\nAn iterator over the variants of Self\n&amp;T\nA shared, mutable reference to some T. Wrapper is required …\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nWrap around an unsolved type\nTypeBindings are the mutable insides of a TypeVariable. …\nA list of (TypeVariableId, Kind)’s to bind to a type. …\nA TypeVariable is a mutable reference that is either bound …\nTypeVariables are stand-in variables for some type which …\nA unique ID used to differentiate different type variables\nThe unit type <code>()</code>.\nApply the given type bindings, making them permanently …\nReturn the operator that will “undo” this operation if …\nReturn the corresponding IntegerTypeSuffix if this is a …\nReturn this type as a monomorphic type - without a …\nBind this type variable to a value.\nA type’s body is private to force struct fields or enum …\nBorrows this TypeVariable to (e.g.) manually match on the …\nTry to canonicalize the representation of this type. …\nOnly simplify constants and drop/skip any CheckedCast’s\nOnly simplify constants and drop/skip any CheckedCast’s\nIf <code>found_checked_cast</code>, then drop additional CheckedCast’s\nRun all simplifications and drop/skip any CheckedCast’s\nCheck whether this type is itself a slice, or a …\nReturns the default type this type variable should be …\nEnsure the given value fits in self.integral_maximum_size()\nevaluate_to_field_element with optional generic arithmetic …\nIf this type is a Type::Constant (used in array lengths), …\nReturns the field at the given index. Panics if no field …\nReturns the number of field elements required to represent …\nReturns each of this type’s field names. Returns None if …\nRetrieve the fields of this type with no modifications. …\nFollow any TypeVariable bindings within this type. Doing …\nFollow bindings if this is a type variable or generic to …\nForcibly bind a type variable to a new type - even if the …\nForcibly substitute any type variables found within this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform the actual rust numeric operation associated with …\nTakes a monomorphic type and generalizes it over each of …\nReturns the number of <code>Forall</code>-quantified type variables on …\nReturn the generics on this type as a vector of types\nReturns the field matching the given field name, as well …\nRetrieves the Type and ItemVisibility of the given field …\nRetrieve the fields of this type. Returns None if this is …\nReturns the name and raw types of each field of this type. …\nReturns all the fields of this type, after being applied …\nBind the generics of the aliased Type to the given generic …\nRetrieve the given variant at the given variant index of …\nReturns the name and raw parameters of the variant at the …\nRetrieve the variants of this type. Returns None if this …\nReturns the name and raw parameters of each variant of …\nDetermines if a type contains a self referring alias by …\nA unique id representing this type. Used to check if two …\nWas this named generic implicitly added?\nCreates an <code>InfixExpr</code>.\nUnifies self and other kinds or fails with a Kind error\nInstantiate this struct type, returning a Vec of the new …\nInstantiate this type, replacing any type variables it is …\nInstantiate this type with the given type bindings. If any …\nInstantiates a type with the given types. This differs …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the operator that will “undo” this operation if …\nCreates an <code>InfixExpr</code> that results from the compiler trying …\nA bit of an awkward name for this function - this function …\nTrue if this variant was declared as a function. Required …\nCheck that if bound, it’s an integer and if unbound, …\nCheck that if bound, it’s an integer or field and if …\nReturns <code>true</code> if a type is allowed to appear in an …\nCheck whether this type is an array or slice, and contains …\nWhile Kind::is_numeric refers to numeric <em>types</em>, this …\nCheck that if bound, it’s a signed integer\nCheck that if bound, it’s an unsigned integer\nReturns true if a value of this type can safely pass …\nReturns this type, or a nested one, if this type can be …\nOptional expression, used by type aliases to numeric …\nTrue if the given TypeVariableId is free anywhere within …\nGiven: lhs = <code>N op C1</code> rhs = C2 Returns: <code>(N, op, C1, C2)</code> if …\nReturns this type, or a nested one, that cannot be used as …\nReplace any <code>Type::NamedGeneric</code> in this type with a …\nTo account for cyclic references between structs, a struct…\nSubstitute any type variables found within this type with …\nThis helper function only differs in the additional …\nSubstitute any <code>Kind::Any</code> in this type, for types that hold …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nTry to apply the array to slice coercion to this given …\nTry to bind the given type variable to self. Although the …\nTry to bind a PolymorphicInt variable to self, succeeding …\nAttempt to coerce <code>&amp;mut T</code> to <code>&amp;T</code>, returning true if this is …\nTry to simplify non-constant expressions in the form …\nTry to simplify non-constant expressions in the form …\nTry to simplify partially constant expressions in the form …\n<code>try_unify</code> is a bit of a misnomer since although errors are …\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify the following equations:\nTry to unify a type variable to <code>self</code>. This is a helper …\nPretty print type bindings for debugging\nUnbind this type variable, setting it to Unbound(id).\nUnifies this kind with the other. Returns true on success\nTry to unify this type with another, setting any type …\nSimilar to <code>unify</code> but if the check fails this will attempt …\nReturn the generics and type within this <code>Type::Forall</code>. …\nReturns the enum variant at the given index. Panics if no …\nReturns the function type of the variant at the given …\nReturns the function type of the variant at the given …\nRetrieve the variants of this type with no modifications. …\nIf the right-hand side is <code>expr op constant</code>, don’t try to …\nNothing special to do.\nWhen unifying types we sometimes need to adjust the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWraps a given <code>expression</code> in <code>expression.method()</code>\nAn type incorrectly used as a program input.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the error value\nThe job of the lexer is to transform an iterator of …\nContains the success value\nContains the success value\nCheck for and return the type suffix on the integer string …\nKeeps consuming tokens as long as the predicate is …\nSkips white space. They are not significant in the source …\nReturns the argument unchanged.\nGiven that some tokens can contain two characters, such as …\nCalls <code>U::from(self)</code>.\nGiven a source file of noir code, return all the tokens in …\nLex the next word in the input stream. Returns (start …\nIterates the cursor and returns the char at the new cursor …\nReads the next token, which might be a comment token …\nPeeks at the character two positions ahead. Does not …\nPeeks at the character two positions ahead and returns …\nPeeks at the next char. Does not iterate the cursor\nPeeks at the next char and returns true if it is equal to …\nIf <code>single</code> is followed by <code>character</code> then extend it as <code>double</code>…\nAllow chosen warnings to happen so they are silenced.\n&amp;\n&amp;\n-&gt;\n-&gt;\n=\n=\nAn Attribute can be either a Primary Attribute or a …\n!\n!\nRepresents a token in noir’s grammar - a word, number, …\n^\n^\n:\n:\n,\n,\n$\n$\n.\n.\n::\n::\n..\n..\n..=\n..=\n==\n==\n=&gt;\n=&gt;\nPrimary Attributes are those which a function can only …\nPrimary Attributes are those which a function can only …\nFuzzingScope is used to specify additional annotations for …\n=\n=\nA reference to an existing crate. This is a result of …\nA reference to an interned <code>ExpressionKind</code>.\nA reference to an interned <code>LValue</code>.\nA reference to an interned <code>Pattern</code>.\nA reference to an interned <code>StatementKind</code>.\nA reference to an interned <code>UnresolvedTypeData</code>.\nAn invalid character is one that is not in noir’s …\nAn invalid character is one that is not in noir’s …\nNote that <code>self</code> is not present - it is a contextual keyword …\nAn iterator over the variants of Self\n{\n{\n[\n[\n(\n(\n&lt;\n&lt;\n&lt;=\n&lt;=\n&amp;&amp;\n&amp;&amp;\nAn attribute expected to run a comptime function of the …\nUnlike Rust, all values in Noir already warn if they are …\nNo scope is applied and so the test must pass\n!=\n!=\nIf a test has a scope of OnlyFailWith, then it can only …\nIf a fuzzing harness has a scope of OnlyFailWith, then it …\nFor example <code>foo::bar</code> in <code>#[foo::bar(...)]</code>\n%\n%\n|\n|\nA quoted type resulting from a <code>Type</code> object in noir code …\nthe u8 is the number of hashes, i.e. r###..\nthe u8 is the number of hashes, i.e. r###..\nFor example <code>$expr</code> in <code>#[$expr(...)]</code> inside a <code>quote { ... }</code> …\n}\n}\n]\n]\n)\n)\nSecondary attributes are those which a function can have …\n;\n;\n&lt;&lt;\n&lt;&lt;\nIf a test has a scope of ShouldFailWith, then it can only …\nIf the fuzzing harness has a scope of ShouldFailWith, then …\n/\n/\n&amp; followed immediately by ‘[’ This is a lexer hack to …\nA custom tag attribute: <code>#[&#39;foo]</code>\nTestScope is used to specify additional annotations for …\nThe different kinds of tokens that are possible in the …\nThis is an implementation detail on how macros are …\nThis is an implementation detail on how macros are …\nTreat any metaprogramming functions within this one as …\nA variable-argument comptime function.\nReturns the kind of this integer constant when used in a …\nReturns the type of this integer suffix when used in a …\nThese are all the operators allowed as part of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns note if a deprecated secondary attribute is found\nReturns true if one of the secondary attributes is …\nTrue if the function is marked with an <code>#[export]</code> attribute.\nCheck if secondary attributes contain a specific instance.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if these attributes mean the given function is an …\nCheck whether we have an <code>inline_always</code> attribute This is …\nCheck whether we have an <code>inline</code> attribute Although we also …\nLooks up a word in the source program and returns the …\nIf this is a <code>#[must_use]</code> attribute, return <code>Some(message)</code> …\nA <code>ModuleDefId</code> captured to be offered in LSP’s …\nIf the item is available via a re-export, this contains …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe item to import.\nThe item’s visibility.\nFinds a visible reexport for any ancestor module of the …\nReturns the ModuleId a ModuleDefId is in.\nReturns true if the given ModuleDefId is visible from the …\nReturns the relative path to reach <code>module_def_id</code> named <code>name</code>…\nReturns the fully-qualified path of the given <code>ModuleDefId</code> …\nReturns the path to reach an item inside <code>target_module_id</code> …\nA user-defined alias to another type. Similar to a Struct, …\nArray(N, E) is an array of N elements of type E. It is …\nThe primitive <code>bool</code> type.\nA cast (to, from) that’s checked at monomorphization.\nA type-level integer. Included to let\nA user-defined struct type. The <code>Shared&lt;StructType&gt;</code> field …\nThe result of some type error. Remembering type errors as …\nA primitive Field type\n<code>FmtString(N, Vec&lt;E&gt;)</code> is an array of characters of length N …\nA type generic over the given type variables. Storing both …\nA functions with arguments, a return type and environment. …\nUsing nested HashMaps here lets us avoid cloning HirTypes …\nAn infix expression in the form <code>lhs * rhs</code>.\nA primitive integer type with the given sign and bit count.\nThe context struct for the monomorphization pass.\nNamedGenerics are the ‘T’ or ‘U’ in a user-defined …\nThe type of quoted code in macros. This is always a …\n&amp;T\nSlice(E) is a slice of elements of type E.\nString(N) is an array of characters of length N. It is …\n<code>impl Trait</code> when used in a type position. These are only …\nA tuple type with the given list of fields in the order …\nTypeVariables are stand-in variables for some type which …\nThe unit type <code>()</code>.\nAdds a function argument that contains type metadata that …\nExtend the arguments to <code>print</code> (which is a <code>bool</code> to show if …\nBinds direct generics on a trait impl function to those on …\nCheck that the ‘from’ and to’ sides of a CheckedCast …\nSimilar to <code>convert_type</code> but only checks for errors and …\nMonomorphize a closure, returning it along with its …\nMonomorphize the <code>main</code> function, ensuring it has the id …\nTrue if a value of the given type contains a reference …\nConvert a non-tuple/struct type to a monomorphized type\nConverts a HirType into a ast::Type.\nCall an infix operator overloading method for the given …\nCall an operator overloading method for the given prefix …\nPrerequisite: typ = typ.follow_bindings() and: …\nFor an enum like: enum Foo { A(i32, u32), B(Field), C }\nMonomorphize an expression\nWhen a function finishes being monomorphized, the …\nFollow any type variable links within the given …\nSet to true to force every function to be unconstrained. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMonomorphizes the given function.\nMonomorphize a function call.\nCreate a function value for the given function (not an …\nFunctions are keyed by their unique ID, whether they’re …\nGlobals are keyed by their unique ID because they are …\nUsed to reference existing definitions in the HIR\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCollect all the finished functions and globals into a …\nReturns true if a given function type is a closure. Note …\nA local (ie non-function) ident only\nUnlike functions, locals are only keyed by their unique ID …\nFind a captured variable in the innermost closure, and …\nFind a captured variable in the innermost closure …\nRetrieve the definition for the given function.\nStarting from the given <code>main</code> function, monomorphize the …\nCall the same function with <code>self.in_unconstrained_fn = true</code>…\nA more general entry-point for the monomorphization pass …\nMonomorphize a numeric generic as a numeric constant. …\nMonomorphize each parameter, expanding tuple/struct …\nPatch instrumentation calls inserted for debugging. This …\nUpdate instrumentation code inserted when assigning to a …\nUpdate instrumentation code inserted on variable …\nUpdate instrumentation code for a variable being dropped …\nReturn the item at the front of the queue, if there is …\nCall sites are instantiated against the trait method, but …\nThis module implements printing of the monomorphized AST, …\nPop the front of the function queue and monomorphize that …\nProcess any functions in the function queue to be …\nImplement a post-monomorphization pass where …\nQueue of functions to monomorphize next each item in the …\nMonomorphize an array with repeated elements, such as …\nResolve a trait item to a particular impl, returning the …\nMonomorphize a “standard” array with all elements …\nTry to evaluate certain builtin functions (currently only …\nReturn this enum type’s variants or panic\nReturn this struct type’s fields or panic\nReturn this tuple type’s fields or panic\nImplements std::unsafe_func::zeroed by returning an …\nAnalogous to Expression::Clone. Clone the resulting lvalue …\nA definition is either a local (variable), function, or is …\nThe monomorphized AST is expression-based, all statements …\nFunctions marked as foldable will not be inlined and …\nA function ID corresponds directly to an index of …\n<code>(args, ret, env, unconstrained)</code>\nA function ID corresponds directly to an index of …\nEach identifier is given a unique ID to distinguish …\nThe most basic entry point can expect all its functions to …\nFunctions marked as inline always will always be inlined, …\nRepresents how an Acir function should be inlined. This …\nRepresents an Ast form that can be assigned to\nRather than a Pattern containing possibly several …\nID of a local definition, e.g. from a let binding or …\nFunctions marked to have no predicates will not be inlined …\nCompared to hir_def::types::Type, this monomorphized Type …\nReturns the element type of this array or slice\nCreate proxies for foreign functions used as values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobals are expected to be generated within a different …\nPerform “ownership analysis”.\nPerform “ownership analysis”.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProduce an <code>InlineType</code> which we can use with an …\nCheck if the expression will need to have its type deduced …\nThe return type of an expression, if it has an obvious one.\nCarried over from <code>HirPrefixExpression::skip</code>. This also …\nTakes a function body by replacing it with <code>false</code> and …\nWe keep a collection of the debug variables and their …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSome calls can be printed with the intention of parsing …\nMarks function as comptime. Used in fuzzing.\nWraps function body in a <code>comptime</code> block. Used to make …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint an expression, but expect that we’ve already …\nCheck if we have a tuple of (constrained, unconstrained) …\nSpecial method for printing builtin array method calls, …\nInstead of printing a call to the print oracle as a …\nTry to display a special call as Noir.\nWhen function values are passed around in the …\nApply a function on the constrained and unconstrained …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate proxy functions for the foreign function values we …\nCheck if the definition is that of a function defined by a …\nCheck that the identifier is of a pair of constrained and …\nCreate a proxy function definition for a foreign function …\nGet or create a replacement proxy for the function …\nCheck if we have a pair of identifiers of foreign …\nVisit expressions and replace foreign function identifier …\nVisit the contents of an Expression representing the AST.\nVisit the contents of an Expression representing the AST, …\nVisit for the contents of an Expression representing the …\nVisit the contents of an Expression representing the AST.\nVisit all identifiers under the Expression.\nAssumed impls don’t have an impl id since they don’t …\nA dependency in the dependency graph may be a type or a …\nFields and integers share methods for ease of use. These …\nAll the information from a function that is filled out …\nAn ID for a global value\nWhen searching for a trait impl, these are the types of …\nThe ID of an crate::ast::ExpressionKind that’s been …\nThe ID of a crate::ast::StatementKind that’s been pushed …\nThe ID of a crate::ast::UnresolvedTypeData that’s been …\nLocals may be defined in let statements or parameters, in …\nRepresents the methods on a given type that each share the …\nA Definition enum specifies anything that we can intern in …\nThe node interner is the central storage location of all …\nGeneric types in functions (T, U in <code>fn foo&lt;T, U&gt;(...)</code> are …\nCaptures a reexport that happens inside a module. For …\nA reference to a module, struct, trait, etc., mainly used …\nA trait implementation is either a normal implementation …\nA TypeId wraps a ModuleId, because types are represented …\nThese are the primitive type variants that we support …\nIn LSP mode, take note that a TypeAliasId was referenced …\nAdds an “assumed” trait implementation to the …\nMark a DependencyId as being dependant on a FuncId.\nIn LSP mode, take note that a FuncId was referenced at a …\nMark a DependencyId as being dependant on a GlobalId.\nIn LSP mode, take note that a GlobalId was referenced at a …\nIn LSP mode, take note that a DefinitionId was referenced …\nAdds a non-trait method to a type.\nIn LSP mode, take note that a ModuleId was referenced at a …\nIn LSP mode, take note that a ReferenceId was referenced …\nIn LSP mode, take note that a specific field of a struct …\nIn LSP mode, take note that a TraitAssociatedTypeId was …\nMark a DependencyId as being dependant on a TraitId.\nAdds a trait implementation to the list of known …\nIn LSP mode, take note that a TraitId was referenced at a …\nMark a DependencyId as being dependant on a TypeAliasId.\nAdds TypeAliasId and Location to the type_alias_ref vector …\nRegister that <code>dependent</code> depends on <code>dependency</code>. This is …\nIn LSP mode, take note that a TypeId was referenced at a …\nEach value currently in scope in the comptime interpreter. …\nRetrieves the definition where the given id was defined. …\nRetrieves the definition where the given id was defined. …\nReturns the name of the definition\nReturns the type of the definition, or Type::Error if it …\nGets the dependency graph from the node interner.\nThis graph tracks dependencies between different global …\nTo keep track of where each DependencyId is in …\nCaptures the documentation comments for each module, …\nReturns the interned expression corresponding to <code>expr_id</code>\nRemembers the field index a given HirMemberAccess …\nScans the interner for the item which is located at that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the interned HIR function corresponding to <code>func_id</code>\nLook up the DefinitionId of a FuncId.\nReturns the interned meta data corresponding to <code>func_id</code>\nReturns the module this function was defined within\nReturns the visibility of the given function.\nReturns the associated types for the given trait impl. The …\nBuild up a string starting from the given item containing …\nReturns the Location of the definition of the given Ident …\nGet an interned ExpressionKind by its …\nTry to get the <code>HirLetStatement</code> which defines a given …\nReturns the type of an operator (which is always a …\nGet an interned LValue by its InternedExpressionKind ID.\nRetrieves the trait id for a given binary operator. All …\nGet an interned Pattern by its InternedPattern ID.\nRetrieves the trait id for a given unary operator. Only …\nReturns the type of a prefix operator (which is always a …\nRetrieves the impl selected for a given ExprId during name …\nGet an interned StatementKind by its InternedStatementKind …\nReturns the definition id for the associated constant of …\nReturns the definition id and trait id for a given trait …\nReturns the span of an item stored in the Interner\nReturns the type of an item stored in the NodeInterner, or …\nReturns the type of the definition, unless it’s a …\nHolds the trait ids of the traits used for infix operator …\nMap from ExprId (referring to a Function/Method call) to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this definition is for a global variable. Note …\nTrue if this definition is for a global variable. Note …\nThis is the definition id of the method or associated …\nStore the location of the references in the graph\nLooks up a method that’s directly defined in the given …\nReturns the <code>FuncId</code> corresponding to the function referred …\nLooks up methods at impls for all types <code>T</code>, e.g. …\nGiven a <code>ObjectType: TraitId</code> pair, try to find an existing …\nReturns the trait implementation if found along with the …\nLooks up methods that apply to the given type but are …\nDetermines whether to run in LSP mode. In LSP mode …\nA map from a type and method name to a function id for the …\nThe location of the function’s name rather than the …\nCreates a new struct or enum type with no fields or …\nReturns what the next trait impl id is expected to be.\nThe <code>Ordering</code> type is a semi-builtin type that is the …\nThis function is needed when creating a NodeInterner for …\nHolds the trait ids of the traits used for prefix operator …\nContains the docs comments of primitive types. These are …\nStore the type for a definition\nIntern an empty function.\nIntern an empty global. Used for collecting globals before …\nInterns a HIR expression, with the location and type …\nIntern an expression with everything needed for it …\nStores the span for an interned expression.\nStore the type for an interned expression\nIntern a ExpressionKind.\nInterns a HIR Function.\nInterns a function’s metadata.\nIntern an LValue by turning it into an Expression and …\nIntern a Pattern.\nIntern a StatementKind.\nIntern a HIR statement with everything needed for it …\nIn LSP mode, take note that the Type was referenced at a …\nIntern a UnresolvedTypeData.\nHelper constructs to ensure that no parts are forgotten …\nIn Noir’s metaprogramming, a noir type has the type <code>Type</code>…\nA map of ModuleDefId to each module that pub or pub(crate) …\nStore the location of the references in the graph. Edges …\nTracks the index of the references in the graph\nRemoves all TraitImplKind::Assumed from the list of known …\nReplaces the HirExpression at the given ExprId with a new …\nReplaces the HirStatement at the given StmtId with a new …\nResolves the Location of the definition for a given …\nFor a given Index we return Location to which we resolved …\nResolves the Location of the definition for a given …\nTags the given identifier with the selected trait_impl so …\nWhen impls are found during type checking, we tag the …\nSets the associated types for the given trait impl. Each …\nReturns the interned statement corresponding to <code>stmt_id</code>\nRemember the TypeBindings used during the instantiation of …\nConvert to AST for display (some details lost)\nConvert to AST for display (some details lost)\nEach trait associated type. These are tracked so that we …\nThe associated types for each trait impl. This is stored …\nTrait implementations on each type. This is expected to …\nGets the trait implementations from the node interner.\nReturn a set of TypeBindings to bind types from the parent …\nAdd the given trait as an operator trait if its name …\nAdd the given trait as an operator trait if its name …\nTries to retrieve the given id’s definition. This …\nReturns the span of an item stored in the Interner, if …\nSimilar to <code>lookup_trait_implementation</code> but does not apply …\nAttempts to resolve Location of Trait based on Location of …\nAttempts to resolve Location of Trait’s TraitFunction …\nAttempts to resolve Location of Type based on Location of …\nA list of all type aliases that are referenced in the …\nReturns the Type of the expression that exists at the …\nStores the Location of a Type reference\nUpdates the interned expression corresponding to <code>expr_id</code>\nUpdates the underlying interned Function.\nReturns the interned statement corresponding to <code>stmt_id</code>\nVerifies that each constraint in the given where clause is …\nWhether the function is <code>pub</code> or not.\nThe trait generics to use - if specified. This is allowed …\nA dependency in the dependency graph may be a type or a …\nAn ID for a global value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe ID of an crate::ast::ExpressionKind that’s been …\nThe ID of a crate::ast::StatementKind that’s been pushed …\nThe ID of a crate::ast::UnresolvedTypeData that’s been …\nA reference to a module, struct, trait, etc., mainly used …\nA TypeId wraps a ModuleId, because types are represented …\nThis is the definition id of the method or associated …\nReturns the module where this struct is defined.\nRepresents the methods on a given type that each share the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIterate through each method, starting with the direct …\nCheck if the types can unify without binding any type …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pusher that will need the location and the …\nPush the location first, then the type.\nPush the type after the location, returning the ID as …\nCaptures a reexport that happens inside a module. For …\nAn arbitrary number to limit the recursion depth when …\nAdds a <code>.clone()</code> to the given expression. Note that this …\nTraverse the given function and return the last use(s) of …\nReturns the argument unchanged.\nTraverse an expression comprised of only identifiers, …\nHandle the rhs of a <code>&amp;expr</code> unary expression. Variables and …\nCalls <code>U::from(self)</code>.\nThis module contains the last use analysis pass which is …\nWhenever an ident is used it is always cloned unless it is …\nThis contains each instance of a variable we should move …\nThe Id for a single branch of an if or match\nA variable’s last use may be split into several …\nA single path through a <code>Branches</code> enum.\nThe Id of an <code>if</code> or <code>match</code>, used to distinguish multiple …\nNo use in this branch or there is no branch\nThe outer <code>Vec</code> is each loop we’re currently in, while the …\nCollect all IdentIds from this tree\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStores the location of each variable’s last use\nRemember a new use of the given variable, possibly …\nA variable in an lvalue position is never moved (otherwise …\nA ParsedModule contains an entire Ast for one file.\nA submodule defined via <code>mod name { contents }</code> in some …\nRepresents a parsing error, or a parsing error in the …\nSkips any outer doc comments but produces an error saying …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModule declarations like <code>mod foo;</code>\nAddOrSubtractExpression = …\nAddOrSubtractTypeExpression = …\nAndExpression = XorExpression ( ‘&amp;’ XorExpression )*\nArguments = ‘(’ ArgumentsList? ‘)’\nArrayLiteral = StandardArrayLiteral | RepeatedArrayLiteral\nAsTraitPath = ‘&lt;’ Type ‘as’ PathNoTurbofish …\nAtom = Quark AtomRhs*\nAtomRhs = CallExpression | …\nAtomTypeExpression = ConstantTypeExpression | …\nAttribute = ‘#[’ (FunctionAttribute | …\nAttributes = Attribute*\nBlock = ‘{’ Statement* ‘}’\nParses an expression that looks like a block (ends with ‘…\nCallExpression = Quark CallArguments\nCallArguments = ‘!’? Arguments\nCastExpression = UnaryExpression ‘as’ Type\nComptimeExpression = ‘comptime’ Block\nComptimeStatement = ComptimeBlock | ComptimeLet | …\nConstantTypeExpression = int\nConstrainExpression = ‘constrain’ Expression | ‘…\nConstructorExpression = Type ‘{’ ConstructorFields? ‘…\nEnum = ‘enum’ identifier Generics ‘{’ EnumVariant* …\nEqualOrNotEqualExpression = OrExpression ( ( ‘==’ | ‘…\nExpression = EqualOrNotEqualExpression\nWhen parsing <code>if</code> conditions we don’t allow constructors. …\nForStatement = ‘for’ identifier ‘in’ ForRange Block\nForRange = ExpressionExceptConstructor | …\nFunction = ‘fn’ identifier Generics FunctionParameters …\nFunctionParameters = ‘(’ FunctionParametersList? ‘)…\nGeneric = VariableGeneric | NumericGeneric | …\nGenericTypeArgs = ( ‘&lt;’ GenericTypeArgsList? ‘&gt;’ )\nGenerics = ( ‘&lt;’ GenericsList? ‘&gt;’ )?\nGlobal = ‘global’ identifier OptionalTypeAnnotation ‘…\nIfExpression = ‘if’ ExpressionExceptConstructor Block …\nImpl = TypeImpl | TraitImpl\nIndexExpression = Quark ‘[’ Expression ‘]’\nInnerAttribute = ‘#![’ SecondaryAttribute ‘]’\nInnerDocComments = inner_doc_comment*\nInternedExpression = interned_expr\nInternedPattern = interned_pattern\nInternedStatementExpression = interned_statement\nItem = ( Attribute | OuterDocComments )* ItemKind\nParses an item inside an impl or trait, with good recovery:\nThis method returns one ‘ItemKind’ in the majority of …\nItemVisibility = ‘pub’                 // …\nLambda = ( ‘unconstrained’ )? ‘|’ …\nLessOrGreaterExpression = ShiftExpression ( ( ‘&lt;’ | ‘…\nLetStatement = ‘let’ pattern OptionalTypeAnnotation ‘…\nLiteral = bool | int | str | rawstr | fmtstr | …\nLoopStatement = ‘loop’ Block\nParses a list of items separated by a token, optionally …\nSame as parse_many, but returns a bool indicating whether …\nparse_many, where the given function <code>f</code> may return multiple …\nSame as parse_many, but returns a bool indicating whether …\nMatchExpression = ‘match’ ExpressionExceptConstructor …\nMatchRule = Expression ‘=&gt;’ (Block ‘,’?) | …\nMemberAccessOrMethodCallExpression = MemberAccessExpression\nModOrContract = ( ‘mod’ | ‘contract’ ) identifier …\nModifiers = ItemVisibility ‘unconstrained’? ‘comptime…\nMultiplyOrDivideOrModuloExpression = Term ( ( ‘<em>’ | ‘/</em>…\nMultiplyOrDivideOrModuloTypeExpression = …\nNamelessTypePathExpression = ‘&lt;’ Type ‘&gt;’ ‘::’ …\nNumericGeneric = ‘let’ identifier ‘:’ Type\nOptionalTypeAnnotation = ( ‘:’ Type )?\nOrExpression = AndExpression ( ‘|’ AndExpression )*\nOuterDocComment = outer_doc_comment\nOuterDocComments = OuterDocComment*\nParenthesesExpression = UnitLiteral | …\nParenthesizedPattern = ‘(’ Pattern ‘)’ …\nParenthesizedTypeExpression = ‘(’ TypeExpression ‘)…\nTries to parse a Path. Note that <code>crate::</code>, <code>super::</code>, etc., …\nParses a path assuming the path’s kind (plain, <code>crate::</code>, …\nPathExpression = VariableExpression | ConstructorExpression\nPathGenerics = GenericTypeArgs\nPathKind | ‘crate’ ‘::’ | ‘dep’ ‘::’ | ‘…\nPathNoTurbofish = PathKind identifier ( ‘::’ …\nPattern = ‘mut’ PatternNoMut\nPatternNoMut = InternedPattern | ParenthesizedPattern | …\nPatternOrSelf = Pattern | SelfPattern\nEntry function for the parser - also handles lexing …\nQuark = Literal | ParenthesesExpression | UnsafeExpression …\nResolvedExpression = unquote_marker\nShiftExpression = AddOrSubtractExpression ( ( ‘&lt;&lt;’ | …\nSliceExpression = ‘&amp;’ ArrayLiteral\nStatement = Attributes StatementKind ‘;’?\nStatementKind = BreakStatement | ContinueStatement | …\nParses either a statement, an expression or an LValue. …\nStruct = ‘struct’ identifier Generics ‘{’ …\nStructPattern = Path ‘{’ StructPatternFields? ‘}’\nTerm = UnaryExpression | CastExpression\nTermTypeExpression = ’- TermTypeExpression | …\nTrait = ‘trait’ identifier Generics ( ‘:’ …\nTraitBody = ‘{’ ( OuterDocComments TraitItem )* ‘}’\nTraitBound = PathNoTurbofish GenericTypeArgs\nTraitBounds = TraitBound ( ‘+’ TraitBound )? ‘+’?\nTraitConstant = ‘let’ identifier ‘:’ Type ( ‘=’…\nTraitFunction = Modifiers Function\nTraitImpl = ‘impl’ Generics Type ‘for’ Type …\nTraitImplBody = ‘{’ TraitImplItem* ‘}’\nTraitImplConstant = ‘let’ identifier …\nTraitImplFunction = Attributes Modifiers Function\nTraitImplItem = TraitImplType | TraitImplConstant | …\nTraitImplType = ‘type’ identifier ( ‘:’ Type )? ‘…\nTraitItem = TraitType | TraitConstant | TraitFunction\nTraitType = ‘type’ identifier ( ‘:’ TraitBounds ) …\nTypeAlias = ‘type’ identifier Generics ‘=’ Type ‘…\nTypeExpression= AddOrSubtractTypeExpression\nTypeImpl = ‘impl’ Generics Type TypeImplBody\nTypeImplBody = ‘{’ TypeImplItem* ‘}’\nTries to parse a type. If the current token doesn’t …\nTypeOrTypeExpression = Type | TypeExpression\nTypePathExpression = PrimitiveType ‘::’ identifier ( …\nUnaryExpression = UnaryOp* Atom\nUnaryOp = ‘&amp;’ ‘mut’ | ‘-’ | ‘!’ | ‘*’\nUnquoteExpression = ‘$’ identifier | ‘$’ ‘(’ …\nUnsafeExpression = ‘unsafe’ Block\nUse = ‘use’ PathKind PathNoTurbofish UseTree\nVariableGeneric = identifier ( ‘:’ TraitBounds ) ?\nVariableTypeExpression = Path\nVisibility = ‘pub’ | ‘return_data’ | ‘call_data…\nWhereClause = ‘where’ WhereClauseItems?\nWhileStatement = ‘while’ ExpressionExceptConstructor …\nXorExpression = LessOrGreaterExpression ( ‘^’ …\nThe current statement’s comments. This is used to …\nFull submodules as in <code>mod foo { ... definitions ... }</code>\nSkips any outer doc comments but produces a warning saying …\nRepresents a parsing error, or a parsing error in the …\nUsed to annotate parsing rules with extra context that can …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBumps this parser by one token. Returns the token that was …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nModule = InnerDocComments Item*\nEntry function for the parser - also handles lexing …\nProgram = Module\nInvokes <code>parsing_function</code> (<code>parsing_function</code> must be some …\nThe current statement’s comments. This is used to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nStrips leading ‘*’ from a block comment if all …\nStrips leading ’ ’ from a line comment.\nWhen parsing an array literal we might bump into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSelfPattern is guaranteed to be <code>self</code>, <code>&amp;self</code> or <code>&amp;mut self</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether a parameter or return value is public …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDataBus is public input handled as private input. We use …\nRepresents whether a parameter or return value is public …\nNecessary to handle casting to unsigned generically …\nReturns the inner FieldElement which will always be …\nReturns the argument unchanged.\nConvert a signed integer to a SignedField, carefully …\nCalls <code>U::from(self)</code>.\nConvert a SignedField into a signed integer type (up to …\nConvert a SignedField into an unsigned integer type (up to …\nReturns the argument unchanged.\nCompile a program.\nCalls <code>U::from(self)</code>.\nRegister an item as unused, waiting to be marked as used …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks an item as being referenced. This doesn’t always …\nMarks an item as being used.\nGet all the unused items per module.")