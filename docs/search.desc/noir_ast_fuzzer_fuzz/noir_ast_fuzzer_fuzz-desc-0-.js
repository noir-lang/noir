searchState.loadedDescShard("noir_ast_fuzzer_fuzz", 0, "Compare the execution result and print the inputs if the …\nCompare the execution result for comptime fuzzing and …\nCompare the execution result and print the inputs if the …\nCompile a monomorphized Program into circuit or panic.\nCompile a monomorphized Program into circuit using the …\nShow all SSA passes during compilation.\nCompare the execution of random ASTs between the normal …\nCompare the execution of random ASTs between the comptime …\nCompare the execution of random ASTs between the comptime …\nCreate a default configuration instance, with some common …\nCompare the execution of random ASTs between the initial …\nPerform random metamorphic mutations on the AST and check …\nCompare the execution of an SSA pass to the one preceding …\nRecursively apply rules while keeping a tally on how many …\nContext necessary to generate new local IDs during …\nNumber of rewrites applied so far, up to the <code>target</code>.\n(Over)estimate of the maximum number we could hope to …\nProvide a rough estimate for how many rules can be applied.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if we are calling an oracle or builtin function.\nCheck if we have reached the target.\nMetamorphic transformation rules.\nRules to apply.\nNumber of rewrites we want to achieve.\nCheck if a rule can be applied on an expression. If it …\nBook keeping for local variables.\nTypes we can consider using in this context.\nGenerate an arbitrary binary expression, returning a …\nGenerate an arbitrary pure (free of side effects) …\nGenerate an arbitrary unary expression, returning a …\nCheck if an expression can have a side effect, in which …\nAssign new IDs to variables and identifiers created in the …\nCheck if the rule can be applied on an expression.\nApply the rule on an expression, mutating/replacing it …\nMetamorphic transformation rule.\nTransform any expression into an if-then-else with the …\nTransform boolean value <code>x</code> into <code>x | x</code>.\nCommon match condition for boolean rules.\nTransform boolean value <code>x</code> into <code>rnd ^ x ^ rnd</code>.\nTransform boolean value <code>x</code> into <code>x ^ x ^ x</code>.\nConstruct all rules that we can apply on a program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBreak an integer literal <code>a</code> into <code>b + c</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we rewriting an expression which is a <code>start</code> or <code>end</code> of …\nAre we in an expression that we’re just taking a mutable …\nAre we processing the arguments of an non-user function …\nCheck if the rule can be applied on an expression.\nTransform any numeric value <code>x</code> into <code>x+0</code>\nTransform commutative arithmetic operations:\nTransform any numeric value <code>x</code> into <code>x/1</code>\nTransform any numeric value <code>x</code> into <code>x*1</code>\nTransform any numeric value <code>x</code> into <code>x &lt;op&gt; &lt;rhs&gt;</code>\nCommon condition for numeric rules\nTransform any numeric value <code>x</code> into <code>x-0</code>\nApply the rule on an expression, mutating/replacing it …\nIs the function we’re rewriting unconstrained?")