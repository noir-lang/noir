searchState.loadedDescShard("noir_ast_fuzzer_fuzz", 0, "Compare the execution result and print the inputs if the …\nCompare the execution result for comptime fuzzing and …\nCompare the execution result and print the inputs if the …\nCompile a Program into SSA or panic.\nCompile a Program into SSA using the given primary and …\nCompare the execution of random ASTs between the normal …\nCompare the execution of random ASTs between the comptime …\nCompare the execution of random ASTs between the comptime …\nCompare the execution of random ASTs between the initial …\nPerform random metamorphic mutations on the AST and check …\nCompare the execution of an SSA pass to the one preceding …\nRecursively apply rules while keeping a tally on how many …\nContext necessary to generate new local IDs during …\nNumber of rewrites applied so far, up to the <code>target</code>.\n(Over)estimate of the maximum number we could hope to …\nProvide a rough estimate for how many rules can be applied.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if we are calling an oracle or builtin function.\nCheck if we have reached the target.\nMetamorphic transformation rules.\nRules to apply.\nNumber of rewrites we want to achieve.\nCheck if a rule can be applied on an expression. If it …\nBook keeping for local variables.\nTypes we can consider using in this context.\nGenerate an arbitrary binary expression, returning a …\nGenerate an arbitrary pure (free of side effects) …\nGenerate an arbitrary unary expression, returning a …\nCheck if an expression can have a side effect, in which …\nCheck if the rule can be applied on an expression.\nApply the rule on an expression, mutating/replacing it …\nMetamorphic transformation rule.\nConstruct all rules that we can apply on a program.\nTransform any expression into an if-then-else with the …\nTransform boolean value <code>x</code> into <code>x | x</code>.\nCommon match condition for boolean rules.\nTransform boolean value <code>x</code> into <code>rnd ^ x ^ rnd</code>.\nTransform boolean value <code>x</code> into <code>x ^ x ^ x</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBreak an integer literal <code>a</code> into <code>b + c</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we rewriting an expression which is a <code>start</code> or <code>end</code> of …\nAre we in an expression that we’re just taking a mutable …\nAre we processing the arguments of an non-user function …\nCheck if the rule can be applied on an expression.\nTransform any numeric value <code>x</code> into <code>x+0</code>\nTransform commutative arithmetic operations:\nTransform any numeric value <code>x</code> into <code>x/1</code>\nTransform any numeric value <code>x</code> into <code>x*1</code>\nTransform any numeric value <code>x</code> into <code>x &lt;op&gt; &lt;rhs&gt;</code>\nCommon condition for numeric rules\nTransform any numeric value <code>x</code> into <code>x-0</code>\nApply the rule on an expression, mutating/replacing it …\nIs the function we’re rewriting unconstrained?")