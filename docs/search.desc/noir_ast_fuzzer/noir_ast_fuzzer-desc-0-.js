searchState.loadedDescShard("noir_ast_fuzzer", 0, "AST generation configuration.\nWrapper around <code>Program</code> that prints the AST as close to …\nWrapper around <code>Program</code> that prints its AST as close to …\nGenerate arbitrary inputs for a compiled program according …\nGenerate an arbitrary monomorphized AST.\nGenerate an arbitrary monomorphized AST to be reversed …\nAvoid using constrain statements.\nTry to avoid operations that can result in error when zero …\nTry to avoid “Index out of bounds” by using modulo to …\nAvoid using function pointers in parameters.\nAvoid using large integer literals where the frontend …\nAvoid using loop control (break/continue).\nAvoid match statements and expressions.\nAvoid using negative integer literals where the frontend …\nTry to avoid overflowing operations. Useful when testing …\nAvoid print statements.\nAvoid using the vector type.\nOnly use comptime friendly expressions.\nFrequency of expressions, which produce a value.\nWhether to force all functions to be unconstrained.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum size for arrays.\nMaximum number of statements in a block.\nMaximum nesting depth for complex expressions.\nMaximum number of arguments a function can have.\nMaximum number of statements to aim for in a function body.\nMaximum number of functions (other than main) to generate.\nMaximum number of global definitions.\nMaximum size of for loop ranges, which affects unrolling …\nMaximum number of match cases.\nMaximum number of recursive calls to make at runtime.\nMaximum number of fields for tuples.\nMinimum number of functions (other than main) to generate.\nModule responsible for generating arbitrary Program ASTs.\nGenerate the Abi interface of a Program.\nBuild a program with the single <code>main</code> function returning …\nFrequency of statements in ACIR functions.\nFrequency of statements in Brillig functions.\nWhether to choose the backstop for <code>loop</code> and <code>while</code> randomly.\nCheck if a type is valid as an ABI parameter for the <code>main</code> …\nGenerate the Abi interface of a Program.\nMap an AST type to an ABI type.\nHelp ignore results and errors we find equivalent between …\nCompare the execution of equivalent programs, compiled in …\nThe result of the execution of compiled programs, decoded …\nCompare the execution of a Noir program in pure comptime …\nInputs for comparing the interpretation of two SSA states …\nThe result of the SSA interpreter execution.\nCompare two equivalent variants of the same program, …\nSubset of SsaEvaluatorOptions that we want to vary.\nThe state of the SSA after a particular pass in the …\nCompare the execution the same program compiled in two …\nPossible outcomes of the differential execution of two …\nError returned from the circuit, with tracked side effects.\nHelp iterate over the program(s) in the comparable …\nOptional return value with the tracked side effects.\nCompare an arbitrary AST compiled into bytecode and …\nCompare an arbitrary AST executed as Noir with the comptime\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nABI inputs, which we map to SSA values as part of the …\nConvert one ABI encoded input to what the SSA interpreter …\nConvert the ABI encoded inputs to what the SSA interpreter …\nCompare an arbitrary AST compiled into SSA and executed …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe can turn on the logging of artifacts by setting the …\nThe message (without the counter) of the pass.\nCopy fields into an SsaEvaluatorOptions instance.\nOptions that influence the pipeline, common to both passes.\nCheck that two programs agree on a return value.\nThe state of the SSA after the pass.\nInputs for the <code>main</code> function in the SSA, mapped from the …\nThe overall position of this pass in the pipeline.\nCompare the execution of equivalent programs, compiled in …\nThe result of the execution of compiled programs, decoded …\nCompare two equivalent variants of the same program, …\nCompare the execution the same program compiled in two …\nThe execution result is the value returned from the …\nThese are the error types in the <code>SsaProgramArtifact</code>, which …\nGenerate a random AST and compile it into SSA in two …\nGenerate a random AST, a random metamorph of it, then …\nGenerate a random AST, a random metamorph of it, then …\nExecute the two SSAs and compare the results.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCopy of <code>NargoError::user_defined_failure_message</code> accepting …\nCompare the execution of a Noir program in pure comptime …\nGenerate a random comptime-viable AST, reverse it into …\nFabricate a result from a comptime <code>CustomDiagnostic</code> on the …\nDecode the print output into a string.\nExecute the Noir code (via nargo) and the SSA, then …\nExecute the program bytecode, returning the execution …\nExecute the Noir code with the comptime interpreter and …\nComptime test programs have no inputs.\nCheck if a comptime error is due to some kind of …\nCompile the main function in a code snippet.\nPrepare a code snippet. (copied from …\nInputs for comparing the interpretation of two SSA states …\nThe result of the SSA interpreter execution.\nThe state of the SSA after a particular pass in the …\nContains the error value\nContains the success value\nGenerate an arbitrary ASTStop the compilation at two …\nABI inputs, which we map to SSA values as part of the …\nConvert an ABI type into SSA.\nConvert one ABI encoded input to what the SSA interpreter …\nConvert the ABI encoded inputs to what the SSA interpreter …\nThe message (without the counter) of the pass.\nOptions that influence the pipeline, common to both passes.\nRemove identifiers from the SSA, so we can compare the …\nThe state of the SSA after the pass.\nInputs for the <code>main</code> function in the SSA, mapped from the …\nThe overall position of this pass in the pipeline.\nAssign a value to an identifier.\nAssign a value to a mutable reference.\nMake a binary expression.\nCast an expression to a target type.\nDereference an expression into a target type\nMake an <code>==</code> expression.\nCheck if an <code>Expression</code> or any of its descendants match a …\nAppend statements to a given block.\nGenerate a literal expression according to a type.\nGenerate a literals for loop ranges with signed/unsigned …\nCheck if an <code>Expression</code> contains any <code>Call</code> another function, …\nMake an if/else expression.\nCreate an <code>if</code> expression, with an optional <code>else</code>.\nTake an integer expression and make sure it fits in an …\nInteger literal, can be positive or negative depending on …\nCreate a variable.\nBoolean literal.\nMake a modulo expression.\nPrepend an expression to a destination.\nPrepend statements to a given block.\nTake an integer expression and make sure it’s no larger …\nCollect all the functions referred to by their ID in the …\nReference an expression as a target type\nReplace an expression with another one, passing its …\n32-bit unsigned int literal, used in indexing arrays.\n8-bit unsigned int literal, used in bit shifts.\nMake a unary expression.\nGiven the Abi description of a Noir program, generate …\nGenerate arbitrary inputs for a compiled program according …\nGenerate arbitrary inputs for an SSA of a program, …\nCreate a strategy for generating random values for an …\nGenerate a seed and use it to generate an arbitrary value …\nCollect all <code>Field</code> values in the SSA which could be …\nStrategy for signed ints (up to i128). The strategy …\nBit size of int (e.g. 128)\nThe weight for edge cases (+/- 3 around 0 and max possible …\nReturns the argument unchanged.\nGenerate random values near MIN or the MAX value.\nCalls <code>U::from(self)</code>.\nCreate a new strategy.\nThe weight for purely random values\nMaximum allowed positive number.\nMinimum allowed negative number.\nValue tree for unsigned ints (up to u128). The strategy …\nBit size of uint (e.g. 64)\nThe weight for edge cases (+/- 3 around 0 and max possible …\nA set of fixtures to be generated\nThe weight for fixtures\nReturns the argument unchanged.\nGenerate random numbers starting from near 0 or the …\nPick a random <code>FieldElement</code> from the <code>fixtures</code> as a starting …\nGenerate random values between 0 and the MAX with the …\nCalls <code>U::from(self)</code>.\nCreate a new strategy.\nPick randomly from the 3 available strategies for …\nThe weight for purely random values\nMaximum integer that fits in the given bit width.\nLength of generated random constraint messages.\nID of a function we can call, either as a pointer in a …\nContext to accumulate top level generated item, so we know …\nWrapper around <code>Program</code> that prints the AST as close to …\nWrapper around <code>Program</code> that prints its AST as close to …\nName of a variable.\nID of variables in scope.\nGenerate an arbitrary monomorphized AST.\nGenerate an arbitrary monomorphized AST to be reversed …\nReturn the generated Program.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a function declaration.\nFunction signatures generated up front, so we can call any …\nRandomly generated functions that can access the globals …\nGenerate random function body.\nGenerate a random function declaration.\nGenerate random function names and signatures.\nGenerate function with a specified body generator.\nGenerate random function bodies.\nGenerate the i-th global variable, which is allowed to use …\nGenerate random global definitions.\nGenerate a random Type.\nGlobal variables.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDerive a variable name from the ID.\nBuild a program with the single <code>main</code> function returning …\nPost-processing steps that change functions.\nGet a function declaration.\nRandom types generated for functions.\nAssign a value to an identifier.\nAssign a value to a mutable reference.\nMake a binary expression.\nCast an expression to a target type.\nDereference an expression into a target type\nMake an <code>==</code> expression.\nCheck if an <code>Expression</code> or any of its descendants match a …\nAppend statements to a given block.\nGenerate a literal expression according to a type.\nGenerate a literals for loop ranges with signed/unsigned …\nCheck if an <code>Expression</code> contains any <code>Call</code> another function, …\nMake an <code>Ident</code> expression out of a variable.\nMake an <code>Ident</code> out of a variable.\nMake an if/else expression.\nCreate an <code>if</code> expression, with an optional <code>else</code>.\nTake an integer expression and make sure it fits in an …\nInteger literal, can be positive or negative depending on …\nIs the expression dereferencing something.\nIs the expression an identifier of an immutable variable\nCreate a variable.\nBoolean literal.\nMake a modulo expression.\nPrepend an expression to a destination.\nPrepend statements to a given block.\nTake an integer expression and make sure it’s no larger …\nCollect all the functions referred to by their ID in the …\nReference an expression as a target type\nReplace an expression with another one, passing its …\n32-bit unsigned int literal, used in indexing arrays.\n8-bit unsigned int literal, used in bit shifts.\nMake a unary expression.\nPeel back any dereference operators until we get to some …\nHelp with cumulative frequency distributions.\nFrequency distribution of generators.\nCheck if a key is enabled, based on the already checked …\nLike <code>enabled</code>, but if <code>cond</code> is <code>false</code> it redistributes the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the accumulated weights have passed the random …\nIn call arguments we can use <code>if</code> expressions, but avoid …\nIn <code>if</code> conditions avoid nesting more ifs, like …\nUse random strings to identify constraints.\nControl what kind of expressions we can generate, …\nContext used during the generation of a function body.\nSomething akin to a forward declaration of a function, …\nHelper data structure for generating the lvalue of …\nIn complex nested expressions, avoid generating blocks; …\nIn <code>for</code> ranges we can use <code>if</code> expressions, but let’s not …\nIn a top level context, everything is allowed.\nWe need to track whether expressions are coming from …\nRandom decision whether to allow “Index out of bounds” …\nNumber of statements remaining to be generated in the …\nConstruct a <code>Call</code> to the <code>array_len</code> builtin function, …\nAll the functions callable from this one, with the types …\nConstruct a <code>Call</code> to one of the <code>vector_*</code> builtin functions.\nConstruct a <code>Call</code> to the <code>vector_insert</code> builtin function.\nConstruct a <code>Call</code> to the <code>vector_pop_front</code> or <code>vector_pop_back</code>…\nConstruct a <code>Call</code> to the <code>vector_push_front</code> or …\nConstruct a <code>Call</code> to the <code>vector_remove</code> builtin function.\nExpression to use in a <code>Call</code> for the function (pointer).\nGet the parameter types and return type of a callable …\nCheck if a source type can be used inside a dynamic input …\nHelp avoid infinite recursion by limiting which function …\nChoose a producer for a type, preferring local variables …\nTop level context, to access global variables and other …\nGet the function declaration.\nDecrease the budget by some amount.\nIndicate which local variables are derived from function …\nEnter a new local scope.\nExit the current local scope.\nFind a global function matching a type signature.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIdentifier for a global function.\nAssign to a mutable variable, if we have one in scope.\nTry to generate a binary expression of a certain type, if …\nGenerate a block of statements, finally returning a target …\nGenerate the function body.\nGenerate the function body, wrapping a function call with …\nGenerate a function call to any function in the global …\nGenerate a <code>constrain</code> statement, if there is some local …\nGenerate an expression of a certain type.\nTry to generate an expression that produces a target type …\nTry to generate an expression with a certain type out of …\nGenerate a <code>for</code> loop.\nIf this is main, and we could have made a call to another …\nGenerate an if-then-else statement or expression.\nGenerate an arbitrary index for an array.\nGenerate a <code>Let</code> statement with arbitrary type and value.\nGenerate a call to a specific function, with arbitrary …\nGenerate a literal expression of a certain type.\nGenerate a <code>loop</code> loop.\nChoose a random maximum guard size for <code>loop</code> and <code>while</code> to …\nGenerate an lvalue to assign to a local variable, or some …\nGenerate a <code>match</code> expression, returning a given type.\nGenerate a random field that can be used in the match …\nGenerate a match constructor for a numeric type.\nGenerate a <code>println</code> statement, if there is some printable …\nGenerate a statement, which is an expression that doesn’…\nTry to generate a unary expression of a certain type, if it…\nGenerate code to index an arbitrary item in a vector.\nGenerate a <code>while</code> loop.\nGet a local or global variable.\nGlobal variables.\nIndicate that we have generated a <code>Call</code>.\nCheck if any of the parameters or return value contain a …\nSelf ID.\nIndicator of being affected by dynamic input, in which …\nIndicator of being in a loop (and hence able to generate …\nIndicator of computing an expression that should not …\nMake a name for a local index variable.\nCreate a local let binding over a global variable.\nCreate a local let binding over a local variable.\nCreate a block with a let binding, then return a mutable …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicate whether we are assigning to just a part of a …\nIndicate whether any dynamic input was used to generate …\nCheck if a variable is derived from dynamic input.\nIs this the main function?\nAdd a new local variable and return a <code>Let</code> expression.\nAdd a new local variable and return a <code>Let</code> expression along …\nIdentifier for a local variable.\nMake a name for a local variable.\nType of a local variable.\nVariables accumulated during the generation of the …\nThe lvalue to assign to, e.g. <code>a[i]</code>.\nThe default maximum depth to start from. We use <code>max_depth</code> …\nGet and increment the next ident ID.\nEvery identifier created in the function will have an …\nGet and increment the next local ID.\nEvery variable created in the function will have an …\nCreate a loop index variable.\nCheck if the return type contain a reference.\nCheck if the return type contains a vector.\nMark a variable as dynamic or not dynamic.\nAny statements that had to be broken out to control the …\nThe type of the value that needs to be assigned, e.g. an …\nIs this function unconstrained.\nTurn all ACIR functions into Brillig functions.\nFind the next local ID and ident IDs (in that order) that …\nTo avoid the potential of infinite recursion at runtime, …\nDecide how to pass the recursion limit to function: by …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIn <code>main</code> we initialize the recursion limit.\nFor non-recursive functions just add an unused parameter. …\nIn non-main we look at the limit and return a random value …\nVisit all the calls made by this function and pass along …\nRecursively modify function pointers in the param type.\nGo through the types of each function parameter. If they …\nUpdate any function pointer and the function and its proxy…\nGo through the call arguments and update global function …\nRewrite the function and its proxy (if it has one).\nFill the body of a <code>func_{i}_proxy</code> with an expression to …\nFind functions reachable from main.\nRemove functions that are unreachable from main.\nA layer of variables available to choose from in blocks.\nScope stack as we exit and enter blocks\nScope stack as we exit and enter blocks\nAdd a new variable to the current scope.\nAdd a new variable to the current scope.\nAdd a new variable to the scope.\nChoose a random producer of a type, if there is one.\nChoose a random producer of a type matching some criteria.\nThe top scope in the stack.\nThe top scope in the stack.\nPush a new scope on top of the current one.\nRemove the last layer of block variables.\nCreate a stack from the base variables.\nCreate a stack from the base variables.\nCreate the initial scope from function parameters.\nGet a variable in scope.\nCheck if there are any variables in scope.\nIterate over the layers, starting the base layer.\nCreate a stack from the base layer.\nReverse index of variables which can produce a type. For …\nRemove a variable from all scopes.\nRemove a variable from all scopes.\nRemove a variable from the scope.\nIterate the types we can produce from other variables.\nIterate the IDs of the variables in scope.\nIterate the variables in scope.\nID and type of variables created in all visible scopes, …\nWe can only use globals that can be evaluated at comptime. …\nCheck if a type can be used in the <code>main</code> function.\nCheck if a variable with a given type can be used in a …\nCan the binary operation fail because the RHS is zero. …\nCan the binary operation result in an overflow. These are …\nCheck if a certain binary operation can return a target …\nCheck if a certain binary operation can take a type as …\nCan the type be returned by some <code>BinaryOp</code>.\nCan the type be returned by some <code>UnaryOp</code>.\nCheck if the type contains any references.\nCheck if the type contains any references.\nCheck if the type is a vector or an array.\nCheck if the type works with <code>UnaryOp::Not</code>\nCheck if the type is a function.\nCheck if the type is a number.\nCheck if the type can be used with a <code>println</code> statement.\nCheck if the type is a reference wrapping another.\nCheck if a type is <code>Unit</code>.\nReference an expression into a target type\nConvert the type back into a HIR equivalent (not …\nCalculate the depth of a type.\nCollect all the sub-types produced by a type.\nPeel off all reference types, to get to a concrete …\nPeel off all reference types, to get to a concrete …\nTurn all ACIR functions into Brillig functions.\nFind the next local ID and ident IDs (in that order) that …\nA layer of variables available to choose from in blocks.\nScope stack as we exit and enter blocks\nScope stack as we exit and enter blocks\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReverse index of variables which can produce a type. For …\nID and type of variables created in all visible scopes, …\nWe can only use globals that can be evaluated at comptime. …\nCheck if a type can be used in the <code>main</code> function.\nCheck if a variable with a given type can be used in a …\nCan the binary operation fail because the RHS is zero. …\nCan the binary operation result in an overflow. These are …\nCheck if a certain binary operation can return a target …\nCheck if a certain binary operation can take a type as …\nCan the type be returned by some <code>BinaryOp</code>.\nCan the type be returned by some <code>UnaryOp</code>.\nCheck if the type contains any references.\nCheck if the type contains any references.\nCheck if the type works with <code>UnaryOp::Not</code>\nCheck if the type is a number.\nCheck if the type can be used with a <code>println</code> statement.\nCheck if the type is a reference wrapping another.\nCheck if a type is <code>Unit</code>.\nReference an expression into a target type\nConvert the type back into a HIR equivalent (not …\nCalculate the depth of a type.\nCollect all the sub-types produced by a type.")