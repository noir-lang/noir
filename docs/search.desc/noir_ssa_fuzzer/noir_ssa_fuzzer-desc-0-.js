searchState.loadedDescShard("noir_ssa_fuzzer", 0, "Builder for generating fuzzed SSA functions Contains a …\nInserts unary instruction with one argument and returns Id …\nInserts binary instruction with two arguments and returns …\nCompiles the built function into a CompiledProgram, to run …\nTerminates main function block with the given value\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the index of the entry block\nInserts an add instruction between two values\nInserts a bitwise AND instruction between two values\nGets an element from an array at the given index\nSets an element in an array at the given index\nInserts a new basic block and returns its index\nInserts a cast instruction\nInserts a divide instruction between two values\nInserts an equals comparison instruction between two values\nInserts an unconditional jump to the given block with …\nInserts a conditional jump based on the condition value\nInserts a less than comparison instruction between two …\nCreates an array with the given Ids of values\nInserts a modulo instruction between two values\nInserts a multiply instruction between two values\nInserts a not instruction for the given value\nInserts a bitwise OR instruction between two values\nInserts a return instruction with the given value\nInserts a left shift instruction between two values The …\nInserts a right shift instruction between two values The …\nInserts a subtract instruction between two values\nInserts initial variables of the given type into the …\nInserts a bitwise XOR instruction between two values\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new FuzzerBuilder in ACIR context\nCreates a new FuzzerBuilder in Brillig context\nCreates a numeric constant with the given value\nSwitches the current block to the given block\nCompiles the given FunctionBuilder into a CompiledProgram …\nConverts the generated ACIR into a circuit artifact its …\nCreates a program artifact from the given FunctionBuilder …\nCreates an ABI for the configured number of variables …\nOptimizes the given FunctionBuilder into ACIR its taken …\nThe maximum number of instructions that can be generated …\nThe initial number of basic functions blocks to create …\nThe initial number of variables to create when generating …\nConverts an Id to an integer, to store it for FuzzerContext\nConverts an Id to a Witness, to take result from …\nConverts an integer to an Id of BasicBlock, to call …\nConverts an integer to an Id of Value, to call …\nErrors that can occur during execution of the program It …\nLow level function to execute the given program with the …\nHigh level function to execute the given program with the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHigh level function to execute the given ACIR and Brillig …\nCheck if this type can be used in an operation with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from our simple ValueType to the internal SSA Type\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper to check if this value has a field type\nHelper to check if this value has a signed integer type\nHelper to check if this value has an unsigned integer type\nGet the numeric type if this value has one\nHelper to check if bitwise operations are supported for …\nHelper to check if modulo operations are supported for …\nHelper to check if not operations are supported for this …\nHelper to check if shift operations are supported for this …\nHelper to check if unchecked operations are supported for …\nConvert to the NumericType\nConvert to the SSA Type\nConvert to our simple ValueType from the internal SSA Type")