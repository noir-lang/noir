searchState.loadedDescShard("nargo", 0, "Nargo is the package manager for Noir This name was used …\nAdd any unstable features required by the <code>Package</code> to the …\nThe directory to store serialized ACIR representations of …\nThe package definition file for a Noir project.\nThe file from which Nargo pulls prover inputs\nThe directory to store Noir source files\nThe directory to store circuits’ serialized ACIR …\nThe extension for files containing proof witnesses.\nError while compiling Noir into ACIR.\nErrors covering situations where a package cannot be …\nACIR circuit execution error\nOracle handling error\nErrors encountered while compiling the Noir program. These …\nThe opcode location for a call to a separate ACIR circuit …\nMap the given OpcodeResolutionError to the corresponding …\nExtracts the opcode locations from a nargo error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTries to generate a runtime diagnostic from a nargo error. …\nExtracts the user defined failure message from the …\nThis enumeration represents the Brillig foreign calls that …\nInterface for executing foreign calls\nReference print for more info regarding this call’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA builder for DefaultForeignCallLayers where we can enable …\nConvenience constructor for code that used to create the …\nFacilitate static typing of layers on a base layer, so …\nCompose the executor layers with layers::Empty as the …\nCompose the executor layers with <code>base</code> as the default …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable or disable mocks.\nOverride the output.\nSet or unset resolver url.\nA case where we can have either this or that type of …\nReturns an empty result when called.\nForwards to the inner executor if its own handler doesn’…\nCompose handlers.\nReturns <code>NoHandler</code> for every call.\nLayer an executor on top of this one. The <code>other</code> executor …\nAdd another layer on top of this one.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a layer from two handlers\nCreate a layer from a handler. If the handler doesn’t …\nCreate a layer from a handler. If the handler doesn’t …\nA base layer that doesn’t handle anything.\nHandler that panics if any of the mock functions are …\nThis struct represents an oracle mock. It can be used for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe id of the mock, used to update or remove it\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe parameters with which the mock was last called\nMocks have unique ids used to identify them in Noir, …\nThe registered mocks\nThe oracle it’s mocking\nOptionally match the parameters\nThe result to return when this mock is called\nHow many times this mock was actually called\nHow many times should this mock be called before it is …\nHandle <code>println</code> calls.\nPrint has certain information encoded in the call …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nExecute an async call blocking the current thread. This …\nJSON RPC client to resolve foreign calls\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe foreign call which the external RPC server is to …\nA randomly generated id for this <code>DefaultForeignCallExecutor</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nName of the package in execution\nName of the package in execution\nExternal resolver target. We are keeping it to be able to …\nRoot path to the program or workspace in execution.\nRoot path to the program or workspace in execution.\nRuntime to execute asynchronous tasks on. See bridging.\nA session ID which allows the external RPC server to link …\nLog foreign calls during the execution, for testing …\nReplay an oracle transcript which was logged with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfiguration for fuzzing loop execution\nFolder configuration for fuzzing\nRun the lexing, parsing, name resolution, and type …\nRun each function through a circuit simulator to check …\nConstructs a single <code>CompilationResult</code> for a collection of …\nCompiles workspace.\nCorpus folder\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRuns the fuzzer on a test function. This assumes the …\nFuzzing failure folder\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of executions of ACIR and Brillig (default: …\nMinimized corpus folder\nNumber of threads to use for fuzzing\nRuns a test function. This will either run the test or …\nRuns a test function. This assumes the function has no …\nWhether to output progress to stdout or not.\nTest function failed to compile\nThe test function compiled successfully.\nMaximum time in seconds to spend fuzzing (default: no …\nApply the optimizing transformation on each function in …\nApply ACVM optimizations on the circuit.\nRun each function through a circuit simulator to check …\nRun the lexing, parsing, name resolution, and type …\nConstructs a single <code>CompilationResult</code> for a collection of …\nCompiles workspace.\nReturns the argument unchanged.\nAdd debugging instrumentation to all parsed files …\nCalls <code>U::from(self)</code>.\nExecute the program with ACIR fuzzing enabled (returns the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConfiguration for fuzzing loop execution\nFolder configuration for fuzzing\nCorpus folder\nFuzzing failure folder\nMaximum number of executions of ACIR and Brillig (default: …\nMinimized corpus folder\nNumber of threads to use for fuzzing\nWhether to output progress to stdout or not.\nMaximum time in seconds to spend fuzzing (default: no …\nA specialized foreign call executor which tracks whether …\nReturns the argument unchanged.\nRuns the fuzzer on a test function. This assumes the …\nCalls <code>U::from(self)</code>.\nRuns a test function. This will either run the test or …\nRuns a test function. This assumes the function has no …\nTest function failed to compile\nThe test function compiled successfully.\nApply the optimizing transformation on each function in …\nApply ACVM optimizations on the circuit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf we could not resolve the workspace we would inform the …\nReturns a new <code>FileManager</code> for the root directory of this …\nOptional target directory override.")