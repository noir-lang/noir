searchState.loadedDescShard("acir_field", 0, "This trait is extremely unstable and WILL have breaking …\nTemporarily exported generic field to aid migration to …\nReturns the closest number of bytes to the bits specified …\nReturns the closest number of bytes to the bits specified …\nDefine a <em>newtype</em> wrapper around an <code>AcirField</code> by …\nReturns the argument unchanged.\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes in little-endian order into a FieldElement …\nConverts bytes in little-endian order into a FieldElement …\nCalls <code>U::from(self)</code>.\nComputes the inverse or returns zero if the inverse does …\nComputes the inverse or returns zero if the inverse does …\nMaximum number of bits needed to represent a field element …\nMaximum number of bits needed to represent a field element …\nMaximum numbers of bytes needed to represent a field …\nMaximum numbers of bytes needed to represent a field …\nThis is the number of bits required to represent this …\nThis is the number of bits required to represent this …\nReturns the vale of this field as a hex string without the …\nDowncast the field into a <code>i128</code>. Panic if the value does …\nConverts the field element to a vector of bytes in …\nConverts the field element to a vector of bytes in …\nReturns the value of this field as a hex string with …\nDowncast the field into a <code>u128</code>. Panic if the value does …\nDowncast the field into a <code>u128</code> if it fits into 128 bits, …\nThe value 2^127, which represents the boundary between …\nTotal number of non-zero bytes we found.\nReturns true if this field element can be represented as …\nReturns true if this field element can be represented as a …\nReturns the argument unchanged.\nConstructs a <code>FieldElement</code> from the underlying prime field …\nThe last non-zero byte we found.\nCalls <code>U::from(self)</code>.\nExtracts the underlying prime field representation.\nAssume this field element holds a signed integer of the …\nTotal bytes we found.\nReturns None, if the string is not a canonical …\nThis trait is extremely unstable and WILL have breaking …\nReturns the closest number of bytes to the bits specified …\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes in little-endian order into a FieldElement …\nComputes the inverse or returns zero if the inverse does …\nMaximum number of bits needed to represent a field element …\nMaximum numbers of bytes needed to represent a field …\nThis is the number of bits required to represent this …\nReturns the vale of this field as a hex string without the …\nDowncast the field into a <code>i128</code>. Panic if the value does …\nConverts the field element to a vector of bytes in …\nReturns the value of this field as a hex string with …\nDowncast the field into a <code>u128</code>. Panic if the value does …\nDowncast the field into a <code>u128</code> if it fits into 128 bits, …")