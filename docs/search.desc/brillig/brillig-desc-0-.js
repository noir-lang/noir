searchState.loadedDescShard("brillig", 0, "Brillig\nEncrypts a message using AES-128.\n(&amp;) Bitwise AND\nThe value read should be interpreted as a pointer to a …\nWrapper for array addresses, with convenience methods for …\nBinary fixed-length field expressions\nTakes the fields in addresses <code>lhs</code> and <code>rhs</code>, performs the …\nBinary fixed-length integer expressions\nTakes the <code>bit_size</code> size integers in addresses <code>lhs</code> and <code>rhs</code>, …\nNative functions in the VM. These are equivalent to the …\nThese opcodes provide an equivalent of ACIR blackbox …\nCalculates the Blake2s hash of the inputs.\nCalculates the Blake3 hash of the inputs.\nPushes the current program counter to the call stack as to …\nCopies calldata after the <code>offset_address</code> with length …\nTakes the value from the <code>source</code> address, casts it into the …\nIf the value at <code>condition</code> is non-zero, moves the content …\nStores a constant <code>value</code> with a <code>bit_size</code> in the <code>destination</code> …\nSpecifies an exact index in the VM’s memory.\nField division\nVerifies an ECDSA signature over the secp256k1 curve.\nVerifies an ECDSA signature over the secp256r1 curve.\nPerforms addition over the embedded curve.\n(==) Equal\n(==) Equal\nUsed to get data from an outside source.\nSingle input or output of a foreign call.\nRepresents the full output of a foreign call.\nA fixed-sized array starting from a Brillig memory …\nAn array to be passed to or from an external call. In the …\nDescribes the memory layout for an array/vector element\nA memory-sized vector passed starting from a Brillig …\nA vector to be passed to or from an external call. In the …\nReads the address from <code>destination_pointer</code>, then stores a …\nUnsigned integer division\nSets the program counter to the value of <code>location</code>.\nSets the program counter to the value of <code>location</code> if the …\nKeccak permutation function of 1600 width.\n(&lt;) Field less than\n(&lt;) Integer less than\n(&lt;=) Field less or equal\n(&lt;=) Integer less or equal\nReads the <code>source_pointer</code> to obtain a memory address, then …\nRepresents an address in the VM’s memory. Supports both …\nA single value to be passed to or from an external call. …\nMoves the content in the <code>source</code> address to the <code>destination</code> …\nPerforms multi scalar multiplication over the embedded …\nTakes the value from the <code>source</code> address, inverts it, and …\n(|) Bitwise OR\nApplies the Poseidon2 permutation function to the given …\nSpecifies an index relative to the stack pointer.\nPops the top element from the call stack, which represents …\nApplies the SHA-256 compression function to the input …\n(&lt;&lt;) Shift left\n(&gt;&gt;) Shift right\nA single field element is enough to represent the value …\nHalts execution and returns data specified by a …\nReads the <code>destination_pointer</code> to obtain a memory address, …\nReturns a decomposition in <code>num_limbs</code> limbs of the given …\nUsed to denote execution failure, halting the VM and …\nLays out various ways an external foreign call’s input …\nThe value read should be interpreted as a pointer to a …\nWrapper for vector addresses, with convenience methods for …\n(^) Bitwise XOR\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPointer to a memory address which hold the address to the …\nPointer to a memory address which hold the address to the …\nStatically known size of the array.\nAddress to a memory slot holding the semantic length of …\nResolved output values of the foreign call.\nDestination value types.\nDestination addresses (may be single values or memory …\nInterpreted by caller context, ie. this will have …\nInput value types (for heap allocated structures indicates …\nInput addresses (may be single values or memory pointers).\nEncrypts a message using AES-128.\nThese opcodes provide an equivalent of ACIR blackbox …\nCalculates the Blake2s hash of the inputs.\nCalculates the Blake3 hash of the inputs.\nVerifies an ECDSA signature over the secp256k1 curve.\nVerifies an ECDSA signature over the secp256r1 curve.\nPerforms addition over the embedded curve.\nKeccak permutation function of 1600 width.\nPerforms multi scalar multiplication over the embedded …\nApplies the Poseidon2 permutation function to the given …\nApplies the SHA-256 compression function to the input …\nReturns a decomposition in <code>num_limbs</code> limbs of the given …\nSingle input or output of a foreign call.\nRepresents the full output of a foreign call.\nConvert the fields in the parameter into a vector, used to …\nUnwrap the field in a <code>Single</code> input. Panics if it’s an …\nResolved output values of the foreign call.\n(&amp;) Bitwise AND\nThe value read should be interpreted as a pointer to a …\nWrapper for array addresses, with convenience methods for …\nBinary fixed-length field expressions\nTakes the fields in addresses <code>lhs</code> and <code>rhs</code>, performs the …\nBinary fixed-length integer expressions\nTakes the <code>bit_size</code> size integers in addresses <code>lhs</code> and <code>rhs</code>, …\nNative functions in the VM. These are equivalent to the …\nPushes the current program counter to the call stack as to …\nCopies calldata after the <code>offset_address</code> with length …\nTakes the value from the <code>source</code> address, casts it into the …\nIf the value at <code>condition</code> is non-zero, moves the content …\nStores a constant <code>value</code> with a <code>bit_size</code> in the <code>destination</code> …\nSpecifies an exact index in the VM’s memory.\nField division\n(==) Equal\n(==) Equal\nUsed to get data from an outside source.\nA fixed-sized array starting from a Brillig memory …\nAn array to be passed to or from an external call. In the …\nDescribes the memory layout for an array/vector element\nA memory-sized vector passed starting from a Brillig …\nA vector to be passed to or from an external call. In the …\nReads the address from <code>destination_pointer</code>, then stores a …\nUnsigned integer division\nSets the program counter to the value of <code>location</code>.\nSets the program counter to the value of <code>location</code> if the …\n(&lt;) Field less than\n(&lt;) Integer less than\n(&lt;=) Field less or equal\n(&lt;=) Integer less or equal\nReads the <code>source_pointer</code> to obtain a memory address, then …\nRepresents an address in the VM’s memory. Supports both …\nA single value to be passed to or from an external call. …\nMoves the content in the <code>source</code> address to the <code>destination</code> …\nTakes the value from the <code>source</code> address, inverts it, and …\n(|) Bitwise OR\nSpecifies an index relative to the stack pointer.\nPops the top element from the call stack, which represents …\n(&lt;&lt;) Shift left\n(&gt;&gt;) Shift right\nA single field element is enough to represent the value …\nHalts execution and returns data specified by a …\nReads the <code>destination_pointer</code> to obtain a memory address, …\nUsed to denote execution failure, halting the VM and …\nLays out various ways an external foreign call’s input …\nThe value read should be interpreted as a pointer to a …\nWrapper for vector addresses, with convenience methods for …\n(^) Bitwise XOR\nCheck that all types are <code>Simple</code>.\nCreate a <code>Direct</code> address.\nCreate a <code>Simple</code> type to represent a <code>Field</code>.\nReturns the total number of field elements required to …\nOffset the address by <code>amount</code>, while preserving its type.\nPointer to a memory address which hold the address to the …\nPointer to a memory address which hold the address to the …\nCreate a <code>Relative</code> address.\nStatically known size of the array.\nAddress to a memory slot holding the semantic length of …\nCapacity of the vector.\nReturn the index in the address.\nReturn the index in a <code>Direct</code> address.\nReturn the index in a <code>Relative</code> address.\nDestination value types.\nDestination addresses (may be single values or memory …\nInterpreted by caller context, ie. this will have …\nInput value types (for heap allocated structures indicates …\nInput addresses (may be single values or memory pointers).")