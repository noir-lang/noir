searchState.loadedDescShard("noirc_evaluator", 0, "The <code>acir</code> module contains all the logic necessary for noirc…\nCompare the textural representation of the SSA after …\nThe <code>brillig</code> module contains all logic necessary for noirc…\nNoir Evaluator has two types of errors\nSSA stands for Single Static Assignment The IR presented …\nContext struct for the acir generation pass. May be …\nThe output of the Acir-gen pass, which should only be …\nThe <code>acir_context</code> module acts as a high-level wrapper …\nManages and builds the <code>AcirVar</code>s to which the converted SSA …\nCheck post ACIR generation properties\nCreates an <code>AcirVar</code> corresponding to a parameter witness to …\nGenerates a read opcode for the array\nIf <code>mutate_array</code> is:\nConstruct a value with all zero values, which we can use …\nArray handling in ACIR.\nCorrespondence between an opcode index and the error …\nGet the BlockId corresponding to the ValueId If there is …\nBrillig function id -&gt; Opcodes locations map This map is …\nOptions affecting Brillig code generation.\nBrillig function id -&gt; Brillig procedure locations map …\nMaps the opcode index to a Brillig std library function …\nSource code location of the current instruction being …\nAdds a range check against the bit size of the result of …\nGet an offset such that the type of the array at the …\nWe need to properly setup the inputs for array operations …\nConverts an optional constrain error message into an ACIR …\nInserts one or more elements into a slice at a given index.\nRemoves and returns one or more elements from the back of …\nRemoves and returns one or more elements from the front of …\nPushes one or more elements to the back of a non-nested …\nPushes one or more elements to the front of a non-nested …\nRemoves one or more elements from a slice at a given index.\nProcesses a binary operation and converts the result into …\nAdds and binds <code>AcirVar</code>s for each numeric block parameter …\nConverts an SSA instruction into its ACIR representation\nReturns a vector of <code>AcirVar</code>s constrained to be result of …\nConverts an SSA terminator’s return values into their …\nReturns an <code>AcirVar</code>that is constrained to be result of the …\nGets the cached <code>AcirVar</code> that was converted from the …\nRecursive helper for Self::convert_vars_to_values. If the …\nConvert a <code>Vec&lt;[AcirVar]&gt;</code> into a <code>Vec&lt;[AcirValue]&gt;</code> using the …\nThe <code>AcirVar</code> that describes the condition belonging to the …\nThe next witness index that may be declared. If witness …\nRemember the result of an instruction returning a single …\nRemember the result of instruction returning a single …\nMaps SSA values to a BlockId used internally for computing …\nCorrespondence between error selectors and types …\nFetch a flat list of (AcirVar, AcirType).\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert an SSA array index into a flat ACIR array index.\nReturns the acir value at the provided databus offset\nConverts an SSA terminator’s return values into their …\nHandles an ArrayGet or ArraySet instruction. To set an …\nSee Self::handle_constant_index_wrapper\nAttempts a compile-time read/write from an array.\nFor 0-length arrays and slices, even the disabled memory …\nCheck if the array or slice has 0 length.\nInitializes the element types sizes array to enable …\nInitializes an array with the given values and caches the …\nTrack initialized acir dynamic arrays\nAll witness indices which are inputs to the main function\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoads a value either from call-data bus or from memory.\nConstruct the AcirValue::DynamicArray that represents the …\nNumber of the next BlockId, it is used to construct a new …\nMaps SSA values to BlockId A BlockId is an ACIR structure …\nName for the corresponding entry point represented by this …\nThe opcodes of which the compiled ACIR will comprise.\nComputes the predicated index for an array access. If the …\nWhen there is a predicate, the store value is predicate*…\nAll witness indices that comprise the final return value …\nThe <code>shared_context</code> module contains any shared state needed …\nContains state that is generated and also used across ACIR …\nMaps SSA values to <code>AcirVar</code>.\nOperands in a binary operation are checked to have the …\nGet the next BlockId for the internal element type sizes …\nContext object which holds the relationship between …\nEnum representing the possible values that a Variable can …\nAn in-memory representation of ACIR.\nAdds a constant to the context and assigns a Variable to …\nAdds <code>Data</code> into the context and assigns it a Variable.\nAdds a new Variable to context whose value will be …\nAdds a new Variable to context whose value will be …\nAdds a Variable to the context, whose exact value is …\nEcAdd has 6 inputs representing the two points to add Each …\nReturns an <code>AcirVar</code> that is the AND result of <code>lhs</code> &amp; <code>rhs</code>.\nReturns a FieldElement, if the underlying <code>AcirVarData</code> …\nConstrains the <code>lhs</code> and <code>rhs</code> to be equal.\nConstrains the <code>lhs</code> and <code>rhs</code> to be non-equal.\nReturns <code>AcirVar</code>s constrained to be the bit decomposition …\nCalls a Blackbox function on the given inputs and returns …\nGenerate constraints that are satisfied iff lhs &lt; rhs , …\nRecursively create acir values for returned arrays. This …\nReturns the constant represented by the given variable.\nAdds a new Variable to context whose value will be …\nReturns an <code>AcirVar</code> that is <code>1</code> if <code>lhs</code> equals <code>rhs</code> and 0 …\nReturns the quotient and remainder such that lhs = rhs * …\nTerminates the context and takes the resulting …\nChecks if this expression can fit into one arithmetic …\nRecursive helper to flatten a single AcirValue into the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe <code>generated_acir</code> module is responsible for the lowest …\nReturns Some(String) if the assertion message is present …\nInitializes an array in memory with the given values …\nInsert the MemoryInit for the Return Data array, using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds a new Variable to context whose value will be …\nTrue if the given AcirVar refers to a constant value\nTrue if the given AcirVar refers to a constant one value\nReturns an <code>AcirVar</code> which will be <code>1</code> if lhs &lt; rhs and <code>0</code> …\nReturns a variable which is constrained to be <code>lhs mod rhs</code>\nReturns an <code>AcirVar</code> which will be <code>1</code> if lhs &gt;= rhs and <code>0</code> …\nAdds a new Variable to context whose value will be …\nAdds a new Variable to context whose value will be …\nAdds a new variable that is constrained to be the logical …\nReturns an <code>AcirVar</code> that is the OR result of <code>lhs</code> &amp; <code>rhs</code>.\nReturns an <code>F</code> representing the value <code>2**power</code>\nBlack box function calls expect their inputs to be in a …\nReturns a vector of <code>AcirVar</code>s constrained to be the …\nConstrains the <code>AcirVar</code> variable to be of type <code>NumericType</code>.\nReturns a Variable that is constrained to be the result of …\nGenerates a brillig call to a handwritten section of …\nAdds a new Variable to context whose value will be …\nConverts all enum variants to an Expression.\nReturns an <code>AcirVar</code> which will be constrained to be lhs mod …\nConverts an <code>AcirVar</code> to an <code>Expression</code>\nConverts an <code>AcirVar</code> to a <code>Witness</code>\nConstrains the Variable <code>value</code> to be the new value located …\nReturns an <code>AcirVar</code> that is the XOR result of <code>lhs</code> &amp; <code>rhs</code>.\nRecursively create zeroed-out acir values for returned …\nThe output of the Acir-gen pass, which should only be …\nCorrespondence between an opcode index (in opcodes) and …\nAsserts <code>expr</code> to be zero.\nCorrespondence between an opcode index and the error …\nThis function will return the number of outputs that a …\nThis function will return the number of inputs that a …\nAdds an inversion brillig opcode.\nBrillig function id -&gt; Opcodes locations map This map is …\nBrillig function id -&gt; Brillig procedure locations map …\nMaps the opcode index to a Brillig std library function …\nAdds brillig opcode for to_radix\nCalls a black box function and returns the output of said …\nSource code location of the current instruction being …\nCreates a new <code>Witness</code> which is constrained to be equal to …\nReturns the current witness index.\nThe next witness index that may be declared. If witness …\nCorrespondence between error selectors and types …\nConverts <code>Expression</code> <code>expr</code> into a <code>Witness</code>.\nAll witness indices which are inputs to the main function\nChecks that the number of inputs being used to call the …\nChecks that the number of outputs being used to call the …\nReturns a <code>Witness</code> that is constrained to be:\nReturns a <code>Witness</code> that is constrained to be:\nName for the corresponding entry point represented by this …\nUpdates the witness index counter and returns the next …\nThe opcodes of which the compiled ACIR will comprise.\nAdds a new opcode into ACIR.\nTakes an input expression and returns witnesses that are …\nAdds a constraint which ensure thats <code>witness</code> is an integer …\nAll witness indices that comprise the final return value …\nBrillig calls such as for the Brillig std lib are resolved …\nGenerates brillig bytecode which computes the inverse of …\nGenerates brillig bytecode which computes <code>a / b</code> and …\nGenerates brillig bytecode which performs a radix-base …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the array’s elements have a constant …\nHolds state shared across all ACIR codegen contexts. …\nTrack a new stdlib call site that must later be patched …\nMaps SSA function index -&gt; Final generated Brillig …\nKeeps track of Brillig std lib calls per function that …\nMaps a Brillig std lib function (a handwritten primitive …\nFinalize this context, consuming it and returning all …\nReturns the argument unchanged.\nRegister a stdlib Brillig call for later resolution. If …\nGet the generated Brillig function artifact by raw pointer …\nFinal list of Brillig functions which will be part of the …\nLookup a previously generated Brillig function pointer by (…\nRemove and return the set of globals used by the given …\nGet the list of unresolved stdlib call sites for a given …\nInsert a newly generated Brillig function into the context.\nCalls <code>U::from(self)</code>.\nCreate a new SharedContext with a stdlib and a precomputed …\nAllocate a fresh Brillig function pointer\n<code>used_globals</code> needs to be built from a function call graph.\nHigh level Type descriptor for Variables.\nA Reference to an <code>AcirVarData</code>\nReturns the bit size of the underlying type\nIdentification for the Acir dynamic array This is …\nIdentification for the ACIR dynamic array inner element …\nReturns a field type\nFetch a flat list of the NumericType contained within an …\nFetch a flat list of (AcirVar, AcirType).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the array\nReturns an unsigned type of the specified bit size\nAn ACIR dynamic array is a flat structure, so we use the …\nContext structure for the brillig pass. It stores …\nOptions that affect Brillig code generation.\nProcedures are a set of complex operations that are common …\nThe code generation logic for converting crate::ssa …\nThis module is an abstraction layer over <code>Brillig</code>. To allow …\nCompiles a function into brillig and store the compilation …\nConverting an SSA function into Brillig bytecode.\nFinds a brillig artifact by its label\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps SSA function labels to their brillig artifact\nModule containing Brillig-gen logic specific to an SSA …\nThis module handles allocation, tracking, and lifetime …\nModule containing Brillig-gen logic specific to SSA …\nCodegen for converting SSA globals to Brillig bytecode.\nThis module analyzes the usage of constants in a given …\nGenerates a complete Brillig entry point artifact for a …\nThis module analyzes the liveness of variables …\nContext structure for compiling a function block into …\nOverflow checks for the following unsigned binary …\nAllocates a variable to hold the result of an external …\nRecursively allocates memory for a nested array returned …\nDebug utility method to determine whether an array’s …\nThe basic block that is being converted\nContext for creating brillig opcodes\nStatus variable for whether we are generating Brillig …\nConverts an SSA Basic block into a sequence of Brillig …\nConverts SSA globals into Brillig global values.\nInternal method for BrilligBlock::compile that actually …\nAllocates the block parameters that the given block is …\nConverts an SSA cast to a sequence of Brillig opcodes. …\nLoad from an array variable at a specific index into a …\nGets the “user-facing” length of an array. An array of …\nConverts the ArrayLen intrinsic to Brillig bytecode.\nArray set operation in SSA returns a new array or vector …\nConverts an array to a slice by copying the array contents …\nConverts the Binary instruction into a sequence of Brillig …\nConverts a black box function call into Brillig bytecode.\nConverts a field less than comparison intrinsic to Brillig …\nConverts a foreign function call into Brillig bytecode.\nInternal method to codegen an …\nCopy the input arguments to the results.\nConverts an SSA instruction into a sequence of Brillig …\nConverts an SSA <code>ValueId</code> into a <code>MemoryAddress</code>. Initializes …\nConvert the SSA slice operations to brillig slice …\nConverts an SSA terminator instruction into the necessary …\nConverts an SSA ValueId into a BrilligVariable. …\nCreates a unique label for a block using the function Id …\nCreates a unique global label for a block.\nReturns the argument unchanged.\nPer-function context shared across all of a function’s …\nIf the supplied value is a numeric constant check whether …\nMapping of SSA ValueIds to their already instantiated …\nPre-instantiated constants values shared across functions …\nInitializes a constant array in Brillig memory.\nCodegens Brillig instructions to initialize a constant …\nCodegens Brillig instructions to initialize a large, …\nAccepts a list of constant values to be initialized\nCalls <code>U::from(self)</code>.\nFor each instruction, the set of values that are not used …\nRead the memory starting at the pointer into successive …\nRead the popped number of variables from the front of the …\nReturns the type of the operation considering the types of …\nIncrease or decrease the slice length by 1.\nTracks the available variable during the codegen of the …\nTracks SSA variables that are live and usable during …\nFor a given value_id, allocates the necessary registers to …\nFor a given value_id, allocates the necessary registers to …\nComputes the length of an array. This will match with the …\nDefines a variable that fits in a single register and …\nFor a given SSA value id, define the variable and return …\nReturns the argument unchanged.\nFor a given SSA value id, return the corresponding cached …\nReturns all variables that have not been removed at this …\nCalls <code>U::from(self)</code>.\nChecks if a variable is allocated.\nCreates a BlockVariables instance. It uses the variables …\nRemoves a variable so it’s not used anymore within this …\nCodegen for native (black box) function calls.\nCodegen for converting SSA slice intrinsic functions to …\nConverts a Brillig array or vector into a heap-allocated …\nTransforms SSA’s black box function calls into the …\nInformation required to compile an SSA Function into …\nThe block ids of the function in reverse post order.\nInformation on where to allocate constants\nReturns the argument unchanged.\nA <code>FunctionContext</code> is necessary for using a Brillig block’…\nCalls <code>U::from(self)</code>.\nTrue if this function is a brillig entry point\nLiveness information for each variable in the function.\nCreates a new function context. It will allocate …\nCollects the return values of a given function\nConverts an SSA Type into a corresponding BrilligParameter.\nMap from SSA values its allocation. Since values can be …\nContext structure for generating Brillig globals it stores …\nA globals artifact containing all information necessary …\nMapping of a constant value and the number of functions in …\nMapping of constant values shared across functions hoisted …\nMapping of SSA value ids to their Brillig allocations\nMaps a Brillig entry point to all functions called in that …\nFinal map that associated an entry point with its Brillig …\nFinal map that associates an entry point with any local …\nReturns the argument unchanged.\nFetch the global allocations that can possibly be accessed …\nFetch the global allocations for a given entry point. This …\nMaps a Brillig entry point to constants shared across the …\nMaps an inner call to its Brillig entry point This is …\nCalls <code>U::from(self)</code>.\nHelper for marking that a constant was instantiated in a …\nBoth <code>used_globals</code> and <code>brillig_entry_points</code> need to be built\nReturns the nearest dominator that is outside of any loop.\nFor a given function, finds all the blocks that are within …\nReturn each block that is in a loop starting in the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA back edge is an edge from a node to one of its …\nA struct representing the liveness of variables throughout …\nCollects the underlying variables inside a value id. It …\nRetrieves the list of block params the given block is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the liveness of variables throughout a function.\nA map of instruction id to the set of values that die …\nThe set of values that are alive before the block starts …\nThe set of values that are alive after the block has …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe variables that stop being alive after each specific …\nThe variables that are alive before the block starts …\nThe list of block params the given block is defining. The …\nThe Brillig VM does not apply a limit to the memory …\nBrillig context object that is used while constructing the …\nThis register stores the free memory pointer. Allocations …\nThe number of reserved registers. These are allocated in …\nThis register stores the stack pointer. All relative …\nThis register stores a 1_usize constant.\nSplits a two’s complement signed integer in the sign bit …\nAdds a unresolved external <code>Call</code> instruction to the …\nAdds a unresolved <code>Jump</code> to the bytecode.\nAllocates an unused register.\nReturns the address of the implicit debug variable …\nReturns the artifact\nProcesses a binary instruction according <code>operation</code>.\nIssues a blackbox operation.\nConditionally copies a source array to a destination array.\nIt prepares a vector for a insert operation, leaving a …\nPrepares a vector for a push operation, allocating a …\nReverts with the error selector of the given string This …\nConditionally copies a source array to a destination array.\nPops items from the back of a vector, returning the new …\nPops items from the front of a vector, returning the new …\nRemoves items from the vector, returning the new vector.\nWhether this context can call procedures or not. This is …\nCast truncates the value to the given bit size and …\nAllocates an array of size <code>size</code> and stores the pointer to …\nAllocates an array of size contained in size_register and …\nThis instruction will reverse the order of the <code>size</code> …\nThis codegen will issue an if-then branch that will check …\nConverts a BrilligArray (pointer to <code>[RC, ...items]</code>) to a …\nEmits brillig bytecode to jump to a trap condition if …\nEmits brillig bytecode to jump to a trap condition if …\nAdds the instructions needed to handle entry point …\nAdds the instructions needed to handle return parameters …\nThis codegen will issue a loop for (let iterator_register …\nThis codegen issues a branch that jumps over the code …\nThis codegen issues a branch that jumps over the code …\nInitializes an array, allocating memory to store its …\nInitializes a vector, allocating memory to store its …\nWrites vector metadata (reference count, size, and …\nGets the value stored at base_ptr + index and stores it in …\nThis codegen will issue a loop that will iterate from 0 to …\nReturns a pointer to the items of a given array\nReturns a variable holding the capacity of a given vector\nReturns a pointer to the items of a given vector\nReturns a variable holding the length of a given vector\nCopies the values of memory pointed by source with length …\nCopies num_elements_variable from the source pointer to …\nThis function moves values from a set of registers to …\nReads the metadata of a vector and stores it in the given …\nCodegens a return from the current function.\nStores value at base_ptr + index\nIssues a to_radix instruction. This instruction will write …\nCodegens a truncation of a value to the given bit size\nWrites the value of new length to the length pointer of …\nUtility method to perform a binary instruction with a …\nUtility method to perform a binary instruction with a …\nGenerate code to calculate the flattened vector size from …\nWrites the pointer to the items of a given vector to the …\nInternal function used to compute the section labels\nInsert a conditional move instruction\nStores the value of <code>constant</code> in the <code>result</code> register\nContext label, must be unique with respect to the function …\nCount the number of arrays that are copied, and output …\nSection label, used to separate sections of code\nReturns the current section label\nPush a register to the deallocation list, ready for reuse.\nDeallocates the address where the single address variable …\nThis module contains functions for producing a higher …\nIR printer\nDeflatten an array by recursively allocating nested arrays …\nemit: <code>println(f&quot;Total arrays copied: {array_copy_counter}&quot;)</code>\nEnable the insertion of bytecode with extra assertions …\nInsert extra assertions that we expect to be true, at the …\nAdds a label to the next opcode\nEnter the given section within a basic block\nComputes the size of a parameter if it was flattened\nComputes the size of a parameter if it was flattened\nProcesses a foreign call instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the size of a parameter if it was flattened\nStores the value of <code>constant</code> in the result_pointer\nWe don’t know the length of a vector returned externally …\nInitialize the reference counter for an array or vector. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds a unresolved <code>JumpIf</code> instruction to the bytecode.\nAdds a unresolved <code>Jump</code> instruction to the bytecode.\nMemory layout information. See self::registers for more …\nReturns the length of the reserved registers\nEmits a load instruction\nReturns a register which holds the value of a constant\nReturns a register which holds the value of an usize …\nUtility method to perform a binary instruction with a …\nComputes left % right by emitting the necessary Brillig …\nEmits a <code>mov</code> instruction.\nCreates an entry point artifact that will jump to the …\nStores the next available section\nProcesses a not instruction.\nAdds a brillig instruction to the brillig byte code\nMemory layout and register allocation for Brillig programs.\nTracks register allocations\nCreate, reserve, and return a new section label.\nEmits a return instruction\nSets a current call stack that the next pushed opcodes …\nSet the globals memory size if it is not already set. If …\nEmits a stop instruction with return data\nEmits a store instruction\nAn array parameter or return value. Holds the type of an …\nArtifacts resulting from the compilation of a function …\nRepresents a parameter or a return value of an entry point …\nLabels for the entry point bytecode\nLabels for user defined functions\nThe result of compiling and linking brillig artifacts. …\nLabel for initialization of globals Stores a function ID …\nPointer to a unresolved Jump instruction in the bytecode.\nAn identifier for a location in the code.\nA pointer to a location in the opcode.\nLabels for intrinsic procedures\nA single address parameter or return value. Holds the bit …\nA slice parameter or return value. Holds the type of a …\nWhen constructing the bytecode, there may be instructions …\nAdds a label in the bytecode to specify where this block’…\nAdds a unresolved external call that will be fixed once …\nAdds a unresolved jump to be fixed at the end of bytecode …\nAdds unresolved jumps &amp; function calls from another …\nThe current call stack. All opcodes that are pushed will …\nResolves all jumps and generates the final bytecode\nGets the first unresolved function call of this artifact.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the index of the next opcode.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the opcode is a jump instruction\nA map of labels to their position in byte code.\nLink with an external brillig artifact called from this …\nMaps the opcodes that are associated with a callstack to …\nName of the function, only used for debugging purposes.\nThis field contains the given procedure id if this …\nProcedure ID mapped to the range of its opcode locations …\nAdds a brillig instruction to the brillig byte code\nResolves all of the unresolved jumps in the program.\nSet of labels which are external to the bytecode.\nThe set of jumps that need to have their locations …\nThe representation of a noir array in the Brillig IR\nThe representation of a noir value in the Brillig IR\nThe representation of a noir slice in the Brillig IR\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for converting values into debug-friendly strings.\nDebug function for cast_instruction\nProcesses a binary instruction according <code>operation</code>.\nDebug function for black_box_op\nDebug function for calldata_copy\nEmits a <code>cast</code> instruction.\nEmits a <code>conditional mov</code> instruction.\nStores the value of <code>constant</code> in the <code>result</code> register\nDebug function for enter_context\nProcesses a foreign call instruction.\nReturns the argument unchanged.\nStores the value of <code>constant</code> in the <code>result</code> register\nCalls <code>U::from(self)</code>.\nDebug function for jump_if_instruction\nDebug function for jump_instruction\nEmits a load instruction\nEmits a <code>mov</code> instruction.\nProcesses a not instruction. Append with “_” as this …\nEmits a return instruction\nEmits a stop instruction\nEmits a store instruction\nEmits a <code>trap</code> instruction.\nType to encapsulate the binary operation types in Brillig\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProcedures are a set of complex operations that are common …\nThe metadata string needed to tell <code>print</code> to print out a u32\nThe stack start should be computed earlier after …\nReallocates the target vector for insertion, skipping …\nGlobals have a separate memory space This memory space is …\nDefines the memory layout for Brillig programs.\nThese constants represent expert chosen defaults that are …\nProcedure arguments and returns are passed through scratch …\nEvery brillig stack frame/call context has its own view of …\nAllocates a new register.\nPush a register to the deallocation list, ready for reuse.\nA free-list of registers that have been deallocated and …\nFinds the first register that is available based upon the …\nLast valid memory address\nEnsures a register is allocated, allocating it if necessary\nStart of the entry point region: {reserved} {scratch …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new register context from a set of registers …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the memory layout used by this allocator.\nA usize indicating the next un-used register.\nStart of the return data within the entry point region: …\nFirst valid memory address\nStatic start method for constructors\nComputes the first valid memory address for global space\nThis case is not an error. It’s used during codegen to …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn SSA pass reified as a construct we can put into a list, …\nOptions affecting Brillig code generation.\nMaximum number iterations to do in constant folding, as …\nCompiles the <code>Program</code> into <code>ACIR</code>.\nCompiles the <code>Program</code> into <code>ACIR</code> using the minimum amount of …\nCompiles the <code>Program</code> into <code>ACIR</code> by running it through SSA …\nDump the unoptimized SSA to the supplied path if it exists\nEnable the lookback feature of the Brillig call constraints\nWidth of expressions to be used for ACIR\nProviding a file manager is optional - if provided it can …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe higher the value, the more inlined Brillig functions …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if an SSA pass should be printed.\nMaximum accepted percentage increase in the Brillig …\nFor testing purposes we want a list of the minimum number …\nThis folder contains each optimization pass for the SSA IR.\nOptimize the given program by converting it into SSA form …\nOptimize the given SsaBuilder by converting it into SSA …\nCounters indexed by the message in the SSA pass, so we can …\nThe default SSA optimization pipeline.\nWhether to print the amount of time it took to run …\nPretty print benchmark times of each code generation pass\nSkip the missing Brillig call constraints check\nList of SSA pass message fragments that we want to skip, …\nA list of SSA pass messages to skip, for testing purposes.\nSkip the check for under constrained values\nThe higher the value, the more Brillig functions will be …\nThe SSA being built; it is the input and the output of …\nOptions to control which SSA passes to print.\nEmit debug information for the intermediate SSA IR\nValidator that checks whether a function is well formed.\nContains the error value\nContains the success value\nAn SSA pass reified as a construct we can put into a list, …\nFollow up the pass with another one, without adding a …\nSame as <code>and_then</code> but for passes that can fail.\nProviding a file manager is optional - if provided it can …\nCounters indexed by the message in the SSA pass, so we can …\nWhether to print the amount of time it took to run …\nRuns the given SSA pass and prints the SSA afterward if …\nRun a list of SSA passes.\nList of SSA pass message fragments that we want to skip, …\nThe SSA being built; it is the input and the output of …\nOptions to control which SSA passes to print.\nThe same as <code>run_pass</code> but for passes that may fail\nThis module defines security SSA passes detecting …\nStructure keeping track of value ids descending from …\nBuild the dependency context of variable ValueIds, storing …\nIf Brillig call is properly constrained by the given ids, …\nDetect independent subgraphs (not connected to function …\nCheck if any of the recorded Brillig calls have been …\nEvery Brillig call not properly constrained should remain …\nCompute sets of variable ValueIds that are connected with …\nGo through each instruction in the block and add a set of …\nFind which Brillig calls separate this set from others and …\nFind sets that contain input or output value of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the call being tracked is a simple wrapper of …\nMerge all small sets into larger ones based on whether the …\nParallel version of merge_sets The sets are merged by …\nProcess ArrayGet instruction for tracked Brillig calls\nWhen an ArrayGet instruction occurs, place the resulting …\nGo over the given block tracking Brillig calls and …\nRemember partial constraints (involving some of the …\nUpdate sets of value ids that can be traced back to the …\nAdd children of a given parent to the tainted value set …\nUpdate children of all the results (helper function for …\nThe per-function context for each ssa function being …\nAdds a parameter with the given type to the given block. …\nAdd a parameter to the current function with the given …\nInsert a value into a data bus builder\nReturns the parameters of the given block in the current …\nGenerate the data bus for call-data, based on the …\nReturns the block currently being inserted into\nInsert instructions to decrement the reference count of …\nThis function takes the flattened databus visibilities and …\nInsert a numeric constant into the current function of …\nConsume the FunctionBuilder returning all the functions it …\nReturns the argument unchanged.\nCreate a function builder with a new function created with …\nReturns a ValueId pointing to the given oracle/foreign …\nReturns a ValueId pointing to the given function or …\nRetrieve a value reference to the given intrinsic …\nRetrieve a value reference to the given intrinsic …\nInsert instructions to increment the reference count of …\nCreate a data bus builder from a list of values\nInsert an allocate instruction at the end of the current …\nInsert an instruction to extract an element from an array\nInsert an instruction to create a new array with the given …\nInsert a binary instruction at the end of the current …\nInsert a new block into the current function and return it.\nInsert a call instruction at the end of the current block …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert an instruction to decrement an array’s reference …\nInsert an enable_side_effects_if instruction. These are …\nInsert an instruction to increment an array’s reference …\nInserts a new instruction at the end of the current block …\nInsert a Load instruction at the end of the current block, …\nInsert a <code>make_array</code> instruction to create a new array or …\nInsert a not instruction at the end of the current block. …\nInsert a <code>Instruction::RangeCheck</code> instruction at the end of …\nInsert a Store instruction at the end of the current …\nInsert a truncate instruction at the end of the current …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function of …\nCreates a new FunctionBuilder to build the function with …\nFinish the current function and create a new unconstrained …\nFinish the current function and create a new ACIR function.\nFinish the current function and create a new function.\nInsert a numeric constant into the current function\nForcefully sets the databus of the current function.\nSet the runtime of the initial function that is created …\nWhether instructions are simplified as soon as they are …\nSwitch to inserting instructions in the given block. …\nTerminates the current block with the given terminator …\nTerminate the current block with a jmp instruction to jmp …\nTerminate the current block with a jmpif instruction to …\nTerminate the current block with a return instruction\nTerminate the current block with an unreachable instruction\nReturns the type of the given value.\nIncrement or decrement the given value’s reference count …\nUsed to create a data bus, which is an array of private …\nThe array to read from, when reading from a value in …\nThe id to this calldata assigned by the user\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a databus from call_data and return_data data …\nWhen reading from a value in <code>index_map</code>, read it instead …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a vector telling which flattened parameters from …\nUpdates the databus values with the provided function\nUpdates the databus values in place with the provided …\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nApplies an infallible integer binary operation to two …\nApplies a fallible integer binary operation (e.g., checked …\nPrint is not an intrinsic but it is treated like one.\nContains each function called with <code>main</code> (or the first …\nThe function that was called. This is <code>None</code> only for the …\nDefine or redefine a value. Redefinitions are expected in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true, the interpreter treats all foreign function calls …\nPrint output.\nReset the value’s <code>Shared</code> states in each array within. …\nContains each value currently defined and visible to the …\nThis variable can be modified by <code>enable_side_effects_if</code> …\n(length, slice, index:u32, elem…) -&gt; (length, slice)\n(length, slice) -&gt; (length, slice, elem…)\n(length, slice) -&gt; (elem…, length, slice)\n(length, slice, elem…) -&gt; (length, slice)\n(length, slice, elem…) -&gt; (length, slice)\n(length, slice, index:u32) -&gt; (length, slice, elem…)\nIf true, the interpreter will trace its execution.\nTry to get a function’s name or approximate it if it is …\nThese errors are all the result from malformed input SSA\nThese errors can only result from interpreting malformed …\nThis is not an internal error since the SSA is still …\nFormat the message of a <code>constrain</code> instruction so that we …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse a Value as PrintableType.\nParse a value as <code>[u8]</code> and convert to UTF-8 <code>String</code>.\nConvert a slice of Value to a flattened vector of …\nBe careful when using <code>Clone</code>: <code>ArrayValue</code> and <code>ReferenceValue</code> …\nA value of <code>None</code> here means this allocation is currently …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is included mostly for debugging to distinguish …\nThe <code>Shared</code> type contains its own reference count but we …\nCreate an empty reference value.\nClone the value in a way that modifications to it won’t …\nTake a snapshot of interpreter arguments.\nReturn an uninitialized value of the given type. This is …\nCall graph analysis\nThe dominator tree of a function, represented as a hash …\nThe post-order for a given function represented as a …\nThis file is for pretty-printing the SSA IR in a …\nA Basic block is a maximal collection of instructions such …\nAn identifier for a Basic Block.\nAdds a parameter to this BasicBlock. Expects that the …\nReturns the argument unchanged.\nInsert an instruction at the end of this block\nRetrieve a reference to all instructions in this block.\nInstructions in the basic block.\nRetrieve a mutable reference to all instructions in this …\nCalls <code>U::from(self)</code>.\nCreate a new BasicBlock with the given parameters. …\nReturns the parameters of this block\nParameters to the basic block.\nReplace this block’s current parameters with that of the …\nSets the terminator instruction of this block.\nIterate over all the successors of the currently block, as …\nTake the instructions in this block, replacing it with an …\nRemoves all the parameters of this block\nTake ownership of this block’s terminator, replacing it …\nReturns the terminator of this block.\nThe terminating instruction for the basic block.\nReturn the jmp arguments, if any, of this block’s …\nReturns the terminator of this block, panics if there is …\nReturns a mutable reference to the terminator of this …\nRepresents a function call graph built from the SSA …\nUtility function to find out the deduplicated direct calls …\nUtility function to find out the direct calls of a …\nFetch for each function the set of functions called by it, …\nFetch for each function the set of functions that call it, …\nCompute for each function the set of functions called by …\nReturns the argument unchanged.\nConstruct a CallGraph from an explicit dependency mapping …\nConstruct a CallGraph from the Ssa The edges in this graph …\nConstruct a CallGraph from the Ssa with its edges weighted.\nReturns the set of all recursive functions.\nCalls <code>U::from(self)</code>.\nReturns all functions reachable from the provided root(s).\nReturns both the call graph’s strongly connected …\nCompute the times each function is called from any other …\nA container for the successors and predecessors of some …\nThe Control Flow Graph (CFG) maintains a mapping of blocks …\nAdd a directed edge making <code>from</code> a predecessor of <code>to</code>.\nCompute all of the edges between each reachable block in …\nCompute all of the edges for the current block given\nReturns the entry blocks for a CFG. This is all nodes …\nComputes the reverse graph of the extended CFG. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nClears out a given block’s successors. This also removes …\nGet an iterator over the CFG predecessors to <code>basic_block_id</code>…\nSet of blocks that containing jumps that target this block.\nRecompute the control flow graph of <code>block</code>.\nReverse the control flow graph\nFlag stating whether this CFG has been reversed. In a …\nGet an iterator over the CFG successors to <code>basic_block_id</code>.\nSet of blocks that are the targets of jumps in this block. …\nAllocate and compute the control flow graph for <code>func</code>.\nThe DataFlowGraph contains most of the actual data in a …\nThe GlobalsGraph contains the actual global data. Global …\nResults is the standard case containing the instruction id …\nAdd a parameter to the given block\nDetermine the appropriate ArrayOffset to use for indexing …\nReturns the parameters of the given block\nAll blocks in a function\nIndicate whether the Brillig array index offset …\nEach constant is unique, attempting to insert the same …\nRetrieve the first (and expected to be the only) result.\nReturn the result types of this instruction.\nContains each foreign function that has been imported into …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nContains each function that has been imported into the …\nReturns the item values in with this ValueId if it refers …\nSimilar to <code>get_numeric_constant</code> but returns the value as a …\nUses value information to determine whether an instruction …\nReturns the field element represented by this value if it …\nReturns the field element and type represented by this …\nIf this value points to an array of constant bytes, …\nReturns the maximum possible number of bits that <code>value</code> can …\nGets or creates a ValueId for the given FunctionId.\nGets or creates a ValueId for the given FunctionId.\nGets or creates a ValueId for the given Intrinsic.\nGet a mutable reference to a function’s basic block for …\nMoves the entirety of the given block’s contents into …\nSimplifies a new instruction and inserts it at the end of …\nSimplifies a potentially existing instruction and inserts …\nReturns N results, asserting that there are exactly N …\nReturns all of result values which are attached to this …\nAll of the instructions in a function\nAll of the instructions in the global value space. These …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains each intrinsic that has been imported into the …\nTrue if the given ValueId refers to a (recursively) …\nTrue that the input is a non-zero <code>Value::NumericConstant</code>\nCheck if the function runtime would simply ignore this …\nCheck if the results of an instruction are used in the …\nA constant index less than the array length is safe\nReturns the amount of ValueIds contained\nSource location of each instruction for debugging and …\nCreates a new basic block with no parameters. After being …\nCreate a new block with the same parameter count and …\nCreates a new constant value, or returns the Id to an …\nInserts a new instruction into the DFG. This does not add …\nAttaches results to the instruction, clearing any previous …\nRemove an instruction by replacing it with a <code>Noop</code> …\nReplaces values in the given block according to the given …\nReplaces values in the given block instructions according …\nReplaces values in the given block terminator (if it has …\nReturn all the results contained in the internal results …\nStores the results for a particular instruction.\nRuntime type of the function.\nRuntime of the function that owns this DataFlowGraph. This …\nSets the terminator instruction for the given basic block\nReplace an existing instruction with a new one.\nSet runtime type of the function.\nSet the type of value_id to the target_type.\nIf this value is an array, return the length of the array …\nReturns the type of a given value\nTrue if the type of this value is Type::Reference. Using …\nStorage for all of the values defined in this function.\nStorage for all of the global values\nIterate over every Value in this DFG in no particular …\nIterate over every Value in this DFG in no particular …\nInstruction could not be simplified\nRemove the instruction, it is unnecessary\nReplace this function’s result with the given value\nReplace this function with an simpler but equivalent …\nReplace this function with a set of simpler but equivalent …\nReplace this function’s results with the given values …\nContains the result to Instruction::simplify, specifying …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven an array access on a length 1 array such as:\nTry to simplify this instruction. If the instruction can …\nGiven a chain of operations like: v1 = array_set [10, 11, …\nIf we have an array set whose value is from an array get …\nTry to simplify this binary instruction, returning the new …\nTry to simplify this black box call. If the call can be …\nTry to simplify this call instruction. If the instruction …\nReturns a slice (represented by a tuple (len, slice)) of …\nSlices have a tuple structure (slice length, slice …\nTry to simplify this cast instruction. If the instruction …\nTry to decompose this constrain instruction. This …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven an if expression that returns an array: …\nMerge two numeric values a and b from separate basic …\nMerge two values a and b to a single value. If these two …\nMaps SSA array values with a slice type to their size. …\nThe dominator tree for a single function.\nDominator tree node. We keep one of these per reachable …\nSubsequent calls to <code>dominates</code> are cached to speed up access\nCompute the common dominator of two basic blocks.\nComputes the dominance frontier for all blocks in the …\nBuild a dominator tree from a control flow graph using …\nReturns <code>true</code> if <code>block_a_id</code> dominates <code>block_b_id</code>.\nWalk up the dominator tree until we find a block for which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block_id</code>.\nThe block that immediately dominated that of the node in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block_id</code> reachable from the entry block?\nThe nodes of the dominator tree\nCompare two blocks relative to the reverse post-order.\nPosition in the Reverse Post-Order.\nThe block’s idx in the control flow graph’s reverse …\nUpdates the immediate dominator estimate, returning true …\nAllocate and compute a dominator tree from a pre-computed …\nAllocate and compute a dominator tree for the given …\nA function holds a list of instructions. These …\nFunctionId is a reference for a function\nProvide public access to certain aspects of a <code>Function</code> …\nIterate over the functions called from a block.\nIterate over the successors of a blocks.\nIterate over the blocks in the CFG in reverse-post-order.\nTakes the signature (function name &amp; runtime) from a …\nCreates a new function as a clone of the one passed in …\nThe structure of this pass is simple: Go through each …\nIterate over the numeric constants in the function.\nRemoves any unused instructions in the reachable blocks of …\nThe DataFlowGraph holds the majority of data pertaining to …\nRetrieves the entry block of a function.\nThe first basic block in the function\nThe structure of this pass is simple: Go through each …\nThe structure of this pass is simple: Go through each …\nFinds the block of the function with the Return instruction\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe id of the function.\nCreate a new function which has the functions called by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the runtime type represents an entry point.\nThe name of the function. Used exclusively for debugging …\nName of the function for debugging only\nCreates a new function with an automatically inserted …\nGlobals are generated using the same codegen process as …\nTotal number of instructions in the reachable blocks of …\nReturn the types of the function parameters.\nReturns the parameters of this function. The parameters …\nSee <code>prune_dead_parameters</code> module for more information\nCollects all the reachable blocks of this function.\nIf this is an ACIR function, go through every instruction, …\nThis function is very simplistic for now. It takes …\nReturn the types of the returned values, if there are any.\nReturns the return types of this function. None might be …\nRuntime type of the function.\nSet runtime type of the function.\nPerforms a simple optimization according to the given …\nPerforms a simple optimization according to the given …\nSimplify a function’s cfg by going through each block to …\nUnroll all loops within the function. Any loops which fail …\nTry to unroll loops in the function.\nUpdate terminator arguments of predecessor blocks after …\nIterate over every Value in this DFG in no particular …\nThe FunctionInserter can be used to help modify existing …\nMerge the internal mapping into the given mapping The …\nReturns the argument unchanged.\nModify the values HashMap to remember the mapping between …\nCalls <code>U::from(self)</code>.\nMaps the data bus in place, replacing any ValueId in the …\nGet an instruction and make sure all the values in it are …\nGet an instruction, map all its values, and replace it …\nMaps a terminator in place, replacing any ValueId in the …\nInsert a key, value pair in the map\nPush a new instruction to the given block and return its …\nAssociates each block parameter with a value, unless the …\nResolves a ValueId to its new, updated value. If there is …\nInsert a key, value pair if the key isn’t already …\nAllocates a region of memory. Note that this is not …\nApplyRangeConstraint - Enforces the <code>bit size</code> of the first …\nArrayAsStrUnchecked - Converts a byte array of type <code>[u8; N]</code>…\nRetrieve a value from an array at the given index\nArrayLen - returns the length of the input array argument: …\nDetermines whether an ArrayGet or ArraySet index has been …\nArrayRefCount - Gives the reference count of the array …\nCreates a new array with the new value at the given index. …\nAsSlice argument: value id result: a slice containing the …\nAsWitness - Adds a new witness constrained to be equal to …\nAssertConstant - Enforce the argument to be a constant …\nBinary Operations like +, -, *, /, ==, !=\nBlackBox(BlackBoxFunc) - Calls a blackbox function. More …\nHint to the compiler to treat the call as having potential …\nPerforms a function call with a list of its arguments.\nConverts <code>Value</code> into the given <code>NumericType</code>\nConstrains two values to be equal to one another.\nConstrains two values to not be equal to one another.\nAn instruction to decrement the reference count of a value.\nDerivePedersenGenerators - Computes the Pedersen generators\nProvides a context for all instructions that follow up …\nThe endian-ness of bits when encoding values as bits in …\nFieldLessThan - Compare the arguments: <code>lhs</code> &lt; <code>rhs</code> …\nCompiler hints.\nHint(Hint) - Avoid its arguments to be removed by DIE. …\nMerge two values returned from opposite branches of a …\nAn instruction to increment the reference count of a value.\nInstructions are used to perform tasks. The instructions …\nReference to an instruction\nThe possible return values for Instruction::return_types\nThese are similar to built-ins in other languages. These …\nIsUnconstrained - Indicates if the execution context is …\nUnconditional Jump\nControl flow\nThe result type of this instruction is known to be this …\nLoads a value from memory.\nCreates a new array or slice.\nThis instruction does not return any results.\nA No-op instruction. These are intended to replace other …\nComputes a bit wise not\nThe result type of this instruction matches that of this …\nRange constrain <code>value</code> to <code>max_bit_size</code>\nReturn from the current function with the given return …\nSliceInsert - Insert elements inside a slice. arguments: …\nSlicePopBack - Removes the last element of a slice …\nSlicePopFront - Removes the first element of a slice …\nSlicePushBack - Add elements at the end of a slice …\nSlicePushFront - Add elements at the start of a slice …\nSliceRefCount - Gives the reference count of the slice …\nSliceRemove - Removes an element from a slice arguments: …\nStaticAssert - Enforce the first argument to be true, at …\nWrites a value to memory.\nStrAsBytes - Convert a <code>str</code> into a byte array of type …\nThese are operations which can exit a basic block ie …\nToBits(Endian) - Computes the bit decomposition of the …\nToRadix(Endian) - Decompose the first argument over the …\nTruncates <code>value</code> to <code>bit_size</code>\nThe result type of this function is unknown and separate …\nA terminator that will never be reached because an …\nReturns a binary instruction with the given operator, lhs, …\nApplies a function to each input value this instruction …\nApply a function to each value\nApply a function to each value along with its index\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether the <code>Intrinsic</code> has side effects.\nIndicates if the instruction has a side effect, ie. it can …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLookup an Intrinsic by name and return it if found. If …\nMaps each ValueId inside this instruction to a new …\nMaps each ValueId inside this instruction to a new ValueId …\nMutate each ValueId to a new ValueId using the given …\nMutate each BlockId to a new BlockId specified by the …\nReplaces values present in this instruction with other …\nIf true the instruction will depend on <code>enable_side_effects</code> …\nTrue if this instruction requires specifying the control …\nReturns the type that this instruction will return.\nAddition of lhs + rhs.\nBitwise and (&amp;)\nA binary instruction in the IR.\nBinary Operations allowed in the IR. Aside from the …\nThe binary operation could not be evaluated\nDivision of lhs / rhs.\nChecks whether two types are equal. Returns true if the …\nThe binary operation could be evaluated but it is …\nChecks whether the lhs is less than the rhs. All other …\nModulus of lhs % rhs.\nMultiplication of lhs * rhs.\nBitwise or (|)\nBitshift left (&lt;&lt;)\nBitshift right (&gt;&gt;)\nSubtraction of lhs - rhs.\nThe binary operation could be evaluated and it was …\nBitwise xor (^)\nEvaluate a binary operation with constant arguments.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLeft hand side of the binary operation\nThe binary operation to apply\nThe type of this Binary instruction’s result\nRight hand side of the binary operation\nTruncates <code>int</code> to fit within <code>bit_size</code> bits.\nValues in the range <code>[0, 2^(bit_size-1))</code> are interpreted as …\nA <code>Signed</code> or <code>Unsigned</code> value of a <code>Value::NumericConstant</code>, …\nApply functions on signed/unsigned values.\nDecrement the value by 1, saturating at the minimum value.\nReturns the argument unchanged.\nIncrement the value by 1, saturating at the maximum value.\nCalls <code>U::from(self)</code>.\nConvert back into a field.\nReduce two constants into a result by applying functions …\nA simple counter to create fresh Ids without any storage. …\nA DenseMap is a Vec wrapper where each element corresponds …\nA unique ID corresponding to a value of type T. This type …\nA SparseMap is a HashMap wrapper where each element …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds an element to the map. Returns the …\nGiven the Id of the element being created, adds the element\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps the inner storage of this map\nGets an iterator to a reference to each element in the …\nConstructs a new Id for the given index.\nReturn the next fresh id\nCreate a new counter starting after the given Id. Use …\nReturns the underlying index of this Id.\nDepth-first traversal stack state marker for computing the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn blocks in post-order.\nReturn blocks in reverse-post-order a.k.a. forward-order.\nAllocate and compute a function’s block post-order.\nAllocate and compute a function’s block post-order.\nDisplay a single block. This will not display the block’…\nHelper function for Function’s Display impl to …\nDisplay an arbitrary instruction\nDisplay a terminator instruction\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFormats the given number assuming it has the given type. …\nTries to extract a constant string from an error payload.\nSpecialize displaying value ids so that if they refer to a …\nDisplay each value separated by a comma\nDisplay each value along with its type. E.g. …\nAn immutable array value with the given element type and …\nComposite Types are essentially flattened struct or tuple …\nA function that may be called directly\nRepresents numeric types in the IR, including field …\nA numeric type in the Intermediate representation Note: we …\nA reference to some value, such as an array\nAn immutable slice value with a given element type\nAll types representable in the IR.\nReturns the bit size of the provided numeric type.\nReturns the bit size of the provided numeric type.\nCreates the u1 type\nCreates the boolean type, represented as u1.\nCreates the char type, represented as u8.\nCreates the char type, represented as u8.\nTrue if this type is an array (or slice) or internally …\nTrue if this is a function type or if it is a composite …\nTrue if this is a reference type or if it is a composite …\nReturns the size of the element type for this array/slice. …\nReturn the types of items in this array/slice.\nCreates the native field type.\nReturns the flattened size of a Type\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this type is an array (or slice)\nTrue if this type is a numeric primitive type.\nReturns whether the <code>Type</code> represents an signed numeric type.\nReturns whether the <code>Type</code> represents an unsigned numeric …\nCreates the type of an array’s length.\nCreates the type of an array’s length.\nCreates a NumericType::Signed type\nCreate a new signed integer type with the given amount of …\nCreates the <code>str&lt;N&gt;</code> type, of the given length N\nCreates a NumericType::Unsigned type\nCreate a new unsigned integer type with the given amount …\nReturns the inner NumericType if this is one, or panics …\nReturns None if the given Field value is within the …\nThis Value refers to an external function in the IR. …\nThis Value refers to a function in the IR. Functions …\nThis Value indicates we have a reserved slot that needs to …\nThis value was created due to an instruction\nAn Intrinsic is a special kind of builtin function that …\nThis Value originates from a numeric constant\nThis Value originates from a block parameter. Since …\nValue is the most basic type allowed in the IR. Transition …\nLike <code>HashMap&lt;ValueId, ValueId&gt;</code> but handles:\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the type of this Value\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if all <code>ValueId</code>s are mapped to a <code>ValueId</code> of …\nThe maximum number of instructions chosen below is an …\nThe purpose of the <code>array_set_optimization</code> SSA pass is to …\nThis SSA pass adjusts constant indexes of array operations …\nThe purpose of this pass is to perform function …\nAn SSA pass that operates on ACIR functions that checks …\nThis SSA pass will turn checked unsigned binary additions, …\nThe goal of the constant folding optimization pass is to …\nThis module defines the defunctionalization pass for the …\nDead Instruction Elimination (DIE) pass: Removes any …\nA simple SSA pass to go through each instruction and …\nThis file contains the SSA flattening pass - a required …\nThis modules defines an SSA pass that inlines calls to …\nThis module defines the function inlining pass for the SSA …\nThe loop invariant code motion (LICM) pass performs two …\nThe goal of this SSA pass is to go through each …\nThe goal of the mem2reg SSA optimization pass is to …\nPre-process functions before inlining them into others.\nThis SSA pass replaces Shl and Shr instructions in ACIR …\nThe goal of the “remove enable side effects” …\nThis file contains the SSA <code>remove_if_else</code> pass - a …\nRemoves any unreachable functions from the code. These can …\nThis module defines an SSA pass to remove instructions …\nThis file contains the simplify cfg pass of the SSA IR.\nThis file contains the loop unrolling pass for the new SSA …\nBuilds the set of <code>ArraySet</code> instructions that can be made …\nPost-check condition for Function::array_set_optimization.\nPre-check condition for Function::array_set_optimization.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMake each ArraySet instruction in <code>instructions_to_update</code> …\nRemember this instruction as the last time the array has …\nComputes a cost estimate of a basic block returns u32::MAX …\nIdentifies all simple conditionals in the function and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the blocks of the simple conditional sub-graph …\nGiven an array or slice value and a constant index, …\nStores the information necessary to appropriately update …\nReturns all functions reachable from the given Brillig …\nCheck post-execution properties of the Brillig …\nClones new functions and returns a mapping representing …\nFor every call site, we can determine the entry point for …\nBuilds a mapping from a <code>FunctionId</code> to the set of <code>FunctionId</code>…\nGo through the supplied function and based upon the call …\nReturns the argument unchanged.\nReturns the set of Brillig entry points\nReturns a map of Brillig entry points to all reachable …\nLike get_brillig_entry_points_with_reachability, but uses …\nCalls <code>U::from(self)</code>.\nGiven that we have already rewritten all the call sites …\nMAX_NON_OVERFLOWING_CONST_ARG is expected to be [p/U], …\nThe logic here is almost the same as …\nThis instruction has no side effects so we can substitute …\nThis instruction has side effects which prevent all …\nThis instruction has some side effects such as potentially …\nKeeps track of visited blocks and blocks to visit. …\nBlocks which we hoisted instructions into. We can make …\nReturns the predicate value to be used when looking up …\nCache of instructions along with their outputs which are …\nIndicates if the instruction can be safely replaced with …\nContains sets of values which are constrained to be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPushes a new <code>Instruction</code> into the <code>DataFlowGraph</code> which …\nFetches an <code>Instruction</code> by its <code>InstructionId</code> and fully …\nWhether to use constraints to inform simplifications later …\nMaps pre-folded ValueIds to the new ValueIds obtained by …\nThe instruction was a call to a brillig function, but we …\nThe instruction was a call to a brillig function and we …\nResult of trying to evaluate an instruction (any …\nNothing was done because the instruction wasn’t a call …\nConverts a constant SSA value into an interpreter value …\nTries to evaluate an instruction if it’s a call where …\nReturns the argument unchanged.\nConverts a constant interpreter value back into an SSA …\nCalls <code>U::from(self)</code>.\nChecks if the given instruction is a call to a function …\nThe result of an earlier instruction can be readily …\nHashMap from <code>(Instruction, side_effects_enabled_var)</code> to …\nWe found an identical instruction in a non-dominating …\nRecords the results of all duplicate <code>Instruction</code>s along …\nRecords that an <code>Instruction</code> in block <code>block</code> produced the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a cached result if it can be used in this context.\nReturns a set of <code>ValueId</code>s produced from a copy of this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove previously cached instructions that created arrays, …\nThe common dominator where we can hoist the current …\nThe value IDs we can reuse.\nHashMap from <code>(side_effects_enabled_var, Instruction)</code> to a …\nRecords a simplified equivalents of an <code>Instruction</code> in the …\nAdd a newly encountered simplification to the cache.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to find a simplification in a visible block.\nGet the simplification mapping from complex to simpler …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSimplified expressions where we found them.\nCheck if one expression is simpler than the other. Returns …\nRepresents an ‘apply’ function created by this pass to …\nAll generated apply functions for each grouping of …\nPerforms defunctionalization on all functions This is done …\nAll functions used as a value that share the same …\nCreates a single apply function to enable dispatch across …\nCreates all apply functions needed for dispatch of …\nCreates a placeholder (dummy) function to replace calls to …\nDefunctionalize a single function\nDefunctionalize all functions in the SSA\nCheck post-execution properties:\nFinds all dynamic dispatch signatures in the given …\nFinds all literal functions used as values in the given …\nCollects all functions used as values that can be called …\nReturns the argument unchanged.\nReturns the argument unchanged.\nTransforms a FunctionId into a FieldElement\nReturns the apply function for the given signature\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a dummy value to be returned from the …\nTry to map the given function literal to a field, …\nReplace any first class functions used in an instruction …\nReplaces any function calls using first-class function …\nReturn what type a function value type should be replaced …\nTake a list of types that might need replacement. Replaces …\nPer function context for tracking unused values and which …\nCheck post-execution properties:\nCheck pre-execution properties:\nThe elimination of certain unused instructions assumes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this is a <code>Instruction::IncrementRc</code> or …\nReturns true if an instruction can be removed.\nAdds values referenced by the terminator to the set of …\nInspects a value and marks all instruction results as used.\nA per-block list indicating which block parameters are …\nThis module implements the pruning of unused block …\nIncrementRc &amp; DecrementRc instructions must be revisited …\nGo through the RC instructions collected when we figured …\nSteps backwards through the instruction of the given …\nReplaces unused ArrayGet/ArraySet instructions with out of …\nStore instructions must be removed by DIE in acir code, …\nGiven <code>lhs</code> and <code>rhs</code> values, if there’s a side effects …\nHandle the case when an <code>ArrayGet</code> is potentially …\nArray get/set has explicit out of bounds (OOB) checks laid …\nDuring the loop unrolling pass we also evaluate calls to …\nEvaluate a call to <code>assert_constant</code>, returning an error if …\nEvaluate a call to <code>static_assert</code>, returning an error if …\nReturns all of a function’s block that are part of empty …\nhelper function which add instructions to the block …\nInsert constraints ensuring that the operation does not …\nPost-check condition for Function::expand_signed_checks.\nReturns the argument unchanged.\nInsert a binary instruction at the end of the current …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert a not instruction at the end of the current block. …\nInsert a <code>Instruction::RangeCheck</code> instruction at the end of …\nInserts a cast instruction at the end of the current block …\nInsert a truncate instruction at the end of the current …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function\nPost-check condition for Function::expand_signed_math.\nReturns the argument unchanged.\nInsert a binary instruction at the end of the current …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert a not instruction at the end of the current block. …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function\nReturns the 2-complement of <code>value</code>, given <code>value_is_negative</code> …\nBlocks enqueued for processing.\nWhen a MSM is done under a predicate, we need to apply the …\nThis is an algorithm for identifying branch starts and …\nMaps start of branch -&gt; end of branch.\nCall stack where the final location is that of the entire …\n‘Cast’ the ‘condition’ to ‘value’ type\nThis <code>ControlFlowGraph</code> is the graph from before the …\nCondition from the conditional statement\nThe resolved condition of the branch, AND-ed with all …\nA stack of each jmpif condition that was taken to reach a …\nConsume the arguments prepared by the previous block.\nFirst block of the else branch\nSwitch context the ‘exit’ block of a conditional …\nBlock containing the conditional statement\nFlatten the CFG by inlining all instructions from the …\nPost-check condition for Ssa::flatten_cfg.\nPre-check condition for Ssa::flatten_cfg.\nFlattens the control flow graph of the function such that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the current condition\nWeave the <code>condition</code> into blackbox call arguments, …\nWeave the <code>condition</code> into call arguments, returning the …\nIf we are currently in a branch, we need to modify …\nWeave the <code>condition</code> into intrinsic call arguments, …\nReturns the list of blocks that need to be processed after …\nProcess a conditional statement by creating a …\nInline all instructions from the given block into the …\nInline the ending block of a branch, the point where all …\nChecks the branch condition on the top of the stack and …\nInsert a new instruction into the target block. Unlike …\nInserts a new instruction into the target block, using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse the provided map to say if the instruction is a call …\nContains the last processed block during the processing of …\nReturns the updated condition so that it is ‘AND-ed’ …\nStores all allocations local to the current branch.\nThe allocations accumulated before processing the branch.\nMerges the given array with a constant array of 32 …\nInsert a multiplication between ‘condition’ and ‘…\nArguments prepared by the last inlined block for the next …\nFlag to tell the context to not issue ‘enable_side_effect…\nNegates a boolean value by inserting a Not instruction\nA map from <code>cond</code> to <code>Not(cond)</code>.\nThe unresolved condition of the branch\nReturns the values corresponding to the given inputs by …\nMap the value to its predicated value in the current …\nList of values which have been replaced with a predicated …\nPrepare the arguments for the next block to consume.\nPush the given instruction to the end of the target block …\nRestore the previously known local allocations after a …\nRestore the previous mapping of predicated values after a …\nTarget block of the flattening.\nFirst block of the then branch\nSwitch context to the ‘else_branch’:\nComputes: <code>if condition { var } else { other }</code>\nComputes: <code>if condition { var } else { 1 }</code>\nThe CFG branched again at a parent block into a left and …\nThe CFG rejoined.\nThe next interesting point following some block.\nTry to complete as many of the parent levels as we can, …\nReturns a <code>HashMap</code> mapping blocks that start a branch (i.e. …\nStarting with the current block, find the next join or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the left and right branches joined. If so, mark …\nTry to join a pending branch, once the next join point is …\nCheck that the left and right join points are the same, …\nPush a branch to the stack for exploration, remembering …\nThe context for the function inlining pass.\nThe per-function inlining context contains information …\nAn arbitrary limit to the maximum number of recursive call …\nMaps blocks in the source function to blocks in the …\nThe shared inlining context for all functions. This …\nThe function that we are inlining calls into.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to retrieve the function referred to by the given Id. …\nHandle inlining a function’s possibly multiple return …\nHandle the given terminator instruction from the given …\nStart inlining the entry point function and all functions …\nInline each instruction in the given block into the …\nInline all reachable blocks within the source_function …\nInlines a function into the current function and returns …\nInline a function call and remember the inlined return …\nTrue if we’re currently working on the entry point …\nModify the values HashMap to remember the mapping between …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new context object for the function inlining pass.\nCreate a new PerFunctionContext from the source function. …\nPush the given instruction from the source_function into …\nThe source function is the function we’re currently …\nTranslates the program point representing the start of the …\nCopy block parameters from <code>source_block</code> into <code>target_block</code>.\nTranslates a ValueId from the function being inlined to a …\nExtra error check where given a caller’s runtime its …\nMaps ValueIds in the function being inlined to the new …\nInformation about a function to aid the decision about …\nThe maximum number of instructions chosen below is an …\nCompute something like a topological order of the …\nCompute interface cost of a function based on the number …\nCompute a weight of a function based on the number of …\nDetermines whether a function should be inlined.\nThe functions we should inline into (and that should be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFunctions which are to be retained, not inlined.\nIndicate whether an instruction can be hoisted.\nContext with the scope of just one loop.\nContext with the scope of an entire function.\nAll induction variables collected up front.\nIndicates if the instruction can be safely hoisted out of …\nCertain instructions can take advantage of that our …\nChecks whether a binary operation can be evaluated using …\nA control dependent instruction (e.g. constrain or …\nDecide if an in instruction can be hoisted into the …\nA control dependent instruction (e.g. constrain or …\nAny values defined in the loop: block parameters and …\nDetermine whether a block in the loop body is guaranteed …\nStores whether the current loop has known fixed upper and …\nCheck that a loop has have fixed bounds and upper is …\nIndicate whether this loop has fixed bounds that are …\nUpdate any values defined in the loop and loop invariants …\nDetermines if the <code>block</code> is in a nested loop that is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the induction variable bounds if it the current …\nKeep track of a loop induction variable and respective …\nGet and resolve the induction variable of a loop.\nPerform loop invariant code motion and induction variable …\nMaps current loop induction variable with a fixed lower …\nCreate a <code>BlockContext</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether a <code>block</code> is control dependent on a …\nStores whether the current block being processed is …\nChecks whether a <code>block</code> is control dependent on any blocks …\nIndicate that this block is the header of the current loop.\nTracks whether the current block has a side-effectual …\nLoop invariant hoisting only operates over loop …\nIf the inputs are an induction variable and a constant, it …\nIf the inputs are an induction and loop invariant …\nCaches all blocks that belong to nested loops determined …\nCreate a <code>LoopContext</code>:\nIndicates whether the current loop has break or early …\nMaps outer loop induction variable -&gt; fixed lower and …\nMaps a block to its post-dominance frontiers\nSome instructions can take advantage of that our induction …\nSimplify certain instructions using the lower/upper bounds …\nGiven a constant <code>c</code> and an induction variable <code>i</code>:\nReplace ‘assert(invariant != induction)’ with …\nGo through each parameter and register that all reference …\nIn order to handle nested arrays we need to recursively …\nTrack whether a reference has been aliased, and store the …\nAnalyze a block with the given starting reference values.\nThe value of each reference at the start of the given …\nReturns the argument unchanged.\nTrack whether a reference was passed into another …\nLoad and Store instructions that should be removed at the …\nCalls <code>U::from(self)</code>.\nTrack a value’s last load across all blocks. If a value …\nApply the mem2reg pass to the given function.\nCollect the input parameters of the function which are of …\nRemove any instructions in <code>self.instructions_to_remove</code> …\nAdd all instructions in <code>last_stores</code> to …\nA set of possible aliases. Each ValueId in this set …\nReturns <code>Some(true)</code> if <code>f</code> returns true for any known alias …\nReturn the first ValueId in the alias set as long as there …\nReturns the argument unchanged.\nInserts a new alias into this set if it is not unknown\nCalls <code>U::from(self)</code>.\nReturns an iterator over the values in this alias set.\nIn rare cases, such as when creating an empty array of …\nReturns true if calling <code>unify</code> would change something in …\nReturn the single known alias if there is exactly one. …\nUnify this alias set with another. The result of this set …\nA <code>Block</code> acts as a per-block context for the mem2reg pass. …\nAn <code>Expression</code> here is used to represent a canonical key …\nEach expression is tracked as to how many aliases it may …\nCollect all aliases used by the given value list\nMaps a ValueId to the Expression it represents. Multiple …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the given reference id points to a known value, return …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForget the last store to an address, to remove it from the …\nForget the last store to an address and all of its …\nThe last instance of a <code>Store</code> instruction to each address …\nMark a value (for example an address we loaded) as used by …\nEach allocate instruction result (and some reference block …\nRemember that <code>result</code> is the result of dereferencing <code>address</code>…\nIf the given address is known, set its value to <code>value</code>.\nMaps from old ids to new ones. Separate from the rest of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis function is impure and cannot be deduplicated even …\nFunction is completely pure and doesn’t rely on a …\nFunction is mostly pure. As long as the predicate is the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPost-check condition for Ssa::purity_analysis.\nUnifies two purity values, returning the lower common …\nFind each dec_rc instruction and if the most recent inc_rc …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinds and pops the IncRc for the given array value if …\nFind each array_set instruction in the function and mark …\nInsert constraints ensuring that the right-hand side of a …\nReturns the argument unchanged.\nInsert an instruction to extract an element from an array\nInsert a binary instruction at the end of the current …\nInsert a call instruction at the end of the current block …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert a not instruction at the end of the current block. …\nInsert SSA instructions which computes lhs &gt;&gt; rhs by doing …\nInsert a truncate instruction at the end of the current …\nInsert SSA instructions which computes lhs &lt;&lt; rhs by doing …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function\nPost-check condition for Function::remove_bit_shifts.\nComputes 2^exponent via square&amp;multiply, using the bits …\nCheck that the CFG has been flattened.\nMake the size of the new slice equal to old-1.\nMake the size of the new slice equal to old+1.\nMake the size of the new slice equal to the old array.\nMake sure the slice capacity is recorded.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the tracked size of array/slices, or retrieve (and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nProcess each instruction in the entry block of the (fully …\nPost-check condition for Function::remove_if_else.\nSet the capacity of the new slice based on the capacity of …\nFind the change to a slice’s capacity an instruction …\nKeeps track of each size a slice is known to be.\nIdentifies all reachable function IDs within the provided …\nPost-check condition for Ssa::remove_unreachable_functions.\nIdentifies all reachable function IDs within a given …\nBy default instructions are reachable.\nWe encountered an instruction that always fails.\nWe encountered an instruction that fails, but only under a …\nIf a binary operation is guaranteed to fail, returns the …\nReturns the argument unchanged.\nInsert a <code>constrain 0 == &lt;predicate&gt;, &quot;&lt;msg&gt;&quot;</code> instruction.\nCalls <code>U::from(self)</code>.\nRemove the current instruction and replace it with default …\nCheck if an instruction should be replaced with default …\nReturns the argument unchanged.\nCheck if the instruction has changed relative to its …\nInstructs this context to insert the current instruction …\nInserts an instruction in the current block right away.\nInserts an instruction by id in the current block right …\nReturns the current instruction being visited.\nCalls <code>U::from(self)</code>.\nInstructs this context to remove the current instruction …\nReplaces the current instruction with another one.\nInstructs this context to replace a value with another …\nOptimize a jmpif into a jmp if the condition is known\nAttempts to simplify a <code>jmpif</code> terminator if both branches …\nOptimize a jmp to a block which immediately jmps elsewhere …\nOptimize a jmpif on a negated condition by swapping the …\nIf the given block has block parameters, replace them with …\nFollow a chain of empty blocks to find the real …\nA helper function to simplify the current block based on …\nTry to inline a block into its predecessor, returning true …\nAll the instructions in the following example are …\nDescribe the blocks that constitute up a loop.\nThe context object for each loop iteration. Notably each …\nAll the unrolled loops in the SSA.\nNumber of instructions in the loop, including boilerplate, …\nThe start of the back_edge n -&gt; d is the block n at the …\nInstruction count if we leave the loop as-is. It’s the …\nMaps pre-unrolled block ids from within the loop to new …\nAll the blocks contained within the loop, including <code>header</code> …\nCollect boilerplate stats if we can figure out the upper …\nThe CFG so we can query the predecessors of blocks when …\nCount the number of instructions in the loop, including …\nCount the number of increments to the induction variable. …\nCount the number of load and store instructions of …\nFind all loops in the program by finding a node that …\nReturn each block that is in a loop starting in the given …\nFind all reference values which were allocated before the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the lower and upper bounds of the loop if both are …\nFind the lower bound of the loop in the pre-header and …\nFind the upper bound of the loop in the loop header and …\nReturn the induction value of the current iteration of the …\nFind the value that controls whether to perform a loop …\nTranslate a block id to a block id in the unrolled loop.\nFind the original ID of a block that replaced it.\nThe loop pre-header is the block that comes before the …\nFind the next branch(es) to take from a jmpif terminator …\nCheck that the loop does not end with a constant value …\nCheck if the loop header has a constant zero jump …\nIndicate whether the comparison with the upper bound has …\nThe header block of a loop is the block which dominates …\nNumber of increments to the induction variable (might be …\nThe induction value (and the block it was found in) is the …\nCopy over instructions from the source into the insert …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the loop will be fully executed, that is, there …\nDecide if the new bytecode size is acceptable, compared to …\nA small loop is where if we unroll it into the pre-header …\nDecide if this loop is small enough that it can be inlined …\nNumber of iterations in the loop.\nNumber of loads  pre-header references in the loop.\nMaps unrolled block ids back to the original source block …\nUnrolling leaves some duplicate instructions which can …\nNumber of stores into pre-header references in the loop.\nUnroll a single loop in the function. Returns Ok(()) if it …\nUnrolls the header block of the loop. This is the block …\nUnroll a single block in the current iteration of the loop.\nUnroll a single iteration of the loop.\nEstimated number of instructions if we unroll the loop.\nEstimated number of <em>useful</em> instructions, which is the ones …\nLoops that haven’t been unrolled yet, which is all the …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses <code>&amp;mut Type</code>, returns <code>Some(Type)</code> if <code>&amp;mut</code> was found, …\nParses <code>&amp;mut Type</code>, returns <code>Type</code> if <code>&amp;mut</code> was found, errors …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps block names to their IDs\nComputes the order in which blocks should be translated. …\nReturns the argument unchanged.\nMaps internal function names (e.g. “f1”) to their IDs\nThe types of globals in the parsed SSA, in the order they …\nMaps names (e.g. “g0”) in the parsed SSA to global IDs.\nThe function that will hold the actual SSA globals.\nCalls <code>U::from(self)</code>.\nIf any array instruction has an offset, mark the DFG as …\nMaps variable names to their IDs.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&amp;\n-&gt;\n=\n:\n,\n==\n{\n[\n(\n!=\n}\n]\n)\n;\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the entire SSA representation of the program.\nFinds the last instruction that writes to an array and …\nA simple SSA pass to find any calls to <code>Intrinsic::AsSlice</code> …\nSee <code>brillig_array_get_and_set</code> module for more information.\nDetect Brillig calls left unconstrained with manual asserts\nThis function provides an SSA pass that detects if the …\nSee <code>check_u128_mul_overflow</code> module for more information.\nSee <code>checked_to_unchecked</code> module for more information.\nPerforms Dead Instruction Elimination (DIE) to remove any …\nSanity check on the final SSA, panicking if the …\nThe elimination of certain unused instructions assumes …\nSee <code>defunctionalize</code> module for more information.\nMaps SSA entry point function ID -&gt; Final generated ACIR …\nSee <code>evaluate_static_assert_and_assert_constant</code> module for …\nExpands signed arithmetic operations to include explicit …\nExpands signed “less than”, “div” and “mod” …\nThis pass flatten simple IF-THEN-ELSE statements This …\nFlattens the control flow graph of main such that the …\nPerforms constant folding on each instruction.\nPerforms constant folding on each instruction.\nPerforms constant folding on each instruction while also …\nReturns the argument unchanged.\nCreates an Ssa object from the given string.\nCreates an Ssa object from the given string without …\nCreates an Ssa object from the given string but trying to …\nGenerates SSA for the given monomorphized program.\nInline all functions within the IR.\nRun the inlining pass where functions marked with …\nSee the <code>inline_simple_functions</code> module for more …\nInline functions repeatedly until no new functions are …\nCalls <code>U::from(self)</code>.\nSee <code>loop_invariant</code> module for more information.\nReplaces <code>Instruction::Constrain</code> asserting two values are …\nAttempts to remove any load instructions that recover …\nThis is a debugging pass which re-inserts each instruction …\nRun pre-processing steps on functions in isolation.\nSee <code>prune_dead_parameters</code> module for more information.\nAnalyze the purity of each function and tag each function …\nGo through every ACIR function replacing bit shifts with …\nSee <code>remove_enable_side_effects</code> module for more information.\nReplaces all <code>Instruction::IfElse</code> instructions with the …\nThis pass removes <code>inc_rc</code> and <code>dec_rc</code> instructions as long …\nThis SSA pass removes <code>truncate</code> instructions that happen on …\nSee <code>remove_unreachable</code> module for more information.\nHelper to rewrite Call instructions targeting functions …\nSee <code>simplify_cfg</code> module for more information\nCompile Brillig functions and ACIR functions reachable …\nLoop unrolling can return errors, since ACIR functions …\nVerifies there are no <code>array_get</code> or <code>array_set</code> instructions …\nThe FunctionContext is the main context object for …\nThe queue of functions remaining to compile\nUsed to remember the results of each step of extracting a …\nShared context for all functions during ssa codegen. This …\nAdds a “single” parameter to scope.\nAdd each parameter to the current scope, and return the …\nGiven an lhs containing only references, create a store …\nAssigns a new value to the given LValue. The LValue can be …\nBind the given variable ids to each argument of the given …\nInsert a numeric constant into the current function\nPrepare an array or slice access. Check that the index …\nCodegen an array by allocating enough space for each …\nThe bool aspect of each array element indicates whether …\nThis is broken off from codegen_index so that it can also …\nGenerate SSA for a function call. Note that calls to …\nEvaluate the given expression, increment the reference …\nEvaluate the given expression, decrement the reference …\nCodegens a for loop, creating three new blocks in the …\nCodegen a function’s body and set its return value to …\nCodegen an identifier, automatically loading its value if …\nCodegen a reference to an ident. The only difference …\nCodegens an if expression, handling the case of what to do …\nGenerate SSA for the given variable. If the variable is …\nCodegens a loop, creating two new blocks in the process. …\nCodegen any non-tuple expression so that we can unwrap the …\nCodegens a while loop, creating three new blocks in the …\nConverts a non-tuple type into an SSA type. Panics if a …\nConverts the given operator to the appropriate BinaryOp. …\nConvert a monomorphized type to an SSA type, preserving …\nDefine a local variable to be some Values that can later …\nExtracts the tag value from an enum. Assumes enums are …\nExtracts the current value out of an LValue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nShared counter used to assign the ID of the next function\nQueue of which functions still need to be compiled.\nAll currently known functions which have already been …\nExtract the given field of the tuple. Panics if the given …\nExtract the given field of the tuple by reference. Panics …\nRetrieves the given function, adding it to the function …\nReturn the matching id for the given function if known. If …\nA pseudo function that represents global values. Globals …\nCompile the given identifier as a reference - ie. avoid …\nCompile the given <code>array[index]</code> expression as a reference. …\nInsert a binary instruction at the end of the current …\nInserts a call instruction at the end of the current block …\nInserts a cast instruction at the end of the current block …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up the value of a given local variable. Expects the …\nThe loop index will be <code>Some</code> for a <code>for</code> and <code>None</code> for a <code>loop</code>\nContains any loops we’re currently in the middle of …\nArray indexes are u32. This function casts values used as …\nCreate a const offset of an address for an array load or …\nMaps the given type to a Tree of the result type.\nCreate a new FunctionContext to compile the first function …\nCreate a new SharedContext for the given monomorphized …\nFinish building the current function and switch to …\nAllocate a single slot of memory and store into it the …\nTrue if the given operator cannot be encoded directly and …\nTrue if the given operator cannot be encoded directly and …\nPops the next function from the shared function queue, …\nThe entire monomorphized source program\nReplace the given field of the tuple with a new one. …\nDuring casting signed values, if target size is bigger, we …\nIf the condition is known, skip codegen for the then/else …\nReturns the unit value, represented as an empty tree of …\nContains the entire SSA representation of the program.\nAdds a new function to the program\nMaps SSA entry point function ID -&gt; Final generated ACIR …\nReturns the entry-point function of the program\nCreate a new Ssa object from the given SSA functions. The …\nA mutable variable that must be loaded as the given type …\nA general Tree structure which is used in the SSA …\nA single value in ssa form. This wrapper enum is needed …\nA tree of values.\nReturns the total amount of leaves in this tree\nReturns an empty tree node represented by a Branch with no …\nEvaluate a value, returning an IrValue from it. This has …\nEvaluates the value, returning a reference to the mutable …\nFlattens the tree into a vector of each leaf value\nIterates over each Leaf node, calling f on each value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps this Tree into the value of the leaf node. Panics …\nFlattens and evaluates this <code>Tree&lt;Value&gt;</code> into a list of ir …\nCalls the given function on each leaf node, mapping this …\nMap two trees alongside each other. This asserts each tree …\nReturns the size of the type in terms of the number of …\nAside the function being validated, the validator …\nValidates that acir functions are not called from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nValidates that the instruction has the expected types …\nEnforces that every cast from Field -&gt; unsigned/signed …\nValidates that the Function is well formed.\nCheck if an value is a numeric constant, or a result of an …\nA wrapper around <code>VecDeque</code> to ensure that we never process …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA priority queue that serves the next item with the lowest …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")