searchState.loadedDescShard("noirc_evaluator", 0, "The <code>acir</code> module contains all the logic necessary for noirc…\nCompare the textural representation of the SSA after …\nThe <code>brillig</code> module contains all logic necessary for noirc…\nNoir Evaluator has two types of errors\nSSA stands for Single Static Assignment The IR presented …\nContext struct for the acir generation pass. May be …\nThe output of the Acir-gen pass, which should only be …\nThe <code>acir_context</code> module acts as a high-level wrapper …\nManages and builds the <code>AcirVar</code>s to which the converted SSA …\nCreates an <code>AcirVar</code> corresponding to a parameter witness to …\nGenerates a read opcode for the array …\nIf <code>mutate_array</code> is:\nConstruct a value with all zero values, which we can use …\nCorrespondence between an opcode index and the error …\nGet the BlockId corresponding to the ValueId If there is …\nMaps SSA function index -&gt; Final generated Brillig …\nBrillig function id -&gt; Opcodes locations map This map is …\nOptions affecting Brillig code generation.\nBrillig function id -&gt; Brillig procedure locations map …\nKeeps track of Brillig std lib calls per function that …\nMaps the opcode index to a Brillig std library function …\nMaps a Brillig std lib function (a handwritten primitive …\nSource code location of the current instruction being …\nAdds a range check against the bit size of the result of …\nWe need to properly setup the inputs for array operations …\nProcesses a binary operation and converts the result into …\nAdds and binds <code>AcirVar</code>s for each numeric block parameter …\nConverts an SSA instruction into its ACIR representation\nReturns a vector of <code>AcirVar</code>s constrained to be result of …\nConverts an SSA terminator’s return values into their …\nReturns an <code>AcirVar</code>that is constrained to be result of the …\nGets the cached <code>AcirVar</code> that was converted from the …\nRecursive helper for convert_vars_to_values. If the given …\nConvert a <code>Vec&lt;AcirVar&gt;</code> into a <code>Vec&lt;AcirValue&gt;</code> using the …\nThe <code>AcirVar</code> that describes the condition belonging to the …\nThe next witness index that may be declared. If witness …\nRemember the result of an instruction returning a single …\nRemember the result of instruction returning a single …\nCorrespondence between error selectors and types …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFinal list of Brillig functions which will be part of the …\nReturns the acir value at the provided databus offset\nConverts an SSA terminator’s return values into their …\nHandles an ArrayGet or ArraySet instruction. To set an …\nHandle constant index: if there is no predicate and we …\nInitializes an array with the given values and caches the …\nTrack initialized acir dynamic arrays\nAll witness indices which are inputs to the main function\nInsert a newly generated Brillig stdlib function\nGet the next BlockId for internal memory used during ACIR …\nMaps an internal memory block to its length\nMaps SSA values to a BlockId used internally A BlockId is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of the next BlockId, it is used to construct a new …\nMaps SSA values to BlockId A BlockId is an ACIR structure …\nName for the corresponding entry point represented by this …\nThe opcodes of which the compiled ACIR will comprise.\nAll witness indices that comprise the final return value …\nContains state that is generated and also used across ACIR …\nMaps SSA values to <code>AcirVar</code>.\nOperands in a binary operation are checked to have the …\nContext object which holds the relationship between …\nEnum representing the possible values that a Variable can …\nAn in-memory representation of ACIR.\nAdds a constant to the context and assigns a Variable to …\nAdds <code>Data</code> into the context and assigns it a Variable.\nAdds a new Variable to context whose value will be …\nAdds a new Variable to context whose value will be …\nAdds a Variable to the context, whose exact value is …\nEcAdd has 6 inputs representing the two points to add Each …\nReturns an <code>AcirVar</code> that is the AND result of <code>lhs</code> &amp; <code>rhs</code>.\nReturns a FieldElement, if the underlying <code>AcirVarData</code> …\nConstrains the <code>lhs</code> and <code>rhs</code> to be equal.\nConstrains the <code>lhs</code> and <code>rhs</code> to be non-equal.\nThe BigIntContext, used to generate identifiers for …\nReturns <code>AcirVar</code>s constrained to be the bit decomposition …\nCalls a Blackbox function on the given inputs and returns …\nGenerate constraints that are satisfied iff lhs &lt; rhs , …\nRecursively create acir values for returned arrays. This …\nRecursively create <code>AcirValue</code>s for returned arrays. This is …\nReturns the constant represented by the given variable.\nAdds a new Variable to context whose value will be …\nReturns an <code>AcirVar</code> that is <code>1</code> if <code>lhs</code> equals <code>rhs</code> and 0 …\nReturns the quotient and remainder such that lhs = rhs * …\nTerminates the context and takes the resulting …\nChecks if this expression can fit into one arithmetic …\nRecursive helper to flatten a single AcirValue into the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe <code>generated_acir</code> module is responsible for the lowest …\nReturns Some(String) if the assertion message is present …\nInitializes an array in memory with the given values …\nInsert the MemoryInit for the Return Data array, using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds a new Variable to context whose value will be …\nTrue if the given AcirVar refers to a constant value\nTrue if the given AcirVar refers to a constant one value\nReturns an ‘AcirVar’ containing the boolean value lhs&lt;…\nReturns an <code>AcirVar</code> which will be <code>1</code> if lhs &lt; rhs and <code>0</code> …\nReturns a variable which is constrained to be <code>lhs mod rhs</code>\nReturns an <code>AcirVar</code> which will be <code>1</code> if lhs &gt;= rhs and <code>0</code> …\nAdds a new Variable to context whose value will be …\nAdds a new Variable to context whose value will be …\nAdds a new variable that is constrained to be the logical …\nReturns an <code>AcirVar</code> that is the OR result of <code>lhs</code> &amp; <code>rhs</code>.\nReturns an <code>F</code> representing the value <code>2**power</code>\nBlack box function calls expect their inputs to be in a …\nReturns a vector of <code>AcirVar</code>s constrained to be the …\nConstrains the <code>AcirVar</code> variable to be of type <code>NumericType</code>.\nReturns a Variable that is constrained to be the result of …\nReturns the quotient and remainder such that lhs = rhs * …\nGenerates a brillig call to a handwritten section of …\nAdds a new Variable to context whose value will be …\nConverts all enum variants to an Expression.\nReturns an <code>AcirVar</code> which will be constrained to be lhs mod …\nConverts an <code>AcirVar</code> to an <code>Expression</code>\nConverts an <code>AcirVar</code> to a <code>Witness</code>\nConstrains the Variable <code>value</code> to be the new value located …\nReturns an <code>AcirVar</code> that is the XOR result of <code>lhs</code> &amp; <code>rhs</code>.\nRecursively create zeroed-out acir values for returned …\nBigIntContext is used to generate identifiers for big …\nRepresents a bigint value in the form (id, modulus) where …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the BigIntId corresponding to the given identifier\nAdds a modulus to the context (if it is not already …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the modulus corresponding to the given modulus …\nCreates a new BigIntId for the given modulus identifier …\nAttempts to execute the provided <code>Brillig</code> bytecode\nThe output of the Acir-gen pass, which should only be …\nCorrespondence between an opcode index (in opcodes) and …\nAsserts <code>expr</code> to be zero.\nCorrespondence between an opcode index and the error …\nThis function will return the number of outputs that a …\nThis function will return the number of inputs that a …\nAdds an inversion brillig opcode.\nBrillig function id -&gt; Opcodes locations map This map is …\nBrillig function id -&gt; Brillig procedure locations map …\nMaps the opcode index to a Brillig std library function …\nAdds brillig opcode for to_radix\nCalls a black box function and returns the output of said …\nSource code location of the current instruction being …\nCreates a new <code>Witness</code> which is constrained to be equal to …\nReturns the current witness index.\nThe next witness index that may be declared. If witness …\nCorrespondence between error selectors and types …\nConverts <code>Expression</code> <code>expr</code> into a <code>Witness</code>.\nAll witness indices which are inputs to the main function\nChecks that the number of inputs being used to call the …\nChecks that the number of outputs being used to call the …\nReturns a <code>Witness</code> that is constrained to be:\nReturns a <code>Witness</code> that is constrained to be:\nName for the corresponding entry point represented by this …\nUpdates the witness index counter and returns the next …\nThe opcodes of which the compiled ACIR will comprise.\nAdds a new opcode into ACIR.\nTakes an input expression and returns witnesses that are …\nAdds a constraint which ensure thats <code>witness</code> is an integer …\nAll witness indices that comprise the final return value …\nBrillig calls such as for the Brillig std lib are resolved …\nGenerates brillig bytecode which computes the inverse of …\nGenerates brillig bytecode which computes <code>a / b</code> and …\nGenerates brillig bytecode which performs a radix-base …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the array’s elements have a constant …\nHigh level Type descriptor for Variables.\nA Reference to an <code>AcirVarData</code>\nReturns the bit size of the underlying type\nIdentification for the Acir dynamic array This is …\nIdentification for the ACIR dynamic array inner element …\nReturns a field type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the array\nReturns an unsigned type of the specified bit size\nAn ACIR dynamic array is a flat structure, so we use the …\nContext structure for the brillig pass. It stores …\nOptions that affect Brillig code generation.\nProcedures are a set of complex operations that are common …\nThe code generation logic for converting crate::ssa …\nThis module is an abstraction layer over <code>Brillig</code>. To allow …\nCompiles a function into brillig and store the compilation …\nConverting an SSA function into Brillig bytecode.\nFinds a brillig artifact by its label\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps SSA function labels to their brillig artifact\nCodegen for native (black box) function calls.\nModule containing Brillig-gen logic specific to an SSA …\nThis module handles allocation, tracking, and lifetime …\nModule containing Brillig-gen logic specific to SSA …\nCodegen for converting SSA globals to Brillig bytecode.\nCodegen for converting SSA slice intrinsic functions to …\nThis module analyzes the usage of constants in a given …\nGenerates a complete Brillig entry point artifact for a …\nThis module analyzes the liveness of variables …\nConverts a Brillig array or vector into a heap-allocated …\nTransforms SSA’s black box function calls into the …\nContext structure for compiling a function block into …\nOverflow checks for the following unsigned binary …\nAllocates a variable to hold the result of an external …\nRecursively allocates memory for a nested array returned …\nDebug utility method to determine whether an array’s …\nThe basic block that is being converted\nContext for creating brillig opcodes\nStatus variable for whether we are generating Brillig …\nConverts an SSA Basic block into a sequence of Brillig …\nConverts SSA globals into Brillig global values.\nInternal method for BrilligBlock::compile that actually …\nAllocates the block parameters that the given block is …\nConverts an SSA cast to a sequence of Brillig opcodes. …\nLoad from an array variable at a specific index into a …\nGets the “user-facing” length of an array. An array of …\nArray set operation in SSA returns a new array or vector …\nConverts the Binary instruction into a sequence of Brillig …\nInternal method to codegen an Instruction::Call to a …\nCopy the input arguments to the results.\nConverts an SSA instruction into a sequence of Brillig …\nConverts an SSA <code>ValueId</code> into a <code>MemoryAddress</code>. Initializes …\nConvert the SSA slice operations to brillig slice …\nConverts an SSA terminator instruction into the necessary …\nConverts an SSA ValueId into a BrilligVariable. …\nCreates a unique label for a block using the function Id …\nCreates a unique global label for a block.\nReturns the argument unchanged.\nPer-function context shared across all of a function’s …\nIf the supplied value is a numeric constant check whether …\nMapping of SSA ValueIds to their already instantiated …\nPre-instantiated constants values shared across functions …\nInitializes a constant array in Brillig memory.\nCodegens Brillig instructions to initialize a constant …\nCodegens Brillig instructions to initialize a large, …\nAccepts a list of constant values to be initialized\nCalls <code>U::from(self)</code>.\nFor each instruction, the set of values that are not used …\nReturns the type of the operation considering the types of …\nSlices have a tuple structure (slice length, slice …\nTracks the available variable during the codegen of the …\nTracks SSA variables that are live and usable during …\nFor a given value_id, allocates the necessary registers to …\nFor a given value_id, allocates the necessary registers to …\nComputes the length of an array. This will match with the …\nDefines a variable that fits in a single register and …\nFor a given SSA value id, define the variable and return …\nReturns the argument unchanged.\nFor a given SSA value id, return the corresponding cached …\nReturns all variables that have not been removed at this …\nCalls <code>U::from(self)</code>.\nChecks if a variable is allocated.\nCreates a BlockVariables instance. It uses the variables …\nRemoves a variable so it’s not used anymore within this …\nInformation required to compile an SSA Function into …\nThe block ids of the function in reverse post order.\nInformation on where to allocate constants\nReturns the argument unchanged.\nA <code>FunctionContext</code> is necessary for using a Brillig block’…\nCalls <code>U::from(self)</code>.\nTrue if this function is a brillig entry point\nLiveness information for each variable in the function.\nCreates a new function context. It will allocate …\nCollects the return values of a given function\nConverts an SSA Type into a corresponding BrilligParameter.\nMap from SSA values its allocation. Since values can be …\nContext structure for generating Brillig globals it stores …\nA globals artifact containing all information necessary …\nMapping of a constant value and the number of functions in …\nMapping of constant values shared across functions hoisted …\nMapping of SSA value ids to their Brillig allocations\nMaps a Brillig entry point to all functions called in that …\nFinal map that associated an entry point with its Brillig …\nFinal map that associates an entry point with any local …\nReturns the argument unchanged.\nFetch the global allocations that can possibly be accessed …\nFetch the global allocations for a given entry point. This …\nMaps a Brillig entry point to constants shared across the …\nMaps an inner call to its Brillig entry point This is …\nCalls <code>U::from(self)</code>.\nHelper for marking that a constant was instantiated in a …\nBoth <code>used_globals</code> and <code>brillig_entry_points</code> need to be built\nReturns the nearest dominator that is outside of any loop.\nFor a given function, finds all the blocks that are within …\nReturn each block that is in a loop starting in the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA back edge is an edge from a node to one of its …\nA struct representing the liveness of variables throughout …\nCollects the underlying variables inside a value id. It …\nRetrieves the list of block params the given block is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the liveness of variables throughout a function.\nA map of instruction id to the set of values that die …\nThe set of values that are alive before the block starts …\nThe set of values that are alive after the block has …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe variables that stop being alive after each specific …\nThe variables that are alive before the block starts …\nThe list of block params the given block is defining. The …\nThe Brillig VM does not apply a limit to the memory …\nBrillig context object that is used while constructing the …\nThis register stores the free memory pointer. Allocations …\nThe number of reserved registers. These are allocated in …\nThis register stores the stack pointer. All relative …\nThis register stores a 1_usize constant.\nSplits a two’s complement signed integer in the sign bit …\nAdds a unresolved external <code>Call</code> instruction to the …\nAdds a unresolved <code>Jump</code> to the bytecode.\nAllocates an unused register.\nReturns the address of the implicit debug variable …\nReturns the artifact\nProcesses a binary instruction according <code>operation</code>.\nIssues a blackbox operation.\nConditionally copies a source array to a destination array.\nIt prepares a vector for a insert operation, leaving a …\nPrepares a vector for a push operation, allocating a …\nReverts with the error selector of the given string This …\nConditionally copies a source array to a destination array.\nPops items from the back of a vector, returning the new …\nPops items from the front of a vector, returning the new …\nRemoves items from the vector, returning the new vector.\nWhether this context can call procedures or not. This is …\nCast truncates the value to the given bit size and …\nAllocates an array of size <code>size</code> and stores the pointer to …\nAllocates an array of size contained in size_register and …\nThis instruction will reverse the order of the <code>size</code> …\nThis codegen will issue an if-then branch that will check …\nConverts a BrilligArray (pointer to <code>[RC, ...items]</code>) to a …\nEmits brillig bytecode to jump to a trap condition if …\nEmits brillig bytecode to jump to a trap condition if …\nAdds the instructions needed to handle entry point …\nAdds the instructions needed to handle return parameters …\nThis codegen will issue a loop for (let iterator_register …\nThis codegen issues a branch that jumps over the code …\nThis codegen issues a branch that jumps over the code …\nInitializes an array, allocating memory to store its …\nInitializes a vector, allocating memory to store its …\nWrites vector metadata (reference count, size, and …\nGets the value stored at base_ptr + index and stores it in …\nThis codegen will issue a loop that will iterate from 0 to …\nReturns a pointer to the items of a given array\nReturns a variable holding the capacity of a given vector\nReturns a pointer to the items of a given vector\nReturns a variable holding the length of a given vector\nCopies the values of memory pointed by source with length …\nCopies num_elements_variable from the source pointer to …\nThis function moves values from a set of registers to …\nReads the metadata of a vector and stores it in the given …\nCodegens a return from the current function.\nStores value at base_ptr + index\nIssues a to_radix instruction. This instruction will write …\nCodegens a truncation of a value to the given bit size\nUtility method to perform a binary instruction with a …\nUtility method to perform a binary instruction with a …\nWrites a pointer to the items of a given vector\nInternal function used to compute the section labels\nInsert a conditional move instruction\nStores the value of <code>constant</code> in the <code>result</code> register\nContext label, must be unique with respect to the function …\nCount the number of arrays that are copied, and output …\nSection label, used to separate sections of code\nReturns the current section label\nPush a register to the deallocation list, ready for reuse.\nDeallocates the address where the single address variable …\nThis module contains functions for producing a higher …\nIR printer\nDeflatten an array by recursively allocating nested arrays …\nemit: <code>println(f&quot;Total arrays copied: {array_copy_counter}&quot;)</code>\nEnable the insertion of bytecode with extra assertions …\nInsert extra assertions that we expect to be true, at the …\nAdds a label to the next opcode\nEnter the given section within a basic block\nComputes the size of a parameter if it was flattened\nComputes the size of a parameter if it was flattened\nProcesses a foreign call instruction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes the size of a parameter if it was flattened\nStores the value of <code>constant</code> in the result_pointer\nWe don’t know the length of a vector returned externally …\nInitialize the reference counter for an array or vector. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdds a unresolved <code>JumpIf</code> instruction to the bytecode.\nAdds a unresolved <code>Jump</code> instruction to the bytecode.\nReturns the length of the reserved registers\nEmits a load instruction\nReturns a register which holds the value of a constant\nReturns a register which holds the value of an usize …\nUtility method to perform a binary instruction with a …\nComputes left % right by emitting the necessary Brillig …\nEmits a <code>mov</code> instruction.\nCreates an entry point artifact that will jump to the …\nStores the next available section\nProcesses a not instruction.\nAdds a brillig instruction to the brillig byte code\nTracks register allocations\nCreate, reserve, and return a new section label.\nEmits a return instruction\nSets a current call stack that the next pushed opcodes …\nSet the globals memory size if it is not already set. If …\nEmits a stop instruction with return data\nEmits a store instruction\nAn array parameter or return value. Holds the type of an …\nArtifacts resulting from the compilation of a function …\nRepresents a parameter or a return value of an entry point …\nLabels for the entry point bytecode\nLabels for user defined functions\nThe result of compiling and linking brillig artifacts. …\nLabel for initialization of globals Stores a function ID …\nPointer to a unresolved Jump instruction in the bytecode.\nAn identifier for a location in the code.\nA pointer to a location in the opcode.\nLabels for intrinsic procedures\nA single address parameter or return value. Holds the bit …\nA slice parameter or return value. Holds the type of a …\nWhen constructing the bytecode, there may be instructions …\nAdds a label in the bytecode to specify where this block’…\nAdds a unresolved external call that will be fixed once …\nAdds a unresolved jump to be fixed at the end of bytecode …\nAdds unresolved jumps &amp; function calls from another …\nThe current call stack. All opcodes that are pushed will …\nResolves all jumps and generates the final bytecode\nGets the first unresolved function call of this artifact.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the index of the next opcode.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the opcode is a jump instruction\nA map of labels to their position in byte code.\nLink with an external brillig artifact called from this …\nMaps the opcodes that are associated with a callstack to …\nName of the function, only used for debugging purposes.\nThis field contains the given procedure id if this …\nProcedure ID mapped to the range of its opcode locations …\nAdds a brillig instruction to the brillig byte code\nResolves all of the unresolved jumps in the program.\nSet of labels which are external to the bytecode.\nThe set of jumps that need to have their locations …\nThe representation of a noir array in the Brillig IR\nThe representation of a noir value in the Brillig IR\nThe representation of a noir slice in the Brillig IR\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for converting values into debug-friendly strings.\nDebug function for cast_instruction\nProcesses a binary instruction according <code>operation</code>.\nDebug function for black_box_op\nDebug function for calldata_copy\nEmits a <code>cast</code> instruction.\nEmits a <code>conditional mov</code> instruction.\nStores the value of <code>constant</code> in the <code>result</code> register\nDebug function for enter_context\nProcesses a foreign call instruction.\nReturns the argument unchanged.\nStores the value of <code>constant</code> in the <code>result</code> register\nCalls <code>U::from(self)</code>.\nDebug function for jump_if_instruction\nDebug function for jump_instruction\nEmits a load instruction\nEmits a <code>mov</code> instruction.\nProcesses a not instruction. Append with “_” as this …\nEmits a return instruction\nEmits a stop instruction\nEmits a store instruction\nEmits a <code>trap</code> instruction.\nType to encapsulate the binary operation types in Brillig\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nProcedures are a set of complex operations that are common …\nThe message to print when copying an array.\nThe metadata string needed to tell <code>print</code> to print out a u32\nReallocates the target vector for insertion, skipping …\nGlobals have a separate memory space This memory space is …\nProcedure arguments and returns are passed through scratch …\nEvery brillig stack frame/call context has its own view of …\nAllocates a new register.\nPush a register to the deallocation list, ready for reuse.\nA free-list of registers that have been deallocated and …\nFinds the first register that is available based upon the …\nLast valid memory address\nEnsures a register is allocated, allocating it if necessary\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new register context from a set of registers …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA usize indicating the next un-used register.\nFirst valid memory address\nThis case is not an error. It’s used during codegen to …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn SSA pass reified as a construct we can put into a list, …\nOptions affecting Brillig code generation.\nCompiles the <code>Program</code> into <code>ACIR</code>.\nCompiles the <code>Program</code> into <code>ACIR</code> using the minimum amount of …\nCompiles the <code>Program</code> into <code>ACIR</code> by running it through …\nDump the unoptimized SSA to the supplied path if it exists\nEnable the lookback feature of the Brillig call constraints\nWidth of expressions to be used for ACIR\nProviding a file manager is optional - if provided it can …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe higher the value, the more inlined Brillig functions …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum accepted percentage increase in the Brillig …\nFor testing purposes we want a list of the minimum number …\nThis folder contains each optimization pass for the SSA IR.\nOptimize the given program by converting it into SSA form …\nOptimize the given SsaBuilder by converting it into SSA …\nCounters indexed by the message in the SSA pass, so we can …\nThe default SSA optimization pipeline.\nWhether to print the amount of time it took to run …\nPretty print benchmark times of each code generation pass\nThe second SSA pipeline, in which we take the Brillig …\nSkip the missing Brillig call constraints check\nList of SSA pass message fragments that we want to skip, …\nA list of SSA pass messages to skip, for testing purposes.\nSkip the check for under constrained values\nThe SSA being built; it is the input and the output of …\nOptions to control which SSA passes to print.\nEmit debug information for the intermediate SSA IR\nValidator that checks whether a function is well formed.\nContains the error value\nContains the success value\nAn SSA pass reified as a construct we can put into a list, …\nFollow up the pass with another one, without adding a …\nSame as <code>and_then</code> but for passes that can fail.\nProviding a file manager is optional - if provided it can …\nCounters indexed by the message in the SSA pass, so we can …\nWhether to print the amount of time it took to run …\nRuns the given SSA pass and prints the SSA afterward if …\nRun a list of SSA passes.\nList of SSA pass message fragments that we want to skip, …\nThe SSA being built; it is the input and the output of …\nOptions to control which SSA passes to print.\nThe same as <code>run_pass</code> but for passes that may fail\nThis module defines security SSA passes detecting …\nStructure keeping track of value ids descending from …\nBuild the dependency context of variable ValueIds, storing …\nIf Brillig call is properly constrained by the given ids, …\nDetect independent subgraphs (not connected to function …\nCheck if any of the recorded Brillig calls have been …\nEvery Brillig call not properly constrained should remain …\nCompute sets of variable ValueIds that are connected with …\nGo through each instruction in the block and add a set of …\nFind which Brillig calls separate this set from others and …\nFind sets that contain input or output value of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the call being tracked is a simple wrapper of …\nMerge all small sets into larger ones based on whether the …\nParallel version of merge_sets The sets are merged by …\nProcess ArrayGet instruction for tracked Brillig calls\nWhen an ArrayGet instruction occurs, place the resulting …\nGo over the given block tracking Brillig calls and …\nRemember partial constraints (involving some of the …\nUpdate sets of value ids that can be traced back to the …\nAdd children of a given parent to the tainted value set …\nUpdate children of all the results (helper function for …\nThe per-function context for each ssa function being …\nAdds a parameter with the given type to the given block. …\nAdd a parameter to the current function with the given …\nInsert a value into a data bus builder\nReturns the parameters of the given block in the current …\nGenerate the data bus for call-data, based on the …\nReturns the block currently being inserted into\nInsert instructions to decrement the reference count of …\nThis function takes the flattened databus visibilities and …\nConsume the FunctionBuilder returning all the functions it …\nReturns the argument unchanged.\nCreate a function builder with a new function created with …\nReturns a ValueId pointing to the given oracle/foreign …\nReturns a ValueId pointing to the given function or …\nRetrieve a value reference to the given intrinsic …\nRetrieve a value reference to the given intrinsic …\nInsert instructions to increment the reference count of …\nCreate a data bus builder from a list of values\nInsert an allocate instruction at the end of the current …\nInsert an instruction to extract an element from an array\nInsert an instruction to create a new array with the given …\nInsert a binary instruction at the end of the current …\nInsert a new block into the current function and return it.\nInsert a call instruction at the end of the current block …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert an instruction to decrement an array’s reference …\nInsert an enable_side_effects_if instruction. These are …\nInsert an instruction to increment an array’s reference …\nInserts a new instruction at the end of the current block …\nInsert a Load instruction at the end of the current block, …\nInsert a <code>make_array</code> instruction to create a new array or …\nInsert a not instruction at the end of the current block. …\nInsert a <code>Instruction::RangeCheck</code> instruction at the end of …\nInsert a Store instruction at the end of the current …\nInsert a truncate instruction at the end of the current …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function of …\nCreates a new FunctionBuilder to build the function with …\nFinish the current function and create a new unconstrained …\nFinish the current function and create a new ACIR function.\nFinish the current function and create a new function.\nInsert a numeric constant into the current function\nSet the runtime of the initial function that is created …\nWhether instructions are simplified as soon as they are …\nSwitch to inserting instructions in the given block. …\nTerminates the current block with the given terminator …\nTerminate the current block with a jmp instruction to jmp …\nTerminate the current block with a jmpif instruction to …\nTerminate the current block with a return instruction\nTerminate the current block with an unreachable instruction\nReturns the type of the given value.\nIncrement or decrement the given value’s reference count …\nUsed to create a data bus, which is an array of private …\nThe id to this calldata assigned by the user\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a databus from call_data and return_data data …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates a vector telling which flattened parameters from …\nUpdates the databus values with the provided function\nUpdates the databus values in place with the provided …\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nApplies an infallible integer binary operation to two …\nApplies a fallible integer binary operation (e.g., checked …\nPrint is not an intrinsic but it is treated like one.\nContains each function called with <code>main</code> (or the first …\nThe function that was called. This is <code>None</code> only for the …\nDefine or redefine a value. Redefinitions are expected in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint output.\nReset the value’s <code>Shared</code> states in each array within. …\nContains each value currently defined and visible to the …\nThis variable can be modified by <code>enable_side_effects_if</code> …\n(length, slice, index:u32, elem…) -&gt; (length, slice)\n(length, slice) -&gt; (length, slice, elem…)\n(length, slice) -&gt; (elem…, length, slice)\n(length, slice, elem…) -&gt; (length, slice)\n(length, slice, elem…) -&gt; (length, slice)\n(length, slice, index:u32) -&gt; (length, slice, elem…)\nIf true, the interpreter will trace its execution.\nTry to get a function’s name or approximate it if it is …\nThese errors are all the result from malformed input SSA\nThese errors can only result from interpreting malformed …\nThis is not an internal error since the SSA is still …\nFormat the message of a <code>constrain</code> instruction so that we …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a Value to a vector of FieldElement for printing.\nParse a Value as PrintableType.\nParse a value as <code>[u8]</code> and convert to UTF-8 <code>String</code>.\nBe careful when using <code>Clone</code>: <code>ArrayValue</code> and <code>ReferenceValue</code> …\nA value of <code>None</code> here means this allocation is currently …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is included mostly for debugging to distinguish …\nThe <code>Shared</code> type contains its own reference count but we …\nClone the value in a way that modifications to it won’t …\nTake a snapshot of interpreter arguments.\nReturn an uninitialized value of the given type. This is …\nCall graph analysis\nThe dominator tree of a function, represented as a hash …\nThe post-order for a given function represented as a …\nThis file is for pretty-printing the SSA IR in a …\nA Basic block is a maximal collection of instructions such …\nAn identifier for a Basic Block.\nAdds a parameter to this BasicBlock. Expects that the …\nReturns the argument unchanged.\nInsert an instruction at the end of this block\nRetrieve a reference to all instructions in this block.\nInstructions in the basic block.\nRetrieve a mutable reference to all instructions in this …\nCalls <code>U::from(self)</code>.\nCreate a new BasicBlock with the given parameters. …\nReturns the parameters of this block\nParameters to the basic block.\nReplace this block’s current parameters with that of the …\nSets the terminator instruction of this block.\nIterate over all the successors of the currently block, as …\nTake the instructions in this block, replacing it with an …\nRemoves all the parameters of this block\nTake ownership of this block’s terminator, replacing it …\nReturns the terminator of this block.\nThe terminating instruction for the basic block.\nReturn the jmp arguments, if any, of this block’s …\nReturns the terminator of this block, panics if there is …\nReturns a mutable reference to the terminator of this …\nRepresents a function call graph built from the SSA …\nUtility function to find out the deduplicated direct calls …\nUtility function to find out the direct calls of a …\nFetch for each function the set of functions called by it, …\nFetch for each function the set of functions that call it, …\nCompute for each function the set of functions called by …\nReturns the argument unchanged.\nConstruct a CallGraph from an explicit dependency mapping …\nConstruct a CallGraph from the Ssa The edges in this graph …\nConstruct a CallGraph from the Ssa with its edges weighted.\nReturns the set of all recursive functions.\nCalls <code>U::from(self)</code>.\nReturns all functions reachable from the provided root(s).\nCompute the times each function is called from any other …\nA container for the successors and predecessors of some …\nThe Control Flow Graph (CFG) maintains a mapping of blocks …\nAdd a directed edge making <code>from</code> a predecessor of <code>to</code>.\nCompute all of the edges between each reachable block in …\nCompute all of the edges for the current block given\nReturns the entry blocks for a CFG. This is all nodes …\nComputes the reverse graph of the extended CFG. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nClears out a given block’s successors. This also removes …\nGet an iterator over the CFG predecessors to <code>basic_block_id</code>…\nSet of blocks that containing jumps that target this block.\nRecompute the control flow graph of <code>block</code>.\nReverse the control flow graph\nFlag stating whether this CFG has been reversed. In a …\nGet an iterator over the CFG successors to <code>basic_block_id</code>.\nSet of blocks that are the targets of jumps in this block. …\nAllocate and compute the control flow graph for <code>func</code>.\nThe DataFlowGraph contains most of the actual data in a …\nThe GlobalsGraph contains the actual global data. Global …\nResults is the standard case containing the instruction id …\nAdd a parameter to the given block\nGet an iterator over references to each basic block within …\nReturns the parameters of the given block\nAll blocks in a function\nEach constant is unique, attempting to insert the same …\nRetrieve the first (and expected to be the only) result.\nReturn the result types of this instruction.\nContains each foreign function that has been imported into …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nContains each function that has been imported into the …\nReturns the Value::Array associated with this ValueId if …\nSimilar to <code>get_numeric_constant</code> but returns the value as a …\nUses value information to determine whether an instruction …\nReturns the field element represented by this value if it …\nReturns the field element and type represented by this …\nIf this value points to an array of constant bytes, …\nReturns the maximum possible number of bits that <code>value</code> can …\nGets or creates a ValueId for the given FunctionId.\nGets or creates a ValueId for the given FunctionId.\nGets or creates a ValueId for the given Intrinsic.\nGet a mutable reference to a function’s basic block for …\nMoves the entirety of the given block’s contents into …\nSimplifies a new instruction and inserts it at the end of …\nSimplifies a potentially existing instruction and inserts …\nReturns all of result values which are attached to this …\nAll of the instructions in a function\nAll of the instructions in the global value space. These …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains each intrinsic that has been imported into the …\nTrue if the given ValueId refers to a (recursively) …\nTrue that the input is a non-zero <code>Value::NumericConstant</code>\nCheck if the function runtime would simply ignore this …\nA constant index less than the array length is safe\nReturns the amount of ValueIds contained\nSource location of each instruction for debugging and …\nCreates a new basic block with no parameters. After being …\nCreate a new block with the same parameter count and …\nCreates a new constant value, or returns the Id to an …\nInserts a new instruction into the DFG. This does not add …\nAttaches results to the instruction, clearing any previous …\nRemove an instruction by replacing it with a <code>Noop</code> …\nReplaces values in the given block according to the given …\nReplaces values in the given block instructions according …\nReplaces values in the given block terminator (if it has …\nReturn all the results contained in the internal results …\nStores the results for a particular instruction.\nRuntime type of the function.\nRuntime of the function that owns this DataFlowGraph. This …\nSets the terminator instruction for the given basic block\nReplace an existing instruction with a new one.\nSet runtime type of the function.\nSet the type of value_id to the target_type.\nIf this value is an array, return the length of the array …\nReturns the type of a given value\nTrue if the type of this value is Type::Reference. Using …\nStorage for all of the values defined in this function.\nStorage for all of the global values\nIterate over every Value in this DFG in no particular …\nIterate over every Value in this DFG in no particular …\nInstruction could not be simplified\nRemove the instruction, it is unnecessary\nReplace this function’s result with the given value\nReplace this function with an simpler but equivalent …\nReplace this function with a set of simpler but equivalent …\nReplace this function’s results with the given values …\nContains the result to Instruction::simplify, specifying …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTry to simplify this instruction. If the instruction can …\nGiven a chain of operations like: v1 = array_set [10, 11, …\nIf we have an array set whose value is from an array get …\nTry to simplify this binary instruction, returning the new …\nTry to simplify this black box call. If the call can be …\nTry to simplify this call instruction. If the instruction …\nReturns a slice (represented by a tuple (len, slice)) of …\nSlices have a tuple structure (slice length, slice …\nTry to simplify this cast instruction. If the instruction …\nTry to decompose this constrain instruction. This …\nThe dominator tree for a single function.\nDominator tree node. We keep one of these per reachable …\nSubsequent calls to <code>dominates</code> are cached to speed up access\nCompute the common dominator of two basic blocks.\nComputes the dominance frontier for all blocks in the …\nBuild a dominator tree from a control flow graph using …\nReturns <code>true</code> if <code>block_a_id</code> dominates <code>block_b_id</code>.\nWalk up the dominator tree until we find a block for which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block_id</code>.\nThe block that immediately dominated that of the node in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block_id</code> reachable from the entry block?\nThe nodes of the dominator tree\nCompare two blocks relative to the reverse post-order.\nThe block’s idx in the control flow graph’s reverse …\nUpdates the immediate dominator estimate, returning true …\nAllocate and compute a dominator tree from a pre-computed …\nAllocate and compute a dominator tree for the given …\nA function holds a list of instructions. These …\nFunctionId is a reference for a function\nTakes the signature (function name &amp; runtime) from a …\nCreates a new function as a clone of the one passed in …\nThe structure of this pass is simple: Go through each …\nIterate over the numeric constants in the function.\nRemoves any unused instructions in the reachable blocks of …\nThe DataFlowGraph holds the majority of data pertaining to …\nRetrieves the entry block of a function.\nThe first basic block in the function\nThe structure of this pass is simple: Go through each …\nFinds the block of the function with the Return instruction\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIterate over every Value in this DFG in no particular …\nThe id of the function.\nCreate a new function which has the functions called by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the runtime type represents an entry point.\nThe name of the function. Used exclusively for debugging …\nName of the function for debugging only\nCreates a new function with an automatically inserted …\nGlobals are generated using the same codegen process as …\nReturns the parameters of this function. The parameters …\nSee <code>prune_dead_parameters</code> module for more information\nCollects all the reachable blocks of this function.\nThe structure of this pass is simple: Go through each …\nThis function is very simplistic for now. It takes …\nReturns the return types of this function. None might be …\nRuntime type of the function.\nSet runtime type of the function.\nPerforms a simple optimization according to the given …\nPerforms a simple optimization according to the given …\nSimplify a function’s cfg by going through each block to …\nTry to unroll loops in the function.\nThe FunctionInserter can be used to help modify existing …\nMerge the internal mapping into the given mapping The …\nReturns the argument unchanged.\nModify the values HashMap to remember the mapping between …\nCalls <code>U::from(self)</code>.\nMaps the data bus in place, replacing any ValueId in the …\nGet an instruction and make sure all the values in it are …\nGet an instruction, map all its values, and replace it …\nMaps a terminator in place, replacing any ValueId in the …\nInsert a key, value pair in the map\nPush a new instruction to the given block and return its …\nResolves a ValueId to its new, updated value. If there is …\nInsert a key, value pair if the key isn’t already …\nAllocates a region of memory. Note that this is not …\nRetrieve a value from an array at the given index <code>offset</code> …\nDetermines whether an ArrayGet or ArraySet index has been …\nCreates a new array with the new value at the given index. …\nBinary Operations like +, -, *, /, ==, !=\nHint to the compiler to treat the call as having potential …\nPerforms a function call with a list of its arguments.\nConverts <code>Value</code> into the given <code>NumericType</code>\nConstrains two values to be equal to one another.\nConstrains two values to not be equal to one another.\nAn instruction to decrement the reference count of a value.\nProvides a context for all instructions that follow up …\nThe endian-ness of bits when encoding values as bits in …\nCompiler hints.\nMerge two values returned from opposite branches of a …\nAn instruction to increment the reference count of a value.\nInstructions are used to perform tasks. The instructions …\nReference to an instruction\nThe possible return values for Instruction::return_types\nThese are similar to built-ins in other languages. These …\nUnconditional Jump\nControl flow\nThe result type of this instruction is known to be this …\nLoads a value from memory.\nCreates a new array or slice.\nThis instruction does not return any results.\nA No-op instruction. These are intended to replace other …\nComputes a bit wise not\nThe result type of this instruction matches that of this …\nRange constrain <code>value</code> to <code>max_bit_size</code>\nReturn from the current function with the given return …\nWrites a value to memory.\nThese are operations which can exit a basic block ie …\nTruncates <code>value</code> to <code>bit_size</code>\nThe result type of this function is unknown and separate …\nA terminator that will never be reached because an …\nReturns a binary instruction with the given operator, lhs, …\nApplies a function to each input value this instruction …\nApply a function to each value\nApply a function to each value along with its index\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether the <code>Intrinsic</code> has side effects.\nIndicates if the instruction has a side effect, ie. it can …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLookup an Intrinsic by name and return it if found. If …\nMaps each ValueId inside this instruction to a new …\nMaps each ValueId inside this instruction to a new ValueId …\nMutate each ValueId to a new ValueId using the given …\nMutate each BlockId to a new BlockId specified by the …\nReplaces values present in this instruction with other …\nIf true the instruction will depend on <code>enable_side_effects</code> …\nTrue if this instruction requires specifying the control …\nReturns the type that this instruction will return.\nAddition of lhs + rhs.\nBitwise and (&amp;)\nA binary instruction in the IR.\nBinary Operations allowed in the IR. Aside from the …\nThe binary operation could not be evaluated\nDivision of lhs / rhs.\nChecks whether two types are equal. Returns true if the …\nThe binary operation could be evaluated but it is …\nChecks whether the lhs is less than the rhs. All other …\nModulus of lhs % rhs.\nMultiplication of lhs * rhs.\nBitwise or (|)\nBitshift left (&lt;&lt;)\nBitshift right (&gt;&gt;)\nSubtraction of lhs - rhs.\nThe binary operation could be evaluated and it was …\nBitwise xor (^)\nEvaluate a binary operation with constant arguments.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLeft hand side of the binary operation\nThe binary operation to apply\nThe type of this Binary instruction’s result\nRight hand side of the binary operation\nTruncates <code>int</code> to fit within <code>bit_size</code> bits.\nValues in the range <code>[0, 2^(bit_size-1))</code> are interpreted as …\nA <code>Signed</code> or <code>Unsigned</code> value of a <code>Value::NumericConstant</code>, …\nApply functions on signed/unsigned values.\nDecrement the value by 1, saturating at the minimum value.\nReturns the argument unchanged.\nIncrement the value by 1, saturating at the maximum value.\nCalls <code>U::from(self)</code>.\nConvert back into a field.\nReduce two constants into a result by applying functions …\nA simple counter to create fresh Ids without any storage. …\nA DenseMap is a Vec wrapper where each element corresponds …\nA unique ID corresponding to a value of type T. This type …\nA SparseMap is a HashMap wrapper where each element …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds an element to the map. Returns the …\nGiven the Id of the element being created, adds the element\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps the inner storage of this map\nGets an iterator to a reference to each element in the …\nConstructs a new Id for the given index.\nReturn the next fresh id\nCreate a new counter starting after the given Id. Use …\nReturns the underlying index of this Id.\nDepth-first traversal stack state marker for computing the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllocate and compute a function’s block post-order.\nAllocate and compute a function’s block post-order.\nDisplay a single block. This will not display the block’…\nHelper function for Function’s Display impl to …\nDisplay an arbitrary instruction\nDisplay a terminator instruction\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTries to extract a constant string from an error payload.\nSpecialize displaying value ids so that if they refer to a …\nDisplay each value separated by a comma\nDisplay each value along with its type. E.g. …\nAn immutable array value with the given element type and …\nComposite Types are essentially flattened struct or tuple …\nA function that may be called directly\nRepresents numeric types in the IR, including field …\nA numeric type in the Intermediate representation Note: we …\nA reference to some value, such as an array\nAn immutable slice value with a given element type\nAll types representable in the IR.\nReturns the bit size of the provided numeric type.\nReturns the bit size of the provided numeric type.\nCreates the u1 type\nCreates the boolean type, represented as u1.\nCreates the char type, represented as u8.\nCreates the char type, represented as u8.\nTrue if this type is an array (or slice) or internally …\nTrue if this is a function type or if it is a composite …\nTrue if this is a reference type or if it is a composite …\nReturns the size of the element type for this array/slice. …\nCreates the native field type.\nReturns the flattened size of a Type\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the array or slice type within this type, or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this type is an array (or slice)\nReturns whether the <code>Type</code> represents an signed numeric type.\nReturns whether the <code>Type</code> represents an unsigned numeric …\nCreates the type of an array’s length.\nCreates the type of an array’s length.\nCreates a NumericType::Signed type\nCreate a new signed integer type with the given amount of …\nCreates the <code>str&lt;N&gt;</code> type, of the given length N\nCreates a NumericType::Unsigned type\nCreate a new unsigned integer type with the given amount …\nReturns the inner NumericType if this is one, or panics …\nReturns None if the given Field value is within the …\nThis Value refers to an external function in the IR. …\nThis Value refers to a function in the IR. Functions …\nThis Value indicates we have a reserved slot that needs to …\nThis value was created due to an instruction\nAn Intrinsic is a special kind of builtin function that …\nThis Value originates from a numeric constant\nThis Value originates from a block parameter. Since …\nValue is the most basic type allowed in the IR. Transition …\nLike <code>HashMap&lt;ValueId, ValueId&gt;</code> but handles:\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieves the type of this Value\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIn the Brillig runtime arrays are represented as [RC, ……\nThe purpose of this pass is to perform function …\nThe goal of the constant folding optimization pass is to …\nThis module defines the defunctionalization pass for the …\nDead Instruction Elimination (DIE) pass: Removes any …\nThe flatten cfg optimization pass “flattens” the …\nThis modules defines an SSA pass that inlines calls to …\nThis module defines the function inlining pass for the SSA …\nThe loop invariant code motion (LICM) pass moves code from …\nThe goal of the mem2reg SSA optimization pass is to …\nPre-process functions before inlining them into others.\nThe goal of the “remove enable side effects” …\nRemoves any unreachable functions from the code. These can …\nThis module defines an SSA pass to remove instructions …\nThis file contains the simplify cfg pass of the SSA IR.\nThis file contains the loop unrolling pass for the new SSA …\nBuilds the set of ArraySet instructions that can be made …\nPost-check condition for Function::array_set_optimization.\nPre-check condition for Function::array_set_optimization.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMake each ArraySet instruction in <code>instructions_to_update</code> …\nDuring the loop unrolling pass we also evaluate calls to …\nEvaluate a call to <code>assert_constant</code>, returning an error if …\nEvaluate a call to <code>static_assert</code>, returning an error if …\nComputes a cost estimate of a basic block returns u32::MAX …\nIdentifies all simple conditionals in the function and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the blocks of the simple conditional sub-graph …\nStores the information necessary to appropriately update …\nClones new functions and returns a mapping representing …\nRecursively mark any functions called in an entry point\nFor every call site, we can determine the entry point for …\nBuilds a mapping from a <code>FunctionId</code> to the set of <code>FunctionId</code>…\nGo through the supplied function and based upon the call …\nReturns the argument unchanged.\nReturns a map of Brillig entry points to all functions …\nCalls <code>U::from(self)</code>.\nGiven that we have already rewritten all the call sites …\nThe logic here is almost the same as …\nThe instruction was a call to a brillig function, but we …\nHashMap from <code>(side_effects_enabled_var, Instruction)</code> to a …\nThe instruction was a call to a brillig function and we …\nResult of trying to evaluate an instruction (any …\nHashMap from <code>(Instruction, side_effects_enabled_var)</code> to …\nNothing was done because the instruction wasn’t a call …\nRecords the results of all duplicate <code>Instruction</code>s along …\nRecords a simplified equivalents of an <code>Instruction</code> in the …\nCalled with a newly encountered simplification.\nRecords that an <code>Instruction</code> in block <code>block</code> produced the …\nIndicates if the instruction can be safely replaced with …\nContains sets of values which are constrained to be …\nTries to evaluate an instruction if it’s a call that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to find a simplification in a visible block.\nReturns a set of <code>ValueId</code>s produced from a copy of this …\nGet a cached result if it can be used in this context.\nGet the simplification mapping from complex to simpler …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new value inside this function by reading it …\nPushes a new <code>Instruction</code> into the <code>DataFlowGraph</code> which …\nRemove previously cached instructions that created arrays, …\nReplaces a set of <code>ValueId</code>s inside the <code>DataFlowGraph</code> with …\nFetches an <code>Instruction</code> by its <code>InstructionId</code> and fully …\nSimplified expressions where we found them.\nCheck if one expression is simpler than the other. Returns …\nChecks if the given instruction is a call to a brillig …\nSimilar to FunctionContext::ssa_type_to_parameter but …\nMaps pre-folded ValueIds to the new ValueIds obtained by …\nRepresents an ‘apply’ function created by this pass to …\nAll generated apply functions for each grouping of …\nPerforms defunctionalization on all functions This is done …\nAll functions used as a value that share the same …\nCreates a single apply function to enable dispatch across …\nCreates all apply functions needed for dispatch of …\nCreates a placeholder (dummy) function to replace calls to …\nDefunctionalize a single function\nDefunctionalize all functions in the SSA\nCheck post-execution properties:\nFinds all dynamic dispatch signatures in the given …\nFinds all literal functions used as values in the given …\nCollects all functions used as values that can be called …\nReturns the argument unchanged.\nReturns the argument unchanged.\nTransforms a FunctionId into a FieldElement\nReturns the apply function for the given signature\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a dummy value to be returned from the …\nTry to map the given function literal to a field, …\nReplace any first class functions used in an instruction …\nReplaces any function calls using first-class function …\nReturn what type a function value type should be replaced …\nTake a list of types that might need replacement. Replaces …\nPer function context for tracking unused values and which …\nPer block RC tracker.\nCheck post-execution properties:\nThe elimination of certain unused instructions assumes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet all RC instructions which work on arrays whose type …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if this is a <code>Instruction::IncrementRc</code> or …\nReturns true if an instruction can be removed.\nMark any array parameters to the function itself as …\nAdds values referenced by the terminator to the set of …\nInspects a value and marks all instruction results as used.\nA per-block list indicating which block parameters are …\nThis module implements the pruning of unused block …\nIncrementRc &amp; DecrementRc instructions must be revisited …\nTrack IncrementRc instructions per block to determine …\nGo through the RC instructions collected when we figured …\nSteps backwards through the instruction of the given …\nStore instructions must be removed by DIE in acir code, …\nhelper function which add instructions to the block …\nInsert constraints ensuring that the operation does not …\nPost-check condition for Function::expand_signed_checks.\nReturns the argument unchanged.\nInsert a binary instruction at the end of the current …\nInsert a cast instruction at the end of the current block. …\nInsert a constrain instruction at the end of the current …\nInsert a not instruction at the end of the current block. …\nInsert a <code>Instruction::RangeCheck</code> instruction at the end of …\nInserts a cast instruction at the end of the current block …\nInsert a truncate instruction at the end of the current …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function\nWhen a MSM is done under a predicate, we need to apply the …\nStack of block arguments When processing a block, we pop …\nThis is an algorithm for identifying branch starts and …\nMaps start of branch -&gt; end of branch\n‘Cast’ the ‘condition’ to ‘value’ type\nThis ControlFlowGraph is the graph from before the …\nA stack of each jmpif condition that was taken to reach a …\nProcess the ‘exit’ block of a conditional statement:\nFlatten the CFG by inlining all instructions from the …\nFlattens the control flow graph of the function such that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the current condition\nIf we are currently in a branch, we need to modify …\nReturns the list of blocks that need to be processed after …\nProcess a conditional statement by creating a ‘…\nInline all instructions from the given block into the …\nInline the ending block of a branch, the point where all …\nChecks the branch condition on the top of the stack and …\nInsert a new instruction into the target block. Unlike …\nInserts a new instruction into the target block, using the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse the provided map to say if the instruction is a call …\nReturns the updated condition so that it is ‘AND-ed’ …\nStores all allocations local to the current branch.\nMerges the given array with a constant array of 32 …\nInsert a multiplication between ‘condition’ and ‘…\nFlag to tell the context to not issue ‘enable_side_effect…\nNegates a boolean value by inserting a Not instruction\nA map from <code>cond</code> to <code>Not(cond)</code>\nReturns the values corresponding to the given inputs by …\nMap the value to its predicated value, and store the …\nPush the given instruction to the end of the target block …\nRestore the previous mapping of predicated values.\nTarget block of the flattening\nSwitch context to the ‘else-branch’:\nThe CFG branched again at a parent block into a left and …\nThe CFG rejoined.\nThe next interesting point following some block.\nTry to complete as many of the parent levels as we can, …\nReturns a <code>HashMap</code> mapping blocks that start a branch (i.e. …\nStarting with the current block, find the next join or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the left and right branches joined. If so, mark …\nTry to join a pending branch, once the next join point is …\nCheck that the left and right join points are the same, …\nPush a branch to the stack for exploration, remembering …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstruct a dummy value to be attached to the smaller of …\nGiven an if expression that returns an array: …\nMerge two numeric values a and b from separate basic …\nMerge two values a and b from separate basic blocks to a …\nThe maximum number of instructions chosen below is an …\nThe context for the function inlining pass.\nThe per-function inlining context contains information …\nAn arbitrary limit to the maximum number of recursive call …\nMaps blocks in the source function to blocks in the …\nThe shared inlining context for all functions. This …\nThe function that we are inlining calls into.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to retrieve the function referred to by the given Id. …\nHandle inlining a function’s possibly multiple return …\nHandle the given terminator instruction from the given …\nStart inlining the entry point function and all functions …\nInline each instruction in the given block into the …\nInline all reachable blocks within the source_function …\nInlines a function into the current function and returns …\nInline a function call and remember the inlined return …\nTrue if we’re currently working on the entry point …\nModify the values HashMap to remember the mapping between …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new context object for the function inlining pass.\nCreate a new PerFunctionContext from the source function. …\nPush the given instruction from the source_function into …\nThe source function is the function we’re currently …\nTranslates the program point representing the start of the …\nTranslates a ValueId from the function being inlined to a …\nMaps ValueIds in the function being inlined to the new …\nInformation about a function to aid the decision about …\nCompute something like a topological order of the …\nCompute interface cost of a function based on the number …\nCompute a weight of a function based on the number of …\nDetermines whether a function should be inlined.\nThe functions we should inline into (and that should be …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFunctions which are to be retained, not inlined.\nIndicates if the instruction can be safely hoisted out of …\nCertain instructions can take advantage of that our …\nCheck can_be_hoisted with extra control dependence …\nChecks whether a binary operation can be evaluated using …\nA control dependent instruction (e.g. constrain or …\nA control dependent instruction (e.g. constrain or …\nDetermine whether the loop body is guaranteed to execute. …\nUpdate any values defined in the loop and loop invariants …\nReturns the binary instruction only if the input value …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks whether a <code>block</code> is control dependent on a …\nChecks whether a <code>block</code> is control dependent on any blocks …\nDetermines if the <code>block</code> is in a nested loop that is …\nLoop invariant hoisting only operates over loop …\nIf the inputs are an induction variable and a constant, it …\nIf the inputs are an induction and loop invariant …\nCaches all blocks that belong to nested loops determined …\nKeep track of a loop induction variable and respective …\nGather the variables declared within the loop\nSome instructions can take advantage of that our induction …\nSimplify ‘assert(lhs &lt; rhs)’ into ‘assert(max(lhs) &lt; …\nSimplify certain instructions using the lower/upper bounds …\nGiven a constant <code>c</code> and an induction variable <code>i</code>:\nReplace ‘assert(invariant != induction)’ with …\nGo through each parameter and register that all reference …\nIn order to handle nested arrays we need to recursively …\nTrack whether a reference has been aliased, and store the …\nAnalyze a block with the given starting reference values.\nThe value of each reference at the start of the given …\nReturns the argument unchanged.\nTrack whether a reference was passed into another …\nLoad and Store instructions that should be removed at the …\nCalls <code>U::from(self)</code>.\nTrack a value’s last load across all blocks. If a value …\nApply the mem2reg pass to the given function.\nCollect the input parameters of the function which are of …\nRemove any instructions in <code>self.instructions_to_remove</code> …\nAdd all instructions in <code>last_stores</code> to …\nA set of possible aliases. Each ValueId in this set …\nReturns <code>Some(true)</code> if <code>f</code> returns true for any known alias …\nReturn the first ValueId in the alias set as long as there …\nReturns the argument unchanged.\nInserts a new alias into this set if it is not unknown\nCalls <code>U::from(self)</code>.\nIn rare cases, such as when creating an empty array of …\nReturns true if calling <code>unify</code> would change something in …\nReturn the single known alias if there is exactly one. …\nUnify this alias set with another. The result of this set …\nA <code>Block</code> acts as a per-block context for the mem2reg pass. …\nAn <code>Expression</code> here is used to represent a canonical key …\nEvery reference’s value is either Known and can be …\nEach expression is tracked as to how many aliases it may …\nCollect all aliases used by the given value list\nMaps a ValueId to the Expression it represents. Multiple …\nIterate through each known alias of the given address and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the given reference id points to a known value, return …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe last instance of a <code>Store</code> instruction to each address …\nEach allocate instruction result (and some reference block …\nRemember that <code>result</code> is the result of dereferencing <code>address</code>…\nIf the given address is known, set its value to …\nMaps from old ids to new ones. Separate from the rest of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis function is impure and cannot be deduplicated even …\nFunction is completely pure and doesn’t rely on a …\nFunction is mostly pure. As long as the predicate is the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPost-check condition for Ssa::purity_analysis.\nUnifies two purity values, returning the lower common …\nFind each dec_rc instruction and if the most recent inc_rc …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinds and pops the IncRc for the given array value if …\nFind each array_set instruction in the function and mark …\nReturns the argument unchanged.\nInsert an instruction to extract an element from an array\nInsert a binary instruction at the end of the current …\nInsert a call instruction at the end of the current block …\nInsert a cast instruction at the end of the current block. …\nInsert a not instruction at the end of the current block. …\nInsert ssa instructions which computes lhs &gt;&gt; rhs by doing …\nInsert a truncate instruction at the end of the current …\nInsert ssa instructions which computes lhs &lt;&lt; rhs by doing …\nCalls <code>U::from(self)</code>.\nInsert a numeric constant into the current function\nComputes lhs^rhs via square&amp;multiply, using the bits …\nPost-check condition for Function::remove_bit_shifts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPost-check condition for Function::remove_if_else.\nFind the change to a slice’s capacity an instruction …\nIdentifies all reachable function IDs within the provided …\nPost-check condition for Ssa::remove_unreachable_functions.\nIdentifies all reachable function IDs within a given …\nReturns the argument unchanged.\nInstructs this context to insert the current instruction …\nInserts an instruction in the current block right away.\nInserts an instruction by id in the current block right …\nReturns the current instruction being visited.\nCalls <code>U::from(self)</code>.\nInstructs this context to remove the current instruction …\nReplaces the current instruction with another one.\nInstructs this context to replace a value with another …\nOptimize a jmpif into a jmp if the condition is known\nAttempts to simplify a <code>jmpif</code> terminator if both branches …\nOptimize a jmp to a block which immediately jmps elsewhere …\nOptimize a jmpif on a negated condition by swapping the …\nIf the given block has block parameters, replace them with …\nFollow a chain of empty blocks to find the real …\nTry to inline a block into its predecessor, returning true …\nAll the instructions in the following example are …\nThe context object for each loop iteration. Notably each …\nNumber of instructions in the loop, including boilerplate, …\nThe start of the back_edge n -&gt; d is the block n at the …\nInstruction count if we leave the loop as-is. It’s the …\nMaps pre-unrolled block ids from within the loop to new …\nAll the blocks contained within the loop, including <code>header</code> …\nCollect boilerplate stats if we can figure out the upper …\nCount the number of instructions in the loop, including …\nCount the number of increments to the induction variable. …\nCount the number of load and store instructions of …\nThe loops that failed to be unrolled so that we do not try …\nFind a loop in the program by finding a node that …\nReturn each block that is in a loop starting in the given …\nFind all reference values which were allocated before the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the lower and upper bounds of the loop if both are …\nFind the lower bound of the loop in the pre-header and …\nFind the upper bound of the loop in the loop header and …\nReturn the induction value of the current iteration of the …\nFind the value that controls whether to perform a loop …\nTranslate a block id to a block id in the unrolled loop. …\nFind the original ID of a block that replaced it.\nThe loop pre-header is the block that comes before the …\nFind the next branch(es) to take from a jmpif terminator …\nCheck that the loop does not end with a constant value …\nThe header block of a loop is the block which dominates …\nNumber of increments to the induction variable (might be …\nThe induction value (and the block it was found in) is the …\nCopy over instructions from the source into the insert …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecide if the new bytecode size is acceptable, compared to …\nIs the instruction an <code>Rc</code>?\nA small loop is where if we unroll it into the pre-header …\nDecide if this loop is small enough that it can be inlined …\nNumber of iterations in the loop.\nNumber of loads  pre-header references in the loop.\nMaps unrolled block ids back to the original source block …\nUnrolling leaves some duplicate instructions which can …\nNumber of stores into pre-header references in the loop.\nUnroll a single loop in the function. Returns Ok(()) if it …\nUnroll all loops within a given function. Any loops which …\nUnrolls the header block of the loop. This is the block …\nUnroll a single block in the current iteration of the loop\nUnroll a single block in the current iteration of the loop\nUnroll a single iteration of the loop.\nEstimated number of instructions if we unroll the loop.\nEstimated number of <em>useful</em> instructions, which is the ones …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses <code>&amp;mut Type</code>, returns <code>Some(Type)</code> if <code>&amp;mut</code> was found, …\nParses <code>&amp;mut Type</code>, returns <code>Type</code> if <code>&amp;mut</code> was found, errors …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps block names to their IDs\nComputes the order in which blocks should be translated. …\nReturns the argument unchanged.\nMaps internal function names (e.g. “f1”) to their IDs\nThe types of globals in the parsed SSA, in the order they …\nMaps names (e.g. “g0”) in the parsed SSA to global IDs.\nThe function that will hold the actual SSA globals.\nCalls <code>U::from(self)</code>.\nMaps variable names to their IDs.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n&amp;\n-&gt;\n=\n:\n,\n==\n{\n[\n(\n!=\n}\n]\n)\n;\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the entire SSA representation of the program.\nMap arrays with the last instruction that uses it For this …\nA simple SSA pass to find any calls to <code>Intrinsic::AsSlice</code> …\nDetect Brillig calls left unconstrained with manual asserts\nThis function provides an SSA pass that detects if the …\nAn SSA pass that checks that multiplying two u128 doesn’…\nAn SSA pass that will turn checked binary addition, …\nPerforms Dead Instruction Elimination (DIE) to remove any …\nPost the Brillig generation we do not need to run this …\nSanity check on the final SSA, panicking if the …\nThe elimination of certain unused instructions assumes …\nSee <code>defunctionalize</code> module for more information.\nMaps SSA entry point function ID -&gt; Final generated ACIR …\nA simple SSA pass to go through each instruction and …\nExpands signed arithmetic operations to include explicit …\nThis pass flatten simple IF-THEN-ELSE statements This …\nFlattens the control flow graph of main such that the …\nPerforms constant folding on each instruction.\nPerforms constant folding on each instruction.\nPerforms constant folding on each instruction while also …\nReturns the argument unchanged.\nCreates an Ssa object from the given string.\nCreates an Ssa object from the given string without …\nCreates an Ssa object from the given string but trying to …\nGenerates SSA for the given monomorphized program.\nInline all functions within the IR.\nRun the inlining pass where functions marked with …\nSee the <code>inline_simple_functions</code> module for more …\nInline functions repeatedly until no new functions are …\nCalls <code>U::from(self)</code>.\nA simple SSA pass to go through each <code>Instruction::Constrain</code>…\nAttempts to remove any load instructions that recover …\nThis is a debugging pass which re-inserts each instruction …\nRun pre-processing steps on functions in isolation.\nSee <code>prune_dead_parameters</code> module for more information.\nAnalyze the purity of each function and tag each function …\nPerforms constant folding on each instruction.\nSee <code>remove_enable_side_effects</code> module for more information.\nThis pass removes <code>inc_rc</code> and <code>dec_rc</code> instructions as long …\nThis pass removes <code>inc_rc</code> and <code>dec_rc</code> instructions as long …\nThis SSA pass removes <code>truncate</code> instructions that happen on …\nSee <code>remove_unreachable</code> module for more information.\nSee <code>simplify_cfg</code> module for more information\nCompile Brillig functions and ACIR functions reachable …\nLoop unrolling can return errors, since ACIR functions …\nVerifies there are no <code>array_get</code> or <code>array_set</code> instructions …\nThe FunctionContext is the main context object for …\nThe queue of functions remaining to compile\nUsed to remember the results of each step of extracting a …\nShared context for all functions during ssa codegen. This …\nAdds a “single” parameter to scope.\nAdd each parameter to the current scope, and return the …\nGiven an lhs containing only references, create a store …\nAssigns a new value to the given LValue. The LValue can be …\nBind the given variable ids to each argument of the given …\nInsert constraints ensuring that the operation does not …\nOverflow checks for bit-shift We use Rust behavior for …\nInsert a numeric constant into the current function\nPrepare a slice access. Check that the index being used to …\nCodegen an array by allocating enough space for each …\nThe bool aspect of each array element indicates whether …\nThis is broken off from codegen_index so that it can also …\nGenerate SSA for a function call. Note that calls to …\nEvaluate the given expression, increment the reference …\nEvaluate the given expression, decrement the reference …\nCodegens a for loop, creating three new blocks in the …\nCodegen a function’s body and set its return value to …\nCodegen an identifier, automatically loading its value if …\nCodegen a reference to an ident. The only difference …\nCodegens an if expression, handling the case of what to do …\nGenerate SSA for the given variable. If the variable is …\nCodegens a loop, creating two new blocks in the process. …\nCodegen any non-tuple expression so that we can unwrap the …\nCodegens a while loop, creating three new blocks in the …\nConverts a non-tuple type into an SSA type. Panics if a …\nConverts the given operator to the appropriate BinaryOp. …\nConvert a monomorphized type to an SSA type, preserving …\nDefine a local variable to be some Values that can later …\nExtracts the tag value from an enum. Assumes enums are …\nExtracts the current value out of an LValue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nShared counter used to assign the ID of the next function\nQueue of which functions still need to be compiled.\nAll currently known functions which have already been …\nExtract the given field of the tuple. Panics if the given …\nExtract the given field of the tuple by reference. Panics …\nRetrieves the given function, adding it to the function …\nReturn the matching id for the given function if known. If …\nA pseudo function that represents global values. Globals …\nCompile the given identifier as a reference - ie. avoid …\nCompile the given <code>array[index]</code> expression as a reference. …\nInsert a binary instruction at the end of the current …\nInserts a call instruction at the end of the current block …\nInserts a cast instruction at the end of the current block …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up the value of a given local variable. Expects the …\nThe loop index will be <code>Some</code> for a <code>for</code> and <code>None</code> for a <code>loop</code>\nContains any loops we’re currently in the middle of …\nArray indexes are u32. This function casts values used as …\nCreate a const offset of an address for an array load or …\nMaps the given type to a Tree of the result type.\nCreate a new FunctionContext to compile the first function …\nCreate a new SharedContext for the given monomorphized …\nFinish building the current function and switch to …\nAllocate a single slot of memory and store into it the …\nTrue if the given operator cannot be encoded directly and …\nTrue if the given operator cannot be encoded directly and …\nPops the next function from the shared function queue, …\nThe entire monomorphized source program\nReplace the given field of the tuple with a new one. …\nIf the condition is known, skip codegen for the then/else …\nReturns the unit value, represented as an empty tree of …\nContains the entire SSA representation of the program.\nAdds a new function to the program\nMaps SSA entry point function ID -&gt; Final generated ACIR …\nReturns the entry-point function of the program\nCreate a new Ssa object from the given SSA functions. The …\nA mutable variable that must be loaded as the given type …\nA general Tree structure which is used in the SSA …\nA single value in ssa form. This wrapper enum is needed …\nA tree of values.\nReturns the total amount of leaves in this tree\nReturns an empty tree node represented by a Branch with no …\nEvaluate a value, returning an IrValue from it. This has …\nEvaluates the value, returning a reference to the mutable …\nFlattens the tree into a vector of each leaf value\nIterates over each Leaf node, calling f on each value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps this Tree into the value of the leaf node. Panics …\nFlattens and evaluates this <code>Tree&lt;Value&gt;</code> into a list of ir …\nCalls the given function on each leaf node, mapping this …\nMap two trees alongside each other. This asserts each tree …\nReturns the size of the type in terms of the number of …\nAside the function being validated, the validator …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nValidates that the instruction has the expected types …\nEnforces that every cast from Field -&gt; unsigned/signed …\nValidates that the Function is well formed.")