searchState.loadedDescShard("nargo_cli", 0, "For commands that write artifacts.\nWhat kind of lock to take out on the (selected) workspace …\nFor commands that cannot interfere with others.\nOptions for commands that work on either workspace or …\nFor commands that read artifacts, but never write them.\nCommands that can execute on the workspace level, or be …\n“with_workspace”, but use a dummy workspace when ‘…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUse the SSA Interpreter to execute a SSA after a certain …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of lock the command needs to take out on the …\nLock the (selected) packages in the workspace. The lock …\nThe name of the package to run the command on. By default …\nIndicate which package the command will be applied to.\nDecide which package to run the command on:\nRead a given program directory into a workspace.\nOverride the default target directory.\nFind the root directory, parse the workspace, lock the …\nRun on all packages in the workspace\nCheck a local package and all of its dependencies for …\nForce overwrite of existing files\nEvaluates the necessity to create or update Prover.toml …\nGenerates the contents of a toml file with fields for each …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nJust show the hash of each packages, without actually …\nCompile the program and its secret execution trace into …\nCompile the given contracts in the workspace.\nCompile the given binary packages in the workspace.\nCompile binary and contract packages. Returns the merged …\nParse and compile the entire workspace, then report errors.\nReturns the argument unchanged.\nIf a target width was not specified in the CLI we can …\nCalls <code>U::from(self)</code>.\nParse all files in the workspace.\nWatch workspace and recompile on changes.\nContinuously recompile the workspace on any Noir file …\nOverride the expression width requested by the backend.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse pedantic ACVM solving, i.e. double-check some …\nExecutes a circuit in debug mode\nForce ACIR output (disabling instrumentation)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJSON RPC url to solve oracle calls\nThe name of the package to execute\nThe name of the toml file which contains the inputs for …\nRaw string printing of source for testing\nDisable vars debug instrumentation (enabled by default)\nName (or substring) of the test function to debug\nWrite the execution witness to named file\nExecutes a circuit to calculate its return value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPath to the oracle transcript.\nJSON RPC url to solve oracle calls\nThe name of the toml file which contains the inputs for …\nWrite the execution witness to named file\nShow the result of macro expansion\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExports functions marked with #[export] attribute\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFormat the Noir files in a workspace\nRun noirfmt in check mode\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRun the fuzzing harnesses for this program\nIf given, load/store fuzzer corpus from this folder\nOnly run harnesses that match exactly\nReturns the argument unchanged.\nIf given, store the failing input in the given folder\nIf given, only the fuzzing harnesses with names containing …\nCalls <code>U::from(self)</code>.\nList all available harnesses that match the name\nList the fuzzing harnesses for this program\nMaximum number of executions of ACIR and Brillig per …\nIf given, perform corpus minimization instead of fuzzing …\nThe number of threads to use for fuzzing\nJSON RPC url to solve oracle calls\nRun the fuzzing harnesses for this program\nDisplay output of <code>println</code> statements\nMaximum time in seconds to spend fuzzing (default: no …\nGenerates a shell completion script for your favorite shell\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe shell to generate completions for. One of: bash, …\nProvides detailed information on each of a program’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutput a JSON formatted report. Changes to this format are …\nThe name of the toml file which contains the inputs for …\nCreate a Noir project in the current directory.\nUse a binary template [default]\nUse a contract template\nReturns the argument unchanged.\nInitializes a new Noir project in <code>package_dir</code>.\nCalls <code>U::from(self)</code>.\nUse a library template\nName of the package [default: current directory name]\nCompile the program and interpret the SSA after each pass, …\nCompile the source code into the monomorphized AST, which …\nReturns the argument unchanged.\nInterpret the SSA if it’s part of the selected passes.\nCalls <code>U::from(self)</code>.\nThe name of the TOML file which contains the ABI encoded …\nThe name of the SSA passes we want to interpret the …\nIf true, the interpreter will trace its execution.\nStarts the Noir LSP server\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a Noir project in a new directory.\nUse a binary template [default]\nUse a contract template\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse a library template\nName of the package [default: package directory name]\nThe path to save the new project\nOutput a JSON Lines document\nPrint verbose output\nDisplay one character per test\nRun the tests for this program\nCompiles a single package and returns all of its tests\nCompiles all packages in parallel and returns their tests\nIf given, load/store fuzzer corpus from this folder\nDisplay the status of a single test\nOnly run tests that match exactly\nConfigure formatting of output\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaximum number of executions to run for each fuzz test …\nShow progress of fuzzing (default: false)\nMaximum time in seconds to spend fuzzing (default: 1 …\nIf given, store the failing input in the given folder\nCompiles a single package and returns all of its test names\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint all matching test names.\nIf given, perform corpus minimization instead of fuzzing …\nDo not run fuzz tests (tests that have arguments)\nOnly run fuzz tests (tests that have arguments)\nJSON RPC url to solve oracle calls\nProcess a chunk of tests sequentially and send the results …\nDisplay one character per test instead of one line\nRuns all tests. Returns <code>true</code> if all tests passed, <code>false</code> …\nRuns a single test and returns its status together with …\nDisplay output of <code>println</code> statements\nIf given, only tests with names containing this string …\nNumber of threads used for running tests in parallel\nA formatter for showing test results.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nABI encoding/decoding error\nArtifact CLI error\nError from the compilation pipeline\nError from Manifest\nError from Nargo\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")