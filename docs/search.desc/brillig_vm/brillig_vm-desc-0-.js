searchState.loadedDescShard("brillig_vm", 0, "The Brillig VM is a specialized VM which allows the ACVM …\nA sample for an executed opcode.\nAll samples for each opcode that was executed.\nThe error call stack contains the opcode indexes of the …\nThe VM encountered a failure and halted execution.\nRepresents the reason why the Brillig VM failed during …\nThe VM has completed execution successfully. The output of …\nThe VM process is not solvable as a foreign call has been …\nThe VM is still in progress and has not yet completed …\nThe bit size used for addressing memory within the Brillig …\nThe VM’s memory. Memory is internally represented as a …\nA single typed value in the Brillig VM’s memory.\nThe position of the next opcode that will be executed in …\nThe position of an opcode that is currently being executed …\nA runtime failure during execution. This error is …\nThe current stack pointer is always in slot 0.\nA trap was encountered, which indicates an explicit …\nVM encapsulates the state of the Brillig VM during …\nRepresents the current execution status of the Brillig VM.\nImplementations for binary field operations and binary …\nImplementations for VM native black box functions.\nThe solver for blackbox functions.\nExecutable opcodes.\nThe call stack when processing a given opcode.\nCall stack.\nCalldata to the brillig function.\nImplementation for the cast operation.\nSets the current status of the VM to <code>Failure</code>, indicating …\nSets the current status of the VM to Finished (completed …\nImplementation for foreign calls\nA counter maintained throughout a Brillig process that …\nAccumulates the outputs of all foreign calls during a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFuzzing trace structure. If the field is <code>None</code> then fuzzing …\nCollect information about the comparison of two field …\nCollect information about the comparison of two integer …\nMark the execution of a particular branch in the fuzzing …\nMark the execution of a conditional move in the fuzzing …\nReturns the VM’s current call stack, including the …\nReturns the VM’s call stack, but unlike …\nRead memory slots.\nGet input data from memory to pass to foreign calls.\nCheck whether the latest foreign call result is available …\nIncrements the program counter by 1.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementation of the VM’s memory.\nMemory of the VM.\nConstructs a new VM instance.\nOffset constants for arrays and vectors:\nProcess a binary field operation. This method will not …\nProcess a binary integer operation. This method will not …\nHandles the execution of a single ForeignCall opcode.\nProcess a unary negation operation.\nProcess a single opcode and modify the program counter.\nExecute a single opcode:\nProcess opcodes in a loop until a status of <code>Finished</code>, …\nReturns the current value of the program counter.\nInstruction pointer.\nReads an array/vector from memory but recursively reads …\nProvide the results of a Foreign Call to the VM and resume …\nSets the program counter to <code>value</code>. If the program counter …\nUpdates the current status of the VM. Returns the given …\nStatus of the VM.\nTake all the contents of the memory, leaving it empty.\nSets the current status of the VM to <code>Failure</code>, indicating …\nSets the status of the VM to <code>ForeignCallWait</code>. Indicating …\nWrites flattened values to memory, using the provided type.\nWrite a foreign call’s results to the VM memory.\nWrite a numeric value to direct memory slot.\nWrite a single numeric value to the destination address, …\nWrite an array or slice to the destination under the …\nOffset in memory where the revert data begins.\nSize of the revert data.\nThe call stack at the time the failure occurred, useful …\nInterpreted by simulator context.\nInput values. Each input can be either a single value or …\nThe reason for the failure.\nOffset in memory where the return data begins.\nSize of the return data.\nEvaluate a binary operation on two FieldElement memory …\nEvaluate a binary operation on two unsigned big integers …\nEvaluates arithmetic or bitwise operations on unsigned …\nEvaluates comparison operations (<code>Equals</code>, <code>LessThan</code>, …\nEvaluates shift operations (<code>Shl</code>, <code>Shr</code>) for unsigned …\nEvaluates binary operations on 1-bit unsigned integers …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaps a BlackBoxOp variant to its corresponding BlackBoxFunc…\nEvaluates a black box function inside the VM, performing …\nReads a fixed-size array from memory.\nReads a dynamically-sized vector from memory.\nExtracts the last byte of every value\nConverts a slice of u8 values into a Vec&lt;<code>MemoryValue&lt;F&gt;</code>&gt;, …\nWrite values to a array in memory.\nWrite values to a vector in memory.\nCasts a value to a different bit size.\nReturns the total number of field elements required to …\nA tuple of the current opcode position and the next opcode …\nA map for translating encountered branching logic to …\nA state that represents a false comparison as part of a …\nThe start of the range of the states that represent …\nA state that represents a true comparison as part of a …\nContext structure for all information necessary to compute …\nThe index of a unique feature in the fuzzing trace\nBranch to feature map for fuzzing. Maps program counter + …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFuzzer tracing memory.\nWrapper for array addresses, with convenience methods for …\nThe bit size used for addressing memory within the Brillig …\nThe VM’s memory. Memory is internally represented as a …\nRepresents errors that can occur when interpreting or …\nA single typed value in the Brillig VM’s memory.\nThe value’s bit size does not match the expected bit …\nThe memory value is not an integer and cannot be …\nThe current stack pointer is always in slot 0.\nWrapper for vector addresses, with convenience methods for …\nExtracts the field element from the memory value, if it is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead the value from slot 0.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe start of the items, after the meta-data.\nThe start of the items, after the meta-data.\nBuilds a memory value from a field element, checking that …\nBuilds a field-typed memory value.\nBuilds a memory value from a field element, either field …\nBuilds an integer-typed memory value.\nOffset constants for arrays and vectors:\nReads the numeric value at the address.\nReads the value at the address and returns it as a direct …\nRead a contiguous slice of memory starting at <code>address</code>, up …\nIncrease the size of memory fit <code>size</code> elements, or the …\nResolve an address to either:\nSize of the vector.\nConverts the memory value to a field element, independent …\nConverts the memory value to U128, if the value is an …\nExpects a <code>U32</code> value and converts it into <code>usize</code>, otherwise …\nReturns the values of the memory\nSets the value at <code>address</code> to <code>value</code>\nSets the values after <code>address</code> to <code>values</code>\nNumber of prefix fields in an array: RC.\nNumber of prefix fields in a vector: RC, size, capacity.\nNumber of prefix fields in an array: RC.\nNumber of prefix fields in a vector: RC, size, capacity.")