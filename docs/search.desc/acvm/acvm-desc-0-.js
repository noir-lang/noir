searchState.loadedDescShard("acvm", 0, "This trait is extremely unstable and WILL have breaking …\nThis component will generate outputs for Blackbox function …\nThe <code>compiler</code> module contains several passes to transform …\nReturns the closest number of bytes to the bits specified …\nReturns the argument unchanged.\nConverts bytes into a FieldElement and applies a reduction …\nConverts bytes in little-endian order into a FieldElement …\nCalls <code>U::from(self)</code>.\nComputes the inverse or returns zero if the inverse does …\nMaximum number of bits needed to represent a field element …\nMaximum numbers of bytes needed to represent a field …\nThis is the number of bits required to represent this …\nThis module contains methods to implement the partial …\nReturns the vale of this field as a hex string without the …\nDowncast the field into a <code>i128</code>. Panic if the value does …\nConverts the field element to a vector of bytes in …\nReturns the value of this field as a hex string with …\nDowncast the field into a <code>u128</code>. Panic if the value does …\nDowncast the field into a <code>u128</code> if it fits into 128 bits, …\nThis module can move and decompose acir opcodes into …\nSimulate solving a circuit symbolically Instead of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nTrack whether a <code>BlockId</code> has been initialized\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBuilds a map from a vector of pointers to the old acir …\nThis function is similar to <code>new_locations()</code>, but only …\nReturns the new opcode location(s) corresponding to the …\nMaps the old acir indices to the new acir indices\nApplies backend independent optimizations to a <code>Circuit</code>.\nTrack the witnesses that can be solved\nUpdate the assert messages to point to the new opcode …\nApplies backend independent optimizations to a <code>Circuit</code>.\nApplies backend independent optimizations to a <code>Circuit</code>.\nThe redundant range constraint optimization pass aims to …\nWe use multiple passes to stabilize the output in many …\nFold all witnesses in a circuit.\nFold a witness into the state.\nAdd all witnesses from the circuit.\nFold many witnesses into the state.\nAdd witnesses from the opcode.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTake the accumulated state.\nFind the witness with the highest ID in the circuit.\nCreate the folder with some initial state and an …\nApplies backend specific optimizations to a <code>Circuit</code>.\nAccepts an injected <code>acir_opcode_positions</code> to allow …\nA transformer which processes any <code>Expression</code>s to break …\nMinimum width accepted by the <code>CSatTransformer</code>.\nChecks if this expression can fit into one arithmetic …\nReturns the argument unchanged.\nGet or generate a scaled intermediate witness which is …\nCalls <code>U::from(self)</code>.\nAdds the witness to set of solvable witness\nCreate an optimizer with a given width.\nNormalize an expression by dividing it by its first …\nTrack the witness that can be solved\nTransform the input arithmetic expression into a new one …\nCheck if the equation ‘expression=0’ can be solved, …\nThis pass analyzes the circuit and identifies intermediate …\nReturns the argument unchanged.\nReturns the ‘updated’ opcode at the given index in the …\nCalls <code>U::from(self)</code>.\nThe <code>GeneralOptimizer</code> processes all <code>Expression</code>s to:\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSimplifies all mul terms of the form <code>scale*w1*w2</code> with the …\nInformation gathered about witnesses which are subject to …\nThe next potential side effect for each opcode.\nCollect range information about witnesses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaps witnesses to their bit size switch points.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicate whether the bit size comes from an assertion or …\nCalculate the maximum number of bits required to index a …\nCreates a new <code>RangeOptimizer</code> by collecting all known range …\nStrictest constraint on bit size so far.\nReturns a <code>Circuit</code> where each Witness is only range …\nOpcode positions which updated this RangeInfo, i.e at …\n<code>UnusedMemoryOptimizer</code> will remove initializations of …\nCreates a set of ids for memory blocks for which no …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>UnusedMemoryOptimizer </code> by collecting unused …\nReturns a <code>Circuit</code> where <code>Opcode::MemoryInit</code>s for unused …\nSimulate solving a circuit symbolically Instead of …\nCheck whether the circuit is solvable in theory.\nTrack whether a <code>BlockId</code> has been initialized\nAdds the witness to set of solvable witness\nSimulate solving a circuit symbolically by keeping track …\nTrack the witnesses that can be solved\nCheck if the Opcode can be solved, and if yes, add the …\nEncapsulates a request from the ACVM that encounters an …\nSpecific solver for Brillig opcodes It maintains a Brillig …\nUsed by errors to point to a specific opcode as that error…\nThe ACVM has encountered an irrecoverable error while …\nEncapsulates a request from a Brillig VM process that …\nThe ACVM is processing the circuit, i.e solving the …\nA dynamic assertion payload whose data has been resolved. …\nThe ACVM has encountered a request for an ACIR call to …\nThe ACVM has encountered a request for a Brillig foreign …\nEnumeration of possible resolved assertion payloads. This …\nAll witnesses have been computed and all opcodes have been …\nA counter maintained throughout an ACVM process that …\nRepresents the outputs of all ACIR calls during an ACVM …\nStores the solver for memory operations acting on blocks …\nResolved data that represents some ABI type. To be decoded …\nSets the VM status to ACVMStatus::Failure using the …\nFinalize the ACVM execution, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn identifier interpreted by the caller process\nThis id references which Brillig function within the main …\nReturn a reference to the arguments for the next pending …\nReturns the concrete value for a particular expression If …\nReturns the status of the ACVM If the status is an error, …\nIndex in the list of ACIR function’s that should be …\nInitial witness for the given circuit to be called\nResolved inputs to a foreign call computed in the previous …\nInserts <code>value</code> into the initial witness map under the index …\nReturns the index of the current opcode to be executed.\nIndex of the next opcode to be executed.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>Ok(true)</code> if the predicate is zero A predicate is …\nReturns a slice containing the opcodes of the circuit …\nA list of opcodes which are to be executed by the ACVM.\nResolves an ACIR call’s result (simply a list of fields) …\nResolves a foreign call’s result using a result …\nSelector to the respective ABI type the data in this …\nExecutes the ACVM’s circuit until execution halts.\nSolves a Brillig Call opcode, which represents a call to …\nDefer execution of the ACIR call opcode to the caller, or …\nExecutes a single opcode using the dedicated solver.\nUpdates the current status of the VM. Returns the given …\nSets the status of the VM to <code>RequiresAcirCall</code> Indicating …\nSets the status of the VM to <code>RequiresForeignCall</code>. …\nEnable brillig fuzzing\nEnable profiling\nReturns a reference to the current state of the ACVM’s …\nA mapping of witnesses to their solved values The map is …\nAn Expression solver will take a Circuit’s assert-zero …\nCombines linear terms with the same witness by summing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA wrapper around field division which skips the inversion …\nDerives the rest of the witness in the provided expression …\nReturns the summation of all of the variables, plus the …\nReduce a linear term to its value if the witness …\nTry to reduce the multiplication terms of the given …\nTry to solve a multiplication term of the form q<em>a</em>b, where …\nCheck if all of the inputs to the function have assignments\nCheck if all of the inputs to the function have assignments\nSolve a black box function call\nReads the hash function input from a <code>WitnessMap</code>.\nAttempts to solve a 256 bit hash function opcode. If …\nWrites a <code>digest</code> to the <code>WitnessMap</code> at witness indices …\nSolves a <code>BlackBoxFunc::And</code> opcode and inserts the result …\nDerives the rest of the witness based on the initial low …\nSolves a <code>BlackBoxFunc::XOR</code> opcode and inserts the result …\nSpecific solver for Brillig opcodes It maintains a Brillig …\nEncapsulates a request from a Brillig VM process that …\nExtracts a <code>ResolvedAssertionPayload</code> from a block of memory …\nFinalize the VM execution and write the outputs to the …\nFinalize the VM and return the profiling samples.\nAn identifier interpreted by the caller process\nThis id references which Brillig function within the main …\nReturns the status of the Brillig VM as a ‘…\nResolved inputs to a foreign call computed in the previous …\nConstructs a solver for a Brillig block given the bytecode …\nGet a BrilligVM for executing the provided bytecode\nWrite VM execution results into the witness map\nAssigns the zero value to all outputs of a given brillig …\nMaintains the state for solving <code>MemoryInit</code> and <code>MemoryOp</code> …\nKnown values of the memory block, based on the index This …\nReturns the argument unchanged.\nConvert a field element into a memory index Only 32 bits …\nCalls <code>U::from(self)</code>.\nCreates a new MemoryOpSolver with the values given in <code>init</code>.\nReturns the value stored in the ‘block_value’ map for …\nUpdate the ‘block_values’ by processing the provided …\nUpdate the ‘block_value’ map with the provided …")