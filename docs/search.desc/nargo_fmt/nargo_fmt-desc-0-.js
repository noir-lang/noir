searchState.loadedDescShard("nargo_fmt", 0, "The Noir formatter.\nMerge imports from the same crate into a single use …\nHow imports should be grouped into use statements. Imports …\nDo not change the granularity of any imports and preserve …\nMaximum width of an array literal before falling back to …\nThis module has all the logic to format a series of chunks …\nMaximum width of the args of a function call before …\nReturns the argument unchanged.\nReturns the argument unchanged.\nHow imports should be grouped into use statements.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum width of each line\nRemove nested parens\nReorder imports alphabetically\nWidth threshold for an array element to be considered short\nMaximum line length for single line if-else expressions\nNumber of spaces per tab\nThe value of an assignment or let statement. We know this …\nA chunk can either be text or a directive that instructs …\nInterface for creating TextChunks.\nCommand to decrease the current indentation.\nThis is a chunk that has a list of expression in it, for …\nA group of chunks.\nCommand to increase the current indentation.\nThis is a chunk for a lambda argument that is the last …\nThe body of a lambda. We track this as a group kind so …\nA leading comment. Happens at the beginning of a line.\nWrite a line (or two) if we decide to format chunks in …\nA method call. We track all this information to see, if we …\nSet the current indentation by popping it from the …\nPush the current indentation to the indentation stack.\nMost chunks are regular chunks and are not of interest.\nWrites a space if we can write a group in one line, …\nA text chunk. It might contain leading comments.\nA text chunk. It precomputes the text width and whether it …\nA trailing comma that’s only written if we decide to …\nA trailing comment (happens at the end of a line, and …\nStops writing to the current buffer for the duration of …\nThis name is a bit long and explicit, but it’s to make …\nIf true, regardless of this group’s chunks, this group …\nReturns the maximum width of each expression to format. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the current chunk as a Group, if it is one. …\nAppends another group as a nested group.\nDetermines if this group has a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of this group. Some group kinds are formatted in …\nAppends a leading comment (it’s formatted slightly …\nAppend one line to this chunk.\nAppend one or two lines to this chunk.\nAssuming this is a MethodCall group, if the ExpressionList …\nIf <code>true</code>, when formatting in multiple lines, and after a …\nBefore writing a Chunks object in multiple lines, create a …\nAppends a semicolon to this group by reading it from the …\nFinds the <code>LambdaAsLastExpressionInList</code> associated to this …\nStops writing to the current buffer, skips comments and …\nAppends a single space to this group by reading it from …\nAppends a SpaceOrLine chunk, which means that it’s a …\nGroups can be tagged. For example we tag all consequences …\nAppends a text to this group. If the last chunk in this …\nAppends a TextChunk to this chunks chunks. However, if the …\nAppends a trailing comma (will only show up if the group …\nAppends a trailing comment (it’s formatted slightly …\nAppends a verbatim text chunk to this group.\nComputes the width of this chunk considering it’s inside …\nReturns the width of text until we hit a Line or …\nAre there newlines before the left parentheses in this …\nIs this method call the left-hand side of a call chain? If …\nThis is the width of the group until the left parenthesis …\nMerge imports from the same crate into a single use …\nHow imports should be grouped into use statements. Imports …\nDo not change the granularity of any imports and preserve …\nMaximum width of an array literal before falling back to …\nMaximum width of an array literal before falling back to …\nMaximum width of the args of a function call before …\nMaximum width of the args of a function call before …\nReturns the argument unchanged.\nHow imports should be grouped into use statements.\nHow imports should be grouped into use statements.\nCalls <code>U::from(self)</code>.\nMaximum width of each line\nMaximum width of each line\nReads a Config starting at the given path and going …\nRemove nested parens\nRemove nested parens\nReorder imports alphabetically\nReorder imports alphabetically\nWidth threshold for an array element to be considered short\nWidth threshold for an array element to be considered short\nMaximum line length for single line if-else expressions\nMaximum line length for single line if-else expressions\nNumber of spaces per tab\nNumber of spaces per tab\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis is the buffer where we write the formatted code.\nAdvances to the next token (the current token is not …\nReturns an object that has a <code>chunk</code> method to get a …\nReturns the number of newlines that come next, if we are …\nMain interface to format a chunk group. Here it’s …\nReturns whether the left brace of semicolon was written …\nFormats outer doc comments, turning them into regular …\nRemoves the trailing whitespaces from the tag attribute.\nReturns the argument unchanged.\nA counter to create GroupTags.\nIf we find a comment like this one:\nThe current indentation level. We allow it to be negative …\nWhen formatting chunks we sometimes need to remember the …\nCalls <code>U::from(self)</code>.\nWe keep a copy of the config’s max width because when we …\nReturns a new GroupTag that is unique compared to other …\nReturns the next import group, if there’s is one.\nSkips comments and whitespace, writing newlines if there …\nSimilar to skip_comments_and_whitespace, but will write …\nAdvances the lexer until past the given span end without …\nOnly skips whitespace if it doesn’t have newlines in it. …\nReturns true if there at most one newline in the given …\nTrim commas from the end of the buffer. Returns true if a …\nTrim spaces from the end of the buffer.\nWrites a string to the buffer.\nWrites whatever is in the source at the given span without …\nAppends the string to the current buffer line by line, …\nWrites the current token but doesn’t advance to the next …\nWrites the current token and advances to the next one\nWrites the current token but without turning it into a …\nWrites the current token trimming its end but doesn’t …\nWrites the current indentation to the buffer, but only if …\nWrites the given keyword, if the current token is that …\nWrites a single newline, if the last thing we wrote wasn’…\nWrites whatever is in the given span relative to the file…\nWrites whatever is in the given span relative to the file…\nWrites a single space, skipping any whitespace and …\nWrites a single space, but doesn’t skip whitespace and …\nWrites the given token, if the current token is the same …\nWhenever a comment is written, this counter is incremented.\nA buffer to write to. It keeps track of the current line …\nHow many characters we’ve written so far in the current …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrim commas from the end of the buffer. Returns true if a …\nTrim multiple newlines from the end of the buffer, keeping …\nTrim spaces from the end of the buffer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn import tree to represent merged imports. For example …\nWe keep Crate, Super and Dep as special segments so that …\nRepresents the end of a path. This is needed because we …\nCombines two segments into a single one, by joining them …\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a segment to the tree, creating the necessary …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCombines all use trees to form a single ImportTree.\nSimplifies a tree by combining segments that only have one …\nCreates an import tree that has <code>segment</code> as the only …")