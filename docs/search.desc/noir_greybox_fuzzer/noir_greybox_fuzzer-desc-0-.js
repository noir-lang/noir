searchState.loadedDescShard("noir_greybox_fuzzer", 0, "Failed to load corpus or insert a file, etc (mb no write …\nInformation collected from testcase execution on failure …\nInformation collected from testcase execution on failure …\nContains information from parallel execution of testcases …\nWill contain the foreign call failure string if there was …\nA structure with the values for a single mutation-fuzz …\nThe outcome of a fuzz test\nAn executor for Noir programs which which provides fuzzing …\nMinimum pulse interval in milliseconds for printing metrics\nThe metrics of the fuzzing process being output to the user\nWill contain the reason for minimization failure (except …\nSuccessfully minimized corpus\nIf we’ve discovered a failing testcase\nWe aim the number of testcases per round so one round …\nA seed for the XorShift RNG for use during mutation\nIf the program has been executed properly and no failures …\nInformation collected from testcase execution on success\nNumber of testcases discovered with ACIR/Brillig tandem\nGet acir execution time\nHow much time executing the ACIR version took …\nA function which executes the programs with a given set of …\nThe program to be fuzzed (acir version)\nThe size of the corpus being used in mutation schedule\nAn optional id of a second testcase that will be used for …\nBrillig coverage ranges (which are branch coverage and …\nNumber of testcases discovered with Brillig\nGet brillig execution time\nHow much time executing the brillig version took …\nA function which executes the programs with a given set of …\nThe program to be fuzzed (brillig version)\nConstructs a <code>HashSet&lt;F&gt;</code> of values pulled from a <code>Program&lt;F&gt;</code> …\nCorpus folder. If given, the corpus is stored here\nCorpus folder\nThis file implements the mechanisms for coverage - …\nGiven the witness from ACIR execution and coverage from …\nThis module defines how to build a dictionary of values …\nExecuting the testcase resulted in failure\nDetermines what is considered a failure during execution\nIf the fuzzer has detected a condition that will not allow …\nFilter the starting corpus and add elements to the …\nDiscovered something with ACIR/Brillig tandem last round\nDiscovered something with Brillig last round\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe name of the function being fuzzed\nStart the fuzzing campaign\nHandle a failed execution case The handling depends on the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTells if more time has been spent in brillig execution …\nLast round execution time\nLast round size\nLast round accumulated coverage update time\nLocation to feature map (used in brillig fuzzing)\nThe id of the main testcase that is going to be mutated\nMaximum number of executions of ACIR and Brillig (default: …\nMaximum number of executions of ACIR and Brillig (default: …\nExecution metric\nIf this is set, perform minimization of the corpus\nMinimized corpus folder. If given, fuzzed executor …\nCorpus with the minimized\nGet mutation time\nHow much time mutating the testcase took before execution …\nThe object generating mutated version of testcases in the …\nCreate a new FuzzTask where everything is given\nInstantiates a fuzzed executor given an executor\nIf new coverage has been detected when executing the …\nNumber of threads to use for fuzzing\nNumber of threads to use\nNumber of threads involved in fuzzing\nGet the outcome of the execution\nContains the result of executing the testcase and the …\nThe name of the package being fuzzed\nThe number of unique testcases run\nPulse interval in milliseconds\nNumber of testcases removed from the corpus\nPurged a testcase last round\nA seed for the PRNG that will be used for mutating/splicing\nWhether to output progress to stdout or not.\nWhether to output progress to stdout or not.\nGranular and single-step function that runs only one fuzz …\nExecute acir and brillig programs with the following …\nGranular and single-step function that runs only one fuzz …\nTrue if there is no need to perform the merge check\nMaximum time in seconds to spend fuzzing (default: no …\nMaximum time in seconds to spend fuzzing (default: no …\nTotal time spent executing ACIR programs in microseconds\nTotal time spent executing Brillig programs in microseconds\nTotal time spent mutating testcases\nCreate a task for executing a testcase without mutation\nMain corpus manager that tracks all discovered testcases …\nManages reading and writing corpus files to the …\nRepresents the next testcase(s) selected for fuzzing:\nTracks information about a sequence of executions for a …\nRepresents a single test case in the corpus, containing …\nManages the selection of testcases for fuzzing, tracking …\nAttempts to load existing corpus files from disk\nResets the sequence by setting remaining executions to 0\nDecrements the number of remaining executions by 1\nReturns the argument unchanged.\nConverts an InputMap into a TestCase by generating a new …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a unique sequential ID for a testcase by …\nReturns the path to the corpus directory\nReturns the path where corpus files are stored\nReturns a vector of all currently active testcases\nReturns a vector containing all parsed inputs from the …\nReturns all testcases that have ever been added to the …\nSelects the next testcase(s) to use for fuzzing based on …\nSelects the next testcase(s) for ACIR execution\nSelects the next testcase(s) for Brillig execution\nReturns the input values for a testcase by its ID, …\nReturns the number of testcases currently active in the …\nReturns the unique identifier for this test case\nAdds a new testcase to the active corpus. Optionally saves …\nAdds a testcase to the cache (stored but not active)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if there are no executions remaining in this …\nLoads all corpus files from disk into memory, parsing them …\nCreates a new CorpusFileManager for a specific package and …\nCreates a new empty TestCaseOrchestrator\nCreates a new empty corpus for a specific package and …\nCreates a new empty sequence\nAdds a new testcase to be managed by the orchestrator\nRemoves a testcase from being managed by the orchestrator. …\nRemoves a testcase from the active corpus and both …\nSaves a new testcase to disk and adds it to the file …\nReturns a reference to the input values for this test case\nCreates a new TestCase with a specified ID and input values\nMetrics of the closeness of a particular comparison\nTotal coverage presented by all testcases in the corpus\nMetrics of a particular branch\nRepresents a single encountered state of a boolean witness …\nStructure containing information that at a particular …\nStructure containing information about positions of …\nStructure containing information that at a particular …\nA state that represents a false comparison as part of a …\nThe number of states in the range of the states that …\nThe start of the range of the states that represent …\nA state that represents a true comparison as part of a …\nA tuple of the current opcode position and the next opcode …\nA map from a particular branch or comparison to its unique …\nThe position of the next opcode that will be executed in …\nMechanism for excluding non-boolean witnesses from the …\nThe position of an opcode that is currently being executed …\nRaw brillig coverage is just a buffer of unsigned ints …\nInformation about the coverage of a single testcase …\nThe index of a unique feature in the fuzzing trace\nA list of all boolean witness states\nAll observed states of boolean witnesses\nAnalyze the brillig program to detect:\nTestcases in which the boolean states have been observed\nBranch coverage in brillig that has been observed\nComparison coverage in brillig that has been observed\nThe raw coverage from brillig execution\nCheck if particular testcases are no longer needed as …\nHow close did the values get to each other\nTestcase with the closest arguments\nReturns true if there is new coverage in the presented …\nIf tracking this comparison is enabled (we disable it if we…\nA bitmask of encountered powers of 2 of repetitions of …\nHow many time during a single execution this comparison …\nThe maximum number of iterations of this branch …\nThe maximum number of iterations of this comparison with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a non-bool witness list by parsing the witnesses …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTestcase that produced the maximum iterations count\nWhich testcase exhibited this behavior\nMerge the coverage of a testcase into accumulated coverage …\nCreate a new list of non-boolean witnesses by merging the …\nCreate an initial AccumulatedFuzzerCoverage object from …\nThe list of indices of all witnesses that are inferred to …\nIndex of the counter in the raw vector of coverage\nThe starting index of the region in the raw vector of …\nThe id of the testcase\nWhich testcases showed log2 behavior\nWhich testcases exhibited this behavior\nUpdate the non-bool witness list with a witness stack\nGiven witnesses from a program, add non-boolean witnesses …\nCollect <code>Field</code> values used in the opcodes of an ACIR …\nConstructs a <code>HashSet&lt;F&gt;</code> of values pulled from a <code>Program&lt;F&gt;</code> …\nCollect <code>Field</code> values used in the opcodes of a Brillig …\nNodeWeight determines the probability of mutating a …\nThis file contains configurations for selecting particular …\nRecurse through all the inputs in the ABI and collect …\nCount weights of each element recursively (complex …\nThis file contains the collection of objects for providing …\nThis file contains mechanisms for deterministically …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate an input map consisting of default values (0 for …\nGenerate the default input value for a given type false …\nCreate a mutated input for use in fuzzing Picks a number …\nThis file contains mechanisms for mutating integer …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPerform a single update on an input value In case the …\nCreate a new input mutator given the ABI and a hashset of …\nGet a single value from the second input in the new …\nUse one of splicing mechanisms to produce a new testcase …\nRecurse over elements and pick them according to the …\nFill the dictionary with values from an interesting input\nUpdate the dictionary with values from a vector of field …\nCreate buffer from random chunks of 2 buffers\nTake a random chunk of the input and insert it several …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPerform one of structural mutations on the vector of input …\nGenerate a combination of two string inputs\nCreate a spliced version of 2 buffers, where each element …\nSwap 2 random chunks in the buffer\nGeneric vector structural mutation configuration (random …\nAround 50% for each top-level element\nEnum for binary integer operation mutation\nMutations of individual bytes in strings\nField element substitution mutation types\nOne element merged into the main testcase\nEnum for splice candidate selection\nSplicing mutations for strings and arrays\nStructural mutations used in strings and arrays (arrays don…\nEnum for testcase splice type\nSelection of value or structural mutation. Used in …\n80/20 for each element at lower level\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn object with values from the program used for mutating …\nA dictionary for integer values. Separated by width\nParse input map and add elements to the dictionary We use …\nParse input value and add elements to the dictionary We …\nUpdate the dictionary of field elements from a given …\nParse input value and collect value(s) for the dictionary …\nFilter values in the original dictionary collected from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a reference to the field dictionary\nGet a reference to the int dictionary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a full dictionary from a set of field elements …\nUpdate the dictionary with values from a given testcase\nUpdate the dictionary with values from a vector of field …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMutates a field element input value using various mutation …\nPerforms negation with a flag for overflow.\nConvert i128 to given signed integer type, add a small …\nPerform an integer binary operation on 2 field elements …\nPerform an integer binary operation on 2 field elements …\nPerform a signed integer binary operation on 2 field …\nPerform an unsigned integer binary operation on 2 field …\nCalculate all maximum values for integers with widths from …\nCalculate all minimum values for integers with widths from …\nCalculate all minimum and maximum values for integers with …\nCalculate interesting values for unsigned integers\nConvert a value from field representation to integer …\nConvert a value from field representation to integer …\nReturns the argument unchanged.\nGenerate a random unsigned integer of given width and …\nCompute the maximum value of a signed integer of given …\nCompute the minimum value of a signed integer of given …\nConvert a value from integer representation to field …\nCalls <code>U::from(self)</code>.\nMutate an input value depending on the sign and width\nMutate an integer input value\nPerform a mutation on a signed int\nPerform a mutation on an unsigned int\nConvert i128 to given signed integer type, negate and …\nNegate a signed value\nNegate an unsigned value\nReturns a tuple of the negated value along with a boolean …\nPerform a binary operation with the given value and a …\nPerform a binary operation with the given value and a …\nPerform a shift operation on the value and convert to field\nShift signed value\nPerform a shift operation on the value and convert to field\nShift signed value\nAdd or subtract a small signed value to input\nAdd or subtract a small signed value to input\nGet one of the fixed values in place of the original value\nSubstitute with a dictionary value\nConvert a value from integer representation to field …\nConvert u128 to given unsigned integer type, add a small …\nConvert u128 to given unsigned integer type, negate and …\nConvert u128 to given unsigned integer type, subtract a …\nThis file contains mechanisms for mutating string …\nCreate buffer from random chunks of 2 buffers\nTake a random chunk of the input and insert it several …\nTake a random value and insert it several times\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMutate a string input value\nPerform one of structural mutations on the buffer\nPerform one of value-changing mutations (substitution by a …\nGenerate a combination of two string inputs\nCreate a spliced version of 2 buffers, where each element …\nSwap 2 random chunks in the buffer\nFailed to load corpus or insert a file, etc (mb no write …\nReturned by a single fuzz when a counterexample has been …\nReturned by a single fuzz when there is a discrepancy …\nForeign Call issues\nWill contain the foreign call failure string if there was …\nThe outcome of a fuzz test\nOutcome of a single execution (Brillig or Acir and Brillig)\nWill contain the reason for minimization failure (except …\nSuccessfully minimized corpus\nIf we’ve discovered a failing testcase\nReturned to the fuzz op in case the fuzzer found a failure …\nIf the program has been executed properly and no failures …\nReturned by a single fuzz in the case of a successful run\nHow much time executing the acir program took (0 if it hasn…\nCoverage from brillig execution (only available if  …\nHow much time executing the brillig program took (0 if it …\nTestcase contents\nUnique identifier of the testcase\nUnique identifier of the testcase\nUnique identifier of the testcase\nFailing testcase\nMinimal reproduction test case for failing test\nMinimal reproduction test case for failing test\nThe status of the call\nThe status of the call\nFailure message\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResulting witness (only available if the acir program has …")