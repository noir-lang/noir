# Transaction object

The transaction object is the struct broadcasted to the p2p network, generated by [_local execution_](./local-execution.md) by the user's PXE. Sequencers pick up transactions from the p2p network to include in a block.

<!--
Mike review:
- update definitions in light of new contract deployment process. (See contract-deployment/*).
- update definitions, given recent changes to the ../circuits section. (In hindsight, the people making the circuit change could perhaps have done this. We'll get there...)
- wrap the items in "field" and "type" columns with backticks ``.
- Perhaps rename all subheadings to be the name of the struct, e.g. `TransactionObject` (in backticks), for easier searching and referencing.
    - (We should probably adopt this approach throughout the protocol specs)
- Link to any types / fields which are defined on some other page of the protocol specs (e.g. `PrivateKernelPublicInputsFinal` should hopefully have a corresponding definition in the ../circuits/private-kernel-tail.md section).
- Remove private kernel vk tree references; it's an outdated notion that might not be adopted. Edit: liaise with the circuits team, because some of their docs mention a kernel vk tree too, and I'm not sure that's the best approach, given how few vks there will be.
- Perhaps the types should mirror the types of the ../circuits/* section? I'm not sure. Buffers and arrays of fields are technically correct, from the point of view of the typescript orchestration code, but the underlying data types of what these arrays and buffers actually represent might be more informative. What do you think?
- See Lasse's diagrams in `archive.md` and in the rollup directory. He's done some significant restructuring and renaming of classes, and I believe Jan is making corresponding changes to the codebase.
- If any of these class definitions are meant to align with those in the `../circuits/*` sections, perhaps we should link to those sections? The class definitions in the circuits sections should be considered "the most canonical version of structs", because those sections will need to be analysed more closely for bugs (and because the sheer (necessary) complexity of those sections makes it harder to change those sections).

- If you have time, I'm a big fan of also providing a mermaid diagram of how our deeply nested structs explode. See examples in the circuits and rollup-circuits section.
-->

## Transaction object struct

The fields of a transaction object are the following:

<!-- prettier-ignore -->
| Field | Type | Description |
|----------|----------|----------|
| data | PrivateKernelPublicInputsFinal | Public inputs (ie output) of the last iteration of the private kernel circuit for this transaction. |
| proof | Buffer | Zero-knowledge honk proof for the last iteration of the private kernel circuit for this transaction. |
| encryptedLogs | Buffer[][] | Encrypted logs emitted per function in this transaction. Position `i` contains the encrypted logs emitted by the `i`-th function execution. |
| unencryptedLogs | Buffer[][] | Equivalent to the above but for unencrypted logs. |
| enqueuedPublicFunctionCalls | PublicCallRequest[] | List of public function calls to run during public execution. |

### Private kernel public inputs final

Output of the last iteration of the private kernel circuit. Includes _accumulated data_ after recursing through all private function calls, as well as _constant data_ composed of _block header_ reflecting the state of the chain when such functions were executed, and the global _transaction context_. Refer to the circuits section for more info.

**Accumulated data**

<!-- prettier-ignore -->
| Field | Type | Description |
|-------|------|-------------|
| noteHashes | Field[] | The new note hashes made in this transaction. |
| nullifiers | Field[] | The new nullifiers made in this transaction. |
| nullifiedNoteHashes | Field[] | The note hashes which are nullified by a nullifier in the above list. |
| privateCallStack | Field[] | Current private call stack. |
| publicCallStack | Field[] | Current public call stack. |
| l2ToL1Msgs | Field[] | All the new L2 to L1 messages created in this transaction. |
| encryptedLogsHash | Field[] | Accumulated encrypted logs hash from all the previous kernel iterations. |
| unencryptedLogsHash | Field[] | Accumulated unencrypted logs hash from all the previous kernel iterations. |
| encryptedLogPreimagesLength | Field | Total accumulated length of the encrypted log preimages emitted in all the previous kernel iterations. |
| unencryptedLogPreimagesLength | Field | Total accumulated length of the unencrypted log preimages emitted in all the previous kernel iterations. |
| maxBlockNum | Field | Maximum block number (inclusive) for inclusion of this transaction in a block. |

**Block header**

<!-- prettier-ignore -->
| Field | Type | Description |
|-------|------|-------------|
| noteHashTreeRoot | Field | Root of the note hash tree at the time of when this information was assembled. |
| nullifierTreeRoot | Field | Root of the nullifier tree at the time of when this information was assembled. |
| contractTreeRoot | Field | Root of the contract tree at the time of when this information was assembled. |
| l1ToL2MessageTreeRoot | Field | Root of the L1 to L2 message tree at the time of when this information was assembled. |
| archiveRoot | Field | Root of the archive at the time of when this information was assembled. |
| privateKernelVkTreeRoot | Field | Root of the private kernel VK tree at the time of when this information was assembled (future enhancement). |
| publicDataTreeRoot | Field | Current public state tree hash. |
| globalVariablesHash | Field | Previous globals hash, this value is used to recalculate the block hash. |

### Public call request

<!-- I don't see a `PublicCallRequest` mentioned in the other structs. How does this struct fit into the TransactionObject? -->

Each _public call request_ is the preimage of a public call stack item in the transaction's `data`, and has the following fields:

<!-- prettier-ignore -->
| Field | Type | Description |
|----------|----------|----------|
| contractAddress | AztecAddress | Address of the contract on which the function is invoked.  |
| callContext | CallContext | Includes function selector and caller. |
| args | Field[] | Arguments to the function call. |
| sideEffectCounter | number? | Optional counter for ordering side effects of this function call. |

### Extended contract data

Each _extended contract data_ corresponds to a contract being deployed by the transaction, and has the following fields:

<!-- prettier-ignore -->
| Field | Type | Description |
|----------|----------|----------|
| address | AztecAddress | Address where the contract is to be deployed.  |
| portalAddress  | EthereumAddress | Portal address on L1 for this contract (zero if none). |
| bytecode | Buffer | Encoded Brillig bytecode for all public functions in the contract. |
| publicKey | PublicKey | Master public encryption key for this contract (zero if none). |
| partialAddress | Field | Hash of the constructor arguments, salt, and bytecode. |

## Transaction hash

A transaction is identified by its `transaction_hash`. In order to be able to identify a transaction before it has been locally executed, the hash is computed from its [_transaction execution request_](./local-execution.md#execution-request) by hashing:

<!-- Mike review:
As per comments elsewhere in my reviews, please can we exactly specify how the hash is calculated? Hash type, domain separator, ordering of hash inputs.
It would be great if we could also specify the types of these items, and link to where the type is defined elsewhere in this protocol specs.
-->

- `origin`
- `functionSelector`
- `argsHash`
- `txContent` <!-- Missing link to definition -->

The resulting transaction hash is always emitted during local execution as the first nullifier of the transaction, in order to prevent replay attacks. This is enforced by the private kernel circuit.
