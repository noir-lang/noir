const fs = require("fs");
const path = require("path");

const {
  TOPICS_IN_TABLE,
  TOPICS_IN_SECTIONS,
  INSTRUCTION_SET,
  instructionSize,
} = require("./InstructionSet");

function escapeBraces(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function escapeTicks(str) {
  return str.replace(/`/g, "\\`");
}

function instructionSetPreface() {
  let preface = "[comment]: # (THIS IS A GENERATED FILE! DO NOT EDIT!)\n";
  preface += "[comment]: # (Generated via `yarn preprocess`)\n\n";
  preface +=
    "[comment]: # (Generated by genMarkdown.js, InstructionSet.js, InstructionSize.js)\n\n";
  preface += "import Markdown from 'react-markdown'\n";
  preface += "import CodeBlock from '@theme/CodeBlock'\n\n";
  return preface;
}

function toOpcode(index) {
  return "0x" + index.toString(16).padStart(2, "0");
}

function htmlInstructionSetTable() {
  let table = "## Instructions Table\n";
  table += "\nClick on an instruction name to jump to its section.\n";
  table += "\n<table>\n";
  let header = "<th>Opcode</th>";
  for (let t = 0; t < TOPICS_IN_TABLE.length; t++) {
    header += `<th>${TOPICS_IN_TABLE[t]}</th>`;
  }
  table += `${header}\n`;

  for (let i = 0; i < INSTRUCTION_SET.length; i++) {
    const instr = INSTRUCTION_SET[i];
    const name = instr["Name"];
    let row = `<tr>\n`;
    row += `\t<td style={{'text-align': 'center'}}>${toOpcode(i)}</td>\n`;
    row += `\t<td style={{'text-align': 'center'}}><a id='isa-table-${
      instr["id"]
    }'/><Markdown>\\[${escapeTicks(name)}\\](#isa-section-${
      instr["id"]
    })</Markdown></td>`;

    for (let t = 0; t < TOPICS_IN_TABLE.length; t++) {
      const topic = TOPICS_IN_TABLE[t];

      if (topic == "Name") continue; // skip
      let cell = instr[topic];
      if (cell[0] == "\n") {
        // if string starts with newline, assume it's a multi-line code block
        cell = `<CodeBlock language="jsx">\n{\`${cell.trim()}\`}\n\t</CodeBlock>`;
      } else if (cell[0] == "`" && topic != "Name") {
        cell = `<CodeBlock language="jsx">{\n\t\t\`${cell.replace(
          /`/g,
          ""
        )}\`\n\t}</CodeBlock>`;
      } else {
        cell = escapeBraces(cell); // escape html
        cell = `<Markdown>${cell}</Markdown>`;
      }
      row += `\n\t<td>${cell}</td>`;
    }
    row += "\n</tr>";
    table += `${row}\n`;
  }
  table += "</table>\n";
  return table;
}

function markdownSublist(items) {
  let markdown = "";
  for (let i = 0; i < items.length; i++) {
    let item = items[i];
    if (typeof item === "string") {
      markdown += `\n\t- ${item}`;
    } else {
      markdown += `\n\t- **${item["name"]}**: ${item["description"]}`;
    }
  }
  return markdown;
}

function markdownInstructionSetSection(docsDir) {
  let markdown = "## Instructions\n";
  for (let i = 0; i < INSTRUCTION_SET.length; i++) {
    const instr = INSTRUCTION_SET[i];
    const name = instr["Name"];
    let subsection = `### <a id='isa-section-${instr["id"]}'/>${name}\n`;
    subsection += `${instr["Summary"].replace(/[<>=]/g, "\\$&")}\n\n`;
    subsection += `[See in table.](#isa-table-${instr["id"]})\n\n`;
    subsection += `- **Opcode**: ${toOpcode(i)}\n`;
    for (let t = 0; t < TOPICS_IN_SECTIONS.length; t++) {
      const topic = TOPICS_IN_SECTIONS[t];
      let field = instr[topic];
      if (topic == "Name" || topic == "Summary" || !field || field.length == 0)
        continue; // skip

      let item = `- **${topic}**: `;
      if (Array.isArray(field)) {
        item += markdownSublist(field);
      } else if (field[0] == "\n") {
        // if string starts with newline, assume it's a multi-line code block
        item += `\n<CodeBlock language="jsx">\n{\`${field.trim()}\`}\n</CodeBlock>`;
      } else {
        item += field;
      }
      subsection += `${item}\n`;
    }

    // docusaurus will get images from static/img
    const urlPath = `/img/protocol-specs/public-vm/bit-formats/${name.replace(
      /`/g,
      ""
    )}.png`;

    const bitFormatImagePath = path.join(docsDir, "..", `static${urlPath}`);

    if (fs.existsSync(bitFormatImagePath)) {
      subsection += `\n[![](${urlPath})](${urlPath})`;
    }
    markdown += `\n${subsection}\n`;
  }
  return markdown;
}

async function generateInstructionSet() {
  const rootDir = path.join(__dirname, "../../../../");
  const docsDir = path.join(rootDir, "docs", "docs");

  const relPath = path.relative(
    docsDir,
    "docs/protocol-specs/public-vm/gen/_instruction-set.mdx"
  );
  const docsFilePath = path.resolve(docsDir, relPath);
  const docsDirName = path.dirname(docsFilePath);
  if (!fs.existsSync(docsDirName)) {
    fs.mkdirSync(docsDirName, { recursive: true });
  }

  const preface = instructionSetPreface();
  const table = htmlInstructionSetTable();

  const section = markdownInstructionSetSection(docsDir);
  const doc = `${preface}\n${table}\n\n${section}`;
  fs.writeFileSync(docsFilePath, doc);

  console.log("Preprocessing complete.");
}

module.exports = {
  generateInstructionSet,
};
