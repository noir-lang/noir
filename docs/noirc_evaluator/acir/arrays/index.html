<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Array handling in ACIR."><title>noirc_evaluator::acir::arrays - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module arrays</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a><ul><li><a href="#array-flattening" title="Array Flattening">Array Flattening</a></li><li><a href="#side-effects-and-predication" title="Side effects and Predication">Side effects and Predication</a></li><li><a href="#zero-length-arrays" title="Zero-Length Arrays">Zero-Length Arrays</a></li></ul></li></ul><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In noirc_<wbr>evaluator::<wbr>acir</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">noirc_evaluator</a>::<wbr><a href="../index.html">acir</a></span><h1>Module <span>arrays</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/noirc_evaluator/acir/arrays.rs.html#1-1287">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Array handling in ACIR.</p>
<p>This modules how Noir‚Äôs SSA array semantics are lowered into ACIR‚Äôs flat memory model.
Arrays in SSA can appear as constants or dynamically allocated blocks.
Our responsibility here is to preserve correctness while ensuring memory access is efficient.</p>
<h3 id="design"><a class="doc-anchor" href="#design">¬ß</a>Design</h3>
<p>ACIR does not have a first-class array type. Instead, all arrays are
represented as contiguous regions in linear memory, identified by a
<a href="../../../acir/circuit/opcodes/memory_operation/struct.BlockId.html" title="struct acir::circuit::opcodes::memory_operation::BlockId">BlockId</a>. This module provides helpers for translating SSA array
operations into ACIR memory reads and writes.</p>
<p>ACIR generation use two different array types for representing arrays:</p>
<p><a href="../types/enum.AcirValue.html#variant.Array" title="variant noirc_evaluator::acir::types::AcirValue::Array">Constant arrays</a></p>
<ul>
<li>Known at compile time.</li>
<li>Reads and writes may be folded into an <a href="../types/enum.AcirValue.html" title="enum noirc_evaluator::acir::types::AcirValue">AcirValue</a> where possible.</li>
<li>Useful for optimization (e.g., constant element lookups do not require laying down opcodes)</li>
</ul>
<p><a href="../types/enum.AcirValue.html#variant.DynamicArray" title="variant noirc_evaluator::acir::types::AcirValue::DynamicArray">Dynamic arrays</a></p>
<ul>
<li>Referenced by a <a href="../../../acir/circuit/opcodes/memory_operation/struct.BlockId.html" title="struct acir::circuit::opcodes::memory_operation::BlockId">unique identifier</a></li>
<li>Must be explicitly initialized using an <a href="../../../acir/circuit/opcodes/enum.Opcode.html#variant.MemoryInit" title="variant acir::circuit::opcodes::Opcode::MemoryInit">opcode</a></li>
<li>Reads and writes must lower to at least an explicit <a href="../../../acir/circuit/opcodes/enum.Opcode.html#variant.MemoryOp" title="variant acir::circuit::opcodes::Opcode::MemoryOp">memory opcode</a>.</li>
<li>Required for arrays accessed by dynamic indices (witness inputs) or function parameters (the array is itself a witness)</li>
</ul>
<h4 id="array-flattening"><a class="doc-anchor" href="#array-flattening">¬ß</a>Array Flattening</h4>
<p>ACIR memory is flat, while SSA arrays may be multi-dimensional or
contain elements of varying size (we refer to these are non-homogenous arrays).
To reconcile this, each element‚Äôs ‚Äúflattened index‚Äù is computed relative to the array‚Äôs base pointer.
In some cases this requires consulting a side ‚Äúelement type sizes‚Äù
array to calculate offsets when elements have a non-homogenous layout.</p>
<p>The following Noir program:</p>
<div class="example-wrap"><pre class="language-noir"><code>struct Bar {
    inner: [Field; 3],
}
struct Foo {
    a: Field,
    b: [Field; 3],
    bar: Bar,
}
fn main(x: [Foo; 4]) -&gt; pub [Field; 3] {
    x[3].bar.inner
}</code></pre></div>
<p>Will produce the following SSA:</p>
<div class="example-wrap"><pre class="language-text"><code>acir(inline) pure fn main f0 {
  b0(v0: [(Field, [Field; 3], [Field; 3]); 4]):
    v2 = array_get v0, index u32 11 -&gt; [Field; 3]
    return v2
}</code></pre></div>
<p>In the SSA above we see that we have an index of <code>11</code>. However, with a flat memory
the true starting index of <code>x[3].bar.inner</code> is <code>25</code>.</p>
<p>To determine which field within the array we are attempting to access, we use an element type sizes array that stores
the flat starting index for each SSA field. Since tuples are flattened in SSA, each tuple field gets its own entry.
For an array like <code>[(Field, [Field; 3], [Field; 3]); 4]</code>, the element_type_sizes array would be:</p>
<p>[0, 1, 4, 7, 8, 11, 14, 15, 18, 21, 22, 25]</p>
<p>Where:</p>
<ul>
<li>Indices 0-2: element 0‚Äôs three fields (Field at 0, [Field; 3] at 1, [Field; 3] at 4)</li>
<li>Indices 3-5: element 1‚Äôs three fields (Field at 7, [Field; 3] at 8, [Field; 3] at 11)</li>
<li>Indices 6-8: element 2‚Äôs three fields (Field at 14, [Field; 3] at 15, [Field; 3] at 18)</li>
<li>Indices 9-11: element 3‚Äôs three fields (Field at 21, [Field; 3] at 22, [Field; 3] at 25)</li>
</ul>
<p>We use the SSA index directly to look up <code>element_type_sizes[index]</code> to get the flat starting offset.
We then use the resulting type to increment the index appropriately and fetch every element.</p>
<p>This element type sizes array is dynamic as we still need to access it based upon the index which itself can be dynamic.
The module will also attempt to not create this array when possible (e.g., when we have a simple homogenous array).</p>
<h4 id="side-effects-and-predication"><a class="doc-anchor" href="#side-effects-and-predication">¬ß</a>Side effects and Predication</h4>
<p>This module uses the special <a href="../struct.Context.html#structfield.current_side_effects_enabled_var" title="field noirc_evaluator::acir::Context::current_side_effects_enabled_var">side effects variable</a> to guard
array operations that may not always be executed. This variable acts as a predicate.</p>
<p>The goal is to preserve SSA semantics where some array operations are dominated by a branch condition.
We predicate the following:</p>
<h5 id="index-predication"><a class="doc-anchor" href="#index-predication">¬ß</a>Index Predication</h5>
<p>Array indices themselves are guarded by the side-effect predicate.
If an SSA array operation is executed at runtime, then we must ensure any arithmetic that computes the index
and any memory reads/writes implied by that index are safe even when the predicate is false.
The only array operations not left to runtime are those with safe indices (constant index under the array length).</p>
<p>To achieve this we compute a predicated index value (<code>predicate_index</code>) with the formula:</p>
<div class="example-wrap"><pre class="language-text"><code>predicate_index = predicate * index + (1 - predicate) * offset</code></pre></div>
<p>where <code>offset</code> is a safe fallback index (chosen so the element type at that
offset matches the requested element type).
The offset is necessary to match the correct result type for array reads.</p>
<h5 id="writes"><a class="doc-anchor" href="#writes">¬ß</a>Writes</h5>
<p>When the predicate is not a constant, instead of actually overwriting memory, we compute a ‚Äúdummy value‚Äù.
The dummy value is fetched from the same array at the requested <code>predicate_index</code>.
The store value of an array write is then converted from a <code>store_value</code> to <code>predicate * store_value + (1 - predicate) * dummy</code>
This ensures the memory remains unchanged when the write is disabled. In the case of a false predicate, the value stored will be itself.</p>
<h5 id="reads"><a class="doc-anchor" href="#reads">¬ß</a>Reads</h5>
<p>If we perform an array read under a false predicate we will read from <code>offset</code>. As arrays are not always homogenous
the result at index <code>offset</code> may contain a value that will overflow the resulting type of the array read.
When we read a value from a non-homogenous array, we multiply any resulting <a href="../types/enum.AcirValue.html#variant.Var" title="variant noirc_evaluator::acir::types::AcirValue::Var">AcirValue::Var</a> by the predicate
to avoid any possible mismatch. In the case of a false predicate, the value will now be zero.
For homogenous arrays, the fallback <code>offset</code> will produce a value with a compatible type.</p>
<h4 id="zero-length-arrays"><a class="doc-anchor" href="#zero-length-arrays">¬ß</a>Zero-Length Arrays</h4>
<p>Arrays of length 0 are valid in the SSA but must never generate ACIR
memory operations as they may produce runtime errors. These operations are special cased to always fail with an
index out of bounds error (with respect to side effects) and ensures they do not produce illegal memory accesses.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.array_has_constant_element_size.html" title="fn noirc_evaluator::acir::arrays::array_has_constant_element_size">array_<wbr>has_<wbr>constant_<wbr>element_<wbr>size</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Returns whether the array‚Äôs elements have a constant size.</div></li><li><div class="item-name"><a class="fn" href="fn.calculate_element_type_sizes_array.html" title="fn noirc_evaluator::acir::arrays::calculate_element_type_sizes_array">calculate_<wbr>element_<wbr>type_<wbr>sizes_<wbr>array</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Calculates the element type sizes lookup array for heterogeneous arrays/vectors.</div></li><li><div class="item-name"><a class="fn" href="fn.flattened_value_size.html" title="fn noirc_evaluator::acir::arrays::flattened_value_size">flattened_<wbr>value_<wbr>size</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li></ul></section></div></main></body></html>