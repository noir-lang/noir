<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Determines whether a function should be inlined."><title>compute_function_should_be_inlined in noirc_evaluator::ssa::opt::inlining::inline_info - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.16</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In noirc_<wbr>evaluator::<wbr>ssa::<wbr>opt::<wbr>inlining::<wbr>inline_<wbr>info</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../../index.html">noirc_evaluator</a>::<wbr><a href="../../../index.html">ssa</a>::<wbr><a href="../../index.html">opt</a>::<wbr><a href="../index.html">inlining</a>::<wbr><a href="index.html">inline_info</a></span><h1>Function <span class="fn">compute_function_should_be_inlined</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../../src/noirc_evaluator/ssa/opt/inlining/inline_info.rs.html#164-251">Source</a> </span></div><pre class="rust item-decl"><code>fn compute_function_should_be_inlined(
    ssa: &amp;<a class="struct" href="../../../ssa_gen/struct.Ssa.html" title="struct noirc_evaluator::ssa::ssa_gen::Ssa">Ssa</a>,
    inline_no_predicates_functions: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>,
    small_function_max_instructions: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.i64.html">i64</a>,
    aggressiveness: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.i64.html">i64</a>,
    times_called: &amp;HashMap&lt;<a class="struct" href="../../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>&gt;,
    inline_infos: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/collections/btree/map/struct.BTreeMap.html" title="struct alloc::collections::btree::map::BTreeMap">BTreeMap</a>&lt;<a class="struct" href="../../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="struct" href="struct.InlineInfo.html" title="struct noirc_evaluator::ssa::opt::inlining::inline_info::InlineInfo">InlineInfo</a>&gt;,
    call_graph: &amp;<a class="struct" href="../../../ir/call_graph/struct.CallGraph.html" title="struct noirc_evaluator::ssa::ir::call_graph::CallGraph">CallGraph</a>,
    index: <a class="struct" href="https://docs.rs/petgraph/0.4/petgraph/graph_impl/struct.NodeIndex.html" title="struct petgraph::graph_impl::NodeIndex">NodeIndex</a>,
)</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Determines whether a function should be inlined.</p>
<p>Inlining is determined by the following:</p>
<ul>
<li>the function is not recursive</li>
<li>the cost of inlining outweighs the cost of not doing so</li>
</ul>
<p>The total weight of a function and its cost are computed in this method.
The total weight is calculated by taking the function’s own weight and multiplying
it by the weight of each callee. We then determine the cost of inlining to be
the times a function has been called multiplied by its total weight.</p>
<p>To determine the cost of retaining a function we first need the function interface cost,
computed in <a href="fn.compute_function_interface_cost.html" title="fn noirc_evaluator::ssa::opt::inlining::inline_info::compute_function_interface_cost">compute_function_interface_cost</a>.
The cost of retaining of a function is then (times a function has been called) * (interface cost) + total weight.</p>
<p>A function’s net cost is then (cost of inlining - cost of retaining).
The net cost is then compared against the inliner aggressiveness setting. If the net cost is less than the aggressiveness,
we inline the function (granted there are not other restrictions such as recursion).</p>
</div></details></section></div></main></body></html>