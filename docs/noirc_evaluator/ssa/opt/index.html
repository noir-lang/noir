<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This folder contains each optimization pass for the SSA IR."><title>noirc_evaluator::ssa::opt - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module opt</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In noirc_<wbr>evaluator::<wbr>ssa</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">noirc_evaluator</a>::<wbr><a href="../index.html">ssa</a></span><h1>Module <span>opt</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/noirc_evaluator/ssa/opt/mod.rs.html#1-156">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This folder contains each optimization pass for the SSA IR.</p>
<p>Each pass is generally expected to mutate the SSA IR into a gradually
simpler form until the IR only has a single function remaining with 1 block within it.
Generally, these passes are also expected to minimize the final amount of instructions.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="array_set/index.html" title="mod noirc_evaluator::ssa::opt::array_set">array_<wbr>set</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The purpose of the <code>array_set_optimization</code> SSA pass is to mark <code>ArraySet</code> instructions
as mutable <em>iff</em> the array is not potentially shared with the callers or callees of the
function and wonâ€™t be used again in the function itself either. In other words, if this
is the last time we use this version of the array, we can mutate it in place, and avoid
having to make a copy of it.</div></li><li><div class="item-name"><a class="mod" href="as_vector_length/index.html" title="mod noirc_evaluator::ssa::opt::as_vector_length">as_<wbr>vector_<wbr>length</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="basic_conditional/index.html" title="mod noirc_evaluator::ssa::opt::basic_conditional">basic_<wbr>conditional</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">An SSA pass that operates on Brillig functions
This optimization pass identifies simple conditional control flow patterns in unconstrained code
and flattens them to reduce the number of basic blocks and improve performance.</div></li><li><div class="item-name"><a class="mod" href="brillig_array_get_and_set/index.html" title="mod noirc_evaluator::ssa::opt::brillig_array_get_and_set">brillig_<wbr>array_<wbr>get_<wbr>and_<wbr>set</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This SSA pass adjusts constant indexes of array operations inside Brillig functions
to avoid performing an extra binary operation.</div></li><li><div class="item-name"><a class="mod" href="brillig_entry_points/index.html" title="mod noirc_evaluator::ssa::opt::brillig_entry_points">brillig_<wbr>entry_<wbr>points</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The purpose of this pass is to perform function specialization of Brillig functions based upon
a functionâ€™s entry points. Function specialization is performed through duplication of functions.
Brillig entry points are defined as functions called directly by ACIR functions or are <code>main</code>.</div></li><li><div class="item-name"><a class="mod" href="check_u128_mul_overflow/index.html" title="mod noirc_evaluator::ssa::opt::check_u128_mul_overflow">check_<wbr>u128_<wbr>mul_<wbr>overflow</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">An SSA pass that operates on ACIR functions that checks that multiplying two u128 doesnâ€™t
overflow because both operands are greater or equal than 2^64.
If both are, then the result is surely greater or equal than 2^128 so it would overflow.
The operands can still overflow if just one of them is less than 2^64, but in that case
the result will be less than 2^192 so it fits in a Field value, and acir will check that
it fits in a u128.</div></li><li><div class="item-name"><a class="mod" href="checked_to_unchecked/index.html" title="mod noirc_evaluator::ssa::opt::checked_to_unchecked">checked_<wbr>to_<wbr>unchecked</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This SSA pass will turn checked unsigned binary additions, subtractions and multiplications
into unchecked ones if itâ€™s guaranteed that the operations cannot overflow.</div></li><li><div class="item-name"><a class="mod" href="constant_folding/index.html" title="mod noirc_evaluator::ssa::opt::constant_folding">constant_<wbr>folding</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The goal of the constant folding optimization pass is to propagate any constants forwards into
later <a href="../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction"><code>Instruction</code></a>s to maximize the impact of <a href="../ir/dfg/simplify/fn.simplify.html" title="fn noirc_evaluator::ssa::ir::dfg::simplify::simplify">compile-time simplifications</a>.</div></li><li><div class="item-name"><a class="mod" href="defunctionalize/index.html" title="mod noirc_evaluator::ssa::opt::defunctionalize">defunctionalize</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This module defines the defunctionalization pass for the SSA IR.
Certain IR targets (e.g., Brillig and ACIR) do not support higher-order functions directly.</div></li><li><div class="item-name"><a class="mod" href="die/index.html" title="mod noirc_evaluator::ssa::opt::die">die</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Dead Instruction Elimination (DIE) pass: Removes any instruction without side-effects for
which the results are unused.</div></li><li><div class="item-name"><a class="mod" href="evaluate_static_assert_and_assert_constant/index.html" title="mod noirc_evaluator::ssa::opt::evaluate_static_assert_and_assert_constant">evaluate_<wbr>static_<wbr>assert_<wbr>and_<wbr>assert_<wbr>constant</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">A simple SSA pass to go through each instruction and evaluate:</div></li><li><div class="item-name"><a class="mod" href="expand_signed_checks/index.html" title="mod noirc_evaluator::ssa::opt::expand_signed_checks">expand_<wbr>signed_<wbr>checks</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="expand_signed_math/index.html" title="mod noirc_evaluator::ssa::opt::expand_signed_math">expand_<wbr>signed_<wbr>math</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="flatten_cfg/index.html" title="mod noirc_evaluator::ssa::opt::flatten_cfg">flatten_<wbr>cfg</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This file contains the SSA flattening pass - a required pass for ACIR to remove any remaining
control-flow in the singular program-function, resulting in a single block containing the
program logic.</div></li><li><div class="item-name"><a class="mod" href="hint/index.html" title="mod noirc_evaluator::ssa::opt::hint">hint</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="inline_simple_functions/index.html" title="mod noirc_evaluator::ssa::opt::inline_simple_functions">inline_<wbr>simple_<wbr>functions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This modules defines an SSA pass that inlines calls to simple functions.
That is, the contents of the called function is put directly into the callerâ€™s body.
Functions are still restricted to not be inlined if they are recursive or marked with no predicates.</div></li><li><div class="item-name"><a class="mod" href="inlining/index.html" title="mod noirc_evaluator::ssa::opt::inlining">inlining</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This module defines the function inlining pass for the SSA IR.
The purpose of this pass is to inline the instructions of each function call
within the function caller. If all function calls are known, there will only
be a single function remaining when the pass finishes.</div></li><li><div class="item-name"><a class="mod" href="loop_invariant/index.html" title="mod noirc_evaluator::ssa::opt::loop_invariant">loop_<wbr>invariant</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The loop invariant code motion (LICM) pass performs two related optimizations:</div></li><li><div class="item-name"><a class="mod" href="make_constrain_not_equal/index.html" title="mod noirc_evaluator::ssa::opt::make_constrain_not_equal">make_<wbr>constrain_<wbr>not_<wbr>equal</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The goal of this SSA pass is to go through each <a href="../ir/instruction/enum.Instruction.html#variant.Constrain" title="variant noirc_evaluator::ssa::ir::instruction::Instruction::Constrain"><code>Instruction::Constrain</code></a>,
determine whether itâ€™s asserting two values are not equal, and if so replace it
with a <a href="../ir/instruction/enum.Instruction.html#variant.ConstrainNotEqual" title="variant noirc_evaluator::ssa::ir::instruction::Instruction::ConstrainNotEqual"><code>Instruction::ConstrainNotEqual</code></a>.</div></li><li><div class="item-name"><a class="mod" href="mem2reg/index.html" title="mod noirc_evaluator::ssa::opt::mem2reg">mem2reg</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The goal of the mem2reg SSA optimization pass is to replace any <code>Load</code> instructions to known
addresses with the value stored at that address, if it is also known. This pass will also remove
any <code>Store</code> instructions within a block that are no longer needed because no more loads occur in
between the Store in question and the next Store.</div></li><li><div class="item-name"><a class="mod" href="normalize_value_ids/index.html" title="mod noirc_evaluator::ssa::opt::normalize_value_ids">normalize_<wbr>value_<wbr>ids</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="preprocess_fns/index.html" title="mod noirc_evaluator::ssa::opt::preprocess_fns">preprocess_<wbr>fns</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Pre-process functions before inlining them into others.</div></li><li><div class="item-name"><a class="mod" href="pure/index.html" title="mod noirc_evaluator::ssa::opt::pure">pure</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="rc/index.html" title="mod noirc_evaluator::ssa::opt::rc">rc</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="remove_bit_shifts/index.html" title="mod noirc_evaluator::ssa::opt::remove_bit_shifts">remove_<wbr>bit_<wbr>shifts</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This SSA pass replaces Shl and Shr instructions in ACIR functions with more primitive
arithmetic instructions since ACIR doesnâ€™t directly support bit shifts.</div></li><li><div class="item-name"><a class="mod" href="remove_enable_side_effects/index.html" title="mod noirc_evaluator::ssa::opt::remove_enable_side_effects">remove_<wbr>enable_<wbr>side_<wbr>effects</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The goal of the â€œremove enable side effectsâ€ optimization pass is to delay any
<a href="../ir/instruction/enum.Instruction.html#variant.EnableSideEffectsIf" title="variant noirc_evaluator::ssa::ir::instruction::Instruction::EnableSideEffectsIf">Instruction::EnableSideEffectsIf</a> instructions in ACIR functions such that they cover
the minimum number of instructions possible.</div></li><li><div class="item-name"><a class="mod" href="remove_if_else/index.html" title="mod noirc_evaluator::ssa::opt::remove_if_else">remove_<wbr>if_<wbr>else</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This file contains the SSA <code>remove_if_else</code> pass - a required pass for ACIR to remove any
remaining <code>Instruction::IfElse</code> in the singular program-function, and replace them with
arithmetic operations using the <code>then_condition</code>.</div></li><li><div class="item-name"><a class="mod" href="remove_truncate_after_range_check/index.html" title="mod noirc_evaluator::ssa::opt::remove_truncate_after_range_check">remove_<wbr>truncate_<wbr>after_<wbr>range_<wbr>check</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="remove_unreachable_functions/index.html" title="mod noirc_evaluator::ssa::opt::remove_unreachable_functions">remove_<wbr>unreachable_<wbr>functions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Removes any unreachable functions from the code. These can result from
optimizations making existing functions unreachable, e.g. <code>if false { foo() }</code>,
or even from monomorphizing an unconstrained version of a constrained function
where the original constrained version ends up never being used.</div></li><li><div class="item-name"><a class="mod" href="remove_unreachable_instructions/index.html" title="mod noirc_evaluator::ssa::opt::remove_unreachable_instructions">remove_<wbr>unreachable_<wbr>instructions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This module defines an SSA pass to remove instructions that are unreachable.
For example, if an instruction in a block is <code>constrain u1 0 == u1 1</code>,
any subsequent instructions in that block will never be executed. This pass
then removes those subsequent instructions and replaces the blockâ€™s terminator
with a special <code>unreachable</code> value.</div></li><li><div class="item-name"><a class="mod" href="remove_unused_instructions/index.html" title="mod noirc_evaluator::ssa::opt::remove_unused_instructions">remove_<wbr>unused_<wbr>instructions</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This pass replaces instructions that arenâ€™t used anywhere in a function with <code>Noop</code>
to free up some memory.</div></li><li><div class="item-name"><a class="mod" href="simple_optimization/index.html" title="mod noirc_evaluator::ssa::opt::simple_optimization">simple_<wbr>optimization</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="simplify_cfg/index.html" title="mod noirc_evaluator::ssa::opt::simplify_cfg">simplify_<wbr>cfg</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This file contains the simplify cfg pass of the SSA IR.</div></li><li><div class="item-name"><a class="mod" href="unrolling/index.html" title="mod noirc_evaluator::ssa::opt::unrolling">unrolling</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This file contains the loop unrolling pass for the new SSA IR.</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.CONSTANT_FOLDING_MAX_ITER.html" title="constant noirc_evaluator::ssa::opt::CONSTANT_FOLDING_MAX_ITER">CONSTANT_<wbr>FOLDING_<wbr>MAX_<wbr>ITER</a></div></li><li><div class="item-name"><a class="constant" href="constant.INLINING_MAX_INSTRUCTIONS.html" title="constant noirc_evaluator::ssa::opt::INLINING_MAX_INSTRUCTIONS">INLINING_<wbr>MAX_<wbr>INSTRUCTIONS</a></div><div class="desc docblock-short">The maximum number of instructions chosen below is an expert estimation of a â€œsmallâ€ function
in our SSA IR. Generally, inlining small functions with no control flow should enable further optimizations
in the compiler while avoiding code size bloat.</div></li></ul></section></div></main></body></html>