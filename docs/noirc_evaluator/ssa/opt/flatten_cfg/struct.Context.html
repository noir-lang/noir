<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Context` struct in crate `noirc_evaluator`."><title>Context in noirc_evaluator::ssa::opt::flatten_cfg - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.16</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Context</a></h2><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.branch_ends" title="branch_ends">branch_ends</a></li><li><a href="#structfield.cfg" title="cfg">cfg</a></li><li><a href="#structfield.condition_stack" title="condition_stack">condition_stack</a></li><li><a href="#structfield.inserter" title="inserter">inserter</a></li><li><a href="#structfield.local_allocations" title="local_allocations">local_allocations</a></li><li><a href="#structfield.next_arguments" title="next_arguments">next_arguments</a></li><li><a href="#structfield.no_predicate" title="no_predicate">no_predicate</a></li><li><a href="#structfield.not_instructions" title="not_instructions">not_instructions</a></li><li><a href="#structfield.target_block" title="target_block">target_block</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.cast_condition_to_value_type" title="cast_condition_to_value_type">cast_condition_to_value_type</a></li><li><a href="#method.consume_args" title="consume_args">consume_args</a></li><li><a href="#method.else_stop" title="else_stop">else_stop</a></li><li><a href="#method.flatten" title="flatten">flatten</a></li><li><a href="#method.flatten_single_conditional" title="flatten_single_conditional">flatten_single_conditional</a></li><li><a href="#method.get_last_condition" title="get_last_condition">get_last_condition</a></li><li><a href="#method.handle_blackbox_side_effects" title="handle_blackbox_side_effects">handle_blackbox_side_effects</a></li><li><a href="#method.handle_call_side_effects" title="handle_call_side_effects">handle_call_side_effects</a></li><li><a href="#method.handle_instruction_side_effects" title="handle_instruction_side_effects">handle_instruction_side_effects</a></li><li><a href="#method.handle_intrinsic_side_effects" title="handle_intrinsic_side_effects">handle_intrinsic_side_effects</a></li><li><a href="#method.handle_terminator" title="handle_terminator">handle_terminator</a></li><li><a href="#method.if_start" title="if_start">if_start</a></li><li><a href="#method.inline_block" title="inline_block">inline_block</a></li><li><a href="#method.inline_branch_end" title="inline_branch_end">inline_branch_end</a></li><li><a href="#method.insert_current_side_effects_enabled" title="insert_current_side_effects_enabled">insert_current_side_effects_enabled</a></li><li><a href="#method.insert_instruction" title="insert_instruction">insert_instruction</a></li><li><a href="#method.insert_instruction_with_typevars" title="insert_instruction_with_typevars">insert_instruction_with_typevars</a></li><li><a href="#method.is_call_to_no_predicate_function" title="is_call_to_no_predicate_function">is_call_to_no_predicate_function</a></li><li><a href="#method.link_condition" title="link_condition">link_condition</a></li><li><a href="#method.map_block_with_mapping" title="map_block_with_mapping">map_block_with_mapping</a></li><li><a href="#method.mul_by_condition" title="mul_by_condition">mul_by_condition</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.not_instruction" title="not_instruction">not_instruction</a></li><li><a href="#method.predicate_value" title="predicate_value">predicate_value</a></li><li><a href="#method.prepare_args" title="prepare_args">prepare_args</a></li><li><a href="#method.push_instruction" title="push_instruction">push_instruction</a></li><li><a href="#method.reset_predicated_values" title="reset_predicated_values">reset_predicated_values</a></li><li><a href="#method.then_stop" title="then_stop">then_stop</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-UnwindSafe-for-Context%3C'f%3E" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Context%3C'f%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Context%3C'f%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Context%3C'f%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-Context%3C'f%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Context%3C'f%3E" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In noirc_<wbr>evaluator::<wbr>ssa::<wbr>opt::<wbr>flatten_<wbr>cfg</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">noirc_evaluator</a>::<wbr><a href="../../index.html">ssa</a>::<wbr><a href="../index.html">opt</a>::<wbr><a href="index.html">flatten_cfg</a></span><h1>Struct <span class="struct">Context</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#234-280">Source</a> </span></div><pre class="rust item-decl"><code>pub(crate) struct Context&lt;'f&gt; {
    pub(crate) inserter: <a class="struct" href="../../ir/function_inserter/struct.FunctionInserter.html" title="struct noirc_evaluator::ssa::ir::function_inserter::FunctionInserter">FunctionInserter</a>&lt;'f&gt;,
    cfg: <a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
    pub(crate) target_block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    branch_ends: FxHashMap&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>, <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;,
    condition_stack: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.ConditionalContext.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::ConditionalContext">ConditionalContext</a>&gt;,
    next_arguments: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;&gt;,
    local_allocations: FxHashSet&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    not_instructions: FxHashMap&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>, <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    pub(crate) no_predicate: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>,
}</code></pre><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.inserter" class="structfield section-header"><a href="#structfield.inserter" class="anchor field">§</a><code>inserter: <a class="struct" href="../../ir/function_inserter/struct.FunctionInserter.html" title="struct noirc_evaluator::ssa::ir::function_inserter::FunctionInserter">FunctionInserter</a>&lt;'f&gt;</code></span><span id="structfield.cfg" class="structfield section-header"><a href="#structfield.cfg" class="anchor field">§</a><code>cfg: <a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a></code></span><div class="docblock"><p>This <code>ControlFlowGraph</code> is the graph from before the function was modified by this flattening pass.</p>
</div><span id="structfield.target_block" class="structfield section-header"><a href="#structfield.target_block" class="anchor field">§</a><code>target_block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a></code></span><div class="docblock"><p>Target block of the flattening.</p>
</div><span id="structfield.branch_ends" class="structfield section-header"><a href="#structfield.branch_ends" class="anchor field">§</a><code>branch_ends: FxHashMap&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>, <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;</code></span><div class="docblock"><p>Maps start of branch -&gt; end of branch.</p>
</div><span id="structfield.condition_stack" class="structfield section-header"><a href="#structfield.condition_stack" class="anchor field">§</a><code>condition_stack: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.ConditionalContext.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::ConditionalContext">ConditionalContext</a>&gt;</code></span><div class="docblock"><p>A stack of each jmpif condition that was taken to reach a particular point in the program.
When two branches are merged back into one, this constitutes a join point, and is analogous
to the rest of the program after an if statement. When such a join point / end block is
found, the top of this conditions stack is popped since we are no longer under that
condition. If we are under multiple conditions (a nested if), the topmost condition is
the most recent condition combined with all previous conditions via <code>And</code> instructions.</p>
</div><span id="structfield.next_arguments" class="structfield section-header"><a href="#structfield.next_arguments" class="anchor field">§</a><code>next_arguments: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;&gt;</code></span><div class="docblock"><p>Arguments prepared by the last inlined block for the next block we are about to process.</p>
</div><span id="structfield.local_allocations" class="structfield section-header"><a href="#structfield.local_allocations" class="anchor field">§</a><code>local_allocations: FxHashSet&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</code></span><div class="docblock"><p>Stores all allocations local to the current branch.</p>
<p>Since these are local to the current branch (i.e. only defined within one branch of
an if expression), they should not be merged with their previous value or stored value in
the other branch since there is no such value.</p>
<p>The <code>ValueId</code> here is that which is returned by the allocate instruction.</p>
</div><span id="structfield.not_instructions" class="structfield section-header"><a href="#structfield.not_instructions" class="anchor field">§</a><code>not_instructions: FxHashMap&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>, <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</code></span><div class="docblock"><p>A map from <code>cond</code> to <code>Not(cond)</code>.</p>
<p><code>Not</code> instructions are inserted constantly by this pass and this map helps keep
us from unnecessarily inserting extra instructions, and keeps IDs unique which
helps simplifications.</p>
</div><span id="structfield.no_predicate" class="structfield section-header"><a href="#structfield.no_predicate" class="anchor field">§</a><code>no_predicate: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></code></span><div class="docblock"><p>Flag to tell the context to not issue ‘enable_side_effect’ instructions during flattening.</p>
<p>It is set with an attribute when defining a function that cannot fail whatsoever to avoid
the overhead of handling side effects.</p>
<p>It can also be set to true when no instruction is known to fail.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'_%3E" class="impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/basic_conditional.rs.html#323-439">Source</a><a href="#impl-Context%3C'_%3E" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'_&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.flatten_single_conditional" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/basic_conditional.rs.html#342-413">Source</a><h4 class="code-header">fn <a href="#method.flatten_single_conditional" class="fn">flatten_single_conditional</a>(
    &amp;mut self,
    conditional: &amp;<a class="struct" href="../basic_conditional/struct.BasicConditional.html" title="struct noirc_evaluator::ssa::opt::basic_conditional::BasicConditional">BasicConditional</a>,
    no_predicates: &amp;mut HashMap&lt;<a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Flattens a single basic conditional by inlining the 2 branches into the entry block.</p>
<p>This method transforms a conditional control flow pattern (if-then-else) into straight-line code
by merging the entry, then, else, and exit blocks. The conditional logic is converted into
predicated operations using cast and multiplication operations to select between branch values.
The method is adapted from <code>flatten_cfg</code>, tailored to do flatten only the input conditional.</p>
<h5 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h5>
<ul>
<li><code>conditional</code> - The basic conditional structure to flatten</li>
<li><code>no_predicates</code> - Map of function IDs to their no_predicates attribute</li>
</ul>
<h5 id="implementation-details"><a class="doc-anchor" href="#implementation-details">§</a>Implementation Details</h5>
<ul>
<li>Sets up context state (target_block, no_predicate) to enable proper inlining</li>
<li>Inlines each block’s instructions into the entry block</li>
<li>Handles terminators to manage control flow during inlining</li>
<li>Uses a WorkList to track which blocks need processing</li>
<li>Copies the exit block’s terminator to the entry block after inlining</li>
<li>Restores original context state after completion</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_block_with_mapping" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/basic_conditional.rs.html#425-438">Source</a><h4 class="code-header">fn <a href="#method.map_block_with_mapping" class="fn">map_block_with_mapping</a>(
    mapping: HashMap&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>, <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    func: &amp;mut <a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
)</h4></section></summary><div class="docblock"><p>Applies value mappings to all instructions and terminators in a block.</p>
<p>This method rewrites a block by replacing old value IDs with their mapped equivalents
according to the provided mapping. This is used to propagate value simplifications
from conditional flattening throughout the rest of the function.</p>
<h5 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h5>
<ul>
<li><code>mapping</code> - HashMap mapping old ValueIds to their simplified/replaced ValueIds</li>
<li><code>func</code> - The function containing the block to update</li>
<li><code>block</code> - The BasicBlockId of the block to remap</li>
</ul>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Context%3C'f%3E" class="impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#335-1064">Source</a><a href="#impl-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section></summary><div class="impl-items"><section id="method.new" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#336-353">Source</a><h4 class="code-header">pub(crate) fn <a href="#method.new" class="fn">new</a>(
    function: &amp;'f mut <a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    cfg: <a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
    branch_ends: HashMap&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>, <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;,
    target_block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
) -&gt; Self</h4></section><details class="toggle method-toggle" open><summary><section id="method.flatten" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#374-384">Source</a><h4 class="code-header">pub(crate) fn <a href="#method.flatten" class="fn">flatten</a>(&amp;mut self, no_predicates: &amp;HashMap&lt;<a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>&gt;)</h4></section></summary><div class="docblock"><p>Flatten the CFG by inlining all instructions from the queued blocks
until all blocks have been flattened.</p>
<p>We follow the terminator of each block to determine which blocks to process next:</p>
<ul>
<li>If the terminator is a ‘JumpIf’, we assume we are entering a conditional statement and
add the start blocks of the ‘then_branch’, ‘else_branch’ and the ‘exit’ block to the queue.</li>
<li>Other blocks will have only one successor, so we will process them iteratively,
until we reach one block already in the queue, added when entering a conditional statement,
i.e. the ‘else_branch’ or the ‘exit’. In that case we switch to the next block in the queue,
instead of the successor.</li>
</ul>
<p>This process ensures that the blocks are always processed in this order:</p>
<ul>
<li>if_entry -&gt; then_branch -&gt; else_branch -&gt; exit</li>
</ul>
<p>In case of nested if statements, for instance in the ‘then_branch’, it will be:</p>
<ul>
<li>if_entry -&gt; then_branch -&gt; if_entry_2 -&gt; then_branch_2 -&gt; exit_2 -&gt; else_branch -&gt; exit</li>
</ul>
<p>Information about the nested if statements is stored in the ‘condition_stack’ which
is popped/pushed when entering/leaving a conditional statement.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.link_condition" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#388-397">Source</a><h4 class="code-header">fn <a href="#method.link_condition" class="fn">link_condition</a>(&amp;mut self, condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>) -&gt; <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a></h4></section></summary><div class="docblock"><p>Returns the updated condition so that
it is ‘AND-ed’ with the previous condition (if any)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_last_condition" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#405-410">Source</a><h4 class="code-header">fn <a href="#method.get_last_condition" class="fn">get_last_condition</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the current condition</p>
<p>The conditions are in a stack, they are added as conditional branches are encountered
so the last one is the current condition.
When processing a conditional branch, we first follow the ‘then’ branch and only after we
process the ‘else’ branch. At that point, the <code>ConditionalContext</code> has the ‘else_branch’</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_call_to_no_predicate_function" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#413-424">Source</a><h4 class="code-header">fn <a href="#method.is_call_to_no_predicate_function" class="fn">is_call_to_no_predicate_function</a>(
    &amp;self,
    no_predicates: &amp;HashMap&lt;<a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>&gt;,
    instruction: &amp;<a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a>&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Use the provided map to say if the instruction is a call to a <code>no_predicates</code> function</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prepare_args" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#429-433">Source</a><h4 class="code-header">fn <a href="#method.prepare_args" class="fn">prepare_args</a>(&amp;mut self, args: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;)</h4></section></summary><div class="docblock"><p>Prepare the arguments for the next block to consume.</p>
<p>Panics if we already have something prepared.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.consume_args" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#438-440">Source</a><h4 class="code-header">fn <a href="#method.consume_args" class="fn">consume_args</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Consume the arguments prepared by the previous block.</p>
<p>Panics if there was nothing prepared.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inline_block" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#447-483">Source</a><h4 class="code-header">pub(crate) fn <a href="#method.inline_block" class="fn">inline_block</a>(
    &amp;mut self,
    block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    no_predicates: &amp;HashMap&lt;<a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Inline all instructions from the given block into the target block, and track slice capacities.
This is done by processing every instruction in the block and using the flattening context
to push them in the target block.</p>
<ul>
<li><code>no_predicates</code> indicates which functions have no predicates and for which we disable the handling of side effects.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_terminator" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#500-556">Source</a><h4 class="code-header">pub(crate) fn <a href="#method.handle_terminator" class="fn">handle_terminator</a>(
    &amp;mut self,
    block: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    work_list: &amp;IndexSet&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the list of blocks that need to be processed after the given block,
and prepare any arguments for the next-to-be-inlined block to consume.</p>
<p>For a normal block, it would be its successor.</p>
<p>For blocks related to a conditional statement, we ensure to process
the ‘then_branch’, then the ‘else_branch’ (if it exists), and finally the exit block.</p>
<p>The update of the context is done by the functions <code>if_start</code>, <code>then_stop</code> and <code>else_stop</code>
which perform the business logic when entering a conditional statement, finishing the ‘then_branch’
and the ‘else_branch’, respectively.</p>
<p>We know if a block is related to the conditional statement if is referenced by the <code>work_list</code>.
Indeed, the start blocks of the ‘then_branch’ and ‘else_branch’ are added to the <code>work_list</code> when
starting to process a conditional statement.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.if_start" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#563-603">Source</a><h4 class="code-header">fn <a href="#method.if_start" class="fn">if_start</a>(
    &amp;mut self,
    condition: &amp;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    then_destination: &amp;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    else_destination: &amp;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    if_entry: &amp;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;</h4></section></summary><div class="docblock"><p>Process a conditional statement by creating a <code>ConditionalContext</code>
with information about the branch, and storing it in the dedicated stack.
Local allocations are moved to the ‘then_branch’ of the <code>ConditionalContext</code>.
Returns the blocks corresponding to the ‘then_branch’, ‘else_branch’,
and exit block of the conditional statement, so that they will be processed in this order.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.then_stop" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#610-631">Source</a><h4 class="code-header">fn <a href="#method.then_stop" class="fn">then_stop</a>(&amp;mut self, block: &amp;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>)</h4></section></summary><div class="docblock"><p>Switch context to the ‘else_branch’:</p>
<ul>
<li>Negates the condition for the ‘else_branch’ and set it in the <code>ConditionalContext</code></li>
<li>Move the local allocations to the ‘else_branch’</li>
<li>Reset the predicated values to their old mapping in the inserter</li>
<li>Issues the ‘enable_side_effect’ instruction</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.not_instruction" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#634-642">Source</a><h4 class="code-header">fn <a href="#method.not_instruction" class="fn">not_instruction</a>(
    &amp;mut self,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a></h4></section></summary><div class="docblock"><p>Negates a boolean value by inserting a Not instruction</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.else_stop" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#649-681">Source</a><h4 class="code-header">fn <a href="#method.else_stop" class="fn">else_stop</a>(&amp;mut self, block: &amp;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>)</h4></section></summary><div class="docblock"><p>Switch context the ‘exit’ block of a conditional statement:</p>
<ul>
<li>Retrieves the local allocations from the Conditional Context</li>
<li>Reset the predicated values to their old mapping in the inserter</li>
<li>Issues the ‘enable_side_effect’ instruction</li>
<li>Joins the arguments from both branches</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inline_branch_end" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#692-739">Source</a><h4 class="code-header">fn <a href="#method.inline_branch_end" class="fn">inline_branch_end</a>(
    &amp;mut self,
    destination: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    cond_context: <a class="struct" href="struct.ConditionalContext.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::ConditionalContext">ConditionalContext</a>,
)</h4></section></summary><div class="docblock"><p>Inline the ending block of a branch, the point where all blocks from a jmpif instruction
join back together. In particular this function must handle merging block arguments from
all of the join point’s predecessors, and it must handle any differing side effects from
each branch.</p>
<p>The merge of arguments is done by inserting an ‘IfElse’ instructions which returns
the argument from the ‘then_branch’ or the ‘else_branch’ depending the the condition.</p>
<p>The arguments are prepared for the destination to consume in the next immediate inlining.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.predicate_value" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#743-752">Source</a><h4 class="code-header">fn <a href="#method.predicate_value" class="fn">predicate_value</a>(&amp;mut self, value: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>, predicated_value: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>)</h4></section></summary><div class="docblock"><p>Map the value to its predicated value in the current conditional context, and store the previous mapping
to the ‘predicated_values’ map if not already stored.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_predicated_values" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#755-759">Source</a><h4 class="code-header">fn <a href="#method.reset_predicated_values" class="fn">reset_predicated_values</a>(
    &amp;mut self,
    conditional_context: &amp;mut <a class="struct" href="struct.ConditionalContext.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::ConditionalContext">ConditionalContext</a>,
)</h4></section></summary><div class="docblock"><p>Restore the previous mapping of predicated values after a branch is finished.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert_instruction" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#764-771">Source</a><h4 class="code-header">fn <a href="#method.insert_instruction" class="fn">insert_instruction</a>(
    &amp;mut self,
    instruction: <a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a></h4></section></summary><div class="docblock"><p>Insert a new instruction into the target block.
Unlike push_instruction, this function will not map any ValueIds.
within the given instruction, nor will it modify self.values in any way.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert_instruction_with_typevars" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#777-790">Source</a><h4 class="code-header">fn <a href="#method.insert_instruction_with_typevars" class="fn">insert_instruction_with_typevars</a>(
    &amp;mut self,
    instruction: <a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a>,
    ctrl_typevars: <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="../../ir/types/enum.Type.html" title="enum noirc_evaluator::ssa::ir::types::Type">Type</a>&gt;&gt;,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="enum" href="../../ir/dfg/enum.InsertInstructionResult.html" title="enum noirc_evaluator::ssa::ir::dfg::InsertInstructionResult">InsertInstructionResult</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Inserts a new instruction into the target block, using the given
control type variables to specify result types if needed.
Unlike push_instruction, this function will not map any ValueIds.
within the given instruction, nor will it modify self.values in any way.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.insert_current_side_effects_enabled" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#797-810">Source</a><h4 class="code-header">fn <a href="#method.insert_current_side_effects_enabled" class="fn">insert_current_side_effects_enabled</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Checks the branch condition on the top of the stack and uses it to build and insert an
<code>EnableSideEffectsIf</code> instruction into the target block.</p>
<p>If the stack is empty, a “true” u1 constant is taken to be the active condition. This is
necessary for re-enabling side-effects when re-emerging to a branch depth of 0.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_instruction" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#818-836">Source</a><h4 class="code-header">fn <a href="#method.push_instruction" class="fn">push_instruction</a>(&amp;mut self, id: <a class="struct" href="../../ir/map/struct.Id.html" title="struct noirc_evaluator::ssa::ir::map::Id">Id</a>&lt;<a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a>&gt;)</h4></section></summary><div class="docblock"><p>Push the given instruction to the end of the target block of the current function.</p>
<p>Note that each ValueId of the instruction will be mapped via <code>self.inserter.resolve</code>.
As a result, the instruction that will be pushed will actually be a new instruction
with a different InstructionId from the original. The results of the given instruction
will also be mapped to the results of the new instruction.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_instruction_side_effects" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#843-921">Source</a><h4 class="code-header">fn <a href="#method.handle_instruction_side_effects" class="fn">handle_instruction_side_effects</a>(
    &amp;mut self,
    instruction: <a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="enum" href="../../ir/instruction/enum.Instruction.html" title="enum noirc_evaluator::ssa::ir::instruction::Instruction">Instruction</a></h4></section></summary><div class="docblock"><p>If we are currently in a branch, we need to modify instructions that have side effects
(e.g. constraints, stores, range checks) to ensure that the side effect is only applied
if their branch is taken.</p>
<p>For instance we multiply constrain instructions by the branch’s condition (see optimization #1 in the module comment).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_call_side_effects" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#924-941">Source</a><h4 class="code-header">fn <a href="#method.handle_call_side_effects" class="fn">handle_call_side_effects</a>(
    &amp;mut self,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    func: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    arguments: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Weave the <code>condition</code> into call arguments, returning the modified arguments.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_intrinsic_side_effects" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#944-988">Source</a><h4 class="code-header">fn <a href="#method.handle_intrinsic_side_effects" class="fn">handle_intrinsic_side_effects</a>(
    &amp;mut self,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    intrinsic: <a class="enum" href="../../ir/instruction/enum.Intrinsic.html" title="enum noirc_evaluator::ssa::ir::instruction::Intrinsic">Intrinsic</a>,
    arguments: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Weave the <code>condition</code> into intrinsic call arguments, returning the modified arguments.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_blackbox_side_effects" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#991-1031">Source</a><h4 class="code-header">fn <a href="#method.handle_blackbox_side_effects" class="fn">handle_blackbox_side_effects</a>(
    &amp;mut self,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    blackbox: BlackBoxFunc,
    arguments: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Weave the <code>condition</code> into blackbox call arguments, returning the modified arguments.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cast_condition_to_value_type" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#1039-1048">Source</a><h4 class="code-header">fn <a href="#method.cast_condition_to_value_type" class="fn">cast_condition_to_value_type</a>(
    &amp;mut self,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    value: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a></h4></section></summary><div class="docblock"><p>‘Cast’ the ‘condition’ to ‘value’ type</p>
<p>This is needed because we need to multiply the condition with several values
in order to ‘nullify’ side-effects when the ‘condition’ is false (in ‘handle_instruction_side_effects’ function).</p>
<p>Since the condition is a boolean, it can be safely casted to any other type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mul_by_condition" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/flatten_cfg.rs.html#1051-1063">Source</a><h4 class="code-header">fn <a href="#method.mul_by_condition" class="fn">mul_by_condition</a>(
    &amp;mut self,
    value: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    condition: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
    call_stack: <a class="struct" href="../../../../noirc_errors/call_stack/struct.CallStackId.html" title="struct noirc_errors::call_stack::CallStackId">CallStackId</a>,
) -&gt; <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a></h4></section></summary><div class="docblock"><p>Insert a multiplication between ‘condition’ and ‘value’</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Context%3C'f%3E" class="impl"><a href="#impl-Freeze-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section><section id="impl-RefUnwindSafe-for-Context%3C'f%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section><section id="impl-Send-for-Context%3C'f%3E" class="impl"><a href="#impl-Send-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section><section id="impl-Sync-for-Context%3C'f%3E" class="impl"><a href="#impl-Sync-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section><section id="impl-Unpin-for-Context%3C'f%3E" class="impl"><a href="#impl-Unpin-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section><section id="impl-UnwindSafe-for-Context%3C'f%3E" class="impl"><a href="#impl-UnwindSafe-for-Context%3C'f%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'f&gt; !<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Context.html" title="struct noirc_evaluator::ssa::opt::flatten_cfg::Context">Context</a>&lt;'f&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.18.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.18.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#807-809">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#811">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#814">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#792-794">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#796">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#799">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="crate::dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details></div></section></div></main></body></html>