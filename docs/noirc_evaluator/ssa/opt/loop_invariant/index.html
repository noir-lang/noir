<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The loop invariant code motion (LICM) pass performs two related optimizations:"><title>noirc_evaluator::ssa::opt::loop_invariant - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module loop_<wbr>invariant</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a><ul><li><a href="#simplification-from-loop-bounds" title="Simplification from Loop Bounds">Simplification from Loop Bounds</a></li></ul></li><li><a href="#preconditions" title="Preconditions">Preconditions</a></li><li><a href="#post-conditions" title="Post-conditions">Post-conditions</a></li><li><a href="#acir-vs-brillig" title="ACIR vs Brillig">ACIR vs Brillig</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In noirc_<wbr>evaluator::<wbr>ssa::<wbr>opt</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">noirc_evaluator</a>::<wbr><a href="../../index.html">ssa</a>::<wbr><a href="../index.html">opt</a></span><h1>Module <span>loop_invariant</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/noirc_evaluator/ssa/opt/loop_invariant.rs.html#1-3634">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The loop invariant code motion (LICM) pass performs two related optimizations:</p>
<ol>
<li>Loop-Invariant Code Motion: Moves computations that produce the same result
on every iteration out of the loop and into its pre-header.</li>
<li>Loop-Bounds Simplification: Simplifies computations inside the loop body
using information derived from induction variables and loop bounds. This optimization
is essentially constant folding using induction variables.</li>
</ol>
<h3 id="design"><a class="doc-anchor" href="#design">Â§</a>Design</h3>
<p>To identify a loop invariant, check whether all of an instructionâ€™s values are:</p>
<ul>
<li>Outside of the loop</li>
<li>Constant</li>
<li>Already marked as loop invariants</li>
</ul>
<p>If we know that an invariant will always be executed (a loopâ€™s bounds are not dynamic and the upper bound is greater than its lower bounds)
we then hoist that invariant into the loop pre-header.</p>
<p>We also check that we are not hoisting instructions with side effects.
However, there are certain instructions whose side effects are only activated
under a predicate (e.g. an array out of bounds error on a dynamic index).
Thus, we also track the control dependence of loop blocks to determine
whether these â€œpure with predicate instructionsâ€ can be hoisted.
We use post-dominance frontiers to determine control dependence.</p>
<p>Letâ€™s look at definition 3 from the following paper:
Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. 1987.
The program dependence graph and its use in optimization. ACM
Trans. Program. Lang. Syst. 9, 3 (July 1987), 319â€“349.
<a href="https://doi.org/10.1145/24039.24041">https://doi.org/10.1145/24039.24041</a></p>
<div class="example-wrap"><pre class="language-text"><code>Let G be a control flow graph. Let X and Y be nodes in G. Y is
control dependent on X iff
(1) there exists a directed path P from X to Y with any Z in P (excluding X and Y) post-dominated by Y, and
(2) X is not post-dominated by Y.

If Y is control dependent on X then X must have two exits. Following one of the
exits from X always results in Y being executed, while taking the other exit may
result in Y not being executed.</code></pre></div>
<p>Verifying these conditions for every loop block would be quite inefficient.
For example, letâ€™s say we just want to check whether a given loop block is control dependent at all
after the loop preheader. We would have to to verify the conditions above for every block between the loop preheader
and the given loop block. This is n^2 complexity in the worst case.
To optimize the control dependence checks, we can use post-dominance frontiers (PDF).</p>
<p>From Cooper, Keith D. et al. â€œA Simple, Fast Dominance Algorithm.â€ (1999).</p>
<div class="example-wrap"><pre class="language-text"><code>A dominance frontier is the set of all CFG nodes, y, such that
b dominates a predecessor of y but does not strictly dominate y.</code></pre></div>
<p>Reversing this for post-dominance we can see that the conditions for control dependence
are the same as those for post-dominance frontiers: the post-dominance frontier of a block Y
is the set of blocks closest to Y where a choice was made of whether to reach Y or not.</p>
<p>Thus, we rewrite our control dependence condition as Y is control dependent on X iff X is in PDF(Y).</p>
<p>We then can store the PDFs for every block as part of the context of this pass, and use it for checking control dependence.
Using PDFs gets us from a worst case n^2 complexity to a worst case n.</p>
<h4 id="simplification-from-loop-bounds"><a class="doc-anchor" href="#simplification-from-loop-bounds">Â§</a>Simplification from Loop Bounds</h4>
<p>We analyze induction variables and loop bounds to simplify instructions.</p>
<ul>
<li>Replacing conditions with constants when bounds make the condition always true/false.</li>
<li>Simplifying arithmetic expressions involving induction variables (e.g., comparisons against loop bounds)</li>
</ul>
<p>Simplification is attempted before hoisting. This maximizes opportunities for
eliminating redundant computations entirely (by replacing them with constants),
and reduces the amount of code even considered for hoisting.</p>
<h3 id="preconditions"><a class="doc-anchor" href="#preconditions">Â§</a>Preconditions</h3>
<ul>
<li>The pass will only be run on loops with a single pre-header. If a loopâ€™s header has multiple predecessors,
the pass will skip that loop.</li>
</ul>
<h3 id="post-conditions"><a class="doc-anchor" href="#post-conditions">Â§</a>Post-conditions</h3>
<ul>
<li>All loop-invariant instructions that are safe to hoist are moved to the loop pre-header.</li>
<li>Instructions inside loops may be simplified if loop bounds or induction variable
constraints allow (e.g. replacing comparisons with constants).</li>
<li>Control dependence is respected: instructions whose effects depend on runtime conditions
remain in the loop unless proven safe for hoisting.</li>
</ul>
<h3 id="acir-vs-brillig"><a class="doc-anchor" href="#acir-vs-brillig">Â§</a>ACIR vs Brillig</h3>
<ul>
<li>On ACIR, LICM operates only on pure value computations.</li>
<li>On Brillig, additional reference-counting rules apply. For example, hoisting <a href="../../ir/instruction/enum.Instruction.html#variant.MakeArray" title="variant noirc_evaluator::ssa::ir::instruction::Instruction::MakeArray">Instruction::MakeArray</a>
requires inserting an <a href="../../ir/instruction/enum.Instruction.html#variant.IncrementRc" title="variant noirc_evaluator::ssa::ir::instruction::Instruction::IncrementRc">Instruction::IncrementRc</a> to preserve reference semantics if the array
may later be mutated.</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="simplify/index.html" title="mod noirc_evaluator::ssa::opt::loop_invariant::simplify">simplify</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BlockContext.html" title="struct noirc_evaluator::ssa::opt::loop_invariant::BlockContext">Block<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.LoopContext.html" title="struct noirc_evaluator::ssa::opt::loop_invariant::LoopContext">Loop<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Context with the scope of just one loop.</div></li><li><div class="item-name"><a class="struct" href="struct.LoopInvariantContext.html" title="struct noirc_evaluator::ssa::opt::loop_invariant::LoopInvariantContext">Loop<wbr>Invariant<wbr>Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Context with the scope of an entire function.</div></li><li><div class="item-name"><a class="struct" href="struct.PostDominanceFrontiers.html" title="struct noirc_evaluator::ssa::opt::loop_invariant::PostDominanceFrontiers">Post<wbr>Dominance<wbr>Frontiers</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CanBeHoistedResult.html" title="enum noirc_evaluator::ssa::opt::loop_invariant::CanBeHoistedResult">CanBe<wbr>Hoisted<wbr>Result</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Indicate whether an instruction can be hoisted.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.can_be_hoisted.html" title="fn noirc_evaluator::ssa::opt::loop_invariant::can_be_hoisted">can_<wbr>be_<wbr>hoisted</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Indicates if the instruction can be safely hoisted out of a loop.</div></li><li><div class="item-name"><a class="fn" href="fn.does_loop_execute.html" title="fn noirc_evaluator::ssa::opt::loop_invariant::does_loop_execute">does_<wbr>loop_<wbr>execute</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Check that a loop has have fixed bounds and upper is higher than lower, indicating that it would execute.</div></li><li><div class="item-name"><a class="fn" href="fn.get_induction_var_bounds.html" title="fn noirc_evaluator::ssa::opt::loop_invariant::get_induction_var_bounds">get_<wbr>induction_<wbr>var_<wbr>bounds</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Keep track of a loop induction variable and respective upper bound.</div></li><li><div class="item-name"><a class="fn" href="fn.get_induction_variable.html" title="fn noirc_evaluator::ssa::opt::loop_invariant::get_induction_variable">get_<wbr>induction_<wbr>variable</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Get and resolve the induction variable of a loop.</div></li></ul></section></div></main></body></html>