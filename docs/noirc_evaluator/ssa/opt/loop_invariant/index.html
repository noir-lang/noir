<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The loop invariant code motion (LICM) pass moves code from inside a loop to before the loop if that code will always have the same result on every iteration of the loop."><title>noirc_evaluator::ssa::opt::loop_invariant - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.8</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module loop_<wbr>invariant</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In noirc_<wbr>evaluator::<wbr>ssa::<wbr>opt</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">noirc_evaluator</a>::<wbr><a href="../../index.html">ssa</a>::<wbr><a href="../index.html">opt</a></span><h1>Module <span>loop_invariant</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/noirc_evaluator/ssa/opt/loop_invariant.rs.html#1-2878">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The loop invariant code motion (LICM) pass moves code from inside a loop to before the loop
if that code will always have the same result on every iteration of the loop.</p>
<p>To identify a loop invariant, check whether all of an instruction‚Äôs values are:</p>
<ul>
<li>Outside of the loop</li>
<li>Constant</li>
<li>Already marked as loop invariants</li>
</ul>
<p>We also check that we are not hoisting instructions with side effects.
However, there are certain instructions whose side effects are only activated
under a predicate (e.g. an array out of bounds error on a dynamic index).
Thus, we also track the control dependence of loop blocks to determine
whether these ‚Äúpure with predicate instructions‚Äù can be hoisted.
We use post-dominance frontiers to determine control dependence.</p>
<p>Let‚Äôs look at definition 3 from the following paper:
Jeanne Ferrante, Karl J. Ottenstein, and Joe D. Warren. 1987.
The program dependence graph and its use in optimization. ACM
Trans. Program. Lang. Syst. 9, 3 (July 1987), 319‚Äì349.
<a href="https://doi.org/10.1145/24039.24041">https://doi.org/10.1145/24039.24041</a></p>
<div class="example-wrap"><pre class="language-text"><code>Let G be a control flow graph. Let X and Y be nodes in G. Y is
control dependent on X iff
(1) there exists a directed path P from X to Y with any 2 in P (excluding X
and Y) post-dominated by Y and
(2) X is not post-dominated by Y.</code></pre></div>
<p>Verifying these conditions for every loop block would be quite inefficient.
For example, let‚Äôs say we just want to check whether a given loop block is control dependent at all
after the loop preheader. We would have to to verify the conditions above for every block between the loop preheader
and the given loop block. This is n^2 complexity in the worst case.
To optimize the control dependence checks, we can use post-dominance frontiers (PDF).</p>
<p>From Cooper, Keith D. et al. ‚ÄúA Simple, Fast Dominance Algorithm.‚Äù (1999).</p>
<div class="example-wrap"><pre class="language-text"><code>A dominance frontier is the set of all CFG nodes, y, such that
b dominates a predecessor of y but does not strictly dominate y.</code></pre></div>
<p>Reversing this for post-dominance we can see that the conditions for control dependence
are the same as those for post-dominance frontiers.
Thus, we rewrite our control dependence condition as Y is control dependent on X iff X is in PDF(Y).</p>
<p>We then can store the PDFs for every block as part of the context of this pass, and use it for checking control dependence.
Using PDFs gets us from a worst case n^2 complexity to a worst case n.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LoopInvariantContext.html" title="struct noirc_evaluator::ssa::opt::loop_invariant::LoopInvariantContext">Loop<wbr>Invariant<wbr>Context</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.can_be_hoisted.html" title="fn noirc_evaluator::ssa::opt::loop_invariant::can_be_hoisted">can_<wbr>be_<wbr>hoisted</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Indicates if the instruction can be safely hoisted out of a loop.
If <code>hoist_with_predicate</code> is set, we assume we‚Äôre hoisting the instruction
and its predicate, rather than just the instruction. Setting this means instructions that
rely on predicates can be hoisted as well.</div></li></ul></section></div></main></body></html>