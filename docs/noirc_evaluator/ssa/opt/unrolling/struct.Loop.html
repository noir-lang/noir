<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Describe the blocks that constitute up a loop."><title>Loop in noirc_evaluator::ssa::opt::unrolling - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="noirc_evaluator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../noirc_evaluator/index.html">noirc_<wbr>evaluator</a><span class="version">1.0.0-beta.18</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Loop</a></h2><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.back_edge_start" title="back_edge_start">back_edge_start</a></li><li><a href="#structfield.blocks" title="blocks">blocks</a></li><li><a href="#structfield.header" title="header">header</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.boilerplate_stats" title="boilerplate_stats">boilerplate_stats</a></li><li><a href="#method.count_all_instructions" title="count_all_instructions">count_all_instructions</a></li><li><a href="#method.count_induction_increments" title="count_induction_increments">count_induction_increments</a></li><li><a href="#method.count_loads_and_stores" title="count_loads_and_stores">count_loads_and_stores</a></li><li><a href="#method.find_blocks_in_loop" title="find_blocks_in_loop">find_blocks_in_loop</a></li><li><a href="#method.find_pre_header_reference_values" title="find_pre_header_reference_values">find_pre_header_reference_values</a></li><li><a href="#method.get_const_bounds" title="get_const_bounds">get_const_bounds</a></li><li><a href="#method.get_const_lower_bound" title="get_const_lower_bound">get_const_lower_bound</a></li><li><a href="#method.get_const_upper_bound" title="get_const_upper_bound">get_const_upper_bound</a></li><li><a href="#method.get_induction_variable" title="get_induction_variable">get_induction_variable</a></li><li><a href="#method.get_pre_header" title="get_pre_header">get_pre_header</a></li><li><a href="#method.has_const_back_edge_induction_value" title="has_const_back_edge_induction_value">has_const_back_edge_induction_value</a></li><li><a href="#method.has_const_zero_jump_condition" title="has_const_zero_jump_condition">has_const_zero_jump_condition</a></li><li><a href="#method.is_fully_executed" title="is_fully_executed">is_fully_executed</a></li><li><a href="#method.is_small_loop" title="is_small_loop">is_small_loop</a></li><li><a href="#method.unroll" title="unroll">unroll</a></li><li><a href="#method.unroll_header" title="unroll_header">unroll_header</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Loop" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Loop" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Loop" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Loop" title="Send">Send</a></li><li><a href="#impl-Sync-for-Loop" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Loop" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Loop" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Instrument-for-T" title="Instrument">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-Same-for-T" title="Same">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li><li><a href="#impl-WithSubscriber-for-T" title="WithSubscriber">WithSubscriber</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In noirc_<wbr>evaluator::<wbr>ssa::<wbr>opt::<wbr>unrolling</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">noirc_evaluator</a>::<wbr><a href="../../index.html">ssa</a>::<wbr><a href="../index.html">opt</a>::<wbr><a href="index.html">unrolling</a></span><h1>Struct <span class="struct">Loop</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#223-234">Source</a> </span></div><pre class="rust item-decl"><code>pub(crate) struct Loop {
    pub(crate) header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    pub(crate) back_edge_start: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    pub(crate) blocks: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/collections/btree/set/struct.BTreeSet.html" title="struct alloc::collections::btree::set::BTreeSet">BTreeSet</a>&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Describe the blocks that constitute up a loop.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.header" class="structfield section-header"><a href="#structfield.header" class="anchor field">§</a><code>header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a></code></span><div class="docblock"><p>The header block of a loop is the block which dominates all the
other blocks in the loop.</p>
</div><span id="structfield.back_edge_start" class="structfield section-header"><a href="#structfield.back_edge_start" class="anchor field">§</a><code>back_edge_start: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a></code></span><div class="docblock"><p>The start of the back_edge n -&gt; d is the block n at the end of
the loop that jumps back to the header block d which restarts the loop.</p>
</div><span id="structfield.blocks" class="structfield section-header"><a href="#structfield.blocks" class="anchor field">§</a><code>blocks: <a class="struct" href="https://doc.rust-lang.org/1.85.0/alloc/collections/btree/set/struct.BTreeSet.html" title="struct alloc::collections::btree::set::BTreeSet">BTreeSet</a>&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>&gt;</code></span><div class="docblock"><p>All the blocks contained within the loop, including <code>header</code> and <code>back_edge_start</code>.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Loop" class="impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/loop_invariant.rs.html#149-195">Source</a><a href="#impl-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.get_induction_variable" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/loop_invariant.rs.html#167-169">Source</a><h4 class="code-header">fn <a href="#method.get_induction_variable" class="fn">get_induction_variable</a>(&amp;self, function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;</h4></section></summary><div class="docblock"><p>Find the value that controls whether to perform a loop iteration.
This is going to be the block parameter of the loop header.</p>
<p>Consider the following example of a <code>for i in 0..4</code> loop:</p>
<div class="example-wrap"><pre class="language-text"><code>brillig(inline) fn main f0 {
  b0(v0: u32):
    ...
    jmp b1(u32 0)
  b1(v1: u32):                  // Loop header
    v5 = lt v1, u32 4           // Upper bound
    jmpif v5 then: b3, else: b2</code></pre></div>
<p>In the example above, <code>v1</code> is the induction variable.</p>
<p>There is an example in the tests where a loop does not have an induction variable,
but rather loads a reference in the header, in which case this will return <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_fully_executed" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/loop_invariant.rs.html#181-194">Source</a><h4 class="code-header">pub(super) fn <a href="#method.is_fully_executed" class="fn">is_fully_executed</a>(&amp;self, cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Check if the loop will be fully executed, that is, there is no early <code>break</code> in it.</p>
<p>Our SSA code generation restricts loops to having one exit block.
If the exit block has only one predecessor, that means there is no <code>break</code> in the loop.</p>
<p>If a loop can have several exit blocks, we would need to update this function.</p>
<p>If the loop header doesn’t lead to an exit block, then it must be a <code>loop</code> or <code>while</code>,
rather than a <code>for</code> loop. Even if such blocks don’t have a <code>break</code> (e.g. they are infinite),
we don’t consider them fully executed.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Loop-1" class="impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#305-855">Source</a><a href="#impl-Loop-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.find_blocks_in_loop" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#308-335">Source</a><h4 class="code-header">pub(crate) fn <a href="#method.find_blocks_in_loop" class="fn">find_blocks_in_loop</a>(
    header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    back_edge_start: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Return each block that is in a loop starting in the given header block.
Expects back_edge_start -&gt; header to be the back edge of the loop.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_const_back_edge_induction_value" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#358-368">Source</a><h4 class="code-header">fn <a href="#method.has_const_back_edge_induction_value" class="fn">has_const_back_edge_induction_value</a>(&amp;self, dfg: &amp;<a class="struct" href="../../ir/dfg/struct.DataFlowGraph.html" title="struct noirc_evaluator::ssa::ir::dfg::DataFlowGraph">DataFlowGraph</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Check that the loop does not end with a constant value passed to the header
from the back-edge, which would result in a loop we would never finish unrolling.</p>
<p>This can happen if constant folding replaces a variable with a constant it is
constrained to equal (which doesn’t even have to fall into the loop bounds).</p>
<p>For example:</p>
<div class="example-wrap"><pre class="language-text"><code>brillig(inline) predicate_pure fn main f0 {
  b0():
    jmp b1(u32 1)                // Pre-header
  b1(v0: u32):                   // Header
    v3 = lt v0, u32 20
    jmpif v3 then: b2, else: b3
  b2():                          // Back edge
    constrain v0 == u32 1        // Constrain the induction variable to a known value.
    jmp b1(u32 2)                // `v1 = unchecked_add v0, u32 1; jmp b1(v1)` replaced by `jmp b1 (1+1)`
  b3():
    return
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.has_const_zero_jump_condition" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#389-398">Source</a><h4 class="code-header">fn <a href="#method.has_const_zero_jump_condition" class="fn">has_const_zero_jump_condition</a>(&amp;self, dfg: &amp;<a class="struct" href="../../ir/dfg/struct.DataFlowGraph.html" title="struct noirc_evaluator::ssa::ir::dfg::DataFlowGraph">DataFlowGraph</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Check if the loop header has a constant zero jump condition, which indicates an empty loop.</p>
<p>This can happen if a jump condition has been simplified out.</p>
<p>For example:</p>
<div class="example-wrap"><pre class="language-text"><code>brillig(inline) predicate_pure fn main f0 {
  b0():
    jmp b1(u32 10)               // Pre-header
  b1(v0: u32):                   // Header
    // v3 = lt v0, u32 0         // Simplified to `u1 0`
    jmpif u1 0 then: b2, else: b3
  b2():                          // Back edge
    v1 = unchecked_add v0, u32 1 // Increment induction value
    jmp b1(v1)
  b3():
    return
}</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_const_lower_bound" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#414-421">Source</a><h4 class="code-header">fn <a href="#method.get_const_lower_bound" class="fn">get_const_lower_bound</a>(
    &amp;self,
    dfg: &amp;<a class="struct" href="../../ir/dfg/struct.DataFlowGraph.html" title="struct noirc_evaluator::ssa::ir::dfg::DataFlowGraph">DataFlowGraph</a>,
    pre_header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../ir/integer/enum.IntegerConstant.html" title="enum noirc_evaluator::ssa::ir::integer::IntegerConstant">IntegerConstant</a>&gt;</h4></section></summary><div class="docblock"><p>Find the lower bound of the loop in the pre-header and return it
if it’s a numeric constant, which it will be if the previous SSA
steps managed to inline it.</p>
<p>Consider the following example of a <code>for i in 0..4</code> loop:</p>
<div class="example-wrap"><pre class="language-text"><code>brillig(inline) fn main f0 {
  b0(v0: u32):                  // Pre-header
    ...
    jmp b1(u32 0)               // Lower-bound
  b1(v1: u32):                  // Induction variable
    v5 = lt v1, u32 4
    jmpif v5 then: b3, else: b2</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_const_upper_bound" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#437-501">Source</a><h4 class="code-header">fn <a href="#method.get_const_upper_bound" class="fn">get_const_upper_bound</a>(
    &amp;self,
    dfg: &amp;<a class="struct" href="../../ir/dfg/struct.DataFlowGraph.html" title="struct noirc_evaluator::ssa::ir::dfg::DataFlowGraph">DataFlowGraph</a>,
    pre_header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../../ir/integer/enum.IntegerConstant.html" title="enum noirc_evaluator::ssa::ir::integer::IntegerConstant">IntegerConstant</a>&gt;</h4></section></summary><div class="docblock"><p>Find the upper bound of the loop in the loop header and return it
if it’s a numeric constant, which it will be if the previous SSA
steps managed to inline it.</p>
<p>Consider the following example of a <code>for i in 0..4</code> loop:</p>
<div class="example-wrap"><pre class="language-text"><code>brillig(inline) fn main f0 {
  b0(v0: u32):
    ...
    jmp b1(u32 0)
  b1(v1: u32):                  // Loop header
    v5 = lt v1, u32 4           // Upper bound
    jmpif v5 then: b3, else: b2</code></pre></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_const_bounds" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#504-512">Source</a><h4 class="code-header">pub(super) fn <a href="#method.get_const_bounds" class="fn">get_const_bounds</a>(
    &amp;self,
    dfg: &amp;<a class="struct" href="../../ir/dfg/struct.DataFlowGraph.html" title="struct noirc_evaluator::ssa::ir::dfg::DataFlowGraph">DataFlowGraph</a>,
    pre_header: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="enum" href="../../ir/integer/enum.IntegerConstant.html" title="enum noirc_evaluator::ssa::ir::integer::IntegerConstant">IntegerConstant</a>, <a class="enum" href="../../ir/integer/enum.IntegerConstant.html" title="enum noirc_evaluator::ssa::ir::integer::IntegerConstant">IntegerConstant</a>)&gt;</h4></section></summary><div class="docblock"><p>Get the lower and upper bounds of the loop if both are constant numeric values.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unroll" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#572-583">Source</a><h4 class="code-header">fn <a href="#method.unroll" class="fn">unroll</a>(
    &amp;self,
    function: &amp;mut <a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.unit.html">()</a>, CallStack&gt;</h4></section></summary><div class="docblock"><p>Unroll a single loop in the function.
Returns Ok(()) if it succeeded, Err(callstack) if it failed,
where the callstack indicates the location of the instruction
that could not be processed, or empty if such information was
not available.</p>
<p>Consider this example:</p>
<div class="example-wrap"><pre class="language-text"><code>main():
  v0 = 0
  v1 = 2
  jmp loop_entry(v0)
loop_entry(i: Field):
  v2 = lt i, v1
  jmpif v2, then: loop_body, else: loop_end</code></pre></div>
<p>The first step is to unroll the header by recognizing that jump condition
is a constant, which means it will go to <code>loop_body</code>:</p>
<div class="example-wrap"><pre class="language-text"><code>main():
  v0 = 0
  v1 = 2
  v2 = lt v0, v1
  // jmpif v2, then: loop_body, else: loop_end
  jmp dest: loop_body</code></pre></div>
<p>Following that we unroll the loop body, which is the next source, replace
the induction variable with the new value created in the body, and have
another go at the header.</p>
<div class="example-wrap"><pre class="language-text"><code>main():
  v0 = 0
  v1 = 2
  v2 = lt v0, v1
  v3 = ... body ...
  v4 = add v0, u32 1
  jmp loop_entry(v4)</code></pre></div>
<p>At the end we reach a point where the condition evaluates to 0 and we jump to the end.</p>
<div class="example-wrap"><pre class="language-text"><code>main():
  v0 = 0
  v1 = 2
  v2 = lt v0, v1
  v3 = ... body ...
  v4 = add u32 1, v0
  v5 = lt v4, v1
  v6 = ... body ...
  v7 = add v4, u32 1
  v8 = lt v7, v1
  jmp loop_end</code></pre></div>
<p>When e.g. <code>v8 = lt v7, v1</code> cannot be evaluated to a constant, the loop signals by returning <code>Err</code>
that a few SSA passes are required to evaluate and simplify these values.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_pre_header" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#588-607">Source</a><h4 class="code-header">pub(super) fn <a href="#method.get_pre_header" class="fn">get_pre_header</a>(
    &amp;self,
    function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>, CallStack&gt;</h4></section></summary><div class="docblock"><p>The loop pre-header is the block that comes before the loop begins. Generally a header block
is expected to have 2 predecessors: the pre-header and the final block of the loop which jumps
back to the beginning. Other predecessors can come from <code>break</code> or <code>continue</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unroll_header" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#612-680">Source</a><h4 class="code-header">fn <a href="#method.unroll_header" class="fn">unroll_header</a>&lt;'a&gt;(
    &amp;'a self,
    function: &amp;'a mut <a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    unroll_into: <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>,
    induction_value: <a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="struct.LoopIteration.html" title="struct noirc_evaluator::ssa::opt::unrolling::LoopIteration">LoopIteration</a>&lt;'a&gt;, <a class="type" href="../../ir/basic_block/type.BasicBlockId.html" title="type noirc_evaluator::ssa::ir::basic_block::BasicBlockId">BasicBlockId</a>)&gt;, CallStack&gt;</h4></section></summary><div class="docblock"><p>Unrolls the header block of the loop. This is the block that dominates all other blocks in the
loop and contains the jmpif instruction that lets us know if we should continue looping.
Returns Some((iteration context, loop_header_id)) if we should perform another iteration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_pre_header_reference_values" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#729-756">Source</a><h4 class="code-header">fn <a href="#method.find_pre_header_reference_values" class="fn">find_pre_header_reference_values</a>(
    &amp;self,
    function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.85.0/std/collections/hash/set/struct.HashSet.html" title="struct std::collections::hash::set::HashSet">HashSet</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Find all reference values which were allocated before the pre-header.</p>
<p>These are accessible inside the loop body, and they can be involved
in load/store operations that could be eliminated if we unrolled the
body into the pre-header.</p>
<p>Consider this loop:</p>
<div class="example-wrap"><pre class="language-text"><code>let mut sum = 0;
let mut arr = &amp;[];
for i in 0..3 {
    sum = sum + i;
    arr.push_back(sum)
}
sum</code></pre></div>
<p>The SSA has a load+store for the <code>sum</code> and a load+push for the <code>arr</code>:</p>
<div class="example-wrap"><pre class="language-text"><code>b0(v0: u32):
  v2 = allocate -&gt; &amp;mut u32     // reference allocated for `sum`
  store u32 0 at v2             // initial value for `sum`
  v4 = allocate -&gt; &amp;mut u32     // reference allocated for the length of `arr`
  store u32 0 at v4             // initial length of `arr`
  inc_rc [] of u32              // storage for `arr`
  v6 = allocate -&gt; &amp;mut [u32]   // reference allocated to point at the storage of `arr`
  store [] of u32 at v6         // initial value for the storage of `arr`
  jmp b1(u32 0)                 // start looping from 0
b1(v1: u32):                    // `i` induction variable
  v8 = lt v1, u32 3             // loop until 3
  jmpif v8 then: b3, else: b2
b3():
  v11 = load v2 -&gt; u32          // load `sum`
  v12 = add v11, v1             // add `i` to `sum`
  store v12 at v2               // store updated `sum`
  v13 = load v4 -&gt; u32          // load length of `arr`
  v14 = load v6 -&gt; [u32]        // load storage of `arr`
  v16, v17 = call vector_push_back(v13, v14, v12) -&gt; (u32, [u32]) // builtin to push, will store to storage and length references
  v19 = add v1, u32 1           // increase `arr`
  jmp b1(v19)                   // back-edge of the loop
b2():                           // after the loop
  v9 = load v2 -&gt; u32           // read final value of `sum`</code></pre></div>
<p>We won’t always find load <em>and</em> store ops (e.g. the push above doesn’t come with a store),
but it’s likely that mem2reg could eliminate a lot of the loads we can find, so we can
use this as an approximation of the gains we would see.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_loads_and_stores" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#761-782">Source</a><h4 class="code-header">fn <a href="#method.count_loads_and_stores" class="fn">count_loads_and_stores</a>(
    &amp;self,
    function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    refs: &amp;<a class="struct" href="https://doc.rust-lang.org/1.85.0/std/collections/hash/set/struct.HashSet.html" title="struct std::collections::hash::set::HashSet">HashSet</a>&lt;<a class="type" href="../../ir/value/type.ValueId.html" title="type noirc_evaluator::ssa::ir::value::ValueId">ValueId</a>&gt;,
) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>, <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Count the number of load and store instructions of specific variables in the loop.</p>
<p>Returns <code>(loads, stores)</code> in case we want to differentiate in the estimates.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_all_instructions" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#785-791">Source</a><h4 class="code-header">fn <a href="#method.count_all_instructions" class="fn">count_all_instructions</a>(&amp;self, function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Count the number of instructions in the loop, including the terminating jumps.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.count_induction_increments" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#796-811">Source</a><h4 class="code-header">fn <a href="#method.count_induction_increments" class="fn">count_induction_increments</a>(&amp;self, function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Count the number of increments to the induction variable.
It should be one, but it can be duplicated.
The increment should be in the block where the back-edge was found.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_small_loop" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#816-820">Source</a><h4 class="code-header">fn <a href="#method.is_small_loop" class="fn">is_small_loop</a>(&amp;self, function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>, cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Decide if this loop is small enough that it can be inlined in a way that the number
of unrolled instructions times the number of iterations would result in smaller bytecode
than if we keep the loops with their overheads.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.boilerplate_stats" class="method"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#824-854">Source</a><h4 class="code-header">fn <a href="#method.boilerplate_stats" class="fn">boilerplate_stats</a>(
    &amp;self,
    function: &amp;<a class="struct" href="../../ir/function/struct.Function.html" title="struct noirc_evaluator::ssa::ir::function::Function">Function</a>,
    cfg: &amp;<a class="struct" href="../../ir/cfg/struct.ControlFlowGraph.html" title="struct noirc_evaluator::ssa::ir::cfg::ControlFlowGraph">ControlFlowGraph</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.BoilerplateStats.html" title="struct noirc_evaluator::ssa::opt::unrolling::BoilerplateStats">BoilerplateStats</a>&gt;</h4></section></summary><div class="docblock"><p>Collect boilerplate stats if we can figure out the upper and lower bounds of the loop,
and the loop doesn’t have multiple back-edges from breaks and continues.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Loop" class="impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#222">Source</a><a href="#impl-Debug-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../../src/noirc_evaluator/ssa/opt/unrolling.rs.html#222">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.85.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Loop" class="impl"><a href="#impl-Freeze-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section><section id="impl-RefUnwindSafe-for-Loop" class="impl"><a href="#impl-RefUnwindSafe-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section><section id="impl-Send-for-Loop" class="impl"><a href="#impl-Send-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section><section id="impl-Sync-for-Loop" class="impl"><a href="#impl-Sync-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section><section id="impl-Unpin-for-Loop" class="impl"><a href="#impl-Unpin-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section><section id="impl-UnwindSafe-for-Loop" class="impl"><a href="#impl-UnwindSafe-for-Loop" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Loop.html" title="struct noirc_evaluator::ssa::opt::unrolling::Loop">Loop</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.85.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.85.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.85.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#767">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#770">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Instrument for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a class="fn">instrument</a>(self, span: Span) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided [<code>Span</code>], returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a class="fn">in_current_span</a>(self) -&gt; Instrumented&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="super::Span::current()">current</a> <a href="crate::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#750-752">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#760">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.85.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#34">Source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a class="src rightside" href="https://docs.rs/typenum/1.19.0/src/typenum/type_operators.rs.html#35">Source</a><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.19.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#807-809">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#811">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#814">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#792-794">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#796">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#799">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; WithSubscriber for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; WithDispatch&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/1.85.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a class="fn">with_current_subscriber</a>(self) -&gt; WithDispatch&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="dispatcher#setting-the-default-subscriber">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
[<code>WithDispatch</code>] wrapper. <a>Read more</a></div></details></div></details></div></section></div></main></body></html>