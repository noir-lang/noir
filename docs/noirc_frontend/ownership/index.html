<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module implements the “ownership analysis” compiler pass on the monomorphized AST. It is run after monomorphization and before SSA-gen. At this point the monomorphized AST has no polymorphic types and all functions are specialized into either constrained or unconstrained versions. This pass only operates on unconstrained functions since only Noir’s unconstrained runtime Brillig has any notion of cloning a value - specifically arrays with their brillig-only reference counts."><title>noirc_frontend::ownership - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="noirc_frontend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../noirc_frontend/index.html">noirc_<wbr>frontend</a><span class="version">1.0.0-beta.10</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module ownership</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate noirc_<wbr>frontend</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">noirc_frontend</a></span><h1>Module <span>ownership</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/noirc_frontend/ownership/mod.rs.html#1-432">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module implements the “ownership analysis” compiler pass on the
monomorphized AST. It is run after monomorphization and before SSA-gen.
At this point the monomorphized AST has no polymorphic types and all functions
are specialized into either constrained or unconstrained versions. This pass
only operates on unconstrained functions since only Noir’s unconstrained runtime Brillig
has any notion of cloning a value - specifically arrays with their brillig-only reference counts.</p>
<p>Note that this documentation may refer to cloning a value or incrementing an array’s reference
count. These operations are equivalent on arrays. Cloning may be applied to any value and only
increments the reference counts of any arrays contained within (but not behind references or
inside nested arrays). This document also focuses on arrays but all reference count operations
on arrays are also performed on slices.</p>
<p>Arrays in brillig have copy on write semantics which relies on us incrementing their
reference counts when they are shared in multiple places. Note that while Noir has references,
arrays can also be shared by value and we want to avoid clones when possible. This pass
clones arrays (increments their reference counts) in the following situations which roughly
correspond to where a <code>Copy</code> variable in Rust would be copied:</p>
<ul>
<li>Variables are copied on each use, except for the last use where they are moved.
<ul>
<li>If a variable’s last use is in a loop that it was not defined in, it is copied instead of moved.</li>
<li>The last use analysis isn’t sophisticated on struct fields. It will count <code>a.b</code> and <code>a.c</code>
both as uses of <code>a</code>. Even if both could conceptually be moved, only the last usage will be
moved and the first (say <code>a.b</code>) will still be cloned.</li>
</ul>
</li>
<li>Dereferences always clone.</li>
<li>Certain expressions will avoid cloning or delay where clones are performed:
<ul>
<li>Reference expressions <code>&amp;e</code> will not clone <code>e</code> but may still clone variables used within.
<ul>
<li>E.g. <code>&amp;foo.bar</code> will not clone but <code>&amp;foo(bar)</code> may still clone <code>foo</code> or <code>bar</code>.</li>
</ul>
</li>
<li>Dereferences will attempt to extract a field first if possible.
<ul>
<li>E.g. <code>(*self).b.c</code> is transformed to <code>*(self.b.c)</code> where the <code>*</code> operation also clones.</li>
</ul>
</li>
<li>Ordinary member access will also delay clones.
<ul>
<li>E.g. <code>self.b.c</code> is compiled as <code>self.b.c.clone()</code> over <code>self.clone().b.c</code></li>
</ul>
</li>
<li>Array indexing <code>a[i]</code> will avoid cloning <code>a</code>. The extracted element is always cloned.</li>
</ul>
</li>
</ul>
<p>Most of this logic is contained in this file except for the last use analysis which is in the
<code>last_uses</code> module. That module contains a separate pass run on each function before this pass
to find the last use of each local variable to identify where moves can occur.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="last_uses/index.html" title="mod noirc_frontend::ownership::last_uses">last_<wbr>uses</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">This module contains the last use analysis pass which is run on each function before
the ownership pass when the experimental ownership scheme is enabled. This pass does
not run without this experimental flag - and if it did its results would go unused.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Context.html" title="struct noirc_frontend::ownership::Context">Context</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.clone_expr.html" title="fn noirc_frontend::ownership::clone_expr">clone_<wbr>expr</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Adds a <code>.clone()</code> to the given expression.
Note that this method should be careful not to actually duplicate the given expression
so that we do not duplicate any side-effects.</div></li><li><div class="item-name"><a class="fn" href="fn.contains_array_or_str_type.html" title="fn noirc_frontend::ownership::contains_array_or_str_type">contains_<wbr>array_<wbr>or_<wbr>str_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.contains_index.html" title="fn noirc_frontend::ownership::contains_index">contains_<wbr>index</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.unwrap_tuple_type.html" title="fn noirc_frontend::ownership::unwrap_tuple_type">unwrap_<wbr>tuple_<wbr>type</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul></section></div></main></body></html>