<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module implements the â€œownership analysisâ€ compiler pass on the monomorphized AST. It is run after monomorphization and before SSA-gen. At this point the monomorphized AST has no polymorphic types and all functions are specialized into either constrained or unconstrained versions. This pass only operates on unconstrained functions since only Noirâ€™s unconstrained runtime Brillig has any notion of cloning a value - specifically arrays with their brillig-only reference counts."><title>noirc_frontend::ownership - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="noirc_frontend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../noirc_frontend/index.html">noirc_<wbr>frontend</a><span class="version">1.0.0-beta.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module ownership</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate noirc_<wbr>frontend</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">noirc_frontend</a></span><h1>Module <span>ownership</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/noirc_frontend/ownership/mod.rs.html#1-733">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module implements the â€œownership analysisâ€ compiler pass on the
monomorphized AST. It is run after monomorphization and before SSA-gen.
At this point the monomorphized AST has no polymorphic types and all functions
are specialized into either constrained or unconstrained versions. This pass
only operates on unconstrained functions since only Noirâ€™s unconstrained runtime Brillig
has any notion of cloning a value - specifically arrays with their brillig-only reference counts.</p>
<p>Note that this documentation may refer to cloning a value or incrementing an arrayâ€™s reference
count. These operations are equivalent on arrays. Cloning may be applied to any value and only
increments the reference counts of any arrays contained within (but not behind references or
inside nested arrays). This document also focuses on arrays but all reference count operations
on arrays are also performed on slices.</p>
<p>Arrays in brillig have copy on write semantics which relies on us incrementing their
reference counts when they are shared in multiple places. Note that while Noir has references,
arrays can also be shared by value and we want to avoid clones when possible. This pass
clones arrays (increments their reference counts) in the following situations:</p>
<ul>
<li>Function parameters:
<ul>
<li>Any arrays behind a mutable reference <code>&amp;mut [T; N]</code> will have their reference count
incremented iff there was already a prior array of the same type passed into the same
function. E.g. if there are two parameters of type <code>&amp;mut [Field; 3]</code> we increment only
the later. If there are 3 we increment the last two.
<ul>
<li>This applies within struct &amp; tuple types as well. If a function only takes 1 struct
parameter but that struct contains 2 or more mutable references to the same array
type, we increment the reference count of each instance of the type after the first.</li>
<li>In the case of references to nested arrays, only the outer array has its reference count incremented.</li>
</ul>
</li>
<li>Arrays taken by mutable value are always cloned, e.g. in <code>mut x: [u32; 3]</code>, <code>x</code> will
have its reference count incremented.</li>
</ul>
</li>
<li>Let bindings (<code>let _ = &lt;expression which returns an array&gt;;</code>):
<ul>
<li>Binding an array to a let binding increments the reference count of the array unless
the expression is an array literal in which case it is considered to be moved.</li>
</ul>
</li>
<li>Assignments (<code>x = &lt;expression which returns an array&gt;;</code>):
<ul>
<li>Similarly, assigning an array to an existing variable will also increment the reference
count of the array unless it is an array literal.</li>
</ul>
</li>
<li>Array literals:
<ul>
<li>Arrays stored inside a nested array literal (e.g. both variables in <code>[array1, array2]</code>
have their reference count incremented).</li>
<li>This does not apply to nested array literals since we know they are not referenced elsewhere.</li>
</ul>
</li>
<li>Extracting an array from another array (<code>let inner: [_; _] = array[0];</code>):
<ul>
<li>Extracting a nested array from its outer array will always increment the reference count
of the nested array.</li>
</ul>
</li>
</ul>
<p>Additionally we currently only decrement reference counts at the end of the function when
a parameter goes out of scope. These means reference counts likely trend upward over time
until the array is eventually mutated and it is reset back to 1.</p>
<p>â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” EXPERIMENTAL OWNERSHIP RULES â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”</p>
<p>This pass currently contains two sets of ownership rules. There is the current default set of
rules described above, and there is the set of rules enabled by <code>Context::experimental_ownership_feature</code>.
The experimental ownership rules aim to be less ad-hoc than the current rules with the goal of
making it easier for users to see where clones occur - and possibly forcing users to write
their own clones manually. These rules treat each variable roughly as a variable in Rust which
implements <code>Copy</code>:</p>
<ul>
<li>Variables are copied on each use, except for the last use where they are moved.
<ul>
<li>If a variableâ€™s last use is in a loop that it was not defined in, it is copied instead of moved.</li>
<li>The last use analysis isnâ€™t sophisticated on struct fields. It will count <code>a.b</code> and <code>a.c</code>
both as uses of <code>a</code>. Even if both could conceptually be moved, only the last usage will be
moved and the first (say <code>a.b</code>) will still be cloned.</li>
</ul>
</li>
<li>Dereferences always clone.</li>
<li>Certain expressions will avoid cloning or delay where clones are performed:
<ul>
<li>Reference expressions <code>&amp;e</code> will not clone <code>e</code> but may still clone variables used within.
<ul>
<li>E.g. <code>&amp;foo.bar</code> will not clone but <code>&amp;foo(bar)</code> may still clone <code>foo</code> or <code>bar</code>.</li>
</ul>
</li>
<li>Dereferences will attempt to extract a field first if possible.
<ul>
<li>E.g. <code>(*self).b.c</code> is transformed to <code>*(self.b.c)</code> where the <code>*</code> operation also clones.</li>
</ul>
</li>
<li>Ordinary member access will also delay clones.
<ul>
<li>E.g. <code>self.b.c</code> is compiled as <code>self.b.c.clone()</code> over <code>self.clone().b.c</code></li>
</ul>
</li>
<li>Array indexing <code>a[i]</code> will avoid cloning <code>a</code>. The extracted element is always cloned.</li>
</ul>
</li>
</ul>
<p>Most of this logic is contained in this file except for the last use analysis which is in the
<code>last_uses</code> module. That module contains a separate pass run on each function before this pass
to find the last use of each local variable to identify where moves can occur.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="last_uses/index.html" title="mod noirc_frontend::ownership::last_uses">last_<wbr>uses</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">This module contains the last use analysis pass which is run on each function before
the ownership pass when the experimental ownership scheme is enabled. This pass does
not run without this experimental flag - and if it did its results would go unused.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Context.html" title="struct noirc_frontend::ownership::Context">Context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.clone_expr.html" title="fn noirc_frontend::ownership::clone_expr">clone_<wbr>expr</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Adds a <code>.clone()</code> to the given expression.
Note that this method should be careful not to actually duplicate the given expression
so that we do not duplicate any side-effects.</div></li><li><div class="item-name"><a class="fn" href="fn.contains_array_or_str_type.html" title="fn noirc_frontend::ownership::contains_array_or_str_type">contains_<wbr>array_<wbr>or_<wbr>str_<wbr>type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.is_array_or_str_literal.html" title="fn noirc_frontend::ownership::is_array_or_str_literal">is_<wbr>array_<wbr>or_<wbr>str_<wbr>literal</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.recur_on_parameter.html" title="fn noirc_frontend::ownership::recur_on_parameter">recur_<wbr>on_<wbr>parameter</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">Recur on a parameterâ€™s type, digging into any struct fields, looking for references to arrays.
This will build up an Expression of the current parameter access weâ€™re doing, e.g. <code>*foo.bar</code>
would correspond to a parameter <code>foo</code> with struct field <code>bar</code> that is a reference to an array.</div></li><li><div class="item-name"><a class="fn" href="fn.unwrap_tuple_type.html" title="fn noirc_frontend::ownership::unwrap_tuple_type">unwrap_<wbr>tuple_<wbr>type</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li></ul></section></div></main></body></html>