<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Coming after elaboration, monomorphization is the last pass in Noirâ€™s frontend. It accepts the type checked HIR as input and produces a monomorphized AST as output. This file implements the pass itself, while the AST is defined in the ast module."><title>noirc_frontend::monomorphization - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="noirc_frontend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../noirc_frontend/index.html">noirc_<wbr>frontend</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module monomorphization</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate noirc_<wbr>frontend</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">noirc_frontend</a></span><h1>Module <span>monomorphization</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/noirc_frontend/monomorphization/mod.rs.html#1-3268">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Coming after elaboration, monomorphization is the last pass in Noirâ€™s frontend.
It accepts the type checked HIR as input and produces a monomorphized AST as output.
This file implements the pass itself, while the AST is defined in the ast module.</p>
<p>Unlike the HIR, which is stored within the NodeInterner, the monomorphized AST is
self-contained and does not need an external context struct. As a result, the NodeInterner
can be safely discarded after monomorphization.</p>
<p>The entry point to this pass is the <code>monomorphize</code> function which, starting from a given
function, will monomorphize the entire reachable program.</p>
<p>The monomorphized AST (mAST) has a few notable differences from the HIR:</p>
<ul>
<li>It is self-contained without the need for an external context like the NodeInterner.</li>
<li>All generics are gone, they are specialized away by creating a new copy of each function
for each combination of generic arguments it is used with.</li>
<li>All local lambdas are gone and closure environments are explicit. Closures are converted
into normal tuples of (function, environment) and when the function is called, will forward
the environment argument to the function as well. All functions are global and local lambdas
no longer exist.</li>
<li>Most patterns are simplified away. For example, a tuple pattern in a function parameter:
<code>fn foo((a, b): (i32, i32))</code> will be translated into separate parameters:
<code>fn foo(a: i32, b: i32)</code>. Note that this transformation relies on our SSA construction
pass to perform a similar translation for the callsites of functions. The monomorphized
output alone does not change callsites, so it will produce mAST like the following:<div class="example-wrap"><pre class="language-noir"><code>fn main$f0() -&gt; () {
    let tuple$l0 = (0, 1);
    foo$f1(tuple$l0);  // single tuple argument
}

fn foo$f1(a$l1: i32, b$l2: i32) -&gt; () {}  // two separate parameters</code></pre></div></li>
<li>Functions are represented as a pair of <code>(constrained, unconstrained)</code> versions of the same
function. The variant to use is selected by <code>Monomorphizer::extract_function</code> to match the
runtime when the function is later called.</li>
</ul>
<p>At the end of monomorphization, a couple sub-passes are performed:</p>
<ul>
<li><a href="../ownership/index.html" title="mod noirc_frontend::ownership">ownership</a>: infers when values should be cloned or moved for unconstrained code.
This is only relevant for arrays in unconstrained code which are implemented with copy on
write semantics. An <a href="ast/enum.Expression.html#variant.Clone" title="variant noirc_frontend::monomorphization::ast::Expression::Clone">ast::Expression::Clone</a> corresponds to an increment of the reference-count on
a particular array rather than a deep clone. The deep clone itself will be performed by the
Brillig runtime when mutating an array with a reference count greater than one.</li>
<li><a href="proxies/index.html" title="mod noirc_frontend::monomorphization::proxies">proxies</a>: wraps oracle functions in unconstrained function wrappers automatically.
This is required in some corner cases when oracles are used as first-class functions.</li>
</ul>
<p>Compared to monomorphization passes in other compilers, Noirâ€™s is a bit odd in that it may
still fail with an error message. An example of an error caught at this step would be
an unconstrained lambda being passed into and called in constrained code. This is possible
when a normal lambda is compiled in an unconstrained context and uses types, such as references,
which shouldnâ€™t leave the current context.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="ast/index.html" title="mod noirc_frontend::monomorphization::ast">ast</a></div></li><li><div class="item-name"><a class="mod" href="debug/index.html" title="mod noirc_frontend::monomorphization::debug">debug</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="debug_types/index.html" title="mod noirc_frontend::monomorphization::debug_types">debug_<wbr>types</a></div></li><li><div class="item-name"><a class="mod" href="errors/index.html" title="mod noirc_frontend::monomorphization::errors">errors</a></div></li><li><div class="item-name"><a class="mod" href="printer/index.html" title="mod noirc_frontend::monomorphization::printer">printer</a></div><div class="desc docblock-short">This module implements printing of the monomorphized AST, for debugging purposes.</div></li><li><div class="item-name"><a class="mod" href="proxies/index.html" title="mod noirc_frontend::monomorphization::proxies">proxies</a></div><div class="desc docblock-short">Implement a post-monomorphization pass where builtin/intrinsic/oracle functions used as values
are wrapped in a proxy function which replaces them as a value and forwards calls to them.</div></li><li><div class="item-name"><a class="mod" href="visitor/index.html" title="mod noirc_frontend::monomorphization::visitor">visitor</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LambdaContext.html" title="struct noirc_frontend::monomorphization::LambdaContext">Lambda<wbr>Context</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="struct" href="struct.Monomorphizer.html" title="struct noirc_frontend::monomorphization::Monomorphizer">Monomorphizer</a></div><div class="desc docblock-short">The context struct for the monomorphization pass.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.TraitItem.html" title="enum noirc_frontend::monomorphization::TraitItem">Trait<wbr>Item</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.append_printable_type_info_for_type.html" title="fn noirc_frontend::monomorphization::append_printable_type_info_for_type">append_<wbr>printable_<wbr>type_<wbr>info_<wbr>for_<wbr>type</a></div><div class="desc docblock-short">Extend the arguments to <code>print</code> (which is a <code>bool</code> to show if newline is needed and
value to be printed itself) with a JSON serialized <code>PrintableType</code> to describe the
value, and another <code>bool</code> to show if the print is using a format string, or a raw
value.</div></li><li><div class="item-name"><a class="fn" href="fn.append_printable_type_info_inner.html" title="fn noirc_frontend::monomorphization::append_printable_type_info_inner">append_<wbr>printable_<wbr>type_<wbr>info_<wbr>inner</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.bind_trait_impl_func_generics_to_trait_func_generics.html" title="fn noirc_frontend::monomorphization::bind_trait_impl_func_generics_to_trait_func_generics">bind_<wbr>trait_<wbr>impl_<wbr>func_<wbr>generics_<wbr>to_<wbr>trait_<wbr>func_<wbr>generics</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Binds direct generics on a trait impl function to those on a corresponding trait function.</div></li><li><div class="item-name"><a class="fn" href="fn.monomorphize.html" title="fn noirc_frontend::monomorphization::monomorphize">monomorphize</a></div><div class="desc docblock-short">Starting from the given <code>main</code> function, monomorphize the entire program,
replacing all references to type variables and NamedGenerics with concrete
types, duplicating definitions as necessary to do so.</div></li><li><div class="item-name"><a class="fn" href="fn.monomorphize_debug.html" title="fn noirc_frontend::monomorphization::monomorphize_debug">monomorphize_<wbr>debug</a></div><div class="desc docblock-short">A more general entry-point for the monomorphization pass containing an optional
<a href="../debug/struct.DebugInstrumenter.html" title="struct noirc_frontend::debug::DebugInstrumenter">DebugInstrumenter</a> which can be set to <a href="../debug/struct.DebugInstrumenter.html#method.default" title="associated function noirc_frontend::debug::DebugInstrumenter::default">DebugInstrumenter::default</a> in case it
is not desired. If debugging is desired, additional function calls will be inserted
to inspect values via debug functions.</div></li><li><div class="item-name"><a class="fn" href="fn.perform_impl_bindings.html" title="fn noirc_frontend::monomorphization::perform_impl_bindings">perform_<wbr>impl_<wbr>bindings</a></div><div class="desc docblock-short">Call sites are instantiated against the trait method, but when an impl is later selected,
the corresponding method in the impl will have a different set of generics. <code>perform_impl_bindings</code>
is needed to apply the generics from the trait method to the impl method. Without this,
static method references to generic impls (e.g. <code>Eq::eq</code> for <code>[T; N]</code>) will fail to re-apply
the correct type bindings during monomorphization.</div></li><li><div class="item-name"><a class="fn" href="fn.perform_instantiation_bindings.html" title="fn noirc_frontend::monomorphization::perform_instantiation_bindings">perform_<wbr>instantiation_<wbr>bindings</a></div></li><li><div class="item-name"><a class="fn" href="fn.resolve_trait_item.html" title="fn noirc_frontend::monomorphization::resolve_trait_item">resolve_<wbr>trait_<wbr>item</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.resolve_trait_item_impl.html" title="fn noirc_frontend::monomorphization::resolve_trait_item_impl">resolve_<wbr>trait_<wbr>item_<wbr>impl</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Resolve a trait item to a particular impl, returning the id of that impl or an error on failure.</div></li><li><div class="item-name"><a class="fn" href="fn.undo_instantiation_bindings.html" title="fn noirc_frontend::monomorphization::undo_instantiation_bindings">undo_<wbr>instantiation_<wbr>bindings</a></div></li><li><div class="item-name"><a class="fn" href="fn.unwrap_enum_type.html" title="fn noirc_frontend::monomorphization::unwrap_enum_type">unwrap_<wbr>enum_<wbr>type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Return this enum typeâ€™s variants or panic</div></li><li><div class="item-name"><a class="fn" href="fn.unwrap_struct_type.html" title="fn noirc_frontend::monomorphization::unwrap_struct_type">unwrap_<wbr>struct_<wbr>type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Return this struct typeâ€™s fields or panic</div></li><li><div class="item-name"><a class="fn" href="fn.unwrap_tuple_type.html" title="fn noirc_frontend::monomorphization::unwrap_tuple_type">unwrap_<wbr>tuple_<wbr>type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Return this tuple typeâ€™s fields or panic</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Functions.html" title="type noirc_frontend::monomorphization::Functions">Functions</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Using nested HashMaps here lets us avoid cloning HirTypes when calling .get()</div></li><li><div class="item-name"><a class="type" href="type.HirType.html" title="type noirc_frontend::monomorphization::HirType">HirType</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul></section></div></main></body></html>