<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Inherent type implementations collection and method declaration."><title>noirc_frontend::elaborator::impls - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="noirc_frontend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../noirc_frontend/index.html">noirc_<wbr>frontend</a><span class="version">1.0.0-beta.14</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module impls</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#design" title="Design">Design</a></li><li><a href="#cross-module-resolution-strategy" title="Cross Module Resolution Strategy">Cross Module Resolution Strategy</a><ul><li><a href="#example" title="Example:">Example:</a></li></ul></li><li><a href="#method-shadowing-and-specialization" title="Method Shadowing and Specialization">Method Shadowing and Specialization</a></li><li><a href="#restrictions" title="Restrictions">Restrictions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In noirc_<wbr>frontend::<wbr>elaborator</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">noirc_frontend</a>::<wbr><a href="../index.html">elaborator</a></span><h1>Module <span>impls</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/noirc_frontend/elaborator/impls.rs.html#1-252">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Inherent type implementations collection and method declaration.</p>
<p>This module handles the collection phase of impl blocks, where methods are declared
and registered in their appropriate modules. This is distinct from elaboration, where
method bodies are resolved and type-checked (which happens later through regular function
elaboration).</p>
<h3 id="design"><a class="doc-anchor" href="#design">§</a>Design</h3>
<p>The impl collection process occurs in several phases:</p>
<ol>
<li>
<p>Function metadata definition</p>
<ul>
<li>Resolves the impl’s self type (e.g., <code>impl Foo</code> → resolves <code>Foo</code> to a concrete type)</li>
<li>Collects function signatures for all methods in the impl block</li>
<li>This happens early so method signatures are available before bodies are elaborated</li>
</ul>
</li>
<li>
<p>Method declaration</p>
<ul>
<li>Declares methods in the struct’s module (not the impl’s module)</li>
<li>Handles method shadowing (inherent impls take precedence over trait impls)</li>
<li>Validates that impls are only defined for types in the current crate</li>
<li>This phase makes methods discoverable via <code>TypeName::method</code> syntax</li>
</ul>
</li>
<li>
<p>Method elaboration</p>
<ul>
<li>Elaborates method bodies using regular function elaboration</li>
<li>Type-checks method implementations</li>
<li>This is straightforward since methods are just functions with an implicit self parameter</li>
</ul>
</li>
</ol>
<h3 id="cross-module-resolution-strategy"><a class="doc-anchor" href="#cross-module-resolution-strategy">§</a>Cross Module Resolution Strategy</h3>
<p>Impl methods can be declared in one module but resolved in another.</p>
<ul>
<li>Declaration module: The struct’s defining module (where the type was defined)
<ul>
<li>Methods are added here so <code>TypeName::method</code> resolves correctly</li>
<li>This allows qualified method calls from anywhere with the right imports</li>
</ul>
</li>
<li>Resolution module: The impl block’s module (where the impl appears)
<ul>
<li>Names inside method bodies resolve in this scope</li>
<li>This determines what imports, types, and functions are visible to the method</li>
</ul>
</li>
</ul>
<h4 id="example"><a class="doc-anchor" href="#example">§</a>Example:</h4><div class="example-wrap"><pre class="language-noir"><code>// In module `types`:
struct Point { x: Field, y: Field }

// In module `methods`:
use crate::types::Point;
impl Point {
    fn distance(self) -&gt; Field {
        // This resolves names in `methods` module
        helper_function() // looks for helper_function in `methods`
    }
}</code></pre></div>
<ul>
<li><code>distance</code> is declared in the <code>types</code> module (with <code>Point</code>)</li>
<li><code>distance</code> body resolves names in the <code>methods</code> module</li>
<li>Users can call <code>Point::distance</code> if they import <code>Point</code></li>
</ul>
<h3 id="method-shadowing-and-specialization"><a class="doc-anchor" href="#method-shadowing-and-specialization">§</a>Method Shadowing and Specialization</h3>
<p>When multiple methods with the same name are declared:</p>
<ol>
<li>Inherent impls shadow trait impls: If both an inherent impl and a trait impl
define the same method, the inherent impl version takes precedence for qualified
calls like <code>Foo::method()</code>. The trait impl version is removed from the module scope
to prevent ambiguity.</li>
<li>Specialization: Multiple trait impls can define the same method if their
self types don’t overlap. The method is removed from module scope when a duplicate
is found, preventing qualified access. However, the methods are still registered
in the interner for dynamic dispatch. Overlap checking happens later during
trait resolution.</li>
</ol>
<h3 id="restrictions"><a class="doc-anchor" href="#restrictions">§</a>Restrictions</h3>
<ul>
<li>Foreign impl check: Inherent impls are only allowed on types defined in the
current crate. This prevents external crates from adding methods to your types.</li>
<li>Primitive type impls: Only the standard library can impl methods on primitive
types like <code>Field</code>, <code>bool</code>, <code>u32</code>, etc. User code cannot add methods to primitives.</li>
</ul>
</div></details></section></div></main></body></html>