<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Abstract Circuit Intermediate Representation (ACIR)"><title>acir::circuit - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="acir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../acir/index.html">acir</a><span class="version">1.0.0-beta.16</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module circuit</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-abstract-circuit-intermediate-representation-acir" title="The Abstract Circuit Intermediate Representation (ACIR)">The Abstract Circuit Intermediate Representation (ACIR)</a><ul><li><a href="#acir" title="ACIR">ACIR</a></li><li><a href="#the-constraint-model" title="The constraint model">The constraint model</a></li><li><a href="#solving" title="Solving">Solving</a></li><li><a href="#documentation" title="Documentation">Documentation</a></li></ul></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate acir</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">acir</a></span><h1>Module <span>circuit</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/acir/circuit/mod.rs.html#1-655">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="the-abstract-circuit-intermediate-representation-acir"><a class="doc-anchor" href="#the-abstract-circuit-intermediate-representation-acir">§</a>The Abstract Circuit Intermediate Representation (ACIR)</h2>
<p>The purpose of ACIR is to make the link between a generic proving system, such
as Aztec’s Barretenberg, and a frontend, such as Noir, which describes user
specific computations.</p>
<p>More precisely, Noir is a programming language for zero-knowledge proofs (ZKP)
which allows users to write programs in an intuitive way using a high-level
language close to Rust syntax. Noir is able to generate a proof of execution of
a Noir program, using an external proving system. However, proving systems use
specific low-level constrain-based languages. Similarly, frontends have their
own internal representation in order to represent user programs.</p>
<p>The goal of ACIR is to provide a generic open-source intermediate
representation close to proving system ‘languages’, but agnostic to a specific
proving system, that can be used both by proving system as well as a target for
frontends. So, at the end of the day, an ACIR program is just another
representation of a program, dedicated to proving systems.</p>
<h3 id="acir"><a class="doc-anchor" href="#acir">§</a>ACIR</h3>
<p>ACIR stands for Abstract Circuit Intermediate Representation:</p>
<ul>
<li><strong>abstract circuit</strong>: circuits are a simple computation model where basic
computation units, named gates, are connected with wires. Data flows
through the wires while gates compute output wires based on their input.
More formally, they are directed acyclic graphs (DAG) where the vertices
are the gates and the edges are the wires. Due to the immutability nature
of the wires (their value does not change during an execution), they are
well suited for describing computations for ZKPs. Furthermore, we do not
lose any expressiveness when using a circuit as it is well known that any
bounded computation can be translated into an arithmetic circuit (i.e a
circuit with only addition and multiplication gates).
The term abstract here simply means that we do not refer to an actual physical
circuit (such as an electronic circuit). Furthermore, we will not exactly use
the circuit model, but another model even better suited to ZKPs, the constraint
model (see below).</li>
<li><strong>intermediate representation</strong>: The ACIR representation is intermediate
because it lies between a frontend and its proving system. ACIR bytecode makes
the link between noir compiler output and the proving system backend input.</li>
</ul>
<h3 id="the-constraint-model"><a class="doc-anchor" href="#the-constraint-model">§</a>The constraint model</h3>
<p>The first step for generating a proof that a specific program was executed, is
to execute this program. Since the proving system is going to handle ACIR
programs, we need in fact to execute an ACIR program, using the user-supplied
inputs.</p>
<p>In ACIR terminology, the gates are called opcodes and the wires are called
partial witnesses. However, instead of connecting the opcodes together through
wires, we create constraints: an opcode constraints together a set of wires.
This constraint model trivially supersedes the circuit model. For instance, an
addition gate <code>output_wire = input_wire_1 + input_wire_2</code> can be expressed with
the following arithmetic constraint:
<code>output_wire - (input_wire_1 + input_wire_2) = 0</code></p>
<h3 id="solving"><a class="doc-anchor" href="#solving">§</a>Solving</h3>
<p>Because of these constraints, executing an ACIR program is called solving the
witnesses. From the witnesses representing the inputs of the program, whose
values are supplied by the user, we find out what the other witnesses should be
by executing/solving the constraints one-by-one in the order they were defined.</p>
<p>For instance, if <code>input_wire_1</code> and <code>input_wire_2</code> values are supplied as <code>3</code> and
<code>8</code>, then we can solve the opcode
<code>output_wire - (input_wire_1 + input_wire_2) = 0</code> by saying that <code>output_wire</code> is
<code>11</code>.</p>
<p>In summary, the workflow is the following:</p>
<ol>
<li>user program -&gt; (compilation) ACIR, a list of opcodes which constrain
(partial) witnesses</li>
<li>user inputs + ACIR -&gt; (execution/solving) assign values to all the
(partial) witnesses</li>
<li>witness assignment + ACIR -&gt; (proving system) proof</li>
</ol>
<p>Although the ordering of opcode does not matter in theory, since a system of
equations is not dependent on its ordering, in practice it matters a lot for the
solving (i.e the performance of the execution). ACIR opcodes <strong>must be ordered</strong>
so that each opcode can be resolved one after the other.</p>
<p>The values of the witnesses lie in the scalar field of the proving system. We
will refer to it as <code>FieldElement</code> or ACIR field. The proving system needs the
values of all the partial witnesses and all the constraints in order to generate
a proof.</p>
<p><em>Note</em>: The value of a partial witness is unique and fixed throughout a program
execution, although in some rare cases, multiple values are possible for a
same execution and witness (when there are several valid solutions to the
constraints). Having multiple possible values for a witness may indicate that
the circuit is not safe.</p>
<p><em>Note</em>: Why do we use the term partial witnesses? It is because the proving
system may create other constraints and witnesses (especially with
<code>BlackBoxFuncCall</code>, see below). A proof refers to a full witness assignment
and its constraints. ACIR opcodes and their partial witnesses are still an
intermediate representation before getting the full list of constraints and
witnesses. For the sake of simplicity, we will refer to witness instead of
partial witness from now on.</p>
<p><em>Note</em>: Opcodes operate on witnesses, but we will see that some opcodes work on
expressions of witnesses. We call an expression a linear combination of
witnesses and/or products of two witnesses (also with a constant term). A
single witness is a (simple) expression, and conversely, an expression can
be turned into a single witness using an assert-zero opcode.
So basically, using witnesses or expressions is equivalent,
but the latter can avoid the creation of witness in some cases.</p>
<h3 id="documentation"><a class="doc-anchor" href="#documentation">§</a>Documentation</h3>
<p>For detailed documentation, visit <a href="https://noir-lang.github.io/noir/docs/acir/index.html">https://noir-lang.github.io/noir/docs/acir/index.html</a>.
Native structures for representing ACIR</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Opcode"><code>pub use opcodes::<a class="enum" href="opcodes/enum.Opcode.html" title="enum acir::circuit::opcodes::Opcode">Opcode</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="black_box_functions/index.html" title="mod acir::circuit::black_box_functions">black_<wbr>box_<wbr>functions</a></div><div class="desc docblock-short">Black box functions are ACIR opcodes which rely on backends implementing
support for specialized constraints.
This makes certain zk-snark unfriendly computations cheaper than if they were
implemented in more basic constraints.</div></li><li><div class="item-name"><a class="mod" href="brillig/index.html" title="mod acir::circuit::brillig">brillig</a></div><div class="desc docblock-short">This module contains <a href="../../brillig/index.html" title="mod brillig">Brillig</a> structures for integration within an ACIR circuit.</div></li><li><div class="item-name"><a class="mod" href="opcodes/index.html" title="mod acir::circuit::opcodes">opcodes</a></div><div class="desc docblock-short">ACIR opcodes</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AcirOpcodeLocation.html" title="struct acir::circuit::AcirOpcodeLocation">Acir<wbr>Opcode<wbr>Location</a></div><div class="desc docblock-short">Opcodes are locatable so that callers can
map opcodes to debug information related to their context.</div></li><li><div class="item-name"><a class="struct" href="struct.AssertionPayload.html" title="struct acir::circuit::AssertionPayload">Assertion<wbr>Payload</a></div><div class="desc docblock-short">Payload tied to an assertion failure.
This data allows users to specify feedback upon a constraint not being satisfied in the circuit.</div></li><li><div class="item-name"><a class="struct" href="struct.BrilligOpcodeLocation.html" title="struct acir::circuit::BrilligOpcodeLocation">Brillig<wbr>Opcode<wbr>Location</a></div><div class="desc docblock-short">Index of Brillig opcode within a list of Brillig opcodes.
To be used by callers for resolving debug information.</div></li><li><div class="item-name"><a class="struct" href="struct.Circuit.html" title="struct acir::circuit::Circuit">Circuit</a></div><div class="desc docblock-short">Representation of a single ACIR circuit. The execution trace of this structure
is dictated by the construction of a <a href="../native_types/struct.WitnessMap.html" title="struct acir::native_types::WitnessMap">crate::native_types::WitnessMap</a></div></li><li><div class="item-name"><a class="struct" href="struct.ErrorSelector.html" title="struct acir::circuit::ErrorSelector">Error<wbr>Selector</a></div><div class="desc docblock-short">Value for differentiating error types. Used internally by an <a href="struct.AssertionPayload.html" title="struct acir::circuit::AssertionPayload">AssertionPayload</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Program.html" title="struct acir::circuit::Program">Program</a></div><div class="desc docblock-short">A program represented by multiple ACIR <a href="struct.Circuit.html" title="struct acir::circuit::Circuit">circuit</a>’s. The execution trace of these
circuits is dictated by construction of the <a href="../native_types/struct.WitnessStack.html" title="struct acir::native_types::WitnessStack">crate::native_types::WitnessStack</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.PublicInputs.html" title="struct acir::circuit::PublicInputs">Public<wbr>Inputs</a></div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ExpressionOrMemory.html" title="enum acir::circuit::ExpressionOrMemory">Expression<wbr>OrMemory</a></div><div class="desc docblock-short">Enumeration of either an <a href="../native_types/struct.Expression.html" title="struct acir::native_types::Expression">expression</a> or a <a href="opcodes/struct.BlockId.html" title="struct acir::circuit::opcodes::BlockId">memory identifier</a>.</div></li><li><div class="item-name"><a class="enum" href="enum.ExpressionWidth.html" title="enum acir::circuit::ExpressionWidth">Expression<wbr>Width</a></div><div class="desc docblock-short">Specifies the maximum width of the expressions which will be constrained.</div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeLocation.html" title="enum acir::circuit::OpcodeLocation">Opcode<wbr>Location</a></div><div class="desc docblock-short">Opcodes are locatable so that callers can
map opcodes to debug information related to their context.</div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeLocationFromStrError.html" title="enum acir::circuit::OpcodeLocationFromStrError">Opcode<wbr>Location<wbr>From<wbr>StrError</a></div></li></ul></section></div></main></body></html>