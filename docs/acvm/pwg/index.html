<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains methods to implement the partial witness generation (PWG) of an ACIR program. The goal of ACIR execution is to compute the values of all the ACIR witnesses, or an error if it could not compute them all. A proving system will then be able to use the ACIR circuit and the values of the ACIR witnesses to generate a proof of this execution. The ACIR opcodes are not modified by the execution. Witness generation means getting valid values for the witnesses used by the ACIR opcodes of the program. They are called partial witness because a proving system may create additional witnesses on its own for generating the proof (and a corresponding low-level circuit). The PWG generates values for all the witnesses of the ACIR program, or returns an error if it cannot do it."><title>acvm::pwg - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="acvm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../acvm/index.html">acvm</a><span class="version">1.0.0-beta.13</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module pwg</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate acvm</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">acvm</a></span><h1>Module <span>pwg</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/acvm/pwg/mod.rs.html#3-1014">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains methods to implement the partial witness generation (PWG) of an ACIR program.
The goal of ACIR execution is to compute the values of all the ACIR witnesses, or an error if it could not compute them all.
A proving system will then be able to use the ACIR circuit and the values of the ACIR witnesses to generate a proof of this execution.
The ACIR opcodes are not modified by the execution.
Witness generation means getting valid values for the witnesses used by the ACIR opcodes of the program.
They are called <em>partial</em> witness because a proving system may create additional witnesses on its own for
generating the proof (and a corresponding low-level circuit). The PWG generates values for all the witnesses
of the ACIR program, or returns an error if it cannot do it.</p>
<p>Implementation details &amp; examples:
It starts by instantiating an ACVM (ACIR Virtual Machine), which executes the given ACIR opcodes in the <code>solve()</code> function.</p>
<p>Parameters: When instantiating the ACVM, it needs to be provided with:</p>
<ul>
<li>a <code>backend</code> implementing the <code>BlackBoxFunctionSolver</code> trait. Different implementation can be used depending on the EC used by the underlying proving system.</li>
<li><code>opcodes</code>: the ACIR opcodes of the program to solve.</li>
<li><code>initial_witness</code>: a mapping of initial witness values representing the inputs of the program. The ACVM will update this map as it solves the opcodes.</li>
<li><code>unconstrained_functions</code>: the Brillig bytecode of the unconstrained functions used by the program.</li>
<li><code>assertion_payloads</code>: additional information used to provide feedback to the user when an assertion fails.</li>
</ul>
<p>Returns: ACVM Status</p>
<ul>
<li><code>Solved</code>: all witness have been successfully computed, execution is complete.</li>
<li><code>InProgress</code>: The ACVM is processing the circuit, i.e solving the opcodes. This status is used to resume execution after it has been paused.</li>
<li><code>Failure(OpcodeResolutionError&lt;F&gt;)</code>: Error, execution is stopped.</li>
<li><code>RequiresForeignCall(ForeignCallWaitInfo&lt;F&gt;)</code>: Execution is paused until the result of a foreign call is provided</li>
<li><code>RequiresAcirCall(AcirCallWaitInfo&lt;F&gt;)</code>: Execution is paused until the result of an ACIR call is provided</li>
</ul>
<p>Each opcode is solved independently. In general we require its inputs to be already known, i.e previously solved,
and the output is simply computed from the inputs, and then the output becomes ‘known’ for the subsequent opcodes.</p>
<ul>
<li>
<p>AssertZero opcode: The arithmetic expression of the opcode is solved for one unknown witness.
It will fail if there is more than one unknown witness in the expression.</p>
</li>
<li>
<p>BlackBoxFuncCall opcode: The blackbox module knows how to compute the result of the function when all its input are known.</p>
</li>
<li>
<p>MemoryInit opcode: Instantiate a MemoryOpSolver for the opcode’s array, using the given initial values.
Initial witness values must be known. The memory values will be updated later by MemoryOp opcodes.</p>
</li>
<li>
<p>MemoryOp opcode: Update the memory values of the opcode’s array from the opcode witness values:
A read operation will solve the corresponding witness value, reading the memory value tracked by the MemoryOpSolver at the (known value) of the opcode index.
A write operation will update the memory value tracked by the MemoryOpSolver using the known values of the opcode index/value witnesses.</p>
</li>
<li>
<p>BrilligCall opcode: Calls an unconstrained Brillig function by instantiating a BrilligSolver (i.e a Brillig VM).
If the function is a foreign call, the <code>solve()</code> will halt and wait for the caller to resolve the foreign call.</p>
</li>
<li>
<p>Call opcode: Execute the ACIR call in a separate ACVM instance. The result of the ACIR call will be passed back to the ACVM using a
mechanism similar to the one for foreign calls.</p>
</li>
</ul>
<p>Example:</p>
<p>This ACIR program defines the ‘main’ function and indicates it is ‘non-transformed’.
Indeed, some ACIR pass can transform the ACIR program in order to apply optimizations,
or to make it compatible with a specific proving system.
However, ACIR execution is expected to work on any ACIR program (transformed or not).
Then the program indicates the ‘current witness’, which is the lasted witness used in the program.
Any transformation that needs to add more witness will use it in order to not overlap with
existing witnesses. This is not relevant for execution.
Then we see the parameters of the program as public and private inputs.
The <code>initial_witness</code> needs to contain values for these parameters before execution, else
the execution will fail.
The first ACIR opcodes are RANGE opcodes which ensure the inputs have the expected range (as specified in the Noir source code).
Solving this black-box simply means to validate that the values (from <code>initial_witness</code>) are indeed 32 bits for w0, w1, w2, w3, w4
If <code>initial_witness</code> does not have values for w0, w1, w2, w3, w4, or if the values are over 32 bits, the execution will fail.
The next opcode is an AssertZero opcode: ASSERT w0 - w1 - w6 = 0, which indicates that <code>w0 - w1 - w6</code> should be equal to 0.
Since we know the values of <code>w0, w1</code> from <code>initial_witness</code>, we can compute <code>w6 = w0 + w1</code> so that the AssertZero is satisfied.
Solving AssertZero means computing the unknown witness and adding the result to <code>initial_witness</code>, which now contains the value for <code>w6</code>.
The next opcode is a Brillig Call where input is <code>w6</code> and output is <code>w7</code>. From the function id of the opcode, the solver will retrieve the
corresponding Brillig bytecode and instantiate a Brillig VM with the value of the input. This value was just computed before.
Executing the Brillig VM on this input will give us the output which is the value for <code>w7</code>, that we add to <code>initial_witness</code>.
The next opcode is again an AssertZero: <code>w6 * w7 + w8 - 1 = 0</code>, which computes the value of <code>w8</code>.
The two next opcode are AssertZero without any unknown witness: <code>w6 * w8 = 0</code> and <code>w1 * w8 = 0</code>
Solving such opcodes means that we compute <code>w6 * w8 </code> and <code>w1 * w8</code> using the known values, and check that it is 0.
If not, we would return an error.
Finally, the last AssertZero computes <code>w9</code> which is the last witness. All the witness have now been computed; execution is complete.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="arithmetic/index.html" title="mod acvm::pwg::arithmetic">arithmetic</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="blackbox/index.html" title="mod acvm::pwg::blackbox">blackbox</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="brillig/index.html" title="mod acvm::pwg::brillig">brillig</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="memory_op/index.html" title="mod acvm::pwg::memory_op">memory_<wbr>op</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ACVM.html" title="struct acvm::pwg::ACVM">ACVM</a></div></li><li><div class="item-name"><a class="struct" href="struct.AcirCallWaitInfo.html" title="struct acvm::pwg::AcirCallWaitInfo">Acir<wbr>Call<wbr>Wait<wbr>Info</a></div></li><li><div class="item-name"><a class="struct" href="struct.BrilligSolver.html" title="struct acvm::pwg::BrilligSolver">Brillig<wbr>Solver</a></div><div class="desc docblock-short">Specific solver for Brillig opcodes
It maintains a Brillig VM that can execute the bytecode of the called brillig function</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignCallWaitInfo.html" title="struct acvm::pwg::ForeignCallWaitInfo">Foreign<wbr>Call<wbr>Wait<wbr>Info</a></div><div class="desc docblock-short">Encapsulates a request from a Brillig VM process that encounters a <a href="../../brillig/opcodes/enum.BrilligOpcode.html#variant.ForeignCall" title="variant brillig::opcodes::BrilligOpcode::ForeignCall">foreign call opcode</a>
where the result of the foreign call has not yet been provided.</div></li><li><div class="item-name"><a class="struct" href="struct.ProfilingSample.html" title="struct acvm::pwg::ProfilingSample">Profiling<wbr>Sample</a></div></li><li><div class="item-name"><a class="struct" href="struct.RawAssertionPayload.html" title="struct acvm::pwg::RawAssertionPayload">RawAssertion<wbr>Payload</a></div><div class="desc docblock-short">A dynamic assertion payload whose data has been resolved.
This is instantiated upon hitting an assertion failure.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ACVMStatus.html" title="enum acvm::pwg::ACVMStatus">ACVM<wbr>Status</a></div></li><li><div class="item-name"><a class="enum" href="enum.BrilligSolverStatus.html" title="enum acvm::pwg::BrilligSolverStatus">Brillig<wbr>Solver<wbr>Status</a></div></li><li><div class="item-name"><a class="enum" href="enum.ErrorLocation.html" title="enum acvm::pwg::ErrorLocation">Error<wbr>Location</a></div><div class="desc docblock-short">Allows to point to a specific opcode as cause in errors.
Some errors don’t have a specific opcode associated with them, or are created without one and added later.</div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeNotSolvable.html" title="enum acvm::pwg::OpcodeNotSolvable">Opcode<wbr>NotSolvable</a></div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeResolutionError.html" title="enum acvm::pwg::OpcodeResolutionError">Opcode<wbr>Resolution<wbr>Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.ResolvedAssertionPayload.html" title="enum acvm::pwg::ResolvedAssertionPayload">Resolved<wbr>Assertion<wbr>Payload</a></div><div class="desc docblock-short">Enumeration of possible resolved assertion payloads.
This is instantiated upon hitting an assertion failure,
and can either be static strings or dynamic payloads.</div></li><li><div class="item-name"><a class="enum" href="enum.StepResult.html" title="enum acvm::pwg::StepResult">Step<wbr>Result</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.any_witness_from_expression.html" title="fn acvm::pwg::any_witness_from_expression">any_<wbr>witness_<wbr>from_<wbr>expression</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.check_bit_size.html" title="fn acvm::pwg::check_bit_size">check_<wbr>bit_<wbr>size</a></div></li><li><div class="item-name"><a class="fn" href="fn.get_value.html" title="fn acvm::pwg::get_value">get_<wbr>value</a></div><div class="desc docblock-short">Returns the concrete value for a particular expression
If the value cannot be computed, it returns an ‘OpcodeNotSolvable’ error.</div></li><li><div class="item-name"><a class="fn" href="fn.input_to_value.html" title="fn acvm::pwg::input_to_value">input_<wbr>to_<wbr>value</a></div></li><li><div class="item-name"><a class="fn" href="fn.insert_value.html" title="fn acvm::pwg::insert_value">insert_<wbr>value</a></div><div class="desc docblock-short">Inserts <code>value</code> into the initial witness map under the index <code>witness</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.is_predicate_false.html" title="fn acvm::pwg::is_predicate_false">is_<wbr>predicate_<wbr>false</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns <code>true</code> if the predicate is zero
A predicate is used to indicate whether we should skip a certain operation.
If we have a zero predicate it means the operation should be skipped.</div></li><li><div class="item-name"><a class="fn" href="fn.witness_to_value.html" title="fn acvm::pwg::witness_to_value">witness_<wbr>to_<wbr>value</a></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ProfilingSamples.html" title="type acvm::pwg::ProfilingSamples">Profiling<wbr>Samples</a></div></li></ul></section></div></main></body></html>