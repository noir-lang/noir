<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains methods to implement the partial witness generation (PWG) of an ACIR program. The goal of ACIR execution is to compute the values of all the ACIR witnesses, or an error if it could not compute them all. A proving system will then be able to use the ACIR circuit and the values of the ACIR witnesses to generate a proof of this execution. The ACIR opcodes are not modified by the execution. Witness generation means getting valid values for the witnesses used by the ACIR opcodes of the program. They are called partial witness because a proving system may create additional witnesses on its own for generating the proof (and a corresponding low-level circuit). The PWG generates values for all the witnesses of the ACIR program, or returns an error if it cannot do it."><title>acvm::pwg - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="acvm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../acvm/index.html">acvm</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module pwg</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate acvm</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">acvm</a></span><h1>Module <span>pwg</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/acvm/pwg/mod.rs.html#3-991">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains methods to implement the partial witness generation (PWG) of an ACIR program.
The goal of ACIR execution is to compute the values of all the ACIR witnesses, or an error if it could not compute them all.
A proving system will then be able to use the ACIR circuit and the values of the ACIR witnesses to generate a proof of this execution.
The ACIR opcodes are not modified by the execution.
Witness generation means getting valid values for the witnesses used by the ACIR opcodes of the program.
They are called <em>partial</em> witness because a proving system may create additional witnesses on its own for
generating the proof (and a corresponding low-level circuit). The PWG generates values for all the witnesses
of the ACIR program, or returns an error if it cannot do it.</p>
<p>Implementation details &amp; examples:
It starts by instantiating an ACVM (ACIR Virtual Machine), which executes the given ACIR opcodes in the <code>solve()</code> function.</p>
<p>Parameters: When instantiating the ACVM, it needs to be provided with:</p>
<ul>
<li>a <code>backend</code> implementing the <code>BlackBoxFunctionSolver</code> trait. Different implementation can be used depending on the EC used by the underlying proving system.</li>
<li><code>opcodes</code>: the ACIR opcodes of the program to solve.</li>
<li><code>initial_witness</code>: a mapping of initial witness values representing the inputs of the program. The ACVM will update this map as it solves the opcodes.</li>
<li><code>unconstrained_functions</code>: the Brillig bytecode of the unconstrained functions used by the program.</li>
<li><code>assertion_payloads</code>: additional information used to provide feedback to the user when an assertion fails.</li>
</ul>
<p>Returns: <a href="enum.ACVMStatus.html" title="enum acvm::pwg::ACVMStatus"><code>ACVMStatus</code></a></p>
<p>Each opcode is solved independently. In general we require its inputs to be already known, i.e previously solved,
and the output is simply computed from the inputs, and then the output becomes â€˜knownâ€™ for the subsequent opcodes.</p>
<p>See [<code>acir::circuit::Opcode</code>] for more details.</p>
<p>Example:</p>
<p>This ACIR program defines the â€˜mainâ€™ function and indicates it is â€˜non-transformedâ€™.
Indeed, some ACIR pass can transform the ACIR program in order to apply optimizations,
or to make it compatible with a specific proving system.
However, ACIR execution is expected to work on any ACIR program (transformed or not).
Then we see the parameters of the program as public and private inputs.
The <code>initial_witness</code> needs to contain values for these parameters before execution, else
the execution will fail.
The first ACIR opcodes are RANGE opcodes which ensure the inputs have the expected range (as specified in the Noir source code).
Solving this black-box simply means to validate that the values (from <code>initial_witness</code>) are indeed 32 bits for w0, w1, w2, w3, w4
If <code>initial_witness</code> does not have values for w0, w1, w2, w3, w4, or if the values are over 32 bits, the execution will fail.
The next opcode is an AssertZero opcode: ASSERT w0 - w1 - w6 = 0, which indicates that <code>w0 - w1 - w6</code> should be equal to 0.
Since we know the values of <code>w0, w1</code> from <code>initial_witness</code>, we can compute <code>w6 = w0 + w1</code> so that the AssertZero is satisfied.
Solving AssertZero means computing the unknown witness and adding the result to <code>initial_witness</code>, which now contains the value for <code>w6</code>.
The next opcode is a Brillig Call where input is <code>w6</code> and output is <code>w7</code>. From the function id of the opcode, the solver will retrieve the
corresponding Brillig bytecode and instantiate a Brillig VM with the value of the input. This value was just computed before.
Executing the Brillig VM on this input will give us the output which is the value for <code>w7</code>, that we add to <code>initial_witness</code>.
The next opcode is again an AssertZero: <code>w6 * w7 + w8 - 1 = 0</code>, which computes the value of <code>w8</code>.
The two next opcodes are AssertZero without any unknown witnesses: <code>w6 * w8 = 0</code> and <code>w1 * w8 = 0</code>
Solving such opcodes means that we compute <code>w6 * w8 </code> and <code>w1 * w8</code> using the known values, and check that they evaluate to 0.
If not, we would return an error.
Finally, the last AssertZero computes <code>w9</code> which is the last witness. All of the witnesses have now been computed; execution is complete.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="arithmetic/index.html" title="mod acvm::pwg::arithmetic">arithmetic</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="blackbox/index.html" title="mod acvm::pwg::blackbox">blackbox</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="brillig/index.html" title="mod acvm::pwg::brillig">brillig</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="memory_op/index.html" title="mod acvm::pwg::memory_op">memory_<wbr>op</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.ACVM.html" title="struct acvm::pwg::ACVM">ACVM</a></div></li><li><div class="item-name"><a class="struct" href="struct.AcirCallWaitInfo.html" title="struct acvm::pwg::AcirCallWaitInfo">Acir<wbr>Call<wbr>Wait<wbr>Info</a></div><div class="desc docblock-short">Encapsulates a request from the ACVM that encounters an [ACIR call opcode][brillig_vm::brillig::Opcode::Call]
where the result of the circuit execution has not yet been provided.</div></li><li><div class="item-name"><a class="struct" href="struct.BrilligSolver.html" title="struct acvm::pwg::BrilligSolver">Brillig<wbr>Solver</a></div><div class="desc docblock-short">Specific solver for Brillig opcodes
It maintains a Brillig VM that can execute the bytecode of the called brillig function</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignCallWaitInfo.html" title="struct acvm::pwg::ForeignCallWaitInfo">Foreign<wbr>Call<wbr>Wait<wbr>Info</a></div><div class="desc docblock-short">Encapsulates a request from a Brillig VM process that encounters a [foreign call opcode][brillig_vm::brillig::Opcode::ForeignCall]
where the result of the foreign call has not yet been provided.</div></li><li><div class="item-name"><a class="struct" href="struct.ProfilingSample.html" title="struct acvm::pwg::ProfilingSample">Profiling<wbr>Sample</a></div></li><li><div class="item-name"><a class="struct" href="struct.RawAssertionPayload.html" title="struct acvm::pwg::RawAssertionPayload">RawAssertion<wbr>Payload</a></div><div class="desc docblock-short">A dynamic assertion payload whose data has been resolved.
This is instantiated upon hitting an assertion failure.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ACVMStatus.html" title="enum acvm::pwg::ACVMStatus">ACVM<wbr>Status</a></div></li><li><div class="item-name"><a class="enum" href="enum.BrilligSolverStatus.html" title="enum acvm::pwg::BrilligSolverStatus">Brillig<wbr>Solver<wbr>Status</a></div></li><li><div class="item-name"><a class="enum" href="enum.ErrorLocation.html" title="enum acvm::pwg::ErrorLocation">Error<wbr>Location</a></div><div class="desc docblock-short">Used by errors to point to a specific opcode as that errorâ€™s cause</div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeNotSolvable.html" title="enum acvm::pwg::OpcodeNotSolvable">Opcode<wbr>NotSolvable</a></div></li><li><div class="item-name"><a class="enum" href="enum.OpcodeResolutionError.html" title="enum acvm::pwg::OpcodeResolutionError">Opcode<wbr>Resolution<wbr>Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.ResolvedAssertionPayload.html" title="enum acvm::pwg::ResolvedAssertionPayload">Resolved<wbr>Assertion<wbr>Payload</a></div><div class="desc docblock-short">Enumeration of possible resolved assertion payloads.
This is instantiated upon hitting an assertion failure,
and can either be static strings or dynamic payloads.</div></li><li><div class="item-name"><a class="enum" href="enum.StepResult.html" title="enum acvm::pwg::StepResult">Step<wbr>Result</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.any_witness_from_expression.html" title="fn acvm::pwg::any_witness_from_expression">any_<wbr>witness_<wbr>from_<wbr>expression</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="fn" href="fn.check_bit_size.html" title="fn acvm::pwg::check_bit_size">check_<wbr>bit_<wbr>size</a></div></li><li><div class="item-name"><a class="fn" href="fn.get_value.html" title="fn acvm::pwg::get_value">get_<wbr>value</a></div><div class="desc docblock-short">Returns the concrete value for a particular expression
If the value cannot be computed, it returns an â€˜OpcodeNotSolvableâ€™ error.</div></li><li><div class="item-name"><a class="fn" href="fn.input_to_value.html" title="fn acvm::pwg::input_to_value">input_<wbr>to_<wbr>value</a></div></li><li><div class="item-name"><a class="fn" href="fn.insert_value.html" title="fn acvm::pwg::insert_value">insert_<wbr>value</a></div><div class="desc docblock-short">Inserts <code>value</code> into the initial witness map under the index <code>witness</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.is_predicate_false.html" title="fn acvm::pwg::is_predicate_false">is_<wbr>predicate_<wbr>false</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Returns <code>Ok(true)</code> if the predicate is zero
A predicate is used to indicate whether we should skip a certain operation.
If we have a zero predicate it means the operation should be skipped.</div></li><li><div class="item-name"><a class="fn" href="fn.witness_to_value.html" title="fn acvm::pwg::witness_to_value">witness_<wbr>to_<wbr>value</a></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ProfilingSamples.html" title="type acvm::pwg::ProfilingSamples">Profiling<wbr>Samples</a></div></li></ul></section></div></main></body></html>