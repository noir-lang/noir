<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `compiler` module contains several passes to transform an ACIR program. Roughly, the passes are separated into the `optimizers` which try to reduce the number of opcodes and the `transformers` which adapt the opcodes to the proving backend."><title>acvm::compiler - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="acvm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../acvm/index.html">acvm</a><span class="version">1.0.0-beta.17</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module compiler</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#optimizers" title="Optimizers">Optimizers</a></li><li><a href="#transformers" title="Transformers">Transformers</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate acvm</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">acvm</a></span><h1>Module <span>compiler</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/acvm/compiler/mod.rs.html#1-125">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <code>compiler</code> module contains several passes to transform an ACIR program.
Roughly, the passes are separated into the <code>optimizers</code> which try to reduce the number of opcodes
and the <code>transformers</code> which adapt the opcodes to the proving backend.</p>
<h2 id="optimizers"><a class="doc-anchor" href="#optimizers">Â§</a>Optimizers</h2>
<ul>
<li>GeneralOptimizer: simple pass which simplifies AssertZero opcodes when possible (e.g remove terms with null coefficient)</li>
<li>UnusedMemoryOptimizer: simple pass which removes MemoryInit opcodes when they are not used (e.g no corresponding MemoryOp opcode)</li>
<li>RangeOptimizer: forward pass to collect range check information, and backward pass to remove the ones that are redundant.</li>
</ul>
<h2 id="transformers"><a class="doc-anchor" href="#transformers">Â§</a>Transformers</h2>
<ul>
<li>CSAT: create intermediate variables so that AssertZero opcodes have the correct Circuitâ€™s <code>ExpressionWidth</code>.</li>
</ul>
<p>ACIR generation is performed by calling the <code>Ssa::into_acir</code> method, providing any necessary brillig bytecode.
The compiled program will be returned as an <code>Artifacts</code> type.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="optimizers/index.html" title="mod acvm::compiler::optimizers">optimizers</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="simulator/index.html" title="mod acvm::compiler::simulator">simulator</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AcirTransformationMap.html" title="struct acvm::compiler::AcirTransformationMap">Acir<wbr>Transformation<wbr>Map</a></div><div class="desc docblock-short">This module can move and decompose acir opcodes into multiple opcodes. The transformation map allows consumers of this module to map
metadata they had about the opcodes to the new opcode structure generated after the transformation.
ACIR opcodes are stored inside a vector of opcodes. A transformation pass will generate a new vector of opcodes,
but each opcode is the result of the transformation of an opcode in the original vector.
So we simply keep track of the relation:  index of the original opcode -&gt; index of the new opcode in the new vector
However we need a vector of new indexes for the map values in the case the old opcode is decomposed into multiple opcodes.</div></li><li><div class="item-name"><a class="struct" href="struct.CircuitSimulator.html" title="struct acvm::compiler::CircuitSimulator">Circuit<wbr>Simulator</a></div><div class="desc docblock-short">Simulate solving a circuit symbolically
Instead of evaluating witness values from the inputs, like the PWG module is doing,
this pass simply marks the witness that can be evaluated, from the known inputs,
and incrementally from the previously marked witnesses.
This avoids any computation on a big field which makes the process efficient.
When all the witness of an opcode are marked as solvable, it means that the
opcode is solvable.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.optimize.html" title="fn acvm::compiler::optimize">optimize</a></div><div class="desc docblock-short">Applies backend independent optimizations to a <a href="../../acir/circuit/struct.Circuit.html" title="struct acir::circuit::Circuit"><code>Circuit</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.transform_assert_messages.html" title="fn acvm::compiler::transform_assert_messages">transform_<wbr>assert_<wbr>messages</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Update the assert messages to point to the new opcode locations.</div></li></ul></section></div></main></body></html>