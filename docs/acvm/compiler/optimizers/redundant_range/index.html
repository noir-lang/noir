<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The redundant range constraint optimization pass aims to remove any BlackBoxFunc::Range opcodes which doesnâ€™t result in additional restrictions on the values of witnesses."><title>acvm::compiler::optimizers::redundant_range - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="acvm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../acvm/index.html">acvm</a><span class="version">1.0.0-beta.16</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module redundant_<wbr>range</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#implicit-range-constraints" title="Implicit range constraints">Implicit range constraints</a><ul><li><a href="#constant-assignments" title="Constant assignments">Constant assignments</a></li><li><a href="#array-indexing" title="Array indexing">Array indexing</a></li></ul></li><li><a href="#side-effects" title="Side effects">Side effects</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In acvm::<wbr>compiler::<wbr>optimizers</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../../index.html">acvm</a>::<wbr><a href="../../index.html">compiler</a>::<wbr><a href="../index.html">optimizers</a></span><h1>Module <span>redundant_range</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/acvm/compiler/optimizers/redundant_range.rs.html#1-693">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The redundant range constraint optimization pass aims to remove any <a href="acir::circuit::black_box_functions::BlackBoxFunc::RANGE">BlackBoxFunc::Range</a> opcodes
which doesnâ€™t result in additional restrictions on the values of witnesses.</p>
<p>Suppose we had the following pseudo-code:</p>
<div class="example-wrap"><pre class="language-noir"><code>let z1 = x as u16;
let z2 = x as u32;</code></pre></div>
<p>It is clear that if <code>x</code> fits inside of a 16-bit integer,
it must also fit inside of a 32-bit integer.</p>
<p>The generated ACIR may produce two range opcodes however;</p>
<ul>
<li>One for the 16 bit range constraint of <code>x</code></li>
<li>One for the 32-bit range constraint of <code>x</code></li>
</ul>
<p>This optimization pass will keep the 16-bit range constraint
and remove the 32-bit range constraint opcode.</p>
<h2 id="implicit-range-constraints"><a class="doc-anchor" href="#implicit-range-constraints">Â§</a>Implicit range constraints</h2>
<p>We also consider implicit range constraints on witnesses - constraints other than <a href="acir::circuit::black_box_functions::BlackBoxFunc::RANGE">BlackBoxFunc::Range</a>
which limit the size of a witness.</p>
<h3 id="constant-assignments"><a class="doc-anchor" href="#constant-assignments">Â§</a>Constant assignments</h3>
<p>The most obvious of these are when a witness is constrained to be equal to a constant value.</p>
<div class="example-wrap"><pre class="language-noir"><code>let z1 = x as u16;
assert_eq(z1, 100);</code></pre></div>
<p>We can consider the assertion that <code>z1 == 100</code> to be equivalent to a range constraint for <code>z1</code> to fit within
7 bits (the minimum necessary to hold the value <code>100</code>).</p>
<h3 id="array-indexing"><a class="doc-anchor" href="#array-indexing">Â§</a>Array indexing</h3>
<p>Another situation which adds an implicit range constraint are array indexing, for example in the program:</p>
<div class="example-wrap"><pre class="language-noir"><code>fn main(index: u32) -&gt; pub Field {
    let array: [Field; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    array[index]
}</code></pre></div>
<p>Here the variable <code>index</code> is range constrained to fit within 32 bits by the <code>u32</code> type however
itâ€™s constrained more restrictively by the length of <code>array</code>. If <code>index</code> were 10 or greater then
it would result in a read past the end of the array, which is invalid. We can then remove the explicit
range constraint on <code>index</code> as the usage as an array index more tightly constrains its value.</p>
<h2 id="side-effects"><a class="doc-anchor" href="#side-effects">Â§</a>Side effects</h2>
<p>The pass will keep range constraints where, should the constraint have failed, removing it
would allow potentially side effecting Brillig calls to be executed, before another constraint
further down the line would have stopped the circuit.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.RangeInfo.html" title="struct acvm::compiler::optimizers::redundant_range::RangeInfo">Range<wbr>Info</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Information gathered about witnesses which are subject to range constraints.</div></li><li><div class="item-name"><a class="struct" href="struct.RangeOptimizer.html" title="struct acvm::compiler::optimizers::redundant_range::RangeOptimizer">Range<wbr>Optimizer</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.memory_block_implied_max_bits.html" title="fn acvm::compiler::optimizers::redundant_range::memory_block_implied_max_bits">memory_<wbr>block_<wbr>implied_<wbr>max_<wbr>bits</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="desc docblock-short">Calculate the maximum number of bits required to index a memory block of a certain size.</div></li></ul></section></div></main></body></html>