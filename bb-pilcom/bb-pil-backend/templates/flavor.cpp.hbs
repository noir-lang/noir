// AUTOGENERATED FILE
#include "barretenberg/vm/generated/{{snakeCase name}}_flavor.hpp"

namespace bb {

{{name}}Flavor::AllConstRefValues::AllConstRefValues(const RefArray<FF const, AvmFlavor::NUM_ALL_ENTITIES>& il) :
    {{#each (join fixed witness_without_inverses lookups shifted) as |item|}}
    {{item}}(il[{{@index}}]){{#unless @last}},{{/unless}}
    {{/each}}
  {}

{{name}}Flavor::ProverPolynomials::ProverPolynomials(ProvingKey& proving_key)
{
    for (auto [prover_poly, key_poly] : zip_view(this->get_unshifted(), proving_key.get_all())) {
        ASSERT(flavor_get_label(*this, prover_poly) == flavor_get_label(proving_key, key_poly));
        prover_poly = key_poly.share();
    }
    for (auto [prover_poly, key_poly] : zip_view(this->get_shifted(), proving_key.get_to_be_shifted())) {
        ASSERT(flavor_get_label(*this, prover_poly) == (flavor_get_label(proving_key, key_poly) + "_shift"));
        prover_poly = key_poly.shifted();
    }
}

{{name}}Flavor::AllConstRefValues {{name}}Flavor::ProverPolynomials::get_row(size_t row_idx) const
{
    {{!--
    // TODO: try to make something like this work.
    // Right now it's too risky because it relies on the order of the columns in `get_all()`.
    RefArray all_cols = get_all();
    std::array<const FF*, {{len all_cols_and_shifts}}> refs;
    for (size_t i = 0; i < refs.size(); ++i) {
        refs[i] = &all_cols[i][row_idx];
    }
    // Note: the order of the constructor must match the order of the columns in `get_all()`!
    return AllConstRefValues(refs);
      --}}
    return AllConstRefValues(RefArray{
      {{#each (join fixed witness_without_inverses lookups shifted) as |item|}}
      {{item}}[row_idx]{{#unless @last}},{{/unless}}
      {{/each}}
    });
}

{{name}}Flavor::CommitmentLabels::CommitmentLabels()
{
    {{#each all_cols as |item|}}
    Base::{{item}} = "{{shoutySnakeCase item}}";
    {{/each}}
};

{{name}}Flavor::VerifierCommitments::VerifierCommitments(const std::shared_ptr<VerificationKey>& verification_key)
{
    {{#each fixed as |item|}}
    {{item}} = verification_key->{{item}};
    {{/each}}
}

void {{name}}Flavor::Transcript::deserialize_full_transcript() {
    size_t num_frs_read = 0;
    circuit_size = deserialize_from_buffer<uint32_t>(proof_data, num_frs_read);
    size_t log_n = numeric::get_msb(circuit_size);

    for (auto& commitment : commitments) {
        commitment = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
    }
    for (size_t i = 0; i < log_n; ++i) {
        sumcheck_univariates.emplace_back(
            deserialize_from_buffer<bb::Univariate<FF, BATCHED_RELATION_PARTIAL_LENGTH>>(
                Transcript::proof_data, num_frs_read));
    }
    sumcheck_evaluations = deserialize_from_buffer<std::array<FF, NUM_ALL_ENTITIES>>(
        Transcript::proof_data, num_frs_read);
    for (size_t i = 0; i < log_n; ++i) {
        zm_cq_comms.push_back(deserialize_from_buffer<Commitment>(proof_data, num_frs_read));
    }
    zm_cq_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
    zm_pi_comm = deserialize_from_buffer<Commitment>(proof_data, num_frs_read);
}

void {{name}}Flavor::Transcript::serialize_full_transcript() {
    size_t old_proof_length = proof_data.size();
    Transcript::proof_data.clear();
    size_t log_n = numeric::get_msb(circuit_size);

    serialize_to_buffer(circuit_size, Transcript::proof_data);

    for (const auto& commitment : commitments) {
        serialize_to_buffer(commitment, Transcript::proof_data);
    }
    for (size_t i = 0; i < log_n; ++i) {
        serialize_to_buffer(sumcheck_univariates[i], Transcript::proof_data);
    }
    serialize_to_buffer(sumcheck_evaluations, Transcript::proof_data);
    for (size_t i = 0; i < log_n; ++i) {
        serialize_to_buffer(zm_cq_comms[i], proof_data);
    }
    serialize_to_buffer(zm_cq_comm, proof_data);
    serialize_to_buffer(zm_pi_comm, proof_data);

    // sanity check to make sure we generate the same length of proof as before.
    ASSERT(proof_data.size() == old_proof_length);
}

{{name}}Flavor::PartiallyEvaluatedMultivariates::PartiallyEvaluatedMultivariates(const size_t circuit_size)
{
    // Storage is only needed after the first partial evaluation, hence polynomials of size (n / 2)
    for (auto& poly : get_all()) {
        poly = Polynomial(circuit_size / 2);
    }
}

} // namespace bb