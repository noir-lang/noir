#![forbid(unsafe_code)]

use std::path::{Path, PathBuf};

use acvm::compiler::validator::validate_witness;
use bn254_blackbox_solver::Bn254BlackBoxSolver;
use clap::{Parser, Subcommand, command};
use color_eyre::eyre;
use const_format::formatcp;
use tracing_subscriber::{EnvFilter, fmt::format::FmtSpan};

use noir_artifact_cli::{Artifact, commands::execute_cmd, fs::witness::load_witness_from_file};
use noirc_driver::CompiledProgram;

const PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
static VERSION_STRING: &str = formatcp!("version = {}\n", PKG_VERSION,);

fn parse_and_normalize_path(path: &str) -> Result<PathBuf, String> {
    let path = PathBuf::from(path);
    Ok(path)
}

#[derive(Parser, Debug)]
#[command(name="noir-execute", author, version=VERSION_STRING, about, long_about = None)]
struct ExecutorCli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand, Debug)]
enum Command {
    /// Execute a binary program or a circuit artifact.
    Execute(execute_cmd::ExecuteCommand),

    /// Validate a previously generated witness file against a program artifact.
    ///
    /// Loads the witness file and verifies that all ACIR constraints are satisfied
    /// by the witness values. This is useful for debugging and validating witness
    /// files generated by external tools.
    CheckWitness {
        /// Path to the JSON build artifact (program).
        #[clap(long, short, value_parser = parse_and_normalize_path)]
        artifact_path: PathBuf,

        /// Path to the witness file to validate.
        #[clap(long, short, value_parser = parse_and_normalize_path)]
        witness: PathBuf,
    },
}

pub fn start_cli() -> eyre::Result<()> {
    let cli = ExecutorCli::parse();

    match cli.command {
        Command::Execute(cmd) => {
            execute_cmd::run(cmd)?;
        }
        Command::CheckWitness { artifact_path, witness } => {
            check_witness_file(&witness, &artifact_path)?;
        }
    }

    Ok(())
}

/// Load a witness file and check if the witnesses satisfy the program.
fn check_witness_file(witness_path: &Path, artifact_path: &Path) -> eyre::Result<()> {
    let artifact = Artifact::read_from_file(artifact_path)?;
    let program: CompiledProgram = match artifact {
        Artifact::Program(program) => program.into(),
        Artifact::Contract(_) => {
            return Err(eyre::eyre!("--check-witness is not supported for contracts"));
        }
    };

    let mut witness_stack = load_witness_from_file(witness_path)?;
    let backend = Bn254BlackBoxSolver(false);

    while let Some(stack_item) = witness_stack.pop() {
        let function_index = stack_item.index as usize;
        let witness_map = stack_item.witness;

        let acir_circuit = &program.program.functions[function_index];
        validate_witness(&backend, witness_map, acir_circuit)
            .map_err(|e| eyre::eyre!("Witness validation failed: {e}"))?;
    }

    println!("Witness validation successful");
    Ok(())
}

fn main() {
    tracing_subscriber::fmt()
        .with_span_events(FmtSpan::ACTIVE)
        .with_writer(std::io::stderr)
        .with_ansi(true)
        .with_env_filter(EnvFilter::from_env("NOIR_LOG"))
        .init();

    if let Err(e) = start_cli() {
        eprintln!("{e:#}");
        std::process::exit(1);
    }
}
