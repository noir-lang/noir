#![forbid(unsafe_code)]

use std::path::{Path, PathBuf};

use acvm::compiler::validator::validate_witness;
use bn254_blackbox_solver::Bn254BlackBoxSolver;
use clap::{Parser, Subcommand, command};
use color_eyre::eyre;
use const_format::formatcp;
use tracing_subscriber::{EnvFilter, fmt::format::FmtSpan};

use noir_artifact_cli::{Artifact, commands::execute_cmd, fs::witness::load_witness_from_file};

const PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
static VERSION_STRING: &str = formatcp!("version = {}\n", PKG_VERSION,);

fn parse_and_normalize_path(path: &str) -> Result<PathBuf, String> {
    let path = PathBuf::from(path);
    Ok(path)
}

#[derive(Parser, Debug)]
#[command(name="noir-execute", author, version=VERSION_STRING, about, long_about = None)]
#[command(args_conflicts_with_subcommands = true)]
struct ExecutorCli {
    #[command(subcommand)]
    command: Option<Command>,

    /// Arguments for the default execute command (when no subcommand is specified).
    #[command(flatten)]
    execute_args: Option<execute_cmd::ExecuteCommand>,
}

#[derive(Subcommand, Debug)]
enum Command {
    /// Execute a binary program or a circuit artifact.
    Execute(execute_cmd::ExecuteCommand),

    /// Validate a previously generated witness file against a program artifact.
    ///
    /// Loads the witness file and verifies that all ACIR constraints are satisfied
    /// by the witness values. This is useful for debugging and validating witness
    /// files generated by external tools.
    CheckWitness {
        /// Path to the JSON build artifact (program or contract).
        #[clap(long, short, value_parser = parse_and_normalize_path)]
        artifact_path: PathBuf,

        /// Path to the witness file to validate.
        #[clap(long, short, value_parser = parse_and_normalize_path)]
        witness: PathBuf,

        /// Name of the contract function to check (required for contract artifacts).
        #[clap(long)]
        contract_function: Option<String>,
    },
}

pub fn start_cli() -> eyre::Result<()> {
    let cli = ExecutorCli::parse();

    match cli.command {
        Some(Command::Execute(cmd)) => {
            execute_cmd::run(cmd)?;
        }
        Some(Command::CheckWitness { artifact_path, witness, contract_function }) => {
            check_witness_file(&witness, &artifact_path, contract_function.as_deref())?;
        }
        None => {
            // Default behavior: run execute with flattened args
            let args = cli.execute_args.expect("execute_args should be present when no subcommand");
            execute_cmd::run(args)?;
        }
    }

    Ok(())
}

/// Load a witness file and check if the witnesses satisfy the program.
fn check_witness_file(
    witness_path: &Path,
    artifact_path: &Path,
    contract_function: Option<&str>,
) -> eyre::Result<()> {
    let artifact = Artifact::read_from_file(artifact_path)?;
    let program = match artifact {
        Artifact::Program(program) => {
            if contract_function.is_some() {
                return Err(eyre::eyre!(
                    "--contract-function is only valid for contract artifacts"
                ));
            }
            program.into()
        }
        Artifact::Contract(contract) => {
            let function_name = contract_function.ok_or_else(|| {
                eyre::eyre!(
                    "Contract artifact requires --contract-function to specify which function to check"
                )
            })?;
            contract.function_as_compiled_program(function_name).ok_or_else(|| {
                eyre::eyre!("Contract function '{}' not found in artifact", function_name)
            })?
        }
    };

    let mut witness_stack = load_witness_from_file(witness_path)?;
    let backend = Bn254BlackBoxSolver(false);

    while let Some(stack_item) = witness_stack.pop() {
        let function_index = stack_item.index as usize;
        let witness_map = stack_item.witness;

        let acir_circuit = &program.program.functions[function_index];
        validate_witness(&backend, witness_map, acir_circuit)
            .map_err(|e| eyre::eyre!("Witness validation failed: {e}"))?;
    }

    println!("Witness validation successful");
    Ok(())
}

fn main() {
    tracing_subscriber::fmt()
        .with_span_events(FmtSpan::ACTIVE)
        .with_writer(std::io::stderr)
        .with_ansi(true)
        .with_env_filter(EnvFilter::from_env("NOIR_LOG"))
        .init();

    if let Err(e) = start_cli() {
        eprintln!("{e:#}");
        std::process::exit(1);
    }
}
