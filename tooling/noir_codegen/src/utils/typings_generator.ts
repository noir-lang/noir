import { CompiledCircuit } from '@noir-lang/types';
import {
  AbiTypeWithGenerics,
  BindingId,
  StructType,
  findAllStructsInType,
  mapAbiTypeToAbiTypeWithGenerics,
} from './abi_type_with_generics.js';
import { Demonomorphizer } from './demonomorphizer.js';
import { Abi } from '@noir-lang/noirc_abi';

const codegenPrelude = `/* Autogenerated file, do not edit! */

/* eslint-disable */

import { Noir, InputMap, CompiledCircuit, ForeignCallHandler } from "@noir-lang/noir_js"

export { ForeignCallHandler } from "@noir-lang/noir_js"
`;
/**
 * Keep track off all of the Noir primitive types that were used.
 * Most of these will not have a 1-1 definition in TypeScript,
 * so we will need to generate type aliases for them.
 *
 * We want to generate type aliases
 * for specific types that are used in the ABI.
 *
 * For example:
 * - If `Field` is used we want to alias that
 * with `number`.
 * - If `u32` is used we want to alias that with `number` too.
 */
type PrimitiveTypesUsed = {
  /**
   * The name of the type alias that we will generate.
   */
  aliasName: string;
  /**
   * The TypeScript type that we will alias to.
   */
  tsType: string;
};

/**
 * Returns the last component of a path, e.g. "foo::bar::baz" -\> "baz"
 * Note: that if we have a path such as "Baz", we will return "Baz".
 *
 * Since these paths corresponds to structs, we can assume that we
 * cannot have "foo::bar::".
 *
 * We also make the assumption that since these paths are coming from
 * Noir, then we will not have two paths that look like this:
 * - foo::bar::Baz
 * - cat::dog::Baz
 * ie the last component of the path (struct name) is enough to uniquely identify
 * the whole path.
 *
 * TODO: We should double check this assumption when we use type aliases,
 * I expect that `foo::bar::Baz as Dog` would effectively give `foo::bar::Dog`
 * @param str - The path to get the last component of.
 * @returns The last component of the path.
 */
function getLastComponentOfPath(str: string): string {
  const parts = str.split('::');
  const lastPart = parts[parts.length - 1];
  return lastPart;
}

/**
 * Replaces a numeric binding with the corresponding generics name or the actual value.
 */
function replaceNumericBinding(id: number | BindingId, genericsNameMap: Map<number, string>): string {
  if (typeof id === 'number') {
    return id.toString();
  } else {
    return genericsNameMap.get(id.id) ?? 'unknown';
  }
}

export class TypingsGenerator {
  /** All the types in the ABIs */
  private allTypes: AbiTypeWithGenerics[] = [];
  /** The demonomorphized ABIs of the circuits */
  private demonomorphizedAbis: {
    circuitName: string;
    params: { name: string; type: AbiTypeWithGenerics }[];
    returnType?: AbiTypeWithGenerics;
    artifact?: CompiledCircuit;
  }[] = [];
  /** Maps struct id to name for structs with the same name and different field sets */
  private structIdToTsName = new Map<string, string>();
  /** Collect all the primitives used in the types to add them to the codegen */
  private primitiveTypesUsed = new Map<string, PrimitiveTypesUsed>();

  constructor(
    circuits: { abi: Abi; circuitName: string; artifact?: CompiledCircuit }[],
    private useFixedLengthArrays: boolean,
  ) {
    // Map all the types used in the ABIs to the demonomorphized types
    for (const { abi, circuitName, artifact } of circuits) {
      const params = abi.parameters.map((param) => {
        const type = mapAbiTypeToAbiTypeWithGenerics(param.type);
        this.allTypes.push(type);
        return { name: param.name, type };
      });
      if (abi.return_type) {
        const returnType = mapAbiTypeToAbiTypeWithGenerics(abi.return_type.abi_type);
        this.allTypes.push(returnType);
        this.demonomorphizedAbis.push({ circuitName, params, returnType, artifact });
      } else {
        this.demonomorphizedAbis.push({ circuitName, params, artifact });
      }
    }
    // Demonomorphize the types
    Demonomorphizer.demonomorphize(this.allTypes, {
      leaveArrayLengthsUnbounded: !useFixedLengthArrays,
      leaveStringLengthsUnbounded: true,
    });
  }

  public codegen(): string {
    this.primitiveTypesUsed = new Map<string, PrimitiveTypesUsed>();
    const structsCode = this.codegenAllStructs();
    const interfacesCode = this.codegenAllInterfaces();
    const primitivesCode = this.codegenAllPrimitives();

    return `
${codegenPrelude}
${primitivesCode}
${structsCode}
${interfacesCode}`;
  }

  private codegenAllStructs(): string {
    const allStructs = this.allTypes.flatMap(findAllStructsInType);
    // First, deduplicate the structs used
    const structTypesToExport = new Map<string, StructType>();
    for (const struct of allStructs) {
      const id = Demonomorphizer.buildIdForStruct(struct.structType);
      if (structTypesToExport.has(id)) {
        continue;
      }
      structTypesToExport.set(id, struct.structType);
    }

    // Then, we have to consider the case where we have struct with the same name but different fields.
    // For those, we'll naively append a number to the name.
    const idsPerName = new Map<string, string[]>();
    for (const [id, structType] of structTypesToExport.entries()) {
      const name = getLastComponentOfPath(structType.path);
      const ids = idsPerName.get(name) ?? [];
      ids.push(id);
      idsPerName.set(name, ids);
    }

    this.structIdToTsName = new Map();
    for (const [name, ids] of idsPerName.entries()) {
      if (ids.length !== 1) {
        ids.forEach((id, index) => {
          this.structIdToTsName.set(id, `${name}${index + 1}`);
        });
      }
    }
    // Now we can just generate the code for the structs
    let resultCode = '';

    for (const structType of structTypesToExport.values()) {
      resultCode += this.codegenStructType(structType);
    }

    return resultCode;
  }

  private getStructName(structType: StructType): string {
    return (
      this.structIdToTsName.get(Demonomorphizer.buildIdForStruct(structType)) || getLastComponentOfPath(structType.path)
    );
  }

  private codegenStructType(structType: StructType): string {
    // Generate names for the generic bindings.
    const genericsNameMap = new Map<number, string>();
    structType.generics.forEach((generic, index) => {
      genericsNameMap.set(generic.id, String.fromCharCode('A'.charCodeAt(0) + index));
    });

    const name = this.getStructName(structType);
    const generics = structType.generics.length
      ? `<${structType.generics
          .map((generic) => `${genericsNameMap.get(generic.id)}${generic.isNumeric ? ' extends number' : ''}`)
          .join(', ')}>`
      : '';

    let resultCode = `export type ${name}${generics} = {\n`;

    for (const field of structType.fields) {
      resultCode += `  ${field.name}: ${this.codegenType(field.type, genericsNameMap)};\n`;
    }

    resultCode += '}\n\n';

    return resultCode;
  }

  private codegenType(type: AbiTypeWithGenerics, genericsNameMap: Map<number, string>): string {
    switch (type.kind) {
      case 'field':
        this.addIfUnique({ aliasName: 'Field', tsType: 'string' });
        return 'Field';
      case 'boolean':
        return 'boolean';
      case 'integer': {
        const typeName = type.sign === 'signed' ? `i${type.width}` : `u${type.width}`;
        // Even though noir accepts numbers or strings for integers, it always returns strings
        // So we must use string as the type here.
        this.addIfUnique({ aliasName: typeName, tsType: 'string' });
        return typeName;
      }
      case 'binding':
        return genericsNameMap.get(type.id.id) ?? 'unknown';
      case 'constant':
        return type.value.toString();
      case 'string':
        return `string`;
      case 'array':
        if (this.useFixedLengthArrays) {
          if (type.length === null) {
            throw new Error('Got unbounded array with fixed length arrays enabled');
          }
          return `FixedLengthArray<${this.codegenType(type.type, genericsNameMap)}, ${replaceNumericBinding(
            type.length,
            genericsNameMap,
          )}>`;
        } else {
          return `${this.codegenType(type.type, genericsNameMap)}[]`;
        }
      case 'tuple': {
        const fieldTypes = type.fields.map((field) => this.codegenType(field, genericsNameMap));
        return `[${fieldTypes.join(', ')}]`;
      }
      case 'struct': {
        const name = this.getStructName(type.structType);
        if (type.args.length) {
          const args = type.args.map((arg) => this.codegenType(arg, genericsNameMap)).join(', ');
          return `${name}<${args}>`;
        } else {
          return name;
        }
      }
    }
  }

  /**
   * Typescript does not allow us to check for equality of non-primitive types
   * easily, so we create a addIfUnique function that will only add an item
   * to the map if it is not already there by using JSON.stringify.
   * @param item - The item to add to the map.
   */
  private addIfUnique(item: PrimitiveTypesUsed) {
    const key = JSON.stringify(item);
    if (!this.primitiveTypesUsed.has(key)) {
      this.primitiveTypesUsed.set(key, item);
    }
  }

  /**
   * Codegen all the interfaces for the circuits.
   * For a circuit named Foo, we'll codegen FooInputType and FooReturnType.
   */
  private codegenAllInterfaces(): string {
    let resultCode = '';
    for (const { circuitName, params, returnType, artifact } of this.demonomorphizedAbis) {
      const functionSignature = {
        inputs: params.map((param): [string, string] => [param.name, this.codegenType(param.type, new Map())]),
        returnValue: returnType ? this.codegenType(returnType, new Map()) : null,
      };
      resultCode += this.codegenStructType({
        path: `${circuitName}InputType`,
        fields: params,
        generics: [],
      });

      if (returnType) {
        resultCode += `export type ${circuitName}ReturnType = ${this.codegenType(returnType, new Map())};\n`;
      }

      resultCode += codegenFunction(circuitName, functionSignature, artifact);
    }
    return resultCode;
  }

  private codegenAllPrimitives(): string {
    let primitiveTypeAliases = this.useFixedLengthArrays
      ? 'export type FixedLengthArray<T, L extends number> = L extends 0 ? never[]: T[] & { length: L }\n'
      : '';
    for (const [, value] of this.primitiveTypesUsed) {
      primitiveTypeAliases += `export type ${value.aliasName} = ${value.tsType};\n`;
    }
    return primitiveTypeAliases;
  }
}

const codegenFunction = (
  name: string,
  function_signature: { inputs: [string, string][]; returnValue: string | null },
  compiled_program?: CompiledCircuit,
): string => {
  const args = function_signature.inputs.map(([name]) => `${name}`).join(', ');
  const args_with_types = function_signature.inputs.map(([name, type]) => `${name}: ${type}`).join(', ');

  const artifact = compiled_program
    ? `export const ${name}_circuit: CompiledCircuit = ${JSON.stringify(compiled_program)};`
    : '';

  return `${artifact}

export async function ${name}(${args_with_types}${compiled_program ? '' : `, ${name}_circuit: CompiledCircuit`}, foreignCallHandler?: ForeignCallHandler): Promise<${function_signature.returnValue}> {
  const program = new Noir(${name}_circuit);
  const args: InputMap = { ${args} };
  const { returnValue } = await program.execute(args, foreignCallHandler);
  return returnValue as ${function_signature.returnValue};
}
`;
};
