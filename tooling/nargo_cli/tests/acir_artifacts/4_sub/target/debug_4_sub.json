{"debug_symbols":[{"locations":{"3":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"4":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"5":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"6":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"7":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"8":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"9":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"10":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"11":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"12":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"13":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"14":[{"span":{"start":152,"end":174},"file":1},{"span":{"start":1545,"end":1645},"file":0}],"15":[{"span":{"start":187,"end":193},"file":1}]}}],"file_map":{"0":{"source":"mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident \n#[oracle(println)]\nunconstrained fn println_oracle<T>(_input: T) {}\n\nunconstrained pub fn println<T>(input: T) {\n    println_oracle(input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key : [Field], _proof : [Field], _public_inputs : [Field], _key_hash : Field, _input_aggregation_object : [Field; N]) -> [Field; N] {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x : Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x : T) -> Field {}\n\n\npub fn wrapping_add<T>(x : T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x : T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x : T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n\npub fn wrapping_shift_left<T>(x : T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * 2.pow_32(crate::as_field(y)))\n}\n","path":"std/lib.nr"},"1":{"source":"use dep::std;\n// Test unsafe integer subtraction with underflow: 12 - 2418266113 = 1876701195 modulo 2^32\nfn main(mut x: u32, y: u32, z: u32) {\n    x = std::wrapping_sub(x,y);\n    assert(x == z);\n\n    // Test constant underflow (regression for #2045)\n    let x = -1 as u4;\n    assert(x == 15);\n}\n","path":"/mnt/user-data/kev/noir/tooling/nargo_cli/tests/execution_success/4_sub/src/main.nr"}}}