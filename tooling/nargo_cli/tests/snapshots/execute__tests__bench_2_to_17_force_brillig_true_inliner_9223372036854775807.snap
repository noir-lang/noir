---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "5767612707075568125",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "5Z3bTttAGITfxde58J53eZWqQgFSZClKUAiVKsS717biQHH6r9JaZnZ8g3CzDt+0eGa862xfq4fN3cvjbbP7sX+ubr69Vtv9/frY7Hft0evbqro7NNtt83j78Y+ruvti6n7889N61x0+H9eHY3WjtFlVm91D+5137fk/mu2munH122o01IT6NNQaex6qLw3VWrnTWK2NkQc7G05jnY0fh35fVUaVCK1LhDYlQtsSoV2J0L5E6FAidCwROhUIbUtMRFtiIlrYRIxqgI76MzRsIkrQsIkoQcMmogQNm4gSNGwiStCwiShBwyaiAO1QE9Gfx/o/h3bQqIkoQqMmogiNmogiNGoiitCoiShCoyaiCI2aiCI0aiKK0KiJKEH7EhPRl5iIvsRE9CUmosdIxI4EI+Y6Eozs6kgwAqkjwUiZjgQjOlqSgJEHHQmGyXckGM7dkWDYcUcC47EBxmMDjMcGGI8NMB4bYDw2wnhshPHYCOOxEcZjI4zHRhiPjTAeG2E8NsJ4bITx2ATjsQnGYxOMxyYYj02zXjvuncT7TySqnvMXJdhhrA7u3wf33BqUW/loB4ZQ6xG3KZTbFsrtCuWOqNwhDY8kqai8PDj44Y2DH13CCtV6rpKY/MCbwshdFaxLTScR1tCmkwjrfddIbC18eOfWXdJIJKxRTinSL0FkWIJIinzMiUwLEKnrJYik6Do5kRRtJyeSou/kRNoliFxC49FLaDx6CY1HL6Hx6CU0HlNg4+m5CywxPXeBvaTnLrBq9Ny2UG7YQpDMmSHZMTdsxme4L8d2iOd/I/+Ruz8lXn9KuvqUv3yGWTxFXX8KxZ2EOMVvC3SCC5PDelhBTXYskaJ7yhIpmqcskaJ3ihIdxTybLJF/RdHxryg6/hXFWT8++0USKWbXZIkUc2uyRI52I0rkaDdxeOOUzEgiR7uRJHqOdiNK5Gg3okSOdiNK5Gg3okTLL5Gt3VyQyN9uPH+78RztRpTI0W4kiYGj3YgS+eduAv/cTeCfu5l1E4Ivksg/dxP4203gbzeBv90E/nYT+dtN5I/+WbdrMHqg1sa4EYrHQQk4KBEHJcGgzLpnQwZF4aDM6VdGmTOK/r9Ha2fd42FKbovK3a5VDwztDeyI2xXK7QvlDoVyR1ju6AcGXX++LvWs26NcxW318D8OtN/qETesf2e4Yf07ww3r3xluWP929uwnLqgRN6x/Z7hh/TvDDevfGe5UJreqC+WGzcsMN2xeZrhh8zLDDZuXGe5C81Lh5mV6Z1BmxI2blzI3bl7K3Lh5KXJr3LyUuXHzUubGzUuZGzcvZW5YHzTvH/E1TsuDpc+KagN7CV8jUVoi0wb2ap9OIqwxTCcR1kOukSgvSOhZ93D4MpGwbX5KkbDVf0qRFPmYEwl7UzGlSNg7kAlFWoqukxNJ0XZyIin6Tk7kEhrPrHvVfJnIJTQeu4TGY5fQeOwSGo/FbTz+vH2ZiaM1BYdbYmRu3F4ic+NWDZkbtz3I3LZQbtyMl7lhY1t+hsrBJnGGGzZcM9yweSlze4zc6VFwrW2q5SRPcacjbXeoPUU7liVSzAaKEgPHuqcokWPdU5TIv+4ZKGYBZYkUuShL5MhFUSLF/J8skWL2T5bI0W5EiRztRtgoT0eOdiNK5Gg3okSOdiNK5Gg3okTLL5Gj3YgS2drNBYn87Sbyt5vI0W4kiYn/mfXE/8w67mY300nkn7vB3UJnOon8cze4G/NMJ5G/3eBu9zOdRPp2Y2r6dmNw93eaTiJ59L+1Rz/Xh2Z9t908t2d0L77s7o/Nfnc6PP56Gl65OzTbbfN4+3TY328eXg6b2+3+vnutqk9fvhkVV8ak9q+u34TF1H5llOoOu98VY+uVsbr9qe1P/g0=",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2;\n\nglobal len: u32 = 2450 * 2;\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon2::Poseidon2::hash(ped_input, len);\n    assert(val != 0);\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/bench_2_to_17/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
