---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "len3",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "len4",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/91Y3U7rMAx227RphibQOQ9xpHPV0o5NXCHEj8Ql13BRivYcfXQIxJvnuQVELDQsVUljJ/7y5UtSNYF3s69PEuomlBnsG8ZchLL6ntURx6oSAXNsvElEvFoY0wPAmEVedwO6624OgNP8ADAWB4DRKmB8s5IJ1G/ULIjXL54nx8K44UTXoXShTIk/4saqHcsbc/xV1fZOmF9E/I0LYxqd8Vc4fq4zfoVauBq249O5YF689K6HLZfXpA+9GG9IzM1IzC2JuWUxc1IHhg/50NDjq14Wynw3c8YxkHli7kInd5uwfADb9aA+zD8DVW3XCcuHeDg/uNZzjBm2eLjPDPvzQF9OfLi+/rz8R+K4thCHg139Rtad9j5vf1B3i9+ou4z5zLA/j6/qjnJiSNwpqTehjmumeW9qnbPe/gr4aS5vdoCNITcZaUNekeeSxjOfIz4z7OaZhXdD8tCxEEfO4uvwfhzKgvTB/idC/oLl38EttHFenBDvhHivw/+hfhQer6FHgpvvM+yr/d3B9yByz3MaMid+RtH9m7O281D6+fakD9/jU/v+BMbvA4m7zVqA6nm64c4K3BUT3FniswJ32HYJ8bjLPskd151V5q4UuLMT3JXEVwrcYdsdxONuSnf8XKbcKd2bk9xJa/lV7u5hnLsU9rmjbVO649pSutNaxOoErBKeY4EfN4IVIuIEhikXcKTMh7EPDJ/T4bL6Q8bl3ByRuhni51+u3rXuDb8jcpB/Vhvip/FP4X0mzOM7P/rWy65eN926W3TPz23fcZ68pYSn2Pm7ZbPqT9t++bRouubsw/wvAPqcaf0XAAA=",
  "debug_symbols": "pdLNjoMgEAfwd+HMAeRD6as0xqBiQ0LQUN1kY3z3HRzdtodNNu2Fn4D/UcispHftcmt8HMY7uVxX0iYfgr81Yezs7McIqythedAwcko0RwpEIBJRiEZKpCKXAjA7JUM4UiACkYhCoIoASqRCzE7FEI4UiECgigQUohGoooAKMTuGIVBFbRsl55mbOTmXj/x0CXA1k00uzuQSlxAo+bJh2V+6TzbuzjbBLqPExR6EgoMPLj9t9JFmf0cF50dYiOI3rv6fl/rM6/KdfHV+XzL9Rl5xeeSVYB/m1Uu+hpntfHppyy1XSt62wR3TYYnd0+78PZ07Z1tPaexcvySXKz16GzrnKgyVpqaEw8rVCGqqPOF5YihnvN7yf/wA",
  "file_map": {
    "50": {
      "source": "fn len_plus_1<T, let N: u32>(array: [T; N]) -> u32 {\n    array.len() + 1\n}\n\nfn add_lens<T, let N: u32, let M: u32>(a: [T; N], b: [Field; M]) -> u32 {\n    a.len() + b.len()\n}\n\nfn nested_call<let N: u32>(b: [Field; N]) -> u32 {\n    len_plus_1(b)\n}\n\nfn main(x: Field, len3: [u8; 3], len4: [Field; 4]) {\n    assert(len_plus_1(len3) == 4);\n    assert(len_plus_1(len4) == 5);\n    assert(add_lens(len3, len4) == 7);\n    assert(nested_call(len4) == 5);\n    // std::array::len returns a compile-time known value\n    assert(len4[len3.len()] == 4);\n    // Regression for #1023, ensure .len still works after calling to_le_bytes on a witness.\n    // This was needed because normally .len is evaluated before acir-gen where to_le_bytes\n    // on a witness is only evaluated during/after acir-gen.\n    assert(x.to_le_bytes::<8>().len() != 0);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
