---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "10190580946026949980",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "t",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "zdvdTuM6EAfwd+l1L+yZ8XjMqxytVnyUVSUEiI8jHSHe/aQsTrvxJNXfrRZuEEH5OY5nHJKJ87a62Vy9/vq5vb99eF5d/PO2unu4vnzZPtwPW2/v69XV0/bubvvr5+GfV2H3Q+Vj/+fHy/vd5vPL5dPL6iLGuF5t7m92v6XB327vNquLFN5/rFeaYKGwyKjI5ArJVYhNhX8elqoocSrc86AYPgVFnYoMC4NFQYWxJzjIp+AwHV1zz1yCfQpRngr3zMWoipKnwmBRUFECLCIs3ExMop8iDbtNhDtWSevoJi0TEYN7IlpqumcKDXHPJEupJLVHIZwwTgQnCSduCmerSZ/NGuLml4UaSQvT2Mfojpjlmi5WtCHuiBWq16HCqSGCk4QTxUnGiTvthwTneh0OsR2z0oEo9KDYg6gHcQ+SHpR60MyQ6/gfNmgzg5h7kPSg1IO0B+UeZD2oZ8gl9KDYg6gH9WSE9GSE9GSE9GSE9GREmolT2U/CIg3imftiHW+MmRqkPUfKPch6UOlA2jN6GnsQ9aCeOM0+ii2i1IO0B+UeZB0oR/i+y3/8M6pBMmoJ40RwknCiOMk4MZz498NcnzSNm4lgAScRJ4QTxongJOHkWPQdknFiOCkw8R+3l0nECeGEceJHP9oCSThRnGSc+NHPef4ptRSUkF+jWCYRJ/ATN/k1imUiOEk48aOfa1nDTBqScWI4KTCJx6JvqSERJ4QTxongJOFEceJH32w+x/x6yzIpMPFrLcsk4oRwwjg5Fn2HJJwoTjJODL4oUYEJB5xEnOBXfsav/H6NaKk4T36FKI05lgo1xHBSYOLXhpZJxAnhhHHizspU0kiauPgVoWWiOMk4MZwUmPgVp2VyNPotIZwwTgQnCSeKk4wTw8nM3Jd5ogEnESeEE8aJG32VehnX/AdZN7sOLYyvx1X2t1VEzs5Mua47GH7d7xzpd2fSOTtj5bAzH+3rOdsvbfv55PbH52bKIZw2mPaNOuPXIZXGztB01QP5FcKl9/KUsfH/IAYdxRmlobpXR8kOCrBdo1TO2RmRaX5aOLn9/VoYO3Gy+8XJr+oMfafOMJz5hk8Wv9TJVE+Dm7cJ5Jc6WcfVTpb/3mTxi6i9nWkni19xhdo/X0r4tdyv6ow7WdhqCYtLczH3q8TLRHCScKI4yTgxnPjpPa594z9flXoR54P0PmmusV9/hjqzNNfYL1ZD7Z8tvdkvg39VZ9yJI6lOfEnT5RDsF9iXScKJ4iTjxHBSYOIX2GVc8eyRiBPCCeNEcJJwojjJOPGjT/WyKUp/7eGU/dJ9b2eah1P26/y97Ze2/Xhy+2d7HmT/dcNXdcafZXNL8p3OSKgdH0q22oy8nNo+F9q3n0872fSdOqPfqTMZ6swHMZj4b2eWvq5h/+1M1HHZnLaEcSI4SThRnGScGE4KTGbWB49JFnNqSMQJ4YRxIjhJOFGcHIu+QwwnBSYzq44XScQJ4YRxIjiBv/njmdXTiyTjxHBSYDKzanqWvA9b/14+bS+v7jafX5Levt5fH3xY+vLf42byjenj08P15ub1abP72nT/oekuvlLWqfzYfVk1bPAQKFbbbe4yjC2u2Xg45nDc/wE=",
  "file_map": {
    "12": {
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n",
      "path": "std/convert.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "//Basic tests for arrays\nfn main(x: [u32; 5], y: [u32; 5], mut z: u32, t: u32) {\n    let mut c = 2301;\n    z = y[4];\n    //Test 1:\n    for i in 0..5 {\n        c = z * z * y[i];\n        z -= c;\n    }\n    assert(z == 0); //y[4]=0, so c and z are always 0\n    //Test 2:\n    c = 2301 as u32;\n    for i in 0..5 {\n        c = t + 2 as u32;\n        c = std::wrapping_mul(std::wrapping_mul(z, z), x[i]);\n        z = std::wrapping_add(z, std::wrapping_sub(x[i] * y[i], c));\n    }\n    assert(z == 3814912846);\n    //Test 3:\n    c = 2300001 as u32;\n    z = y[4];\n    for i in 0..5 {\n        z = z + x[i] * y[i];\n        for _i in 0..3 {\n            c = std::wrapping_sub(i as u32, 2 as u32);\n            z = std::wrapping_mul(z, c);\n        }\n    }\n    assert(z == 41472);\n    //Test 4:\n    z = y[4];\n    for i in 0..3 {\n        z += x[i] * y[i];\n        for j in 0..2 {\n            z += x[i + j] - y[i + j];\n        }\n    }\n    assert(z == 11539);\n    //Test 5:\n    let cc = if z < 1 { x } else { y };\n    assert(cc[0] == y[0]);\n    // Test 6: for-each loops\n    for y_elem in y {\n        for x_elem in x {\n            assert(x_elem != y_elem);\n        }\n    }\n    // Test 7: Arrays of tuples/structs\n    let mut tuple_array = [(1, 2), (3, 4), (5, 6)];\n    tuple_array[1] = (7, 8);\n    assert(tuple_array[1].1 == 8);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
