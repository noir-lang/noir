---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
