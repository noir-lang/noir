---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
