---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
