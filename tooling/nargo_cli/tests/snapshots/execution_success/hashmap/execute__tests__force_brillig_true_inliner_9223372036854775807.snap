---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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Xm89e+u1ut25i/H4eW+9fy+c3d969nDr2eOtZ6dbz55uPXu+9ex3PsOSQr317Hzn2aO79ez+1rPHW89efvy0aqJGm5d3zxP5W88ebj17a5VydSc00Z13ExOlW89+5822RK03rK6+V0gp3HkFpluv79Zvi4Szp1vPnm89e2u2vHo2MKV669nvfOIzZXfr2f2tZw+3nj3eena69ezp1rPnW8/e+hTZ1dOqKddbz853nr24W8/ubz17uPXsrU98Xj1PmgrdevZ069nzrWcvt5693nr2O5/OTtXdenZ/69nDrWe/9Vqtt16r9dZrtd56rdY7n85Otd569jufzk7sbj27v/Xs4dazx1vPTreePd169nzr2W+9VvnWa5XvvFazc7ee3d969vNr9WqfRnY/33ORXf6D3yl/8Dv1D37n53susnd/8Dv+D34n/MHvxD/4HfqD30l/8Dv5D36n/MHv/HzPRQ7uD37H/8HvhD/4nZ/vucjn31QKv5P+4HfyH/xO+YPfqX/wOz/fc5Gj+4Pf8X/wO421xuW3BjmmW8+ebz17ufXsd+6kyPHOnRSZ3K1n97eePdx69njr2enWs9/53Wdu/u7z+uzl1rPftNHgeGTaat7s/vbM8/HQYfaY5HTn49E5hVvPHm89O9159nyr93yr93yr93yv93Tr2e98LD3ncuvZ661n5zvP3volo3B2f+vZw61nj7eevfFavXxgP7d+ySicPd969nLr2eutZ79zC0lu3l159Uh9bt4weX32cOvZ461np1vPnm49e7717OXWs9dbz853np1vvVb51muVb71W+dZrtXkM6tU2jMzp1rPnW89ebj17vfXsd273Ks7denZ/69nDrWePt56dbj17uvXs+dazl1vPXm89+53bvYp3t57d33r2cOvZ461nv2s7yP+3/Jf/5z//+7/+5//yb//t/15+4a//7X//9//6v/71f/z39b/+r//3f77+l//y7//6b//2r//Xf/qf//4//ut/+z//97//t//0b//jv/71v/0Ht/7H/7Gwxvgfl/9MtJD/5STE/xjjX6v49T/H5T7U8p/R/fX/8r9+I9W/fiO7hWYh+v8B",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
