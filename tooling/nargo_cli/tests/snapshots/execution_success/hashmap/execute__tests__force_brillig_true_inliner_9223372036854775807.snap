---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
