---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
