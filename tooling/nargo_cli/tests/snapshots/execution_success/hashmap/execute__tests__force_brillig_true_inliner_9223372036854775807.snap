---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
