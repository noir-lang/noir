---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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s30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7DO9gWss30B62xfwDrbF7HO9kWss30R62xfxDrbFw1UVo6Xn+3z/vnJ+eG2dnIilpyEJSdjySlQci4/29eRY7HkOCw5HksOYcnBysoWKytbrKxssbKyxcrKDisrO6ys7LCyssPKyg4rKzusrOywsrLDysoOKytznO0zJb/kdC529nmt86+39gXbuvTwze6R4xjgTcrttMrdtMr9tMppWuVhWuVxWuVpWuV5WuXT1lBCqaFVDUpdrGpQal1Vg1K/qhqUmlTVoNSZqubq2pGeL8J22R9nA++2z/Xe0i4bpGmV51mVh6tzXnh+sAu0+9sNV+/rGLbq5PdqmPe1y71vNaVNTsq7rypiyUlYcjKWnAIlJxosORZLjsOS46+Vk8ImJz1+gNwu9q1rH/dgtmt/f9p2bZVO80oP80qPuNKtKfGpwpS0XUvf0tO80vO80su00pOZV7qdV7qbVzpwNe1JB66m1sRNunV2Jx24mvakQ1fTY+nQ1fRYOnQ1PZYOXU0PpWfoanosHbqaHkuHrqbH0qGr6bH0odW0LhHGL8HxdFN6Pb+TU+fiuH0BIZbXLdv057/2sZywvUl6nld6mVY6yynfm6TbeaW7eaX7eaXTvNLDvNLnraZl3mpa5q2mZdpqmsy01TSZaatpMtNW02SmrabJTFtNk5m2miYzbTVNZtpqmsy01TSZeaupnbea2nmrqZ23mtp5qynLFICbpM9bTe281dTOW03tvNXUzltN3bzV1M1bTd281dTBVNMqB6ZCVjkwVa/KgalkVQ5MdapyYCpOlXN1FXm4hefFyf0cEJG8wZJjseQ4LDkeSw5hyQlYciKWHKy8Q1fvrELPh5dCCXs5HksOYckJWHIilpyEJSdjySlQcoLBkmOx5FyclaMJTznRxLST47HkEJacgCUnYslJWHIylpwCJScaLDkWSw5WVo5YWTli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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
