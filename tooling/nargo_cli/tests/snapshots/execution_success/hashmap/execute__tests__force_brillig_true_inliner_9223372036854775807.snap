---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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/mr89PzV+EH5uxGBEnUjAmXkRjQ99cTLTiQxHIkajag4HJHHEQUcUcQRCY4o4YgyjqjgiHCeXXCeXXGeXXGeXXGeXad7dsphJ0rlvAYOzu9PvrtYlXq55f1YOXaLVcgrVemne2Ipj09OaedzrG/Rvx1b6tOotI29OQ77RhQ4n4WNCHQdbkSg62Ujml475adeLr946qllHFHBEVUcUYMRVedwRAHm2dVNv/rb49S5RX8kyjii6Vd/28cC3H6uLz5HFUfUaETe4Yg8jijgiCKOSHBECUeUcUQ4z/Y4z/Y4zw44zw44zw44zw44zw44zw44zw44zw44zw44zw44z444z444z444z444z444z444z444z444z444z444zxacQ87fNefbg+j25eAT0Yuj6619ux9d6z/cIzweHb3cD463c+/Hhpcgty8X9jM/vRHp5cHl8ULhpwlht0M3EZOJqIvYwp35eXTaQ8RqIvaL2EzEbhHn7+S7oojeROwXMZiIf0PEfJejlfxCxGgi9osoJmK/iFYn/h0R673Ybi2+EDGbiP0iFhOxX0TrWH7PE1+KaB1Lf7Bk61gGiGgdywARrWMZIKJ1LANEFBOxX0TrWAaIaB3LABGtYxkgonUsA0S0jqVfxGLF9gARZYCI+zZFef4bP4ioDOGtQ4YdjCWqOKJGIxoy7GAskccRBRxRxBHh/KgmHFGeTTR0zG6tZXH+ujh/W5u/ucX5/eL8YXH+uDi/wPmzwp8W56fnr8ZPz1+Nn56/52PKa6Pn7/mY6ebo+avx0/NX46fnr8ZPz9/zMdPN0fNX46fnr8ZPz1+NH5S/GxEoUTciUEb+IvLTU08ZVdq8xxEFHFHEEQmOKOGIMo6o4IgqjqjRiALOswPOswPOswPOswPOs8N0z/7QmPIWMnmlKv10Txw2przFwGHfiITzWdiIQNfhRgS6Xjai6bWTMsy5xYojajQicTgijyMKOCKhebZMv/qVoeBNKo5o+tWvDHVqyeGIPI4o4IgijkhwRAlHlHFEBUdUcUQ4z844z844z844z844z844z844z844z844z844z844zy44zy44zy44zy44zy44zy44zy44zy44zy44zy44z644z644z644h5y/a+56Y8rb/K171xvJ2+bvX7uiiN5E7BcxmIj9IkYTsV9EMRF7h7m0+Rsrryii1YkDRLQ6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2+/mHT8zzb317P6tZ+/9vP9wn/NVt1/2bl95BWuL9X5noIl7mKOvr+6vxHr/ZinG9nTwy6morfr7wc6F84O9d2X/asm7Vp9B/l2+7N55mzg7eevZ01vPnt969jLtY+v2+bLinz6Lyd1R6kdQnnqvHcW3WSi1ur0ira9QguOg+Hko+5fLtQZ5gRI4KHHiP1B+oKQXKO/8BjWHd36DmqN769n9W88e3nr23g/Y/grFUOV4dnnr2dNbz977XdtuePF4By733r9Xzl7fevbea3W/NxndUffe+/fK2f1bzx7eevb41rPLW8+e3nr23mt1v3MX4/Hz3nv/Xjl7fevZ2zvPntxbz+7fevbw1rPHt56981o9fYYlp/TWs+e3nr289ez1nWfP7q1nl99+WjXnTjVP757nXN969vbOs5feKuXsTmgu77ybmMtbO4rSm/Rnd/5zeesVWNo7z17fen1X/9azh7eevTctz57ey73fFilnT289e37r2ctbz17fevZ3PvGZe78tUs7u33r28Naz9z5FdvY8ae79pks5e3rr2fNbz17eevb61rO3N569uN4nPs+eJy3Ov/Xs4a1nj289u7z17OmtZ89vPXt569nrW8/+zqezi3/rterfeq36t16r/q3Xqu+9Vs+eQS4+vfXs+a1nL289e33r2ds7zx7cW8/u33r28Nazx7ee/a3XanjrtRreeq2Gt16r4a3X6g9POJzt0yjx9/dclBj/4HfkD34n/cHv/P6eixLLH/xO/YPf+f09F0XcH/yO/4PfCX/wO/EPfkf+4Hd+f89FkfIHv1P/4Hfa7/9O+v09FyX5P/id8Ae/E//gd+QPfif9we/kP/id8ge/U3//d/I7d1KUHN569vjWs8tbz/7OnRQl57eevbz17PWtZ2/vPPtbv/ssb/3us3R/93l+9vjWs/deq3/7YeC0V6XZ/cNTyQvvAinlTbsRtrPXt579nY9Hl+reeva36l7fqnt9q+7trbo3/9az9xrp2cPXpcW3nl3eevb01rPnt569vPXs9a1nb288e+39kvH0kfra+yWjcvbw1rPHt55d3nr29Naz57eevfdaPXukvnZvmDw/+zu3kFTv3np2/9azh7eePb717PLWs6e3nj2/9exvvVb9W69V/9ZrNbz1Wg3v3EJSQ3jr2eNbzy5vPXt669nzW89e3nr2+tazv3O7V43urWd/67Ua33qtxrdeq/Gt12p867Ua37ndq8by1rPXt579nZtNqri3nv1d20H+7fb//L//6V//+T/953/5r//P7Rf++t/+13/7L//zn//7f9v+3//5//2P+//yn//1n//lX/75//6P/+Nf//t/+a//1//61//6H//lv/+Xv/63/8Nt//F/3liz+w+3/6z+Rv7XVRrif4jxr1X8+p/lxvzXf5a//iv/6zdq+vffKDeaG9H/Dw==",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
