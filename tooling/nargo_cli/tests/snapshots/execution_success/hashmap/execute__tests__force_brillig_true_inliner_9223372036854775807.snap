---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "18120910881087353187",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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70fQJlTorS9sVmh9YbPCYApbFUZT2KqQTGGrQptOGg80y96mk2aFNp00K7TppFmhTSetCoNNJ80KbTppVmjTSeMRoznYdNLaWvfep2BGhTadNCu06aRZoU0nzQptOmlWaNNJq8Jo00mzQptOmhXadNKs0KaTZoVkClsV2nTSrNCmk2aFNp00K7TWulXh+eMg2T//0uOG4v6X6Pl3TktQTk+Vuaa3v3NEqu75yprK8erp1qvnW69e2q4e9m8yhuSPV6+3Xp1vvHo5fyxC7er+1quHW6/e+BP5eOueV/fuePXGdzWm53aBMR+v7t2tV298VyM/UywyH68ebr16vPXqdOvV061Xz7devdx69cYEfm0FToGOV+c7rx7crVf3t1493Hr1eOvV6darN35WyT1rE/ljbQr51quXW69eb70633n16G69ur/16uHWq8dbr063Xv3Wz2ps/azG53dziI69WCy3Xr3eenW+8+rkbr26v/Xq4darx1uvTrdePd169Vs/q3TrZ/V8w/HHzYnt7zxGn8PfOd/0uqT975STvxP+4u/Ev/g79Bd/5/Sn49FyPP9ODce/k//i75S/+Dv1L/4O//zvnG/cK/wd/xd/J/zF34l/8XfOfysUnrdaK538nfwXf6f8xd+pf/F3zm+OX92/LB82+7z+O/4v/k74i78T/+Lv0F/8nfQXfyf/xd8pP/87tfUu6uW9wtp6FzU+Xxnejgrbrx5uvXq89ep069XTrVfPt1693Hr11t94kNvvvJ/8vPOdV2d369X9rVcPt1493np1uvXqN/2G7+y+X9nv+71eefqbaY71eY+Qyb3Khq9nd7hjff5+PEZ+e/Hp+Y9c/fPFzoXrF3v/6CS3Vz/+zPUd5N/11eZfdl39Kq26cuvV661Xv/PXr9W7bj+2bj9Jk/zbz2JyTxT/FZS3qXRHCaEXSn38bD77unqKEnFQqB/K/hWZWgOdoCQclNzxDcovlHREiXd+26HGcOvVW3/Oy/NtCpWOV6dbr55uvXq+9erl1qvXW6/Od1699f593OM0Hu981tb798LVw61Xj7denW69err16vnWq7d+Vvd78dGd/LzXW6/Od149uVuv7m+9erj16vHWq9OtV0+3Xj3fevVbP6up8bMa998QxHjMmcR3Xj27W6/ub716uPXq8dar061XT7dePd969XLr1W/9rOZbP6vlzu9x1+JvvXq49erx1qvTrVfPd179w+8ir54cqq2/pbv87Wht/S2dcPV069Vbu5Sr31rUeuuNcb7zt9KVb/0E8q2fQL7zSYrK+darl1uvXm+9Ot94dW59lk24ur/16uHWq8dbr063Xj3devV869XLrVevt1791s+qv/Wz6u986ol9uPXq8dar061XT7dePd969XLr1eutV7/zCUW+9QlFvvUJRb71CUW+9QlFvvUJRQ63flZvfUKRb31CkW99QpFvfUKRb31CkW99QpFvfUKRb31CkW99QpFvfUKR462f1XjrZzXe+lmNt35W6dbPKt36WaVbP6t062eVbv2s0q2fVbr1s0q3flbpzqeJme58mpiTu/Xq/tarh1uvHm+9Ot169XTr1fOtVy+3Xv3Wz2q69bOab/2s5ls/q/nWz2q+9bOab/2s5ls/q/nWz2q+9bOab/2s5ls/q+XWz+qHbzhc7YnA57/7v9x3gM+fTRb+Tv6Lv1P+4u/8fN8BLj/fd4Cr+4u/4//i74S/+DvxL/4O/cXfSX/xd/Jf/J2f7zvA50/VXv+d828QCH/H/8Xf+fm+A8zxL/4O/cXfSX/xd/Jf/J3yF3+n/sXf+fH+E9459xd/p/WbzxffPnlcvbHXuHq+/XH1dOvV861XL7devd56db7z6s0P215f3d969XDr1eOtV7/1s+pv/az6G7//97h6ufXq9dar851XD+7Wq/tbrx5uvXq3J9LTPiflt2dght7p4qHvxp0uHlcvt1693np1vvPq8Vbv8Vbvdz5G/bg633n11l8yClf3t1493Hr1eOvV6darp1uvnm+9ern16rd+VunWz2q69bOabv2spls/q+nWz2rrLxmvtg14XD3devV869XLrVevt16d77x6drde3d969XDr1eOtV7/1s5pv/azmWz+r+dbPar5xe5LH1fnOqxd369X9rVcPt1493np1uvXq6dar51uvXm69+q2f1XLrZ7Xe+lmtt35W662f1XrrZ7Xe+lmtt35W662f1XrrZ7Xe+lmtt35W+cathB5X97dePdx69Xjr1enWq6dbr55vvXq59er11qvfuJXQ45ch7tar+1uvHm69erz16nTr1dOtV8+3Xr3cevV669Vv/az6Wz+r/tbPqr/1s+pv3HTocXW69erp1qvnW69ebr36XYeh/9vj//h//7f/9p//t//9v/yn/+fxF379t//xf/3H//6f/+v/tf2f//3/+7+f/+V//2//+b/8l//8f/6v//d/+6//8T/9H//jv/2n//W//Nf/+Ou//U9u+5//5cEay394/G+qD/JfP4sh/ocYH3/+949seNydDP/h1/+WX/8v//tv5PDrb2R60DyI/n8=",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
