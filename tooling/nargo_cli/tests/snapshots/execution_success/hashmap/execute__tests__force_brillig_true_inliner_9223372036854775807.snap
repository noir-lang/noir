---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "955212737754845985": {
        "error_kind": "string",
        "string": "HashMap should have retained 2 elements."
      },
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "6895136539169241630": {
        "error_kind": "string",
        "string": "HashMaps should not be equal."
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "9417307514377997680": {
        "error_kind": "string",
        "string": "HashMap after one insert should have a length of 1 element."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12389747999246339213": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14479745468926698352": {
        "error_kind": "string",
        "string": "HashMap after one insert and corresponding removal should be empty."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16567169223151679177": {
        "error_kind": "string",
        "string": "HashMaps should be equal."
      },
      "16850003084350092401": {
        "error_kind": "string",
        "string": "Load factor is exceeded, consider increasing the capacity."
      },
      "16954218183513903507": {
        "error_kind": "string",
        "string": "Attempted to read past end of BoundedVec"
      },
      "17677620431177272765": {
        "error_kind": "string",
        "string": "HashMap length is invalid."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+y9CZhkyVUeejOrqrurpqs7e5np6Vl6ep/ppbr2Xma01EhVI42QkOBZbJZBs3SDAAMPZCGxyCkDYjEIDGZ9EjIgNj8WySwCCUkMxhYPnsHoWWaTAOsDIVuWEAYBQth6vtN5Kv/887/nxs2KyMzqvvf7uvPWjbjnnDgRceKcE+fEbWTXr1v+979G536y89uA391Z72Vla53fha1dixFhLaSisbENaGxuAxontgGNk9uAxqltQOOObUDjzm1A465tQOP0NqBxZhvQeEsCGp+8cBHPic4Xi1wY58IuFyb5ZM0nQz7Y8s7MmXVLVnxZw/944/rvdOfvJpRHFPaL04Q3JvzLC6tXp0X7ItK/PA18TwD/sWmAmQD+ws4OnE9td+FzW2wcNLJk/bSUuJ2PzVLbMmiL4Z5Mg/vxBuHLqJ0Z4Z/Jko6pxQbhM3qYP3Y/a3XaXXoaVDbZ7m+HlU21e9uRX7k8OgT1eGw1od5xuF/q3Ccej1cTz+uFA06b7dnOdrZ5Gd8m4Jnx1fi8C+tT2TSUTbZ78cx0/p4EPAjL6Jii+sc6f+/t/O6Ad+z9lsC/g/D30C2eMV+mRf1pUT9f++7o3Odrnq0Fz2x34UXs04sGfz0N/BWDv5EG/rLBfygN/AWD/6wO/CwB7GcD7RHhb+opD6fhzSb856SBv2TwP6kdm/fLlwz2c6PDvvSowX5efNiPG+xPjg778uZcfX502I9cMdgviA/7EYP9KfFhP5rL4HwNP79+HZ6nh6CuZHNub9avI6LOlv+bKoH1HIKF79u70/R3ZFmyYPrODqCLddGd8DyeHFhaDNVFDf8M0ZpKF91J9DB/UBfNy3YJWluiDPsQyxDPLoGnJcps3RonWDHbWPOr5lfNr5pfw4RV86vmV82v8eSX6VqomzUKfg0PP2M8qNfuIDy7IuJBWObPMJ1/WtBgevcMlMX0fVi/2N6L+doYJ+63YH28z68pevaNnd8nfaRkX+EeyIR4xrzbIeiZprJscN4s8oNZQVOD8CIfIvbLasj4QvwzWf8YSmEP3UL0FPWZ8W63oLVFZfnFcmK3wLNb4NkusJRcQV4OKleYzzFgzUaEtScirL0Cls3DFjyP6dsOnYeGf4ZoTTUPW0QP84d5t0/Q2hJl2DYsQzz7BJ6WKOO5EwOWlaHc3Uvv4ZybpjIc2w8TzD3wHusaTXjP1u18Pv8beAfxTWV673Kj3S3H+nvWuzB/rvNM6QW3UBmu0bupDMfgLJXhfDEYNpd4PKx1/l7Y4mU82t+Bh7qGGp9Nqo/3yEN79vbOr9I11HzBZzz2ZgQ9s+I9lkP70/AuWB8w/DNZUrm4yH2JfJ0RfDX+HEhDz4rRc1DQo/o5H297sv4+Q/oMFu4DrLev/yo5xLIG5RDL3FkoY/mFaybuGzJvVft4TwJlxwy9p2i3flE2gKf7cd2JrDtfkOZBdQA1L3lfJJEufrlsDfgdwIv9rtYApHOK6n//M7swf7/zTPXjTipDnuyiMrUWGr9m0/BrU87bOEY5jziNtmbWv/7iHJiiZ+/r/Co5X1U/nxb0MCxlE+eXzTXuxz8D+lY79Km+4v5A/MPqD8Q5Azyq0h8fgvZyfyh5pdYH1R9Wb1hyJKbNomS56bBKP+OxkGjd3hwLpm/hWECce6E9WB/v82uKnn2886vGAtonns2ixoLVC7EFE+mvwTqY4R+WLbgvkK/Gu/2C1haV5Rfbb0rX2y/wbBdY+T37ZJCXg8595nMMWAciwjoYEdatApbNw9vg+Sh8MoZ/hmhNNQ9vI3qYP8y7Q4LWlihjn8whgeeQwNMSZTx3YsBSfqRb6T2cc2zv4Nhmn8xBeC/UJ3Oi0X0HdZxQn4zVb4M+froDU+nV1m4rQx13P5XhWnCAynD93YyPzpKO3QUeu6gPIE72yeDcxnE/Rc/mO3yL4ZOZFfSE+GQSyaFgfYDlUGqfjJJDs4Kvxp9DaejZ9MncLugp88lgnyF9BsvzyaAcsnmq5BD7ZND3wzIK10z2ycyWtI99Mig7Zum9vYJ26xdlQyudWsE3GDH3eNS8DJXRzyIZbe0I9ZlY/aeDjH4OyWhlSyo7fA/B3oy/Btl1uSO7pgXs/N9a5++FLV0rV5QvIB78i1eV7yce/EubeYd70tC/Op31z5OI9C8p+zsi/BVlo0bkz4rah4gHf2lB+fEj8udRg38wDfyLSp+KyP9FpXNEhP+YWrMj8mdzft2eBv7jBv9wGv5szt870sC/ZPDvTAP/msG/Kw38zfF/dxr4lw3+kTTwN8fPPWngb8qfo0ngX9pc348lgb901fSu41n3Mt3NcJ+A5/H0/eXgHB7DP0O0xqWnaw+dIHqYP+yXOSlobYky1gFPCjwnBR4Fa3dEWLMRYe2JCGtvRFitMW3jvoiw9keEdSAirIMRYd0aEdZtEWEdiggr5vi6PSKsmOPrcERYMXkfU07E5NcdEWHdGRHWuPIrpvy6GXg/rnLiroiwYvI+pm4Sk18xx8TdEWHFXNNi8ium7htTNzkSEda48v6eMW3j0YiwjkG9/G+M98//noSyGSqzuu9rXP9NbI+vsD1rOBD3qUS4G4TPeI3PEP+soMfonhFlk1ug9fHVlcWVa1dWH3382vLVxy9daxB8o5Wf4X5U/u+0qH9c1Dde35sl4fWCOgfvNPA1vyah7BSVTUGZ0Yjn4E0TzNj0h/Af8bdEfTyfqkpftjI9tmLBmhkQ1v6sX/aYnFBnBHFM+LRoz7ByiY3OyUznEXAu8QnRxvyaomf/tSM4YuQSTwp6ZqnMypF3ifJrg2NJDP+MaEcK36ni66Tgq/HuhKC1lfX3LcehKR/tCYFnu8DK7zm2VOWRh/Q74mE+x4B1MiKsUxFhnRaw0q6l4bGlhn8mS7k2dufhvUQP84d5d5+gtSXKsG1YhnjuE3haooznTgxYKheA9QCcc5NUhmObY0txnQ6NW9rX7L6D+EJjS63+sWd2YR7svKDWdWu3iltifQDH4Ekqw/nC+b48HtY6fy9s8TIenenAQ31Ajc8m1cd75KE9u7vDN6UPqPmCz3jszQh6ZsV7LIfOpOFdsD5g+GeypHJxkfsS+erl+55NQ89mbOk5QY/qZ4wtxT5D+gwW6jfr7eu/Sg6xrEE5xDIX9XjPjuHY0umS9nFsqZIdSgdnvXFCtE/l7in4BiOmnqP4HSqjV0lGox+GZXR+z7GlVv+tz+jCvOzIaLa98CwpzsfF86zYLktkWywwH1AOTwtam1n/eMGxwHxac+Rw1fO+JgU9DAvpxzPAbAxMUf0NoO+BDn2pzxCzsRrS76O2x7nfQ+3xT07c7975a2l9p+Hrr+Gfyfr7OcX6eyKQr1VimfKLdfdBfeTjCiu/Z3v8ZrWhB4Xl6cGJbIhge9zwD0sPVrbtvQ7vzghaW6KM7XGlb58ReFqijOdODFhVdd1dVIZjm+1xtF9Ddb2Xka5n+ELtcav/OtD1XkG6Hsp0trlRf2KbG9fYU1SG45PPftiu9vg/i2iPTwt6ant883LtcbXvcaPa4yiHWNagHGIZpfboWA7l11btcZQdnj3OemOoPa7gG4xxsce/L5I9/gjI6NcF2OMN+hvrTIp2TFH9HwB59rR1DTODNiDfbJ0JoW9XCax1gqX8CyG2Uhr/Qvi3W3jvMrWtpOaqZyupPWrlH+az1quecYVlrKONA6yYbaz5VfOr5lfNr2HCqvlV86vm13jyK7VNwvrwTEQ8CMvsG9PJTwgaTO9GOzSFP8dsWfTnKL9/k+rjfX5N0bO/dvw5ah/ihMM75UOr93c2r4H3d04JWpWvlefyoDHN4worv+dvJqUZO4ul54Hvmuhtk83FIp+0ffd7iup/0YNdmLd0YHp+parnXo2bnDLaqsqpAx3exDh/epegR+3TN6LxZ+WyysWJCP9xlb8RD/6lBRWTGw/+8qLaF4kHf+kx3qMzHNj3Z+F5RN9Z8Dpk+GeI1lTr0Fmih/nD69A5QWtLlPEcUvsF5wQeBevWiLBmI8K6OyKsUxFhxeTX6Yiw9keEdVtEWHsiwtodEdYdEWG1IsKKOe5jjokjEWEdiggrpsyJ2Y8xeX84IqyY8zFmG++NCOu+MW1jTJlzZ0RY4zruD0SEdTOsabdHhHWMYJnOqeLe84u/42T1v7qjiKc9K2HpkunQqHM3sl7c5xLhbhA+4zc+Q/yevj8jyrZyTsMjj15bXH5k6crqtUeurTx2+fGqY8Pqnxf1lS1jvJ7LkvB6RZ3TcB74ml+TUHaOyqagzGhU5zScT0R/CP8Rf0vUfxjasNV5zudvhsKysxXQpudzSIYVM5Vqf8L8qub3Q9nFfr9EvoRNv5/xGeUv4jwF7eF+QZk4Rc++0fH7VfUj7xL0ePH4ieMpB/YLpVmjfL+Q4msVv1B+8T7AoHJhXGHl95x/otb7qnOf+RwD1vmIsOYiwrogYNk8nIfnEcd9cP6J4Z8hWlPNw3mih/nDvFsQtLZEGZ99tCDwLAg8LVHGcycGLCtDuXuB3lP+UyvDsc35J6j3hcY2v6niXt9Gu1uO9V/wYBfmz9JeH+6RWbvVun6OynCNPU9lOD4NRuK5tMDjAPUBxGm0NbP+8YljYoqevc3RB3BuePNF7StbvRA5tJCGd8H6gOEflhxSc1rpA8afxTT0bNomS4Ie1c+Yf4J9hvQZLC//BOWQzVMlh1hGoY12hspwzeT8k1Ml7eP8E5Qdp+i9M4J26xfuS6yPMBR8gxEzn1XNy1AZ/W6S0daO0PwTq7/3wS7M3yUZ7Z3Zo2IK+Dyg94Dssm+NZVSH81MQNsP7K/Jdpcn96J4xquzYtHEl4WeMGn6VE290z4iyFGeMhuave/P9uKif1pbXZ4yinZxfk1B2ksqmoMxoVL6rROfRLoTwH/G3RH0+Y3QrZxFwDthWYO0aEJb5wTAmg3ORUa7F1meQdqQV567h93LfGkS7gpVfFmfnxdA1sn55pui6hehSMXchsvE4PI/oqw3OyTP8M1n/WEihLx4XfFXxeEpW27tqDnAM/Y14fkmsNtb8qvlV86vm1zBh1fyq+VXzazz55X0zlH8NDz9jPKjXsj58MiIehGU+H+Ub51yO7brn/dzJ678x9rxnBD0hNkuiPeZgH7fhH5bNovjq2SwqroT9xfnFc1ntrZ8VeLYLrPye97xj+IJv9v1zm4eJ9naC/aqGf4ZoTTUP1R7enMM7tafYEmXsi1N76/MCT0uU8dyJAUvtfczRezjnZqhMxd+pfajQ/ZSXTnbfQXyhe95W/y/WujC/vAMz5OxEdV6cleEY5P1wnC8GY7vvebcdfaDqnvcZQU+95715uXveXjzxjbbn7Z2dGBqXw/IL18yt7nkr2aF0cNYbJ0T7vO9dcN1x2vP+HpLRg+55v2qtC/P/IhmN+ydm76k+OEllN2Is8g9FtMtULHJD0KdskfV2b/1zgFfh5vqKPzhvZwra/6+h/Q9S+5V+oM4tYf3gJwHmegdmyDkWiexTdwwpmVh1DP2MM4ZinGMRct5OIls6eC3neIzU5+0ovnrn7Xh69s1u2yufUUi/I57atu/VbyKP+9q2F3jGwbZHuevZ9nzGeWzb/g9Ibxz0ewqPrXVh/qGjN1q7lW7Itj3qaWzb4/jkePZEc2mBxwHqA4jTaGtm/eMTx8QUPfszRx/AueHNF893FCKHEvlFgvUBzqtJLYfUnPbi2RP5PjZt+0VBj+pntO2xz5Sd79n2Sq9WcohlFNoIHM/u2fYzJe3zvqcwQ+8pu9L6xbPdEYaCbzBS5uxWkdGfIBlt7Qi17a3+Xz69C7PZQb5V2x73fcftfEGjrZn1jxfvfMGZDm+UHMY98wnxzLPLkFf4N9KPY43PqdjsF6DvWR36hj1Wj0fEg7BMT7qRfUd3OuMrhu+ozmPfvOo89i3Cyu/rPPatwarz2NPnsbPdX+exX/+7SKd85lT3HdSbQu1+q/9u0CkfIp0SdbE6j7178Z7+8x19oM5jH96efp3H3i+H6jz2bpn6NZj8LMae/ueSjB50T/9fgoz+fJLRuG6yb1bZrpyT/kUguyyPfTrTa/Ja5++FLV0rq2nP5790WeVqxoN/cVn5RyLSfynt9wVWr9Xn529eyc/P5zm0FTtuJiKsmOfB74kI63hEWK2IsGK2cV9EWON6BnLMs4Zj8v5kRFinIsI6GBFWzO9GxDzLOuZZ/DHHRMyzrO+LCGtcz/WP2Y8xZXR9fv6NsXbcDLxPcX6+/W06J8f45PfTVGZ1f7djB6aNK1267OUUq++excTdIHzGa3yG+GcFPUb3jCib3AKtS1f/t+G39Ni1pWsL11auXbzUIPhGKz9D/0H+L9SOSfydAnl2/lnga35NQtlpKpuCMqNRnT+WyE5dCeE/4m+J+nz+WGhftgQePu9qK7B2DQjLzh9DHZp9TmzvZlm3rxLFhm/6941H6N9HnDuhPcxTPItsip79oePf35n1826n4F0r6+UJ1psV7zHv0pwHGX7umOGfyfr7OYU/ZjqQrxw3g+96cTANKkM8Xp4GlvE+4zjAitnGml81v2p+1fwaJqyaXzW/an6NJ79Sf2uL9eGZiHgQlu3Rq1gFoyGtL6Jrs5htjjaL8jc0qT7e5xfHDCx2gj6VzVL1DLqdgp4Qey91/oDinerLqry74vBuWPZeov3u4P13wz8se+9MIF9VXjfHMZ2F91gOKv/YWYFnu8DK7zm+uwnvYTzSc3b04izLFbXz19mP/L1P68J8Xgemkgch39W4kWXwCxPLYJZJyu+VX9yPVv+zgL7n0Hkdo/TjnXTao+T6ScEbbK89e/EYyPVEa2KwXOf9i9Ry/WQgXzkmDd9tZf1zjeWnWj/Uvsd2gYVyPW284cpVpXPEg3/xipd3lHofKnReGP6ZrH99TTEv1H6vWu85NwrfVTHdPEbUt7TPCzwK1p0RYbUiwtofEdZdEWHF5NehiLB2R4S1LyKsmP14JiKsmPyajQhrT0RYeyPCijm3Y7ZxXMfqPRFhxeTX0YiwYvLrQERYMfkVU07EnEMx5/bRiLBORYR1M8yh2yPCOta5L/MRvT2Sj+jfP7UL84kdvbg9+ziNbyE8zsXwD8s+Vt9T9OxjFcelYrx4X2rQeLH8Ypt2HGDFbGPNr5pfNb9qfg0TVs2vml81v8aTX15sihdPUuu3W9dvpwWtqj94PKp48WmBpyXKeAyNA6yYbaz5VfOr5lfNr2HCqvlV86vm13jyy/uuEP8aHn7GeFR8lqcPD4oHYbHePS3wmN6N8eyj0LsN/0zW3y8p9G4V76/GifIr27u13Tw+sGK2MSasml81v2p+1fwqgxWzjTFh1fyq+TUsfqX+xss04ZmOiAdhmd5tuSLYVoNheneiOOrNXBGLhcZcEcR5GtqD9fE+v6bo2Rs6hobKFak6FhqCnlnxHvMuTUx8eK4Ix8SfTkOPGxOv+FolJj6/eC4PGkc1rrDy+x2de5uT6qzfafFeijlp58hPinYgbU2qj/f5NUXPftGZk1XPzzst6CmLjXvbzl6cZ4HOCfEux8ZZ/T94oAvzlzsw92b9ssJ8KnsJdn6/k8puRBn8a4llsOId56UirdNUdl7ANJ4n+u7lJs/t2wvIc8R5HviA9fE+v6bo2bscnleVT6cFPTG/9aTkoOla6nszPC+26/dm3uv0UdXvzTQEPYp3PL4XEvNuUfBuweEdfj9lUfDOnv1pRN6dFvR48xPlt7fm8DgdNz2wmYYeVw9E/rAeuChobWX9Y4H1LfWt3kWBZ7vAyu9ND2S5/jedcZ+XH9jV+z7K4me3r/+q9Y/H5ajXONYjQ9e4/xVRj1TzxPs24rSgdRRz2vDPZEllzKInWxVfjXdqnWxRWX7x3FHfJ5wXeLYLLJzTKo8e7ZO9u3px2lxB+wT18lugHOv/3f1dmPt3de9Nbii9+TzBsrLbOu/kP89bL36f9W5lPyReDzfljrUF5Q7iNNqaVJ9l6RQ9uxt4wXKn6vk/pwU9nk8pRC4gnhTfio2h89ffd01CT/Lvu2LbsAzxLAg8LVHGsjUGLE+ntzKUSZ5fr8r3XbH/UZZfJllu+FCW47sb7W451n8PyPIHSH6jHs8+ESXvlF14nspwvhiMcbEZjbaqNuO6I7erruvnBD2z4j2WQ4m+XxqsLxr+mSypXFzkvkS+Kn3R+LOUhp7N70AsC3pUP+P3XdU3XRHWJLy/3r7+q+QQjyGUQyxzURdh+eV93/V0Sfv4+65Kdigdk30FE1mx/oIwFHyDEVPPCdmvLZLRLyIZrfYDkB7Wt63+y0BGfw7JaHy/yn4Atpl1a3VGY+qYUPbLYvwjy7o0sZrddcL6GtcJtY/ezPrHBo45tnW+0FknqsbtNgQ9infWD9OZnitrWVzenRW8O+3wDmXBWcE7e/bSiLybEPQwrCK/LMcue37ZRLlzwWuy4R+WX1adken5Zc8KWnkNyy/W52/kM3r520KvBv/K68gvi7KY/bI3ovz8lhHIT9Yjt6v8/M6IvGsKelQuB+pC37tL40RdCOUl60JW/zuvdGG+VswNpd/w98zwPORM1J8i3Fb/B4CHL1jvbbe9bzCyLPU6EJ5bwuvARBJ6/HUA+cPrgMoN8nTERtYv/ybEsyJ9M79Ydo8DrJhtrPlV86vmV82vYcKq+VXzq+bXePIrZa51A+qn9BPml9kUIb6u7Wrn/o/Evi7PZqnaRzFzicY1PoHjSvJrrfO7sLVr1Yt9SBxHFxxjYPhniNbI9Gzaj3NED/OnKD4D322JMo5VrBrPi2Uso2PAUnP2PL2nfFO8R5VfHGOAfqLQ/as90913EF/VGIMvB5/Nvg5MtUdl7bYyJUu93Aorw/liMBLHVW6uCbYnimuCGp9Nqo/3yEN7dkeHAWpNUPMFn/E4mRH0eHFTiWOdgvczONYpkVx0Y53UN1ETx69sxhiomAfVzxhjgH2G9GEsjF3r7eu/Sg7xGEI5xDJXxX2q/ROOMZgoaZ8XYzBB7yk5afUmsmLdCGEo+HYfU4dS/DYZPS3oW+v8LmzterRM/i+T/LexHxq/YPV3gvy/6Mh/L0aBYxtQho3bHo3RVnWP5mmOjFfnNXnfZ24KehqCPp4L+bXe7q1/HvAq3Fxf8Yd1RtX+DWj/g9R+fEfZWicIptV/NsBcp/hyJd+GZTsqHjHOLKs+hj7ZGUNKvqp9GTWG2L734h4S7S8F6wn2bFhxD4qvoXEPE8Tzm/3bxDF9EjdybgLbM/m11vld2Nq1FBJvnFLXzbLyOW74hxVvrHIIVHyvyjm1d1U+JucFj1vOqdJNOaZ4mHkPXx7JJ/FfL3dhfsWAPgnOe1B2j8p7YJ/Eds17+BpH16ia9zAj6KnzHjYvN+/B80ncaHkPnk8iNO/hNJV5eQ8TJe2r4pNQNqvVUz4JZfONk08C6Vvr/C5s7Xq8TP6/luS/9WWoT8LqvwLk/+sj+SRUTs6wzlhSOcneGUuhOck/6sj4qmcsNQU9DUFfiE9iDvAq3Fxf8Yf9x6r9P1XRJ4HtOkEwrf6bBvRJpPZrKR4xziyrPobeXPskxt4nofxzSodnG+NGPisxhU9iXM84mI8Ia0HASqyvB/sNWF9PZHu5+vqCw7slQWtLlHF+z5LAsyTwtEQZz50YsJT+yH4QnHMMU+37qbNvQv0GfxTJb/APQW98XwW/gecbQD1tjspwfPI5N4nm0gKPA9QHlF+rmfWPTxwTU/Tsg44+UPWsjtOCnhA5lMguDtYHDP+w5JCa00pXN/4sp6Fn02+wIuhR/Yx+A+UrQFiD+g1QDrGMQhvhLJXhmhniN8D2VfEbKLvS6im/gbLLxsFvUCajJ2a672A7qtr2H7zUhbljJgz3LsLdrIjb6v8Y4L6lA3OrfgWMs+Z5irHeKdYAFeOs8vWaWf9Y9WKcD3R4o9YAlT+ovgmrbELkFf6N9OM4f067lz6rfzvQ938E5HrGnCch/T7qGBfu99D4hGOJ+z3kG8uJfHHBa7/hn8n6+znF2n82kK/KF8Br3s3uC7gZzjusfQHbyxfAMQTj6gtAuev5AvgMgNi+gIdJ1zN8ob4Aq/9NoOs9l3Q9lOkcJ4D6E/sCcI31fAEGY7v7Al7o6ANVfQG7BD21L2Dzcn0BKp/0RvUFeOdOhfoCOIbA8wXsKmkf+wJQduyi95QObv2i7DPlC1DwDcawzvkrk9H/OJIv4JNBRn+JY49jO/BvPCOoKdrBe7svBXn2aWQ3Dn9/MvyMoHHfn1S55ioPnXP6q9qUWMa60DjAitnGml81v2p+1fwaJqyaXzW/an6NJ79S728U6XQx8CAssyOUv2Xc9lF2QXuwPt7nF++j/DvHb1L1vKimoCfEZkm09xjsNzH8w7JZFF89m+WsoJV9EPnFc/lmyPOM4V+42fdk6lzM7ji8mXIxUe6OMhfzQxViZvJro90tx/oL4KP7iOOj8/JteI8FxyDvsdyIMZUfi7iPUsdUulcdU5n1yyFv7ff2ell+ebmYVfdRlOxQOjjrjaH7KAq+wRjWPgrbMfm11vld2Nq1XCb/99/SpQf7vOr3rX75YhfmrZ1KITH1Kg5RxdTzPEx0fuWmjLcxXHT+kdHWpPo8/vm7u3d3eKNkfFXdvCnoaQj6lP243u6tPw94FW6ur/iD6/WugvafhPY/WGDzFn3L+ATBtPr3AkzOxfT8BqnzeRWPlD1ZdQzNOWOo9huMh99gTtCq1ke2MaqeAzrusPL7lH6D7RQzOSisRQFrGGeDlNGK+GeI1lTzUOnriw7vlgWtLVHG50qrM1GWBZ6WKOO5EwOW0h85nhTnHMNU551YGdpYoX6DF5LeOKjf4AdBb/wMR29kv4GXb6lsEyvD8WkwEs+lBR4HqA+o+OBm1j8+cUxM0bNHHH2gqs/qrKAnRA4lsouD9QHDPyw5pOa00tWNPytp6Nn0G6wKelQ/o99A+QoQ1qB+A5RDLKOUT4/lUH6F+A2wfVX8BsqutH5RfgNll42T3wDpW+v8LmztulQm/7+C5L/1ZajfwOovgfz/6kh+A3UmQeLvcLjfDkCcRlsz658P3rcDvs6R8VVzo5qCnoagL8RvsAB4FW6ur/ijciK4/d9c0W+A7TpBMK3+tw7oN0jte1I8Oi94VHUMfWftNxh7v4HyoSkdnm2Mqmd1jjus/D6l32A72fqDwloSsIaxj1VGK+KfIVpTzUOlry85vFsRtLZEGZ/hpPbvVgSelijjuRMDltIf2Q+Cc45hqr05FXcR6jd4WyS/wUHQG3+5gt/A8w2gnrZAZTg+DUbiubTA4wD1AeXXamb94xPHxBQ9+38cfaBqzvB5QU+IHEpkFwfrA4Z/WHJIzWmlqxt/VtPQs+k3uCjoUf2MfgPlK0BYg/oNUA6xjEIbYY7KcM0M8Rtg+6r4DZRdaf2i/AbKLhsHv0GZjP4vkWz7N6x2Yf5JbdtvXmyX/ffEtr0XF5v4u4BXQuUwfxcw9fdJ5wP5yjo+vqt0JNbhqsbt1bBuXFgxbU/Pnx4zDr4lYNlaoWJxWSZv11jcvbuv/8aIxW0KesrW4AO7e3HOAZ0ha7DVfyWswbd1YKo12LOFOPbaW4MTrSMLzPuiuDNeg3FsYh9N0bMjTn/HWIOV77gRjT8ri6M7q2t1IXSNv1HO6uI+HPR8rfz+SERYd0aEdSgirN0RYbUiwtofEVZM3t8VEVbMNh6MCOvWiLBuiwjrTERY+yLCitmPeyLCisn7mHTFlKsx6RpXWTgbEVbMsRqTrrsjwhrXtTbmfBxX+RWzH2OuQzHXx5gyJybvD0eEFbON4yqjY/L+QERYMeXquOoTMfXoUxFhjavOFHPc3x4RVsw5FFNnimkrjKu+GlNO3BcR1riuaTF1uXH1ddwREVZMPXpc+RVz3b4nIqyYcuJoRFgxZU69bleDFXPdPta5V7l3vG+E76XYN0qVe/frzr5R1dy7pqCHYRXFnnDehNX/kw59aWMVV5c5btZwIO7VRLgbhM/4jc8Q/6ygh+MAsWxyC7SuPnZ19eLVK9ceXV66+PjC6uMNgm+08jMcC/k/Fae3IOobry9lKXi9cs1k80S7C/8i8DW/JqFslcqmoMxozMfuIaL/YiL6Q/iP+Fui/nOgDVX6siXwYKzbVmHNDQhrf9Y7B1BOeDGJ4/oNqEQ5Ru6+ssqVUmcQ8L5y6nMDYsKKmaPSyvrHDueRpYiDzS+Ls2HeTAEsnOMYe4P1/xbW/s+k74Q0BL48BufvKsT15NdGuxe31f9siOv5n05cj/E3JK9x1PGzg+Y1TnYWl9R5janisq1MnXs5bvF089AerI/3+dUXT+f0UdUcQRW3Ni3K4vFneUnlstil5DyPHdSLTR6wHppfz6Ey1Pue3+7C52uC/kZe5LS8COQT17MrJH+K11Ysw3HLcftLAuZ2z5864Yzpqnazys8bYf5UcNz+OORPKb56Np7S6VlfGlQPr2HdeLA830bIPFF4cN6GzPdB8SAsW3dMJis7NK393ZXJZvujTEacq9AerI/3+TVFzx5yZHLVsbBL0FOm3z9nthfnoHH7l0G/f14HplqDbRypuP0lKlO21nb3v77Q6e+q/ld1tt7ozj5bXQpdg8fh7DPvDMbQsxQ4rn7Q8w/y+yMRYd0ZEdahiLB2R4TVighrf0RYMXl/15i28WBEWLdGhHVbRFhnIsLaFxFWzH7cExFWTN7HpCumXI1J17jKwtmIsGKO1Zh03R0R1riutTHn47jKr5j9GHMdOhgRVkyZE5P3h8e0jeMqo2Py/kBEWDHl6rjqEzH16FNj2sZxHfe3R4QVcw7F1Jli2grjqq/GlBP3RYQ1rmtaTF1uXH0dd0SEFVOPHld+xVy3D0aENa4+mJhzaFxlYa1PVIMVU5841rm3/SYVD5M4bmFzvwm/YTIhcC5De7A+3ufXFMPrdKTab6oaY7lL0MOwimLl5ok+q3+kQ1/imPtVFZ/UyHpxX0qEu0H4jN/4DPHPCnqM7hlRtpV4/8uPrFxdWVx4/Noj1x5dWX18tUHwjVZ+hjFX+b/Lor7aYzNeX8mS8HpRxftfBr7m1ySUXaKyKSgzGlW8/+VE9IfwH/G3RH2O9w/ty5bAgzFyW4U1NyAsi/dX8RbeGZXj+u2ARGcOuvvdKj5VxZzxfvd2jHvC9jcKfg0PP2M8OHaMhynPRc0vi89h3oTG+1v9JVj7Q+P9V/b04h403v92iAe61IGp4oGMvyoeiHWw1Gd1qlhyxGm0Nak+3iMv7NnTHB2s6ndqdwl6ZsV7Wx2Pqh9u5Njoh50+ihEbnfZ7UssrKubTLiXneeygXmzygPXQ/OJ4f9T7XtDuwudrgv5GXlSN91dzQMmPCSrDcW/x/rP0N+JMG2u4uBiqPxj+GaI1lf6gxjvyh/WHFUEr29v5xWv+oLZ7DauGVcOqYVWBlTJXIXQ9GRQPwrK12dY0lL229iX+FtOmLobfT5oQOFegPVgf7/Nrip59g6OLVR0Lc4KeMhvom8kGQt8l20D5L+dEWP0/XenC/Faygby8By8vEdd+7u9R50QYbU2qj/fIJ3v23U5/49j3dBHV31V0vFTnzITMecQ/LB1vOZCvdU5EP6w6J2J0vK9zIqrBqnMiqsGqcyJGR1edEzE6uuqciBtDftU5EaPjfZ0TMTre1zkR1WDVORGjG/d1TkQ1WHVOxI2xptU5EdVg1TkRN4a8j8n7vRFhxZTRdX7FjTFWU+ZX4FrCe1e4xqfYuzJacO8KcR6G9mB9vM+vKXr27M6EVHtXh7N+3h12eDcn6GFYRbGJE0Sf1X+0Q9+0aFfEfa6Ltk90CtrXyHpxn0+Eu0H4jN/4DPHPCnqM7hlRtqX8ipWrFy8+fvXa6rWFq4tXrmyOx9BvtFv90P26tPlKq0sqvwLP3s+vSSg7T2VTUGY0qvyKlGfUlfEf8bdEfc6vCO3LVqbnQSxY8wPCsvwKXCuPde5niU4rzy/rq8PUnrXO3wtbuy6FzmvDP5P18zTF3rmS6xOCr7NZv8y1d1tZ/9rCcU/HBJ5jAk8NKx4s6zPs40bBr+HhZ4yH5wfimYiIB2FZPBPzpiiHhPMzrf5XgX4TmkPyyr29uI8Qbn53o92L2+q/eaUL81UdmCqW2/ir9Eyrt931zG+IqGcq3g1r3O/N+tvNfXSKytY6fy9s8eJ1EftIrX3NrH+NxfVzip59h9NHVWXThKBnOku5vlX/ZgSPHbQLTR5U/WbEp7S78PmaoL+RFznPP1Ehh6TqHEhrP4Xnkhr+mSyp7rXojVslW5RNZe8qXfUC3PO8qqr3nosIa5rag+3fqjxEWM9uX//dK2hgW45zmtY6fy9s8TJ+lX3n6Dy0B+vjfX5x/PPPOPKwah81BT1lesibI+kh/xr0kLeQHoJ0Hct637eytwEffm6jl/Ym4GdZk2huB8satquaaehx7SrkD8sapVe1RNlpuMcyxHNE4FGwzkaENUPtSaF75RfLGqSB83ePQVkKWWN6FsoaxHkE2oP18T6/pujZbzuypmof7RL0lMmad0eSNa8DWfO7jqw5nPW+b2V/AHz4hQqyJtE3KIN9OIZ/WLJGfWfPkzWHBa3KzmG9pqpthrBOR4R1LiKssxFhTUeExfI01fc4WZ7eiP6Gjw7J31AkTz+2V+MMladW/9UgT//ekaf8PXIr+wTw4a0V5GkaG30p+MwAezYseTpB9JTJU/VdRrX+TsF9kdz2vo+KZewvHgdYMdtY86vmV82vml/DhFXzq+ZXza/x5FfKPeZGVqzTxcCDsMwuUPYW+8q3q731gk6QcAx7S/mJRuhvDj7/eNz9zccErTdjvEx+v6NzH9N3HXPPzYtHHRTW+Yiw1Fmdic85Dd73MfwzRGuqeThP9DB/mHdLgtaWKGNfbNVzPLGM504MWMqHOUfvHYMyholj+2GCifvJrA9g/6PP7eWt7juIL9TnZvU/D3xuX9mB6e1hqH2pY1SGY/AUleF8MRjjciaW0dak+niPPLRnX+voA2q+qPO91Z5jyBnWic/yDdYHxuHcdLVPmPibICtGjzoTXfVzfhbFnqy/z5A+/L6IXevt679KDnlrP8tc3KNl+YVrpu2bNAhfUftMpnmyQ+ngrDdOiPapPWEF32Ckjo8MldGvJRnt7TPnv3w2odX/2+UuzNc7MtraoWyvXVSm+mC7xxX8qCOHq8YVNAU9DUGfsvHW2731zwNehZvrK/6gjnC4oP0/Be1/sMAuncr0PDxBMK3+mwDmegfmONj2ikeebR86ht5c2/Zjb9ufErQqPZvtgFMCzymBZ7vAyu9T2vbbyR4fFJanUyeyR4Jte/6WQGqdWtnJ3reI1Lc8WqKM45mqfssOy3juxICldDxPb2aYOLbZtkdbOFRv/KNItv3vg974vgFte7bfj0HZeSq7EW37D9a2fW3bC3pGZdujHGIZ5eXz4JpZ2/bXr63Y9hP7uu9gO6ra9p8PMnpHB2Zt2/fbZXs6vLlZbftbof2xbPvbAebNYNsfccZQbdvXtv04wcrva9t+a7Bq2z69bc85QbVt36XfLtQbHyK9cVDb/rmgNz7s6I21bd+92Lb/VEcfqG372rZHemrb/uax7T8/km3/nqUuzH9cwbbHNZVt+xko47mSyLZYYD6gHFY5vc2sf7zgWGA+/RNHDs/AexPimWeXcY4xvsdyOI1NG/7daMM/k/X3cwo5fCSQryqe+gjx/Bi8xzrcMYHnmMBTw6ph1bBqWFuBxWcNGXz1a3j4mafXh6wng+JBWKaLKLuM13zUGVOs+anOX/wxZ82vOhaagp4yHe8nSMfzzqzIf1nHs/o/DjreTzs6no0j5V+foTJPxxt1zhzreDg2sY84Z+7NiXU8hlWko04TfVb/tzv01Wfvb++z9+dEfe/s/TT+Dn32/hzwNb8mocw7e99ozOcOn72fJt8r/Ox9L4cg5tn77GfeCqzDA8IKOXt/Gt5rFPwaHn7GNGOb2R7z9hjT2I7h5xkZ/mHtMar1w9tjVGuv5y9iHQHxhJx3ll+s744DrJhtrPlV86vmV82vYcKq+VXzq+bXePIrpY+skYXpw4PiQVjmMxrh9yaC9/IN/7h+b0LZTXVsXxeeXeinvLC/F+ege9GvX+zCXOzA9M7WVXvRbCvhGJymMjzjjMdBUVsvUVubFdtq9R+Dtt7vtHXCaevNsO/+jA5vbrx994UroTKz3nevYd3osOp90e2zL3rVkclVx8Ig+6IvoTV40H3Rp8Ia/IXOGnyz74u+NPEazLCq7ou+pkNf4n3R5RHuiy6HyCbEP8x90dXHrq5evHrl2qPLSxcfX1h9nOWP0crPcCzk/9S+6IKon3ZfdOXa9t4XXbkWwn/EX++L9tJp5VmWer8yPBeL9yun09Dj7ldOC74qG4Bt8GPw3nbRQ1P5BPl7oCn24vPL9CXmzRTAwjmOOhTW/0FY+0O/1/2GCvpZfm20e3Fb/btBP/tRRz9jHUzFJCSexwvcVtRhVP83s355hn5J5sVPOToY9rs3V5UONozxiDhv5DP3f9Hpo6r7FU1Bz7Qoi8ef6t/r5rET43vdz2134fM1QX8jL3Kev6jC97rVHFDyg/2vOG7Z/3pMwNzutv5/iGjrTwt6ZsV7DeJdGpsq3P9q+Gey/n5OoXudD+Qrn0eA76q8S9aXlL2lzsmvYd34sNhfYPDVr+HhZ57dZuPXm++D4kFY7H/FucEyOVEe+aZMtnUUZTLiNNqaVB/v82uKnn3EkclVx8K0oKdMv/8r0u9ngM4Q/6vV/5uFLsy/If0e6eJzHlCfPkZlqMdxfyeS28nPFfuE099VzxWbFvQwrCLbhW1Eq3/4wPXftLrO6qonoxLnGgTHt/AcUmuz+g7OlvJSHlm5urK48Pi1R649urL6+GpVWWD11Xkii6J+2jNVVheV/xXPK8mvSShj3+wUlBmNyv+aKK9mMYT/iF+ty+x/HXSNx3kbA9bMgLDM/6r2I0Li1hL5BIL9rxyDkTpuTcn10Lg1jsHYTnFrqeMAjIfemBsUD8Ji/6u1tcj/ijoU1p/rrK1V/K/zB3pxe/pZfm20e3Fb/d8B/WypA1PpZ7w/rvyd2z0O7Qr0w1b3wFW84rD2HW5kPXnd6aMYevK0KBul/5XHTgz/6/PaXfh8Kf+r8aKq/1XNgXGIoSk715flR+jY/LSI8kPtfU2L99bi8OYi23URYV9jH2882EuLbIMZz5Bf9bdR43wble2CQb9nynNqq7CK4qGsXP0aHn5W5N/MLzvTUJ1FOhy7Of1ZpF/syLCqZ5E2BT1leu2XkV47aFzBr4Ne+zLSa1FXtP5Va0/+b63z98KWrpVLSu+KB3/5kdH5zZYuh8pBw69iE1PIQeW3UHFjxjvlt2+JMh4jVecFwrozIqxWRFj7I8I6ExHW7oiwjkeEFbMf944prD0RYcXk/c0w7mO2MWY/xhxft0aEFZNfMfsxppyIKQtjjvuYbbwrIqyYbbwnIqyY8/FoRFizEWEdiwgrZj8eiAirHhPVYN3euWfb7c8o1iCNP3DpMdP7jwO9jawXdyKb6bEG4TP+4TPEr2INjO7YsQZLi0sLqwtXH33k6tXl5YsXH2kQfKOVn6G9XzQ2lP2V1meydGl7xxosXQrhP+JXsQYPt7v1YvVlU9RP7P9a3t59ubBctS8tpgLtJd6rwn5Yi0Ln0jLv5caDvbLo7f9Pi/aOwmfPsjXRntSmr+o40cP8YV/VeUGrisllP/tW8jKbEWFxjAaO4UbBr+HhZ0V+5/xin73KNU885tx9x+OCJ1X3Hf+n47OvmpM0Legp89k3DmqcVX32b1vowpzswNwr6Gpmve9b2c7OOzkffmGj930cuzaGFGzO9xllDpuNjdAcNhxLKE+m6Nle4FPK7896sX5p5lr4d45YvqeO9TseyFcV68fy/WY6o66GVcOqYY0nLM9/EiKHFR6lDw0rjtfWfJS9vOYn2rPeXPPNBsQ1X+nzTaqP9/k1Rc+e4az5VcdCU9BTpiM+RDrioOeHfhPoiA+Tjoh0beo69D72fYiOt11tgk9JrOMxrCIdlc/zsvpf0KEvcT7ZxRHmkwV/52gk+WQF3zmK4Rf0vnOUKJ9saZvnky2F8B/xp84n4/O8tgLryICwQvLJxuE7R2lsx/DvHBn+YX3nSK0fai+A/bz4rsrbmoJ7LEM8Xj4HlrG+Ow6wYrax5lfNr5pfNb+GCavmV82vml/jya+UPrJGFqYPD4oHYZnPKCRGII3PIPw7R4Z/WDECyk8XGiNg76q8Nh6Pg+7rjyus/D70O0e/Rn7K4506oX5Kq/9P57swf8PxU3rfOWJbCcdgle8c2XtWnmXdOYTvjWIf1vDPiDammEO7iB7mD/NOnQWq9hB4rN5o39SrYdWwaljjCctkFcq2RsGv4eFnjIfXBcQzEREPwuJ9WC9Wb7vGXlmS26hi9SZv1ThD9Rur/1zQb3Z2YIbE06lxtTcr1m+miY5U/a32MW8RtDaz/rHpnem/1+lvHPueLqL6G3mFfyP9SiecovpnOvSl3cvo7sMOP+Y7fB/W8M8KeozuGVGWYh/2ONHKz9CGyP+dEPW9fdhE++1yH/YE8DW/JqHsOJVNQZnRqPZhTySiP4T/iL8l6vM+bGhfqhgo7uetwNo1ICzbh1XrX8j+aCKb7lLovLZnw9ofVXLd2x89LGit9ePxhJVSB8ZxMiw/K/NmCmChHNsF5Vj/maDfhJ5dukE66C7Cze9utHtxW/0joIM+m3RQnuNYpvid1h/W1TNNhyvS01jPRJ0PY1049+X5EfVMxbthjXsv32dcbIFBv+/1WU4fxfi+13SWcn2rfnYpj50YZ5d+crsLn68J+ht5kfP8EwN+O8rgsj6TX2ud34WtXY/xubPxYC9eTZjLe5H9MRFhL7FdGA/25c2xfCLrHweJ9xeD9VbeX0xj8/j7i8ifQfYXWc5jGeIZxXdmx+GbtQrWkYiw2KeRIl42v7w8a16/t6vv9usi+m6bgp4yvfkbI+nNO0Fv/mZHb+bcDSv7VuDDWzd6aff8AIn2moPjNXivObUfQO01e34A5TdXvl+Oa6qqO2IZ28jjACtmG2t+1fyq+VXza5iwsI2p9+aL1pAYeBCW6SGmJ9wiaEi7hxj+/Z9boD1YH+/zi3OLf83R727JennHzzz9zuqF6EiJfFvBOpLhH5aOpPjq6UhHBK3bJV47Jqz8nmNakZeDzn1vn35QWMcjwjoREdYpASvxOQ/B589x3nciX5T7PfJTDu/mBK0q95d9P4PmEecXz50YsKwM5S77snDOFe2v59fDBBP9dawPYP+jjf8RsvENX6iNb/X/64UuzL90bHxrt/LbHKEyHIPHqUz5wtKer9DVBywnHvUBNT6bVB/vkYf27O8dfaCqT+6woGdWvMdyKNE5pMH6gOEf1jdb1HkSyo+W9jyJ63I6/7cs6FH9vC+7fmY39xnSh99ssmu9ff1XySFv7WeZiz5Mll+4ZpqftkH4itpnMs2THUoHZ71R7aN65whw3bw8pp6j+G0ymu2Y/Frr/C5s6Vp6pEz+33pblx7s86L43Ekox/pfAfL/9g7MkPwjtc+tzlDieYjjL4WMtzFcdE6S0dak+jz+p+jZ0Q5vYnxPtCnoYVgqpiC/bJ5xP57u0Jc27nFhAb+pkBGuEJs/9Z6O6n9lC1bt//NO/8e0+VPLrJj2kVo3TF++kc/Iu98ZCzHPyPPszkS6crC+Z/iHZXfOBfLVeDcvaG1RWX6xrTjod0rGFVZ+z/4f5OWgc5/5HAPWUkRYyxFhrQhYNg9X4fko/D+Gf4ZoTTUPV4ke5g/z7qKgtSXK2P9zUeC5KPC0RBnPnRiwlM9qhd7DOce2FY5t9v9gLGSo/+fRCvp/fm20u+VY/0Wg/18l/R/1Jmu3laFOPU9luBYsUZmKObK5lGjsLvDYRX0AcbL/B+c2jvspevZFjj5Q1f9zXNAT4v9JJIeC9QGWQ6n9P0oOHRd8Nf5cTEPPpv/nkqCnzP+DfYb0GSzP/6POzVRyiP0/6tvqLIfyi/0/x0vax/4flB3H6b1TgnbrF2Wze+fZcF30/yDNjYJfg8nPvHkZKqNfTTLa2hHqo7H6d4GM/kaS0fg+++jRtjhBsO29b7mtC/s7b9N1vo18C6nyKpRvge3hBrUD23i4oI3/cgzoR/5W9a/dKHETrx2SD6UJ7/E6WcdN1HETddxEMawYfsE6bqJ/HtZxE13Yo4yb+FXSyQaNm/hfc12Y73TW9Tpuontx3MR/jGg313ET7lXHTWT9cqiOm+iFMew9yCIZ/QGS0WVnj7HdbPW/F2T0ByPFNtyI+Yp/6cjhGPmKDKsotsHGAPfjx8h+Z3/PWufvhS1eyn7ndXiUdrnqf88uD+3/T9R2+djb5ccFrUpHZh1e+W2Vn3y7wMrvU9rl28mWHhTW8L9xF26Xc1xJan1Y2bjnHd6FxJUYrXaPZYhnlHElSj/zdF6GiWOb7XK0Y0N1vnsPdd9BfFXt8q8Ene9sB2ZVu5zXfNSxTlDZjWiXL3f4VtvltV2O9IzKLkc5xDIKfYC8D45rZm2XX7+2Ypd/EsnoQe3y20BGf7Ijo9kux3axXX4j7pd+miOHY9hlDAvpnwBYbJdb/Rd16Evt/1B2OfvOcWxw/6c+B9LL2UDaqvb/o07/Y/+oPvP63+qF2OUTaXgXvA7bs3E9k/mIoLXeL+/n5aDr1c2wX87nSObXWud3YWvXYm3zd3nRIHxGD/NnUJsf7V4sQzzjYPNjH7A+Pcy9+H8eyeb/2/NdmK9x9Elrt9IZWZ/w/AE4Pg3Gdrf5vzuiza98SrXNv3m5Nr/S4W9Um1/p7FX34g9TGa7HbPNPlLTPs/kn6D1lb1q9CdE+b7+H66LNH0OHUvwOldE/TTIav/MVYvNb/W8EGf1vapt/82Kb7y1jZvPz3JksgDlF7bH6T9Q+gsLxEsNH8M7aR1D7CLYJrPy+9hFsDVZtx9d2/LjZ8X8eyY7/AtAR/0dtxz95VbXjP17b8bUdL+ip7fjed282O/7A7d13sB1V7fgdIKNv68Cs7fh+u+xIhzfjund/skNfbZf38y+GXX7W6f/aLq/t8nGCld/XdvnWYNV2eW2Xj5td/qmk8w1ql3/gXBfmCx2dr7bLuxfb5Z/t6AO1XV7b5UhPbZffPHb5yyLZ5a8AGf2K2i7fvNgue9WQ7fJmpm289XZv/eOAV+Hm+oo/OG8nCtr/DdD+BzvtT2wvXmOapzLf1maavxloXu/QHDJGR30ew6D5+N+eeIzW+fibV52Pv0VY+f3NmI9/PiKsOQErsc4e7DtgnT2R/eXq7HMO75YEreqs49Nwj2WIZ0ngaYkynjsxYCnbjn0hOOcYJo5t9h2gnRWql74lku/gH4Je+jZHL42Vj4/jk/PxE82lBR4HqA8o31Yz6x+fOCam6Nm/d/SBqmc0Hhb0hMihRLZxsD5g+Iclh9Sc9vLxl9PQs+k7WBH0qH5G34HyFyCsGPn4LKNOQBnn4+OaGZKPj+27GfPx031fcGGlTP7/Ecl/ZbthW4u+L/jfz3Zhvq+CX+JmO4PvvzkyPsUZfOiX8PwMJwCvws31FX9QJqB/C+v/hfBLNMQ7ao6z38Dq/9WAfoPteo7f39V+g9pvsE1g5fe132BrsGq/QXq/wTm4xzLEU/sNrv/m8/n44e47iK+q3+A3QW881YFZ+w36x6fnN7jQaUjtN6j9BkhP7TfoffdG8xuUyeiHSEYPeo7f54CMftiR0Wzbz0DZzRBz8CmOHE6dCzADsHittfqf3qFvHHIBcGxw/486F8Boq9r//8jpf+wf1Wde/1u9ELt8Jg3vgtdhwz8su1zx1bPLjwha61yAfl4Oul4xn2PAGlcb/5yANa7fvTuXhh73u3fnHN6pWOuWKOP9/Kr2DJbx3IkBy8pQ7p6j94aZC/B1kezyB0Hn+wZH57N2bzUXAMcn5wIkmksLPA5QH0CcRlsz6x+fOCam6Nm/cPQBnBvefFH6v9ULkUOJ7OBgfYBzklLLITWnvVyAlP7T/J/yE6h+Rrsc+0zlBXh2udKrlRxiGYU2e5VcgJmS9nl2+Qy9F5ILgO0rywVgXTimnqP4HSqjf5xk9KC5AO8604X5E7VdvnmxXfazY26Xv6W2ywv7P4Zd/su1XV7b5dsEVn5f2+Vbg1Xb5ent8lNwj2WIp7bLr/8++a3jSHb5z4LO98HaLn/yqmqX/1Vtl9d2uaCntst7373Z7PLdd3TfwXZUtcufDzJ6bwdmbZf322WHOrwZtV3+nHYvfVb/7g59tV3ez78YdvkJp/+3t12+eFPZ5Shjecwgnu1ul8dqY82vml81v2p+DRMWttHKdkEZvzcNME1HDtFFRp2XyboI2k/o0+Gcus8aki6S2sbZm/W3m/voBJSl6COzM4tyQ49De7A+3mdZt4/s2VWnj44T7/iZ10dWz/NrTwtaR+G3MfwzWX8/p9AXzwXylfPe8F0V389yrerZmOMOK7/nfRzlD6w695nPMWDNRYQ1HxHWkoA1jHyaMloR/wzRmmoeqjNFlxzerQhaW6LsLNxjGeJZEXhaooznTgxYVoZyd4newzl3nMpUjpA6czrUR/gtFXyE+bXR7pZj/UXwEX4b+QjVnoLaqzlPZagHzVGZ8iMPSx9QeY+ePhCa9/i9EfUBtQcWog+MW95jan1gO+Q9qn6Olfeo9kOryCGcpyyH8ov3cQ6XtI/3cVTeorKT2Ges/PrK1lTwDcZs1k9zo+DXYPIzb16Gyug3kYy2dlQ90+iv7+vC/FmS0fi+2WE25tG2yP+tdf5e2NK1tDRFuM/c2aXvF2ivopGEhuVLym8esY2LXu5s2v2uxWDdz/DPZHourUWhpytzlQxQe2HKZ897xlh2Eu6L5nuob+nOiLD2R4R1MCKsWyPCui0irEMRYe2JCCtmP94VEVbMsbo3IqyY/LonIqyYY+JoRFgx+dWICIv1gURr8RXPp5x4rbzaIHzGpyzz18pEcfDuWql89VXXygNwv9Xx0YwIK+Y8PxMR1u6IsPZFhBWT98fGlK7ZiLBaEWHFXCvHdazeERFWzDFx35jSFVMPjqmnjOuYiDkf744Ia1zl6r0RYTUiwrqdYDUELGXjW91ZUV/pOfk4Nr/Zl3zpS77opRldk/Q3OyCNsAMFBNwN7zYA2SQ9z7L+htrfB0rK7xawcqfXt3YsORWY4h00zgo6LpgpNkD2Ak8mBE4OoMaF0u7za4qeLXTaHyOAWgXwe844/jU8/IzxqIPs9mb97eY+QsGXoo9M+cc+Qpx7oT1YH++zrP/wvAecPtpLvONnXh9ZvVnxXoN4lyhBIHiTio3AvWnocY1AxVfj3R2C1haV5RdvcN8h8Nwh8GwXWPk9B63E2MxhPseAdXdEWEciwjouYCXeaA/euDD8w9osPkH0MH+YdycFrS1RxkErJwWekwJPS5Tx3IkBywsqUHNuL5Xh2OagFVQiQzdEH7uz+w7qHqFBK1b/d2FD9BrpXqjPWLvVun4HleEaezeV4fg0GMMKWrF+DQ1awfGJY2KKnn2xow9UDVrZK+gJkUMn0/AuWB8w/MOSQ2pOK33A+HNvGno2g1buE/SUBa1gnyF9BssLWkE5ZPNUySGWUeggaFEZrplsM+4taR8HraDs2EvvtQTt1i/cl1gfYSj4BsPTn0PGc3558zJURn89yWhrR2jQitV/HcjobyIZje/fQu9b2Ws67yQ+uEgmvRqurdj2nDg9K+Bb2xLZIQvch7iGIE6jrZn1j3Ucx9zH3+2sIcoxhM88m9LqzYr3eA1JZI8/GrqGGP6ZTMuGtTj0LHJflvGV7SYlO9GmYv2z6kfgalg1rGHDsjGOc2Kra6Za5z05NCgehGXrrwqu57UC9aQUa4XpWrhWKL9Uk+rjfX5N0bO3O2tF1bEwI+gp02t+hfSavUBniF5j9T8f9Jp/R7qB0v+UfTlLZUovHNahKta3RYeqsG6AYwH9aFP07D9E1A2UrsKwivzlrF9a/T8j/TLNvFq96PkJ0yYrr14MkU2IXwUjGd0zomxyC7ReXrl68eLjV6+tXlu4unjlSt8hL0YrP+MNSOWr2Cnqp/XXrC7ZuJpod+GjLyS/JqHsCJVNQZnRmM+dQ0R/Gh/F6lII/xG/sr+fA22o0pfKp8iHJ40iWGF/1r/Gsd/Qs+tGvVaz7A5dqz+U2K5T+92NaPxZenxatDce/OWr3n5N2nm6uBgq0w2/ktsp7FIlh9Wc4oN2lUzBMo7JUHs5JwQeBeueiLD2RIR1NCKs2yPC2h8R1mxEWHePaRtjjtWDEWHdGhHWbRFhHYoIK+Z8tDkU4n/EsTgKOc/6eWr/492Cr57/8aigtSXKeO4cFXiOCjwKVjMirHsiwjoTEdbuiLD2RYQVk/fHxpSuuyLCijkm9kSEdVtEWOM6vkzOq0OR2VbBPh+WLXeXaHdVW+7BDhBlyzWzft41Hd7NCnrK/K4bd2mcoX5Xq78Kftdnd2B6h4aPy94q91vo3uonR+w3dVBiyKHEifZWg/2SvLfaTEOPu7eq+FrvrQ4HVur9vZC5MCgehDVO+3u2poTu7+EadBe0aYqefYEjr4axv/fFtM4Mur+3F9aZL6V1JnR/r0llKLfGbX+P16fQ/b2viLg+qfWSYYXu71n9f9mhL/H+3rKNS5wbvI7enQh36Dpq+GcFPUb3jCjbyv7e6mNXVy9evXLt0eWli48vrD7eIPhGKz/j/r9H1F8Q9Y3XR+H9eLxeuab29+4BvubXJJTdTWVTUHa080zt792TiP4Q/iN+lQPA+3uhfdkSeHh/byuwWgPCsv09XON4f8+T3aNeq1l2h67V35dYdofYFons6eDYf5Z7qW2LuwL56sloNSdZ7x50Ho0rrPzecgFtTuLYsT3GtGttd06afJzMtPy8C9rD8hzXsil69tPOnFRj5y6Hd0cEPYp37ONKs/Z0eXc06+fdPQ7vjkKZ3SPv7NmbI/JuVtBTZnu8lWyPw0BniO1h9e+7twvz7Xf14vZkaSIfV7CfxvAPS5aqvB5PlrYErewPyC+WWcof1BJ4bnZYqXOXRuWnwXHDfppR2+0taA/Wx/v8Yrv99xxZWXUszAh6ymTle+/SOKvmlzVBVv4x+WnU+RTKh+P5acbt3A/W9UPP/fhA4n0EhlW0D1Lkp2l2lKe082p11Tv7Ia1NslrZJpkV9BjdM6JsS3HYj6xcXVlcePzaI9ceXVl9fLWq3mT1lX6/KOonjnlfVH4a9sVMQtldVDYFZUaj8tMk8ukthvAf8bdEffbTVNWBEQ/7abYCa++AsMxPo/YpQmR36g/TKtmtPpRcVXbv6nRyKtmd9kMBKxd5n9RwIO40PrTwQ/RZribS6xZZrzN6mD+s66o1QM0t7sOtzNM7I8I6FBHW7oiw9kWEtT8irIMRYd0aEdZtEWHFHBN7IsKK2Y8HIsKqx8ToxkSVGEGUTyn0DGsX6hmIk/WMPYIn+TVFz54SUc8YJEZw7W6Ns2qM4LtPd2E+swNT9Ruf24K6EZ/bovS4YfW3ym1GnHxeK/IeY/I59/mTnP6uel5rU9CT+rxWHlcpzmXAcWFjYY+gYVziTPdAe7A+3ucX+9E+0xkLe4h3/MwbC1ZvVrzXIN4l8q0NfIbPnjT0uHGmiq/Gu32C1haV5Rf79vcJPPsEnhpWDWtUsFLH+IbIoUHxICzeO8I5y2sF2hkp1gqzPXCtQJz7oD1YH+/za4qetZ21oupYaAp6yvTEryU9cTfQGaInWv0fBD3x6x09kWN8UffaQ2U3om7wrYl1A4ZVpOfOEH1W/8dp7yiNHtE9wwfHM+sw+xPhDpFNiH82K57vM6IsxRk++4lWfoZjgWWO1ffO8DmYhtfyDJ8DwNf8moSy/VQ2BWVGo9o7OpCI/hD+I/6WqM97R6F92RJ4+OO8W4G1e0BYtnekdGjvw4Uh807RPGiuXRpfwmLw3rPhH1YM126ih/nDvNsjaG2Jsim4xzLE461TWMb67jjAitnGml81v2p+1fwaJixso8l2XAu2uv6q/ZBhxY2O0NcZvM7Xvs7tASu/529gYd+iX+TD5BcZNPf5e051Yf6F4xfh84tR52XdTH3v0NsrVL4WjudKNGbd7yQq/bNJ9fE+v5i/H3f8KUofxmeenWH1PHma2BcVvNfCuSKJ9lDdXBHF1zpXpIZ1o8NKnacTIocGxYOweK8F5yyvFbieplgrzOeEa4XSYZpUH+/za4qeHe8En48qT+f0kV6ce4DOEJ3C6l8FneJMB2ZIno5ab0N0g1HvtbBuELrXsuj0dwzdgGEV6TZNos/qf1KHvnqvpd5rGYR+4nW915LF3Wvhft4KrD0DwgrZa0nhg0GZZ3h2CjxpvyUYvtdi+GeI1shr1qYNNEP0FM151tvwXeVfY19l1XUKy1jfHQdYMdtY86vmV82vml/DhIVtTB3rsJPw7IyIB2HxXovn60zkJw5e5w3/sHydak8u1Ndp796MPrL8PnSv5dsi+UVedLIL8zvIL+LtteA4Y92M89yxTO21cP53fq11fhcvLy8tXVq+cmnhyuXHFxZXHn9s6fLS0uOPriw8tvDIY0tXr6wsXrm2srSy/Njjjz16eeXyI4vXFq498tiVa5evj8kyPn4f8XGiIh+t/lHg4+s6MMtwv55wNyvitvq/f6IL8wfJP9Kk99c6fy9s8Zql9mdZv9ybhOcR7Zvgb9IY/pmsf8ymkHuTRA/zh+XeTkFrS5SxfrBT4FF2lFq3WFYNCovH1lZhxWpjza+aXzW/4rXRZBXKtkbBr+HhZ4yH1wXEMyx9fZfAY+vWNNG31vl7YUtX+Lpl+GeI1lTr1jTRw/zhdUvlqStbjOeJ8v/NCDwtUcbzZFBYap5sBVasNtb8qvlV8yteG01WoWzb6nqC68IuwrMrIh6ExTEmvGeUZcM7X07t2au4yibVx/v84j39TzgxB1XHgvJLhNiqafbiFgbei0ttqyq+erZqyF5cfo2j/zkmrPyefXQxfNkxY9VinkcT87wCL+4vcV5C8DmMhn+GaE01D5WveK/Du5C8hPz+FNxjGeIZZV6CWrs5zpn3KbAMx/bDBNPL8cH+R1/svfd030F8yhebXxvtbjnW/6UTXZhnOzA9n7k634vjDHEMsh8e54vB2O4xp8sdvsWIOb1F0OOd9ZL4bJRgfcDwz2RJ5eIi9yXyVZ23ljae7bqczv8dFPSofs7H256sv8+QPoOFPqz19vVfJYdY1qAcYpmL+1ksv3DNfHa7Ww/xFbXPZJonO5QOznrjhGifOltPwbfnqffsTUYrOybintVS2RrwXFoDvHN98mu93S3H+s+FNeD5zhpg41HZdjupTK2Fxq9ZKluLwy/3vE/EybHmoed9froj56vq5xOCnoagT9mQ6+3e+nsBr8LN9RV/cM0uOjfos6H9D3ban9gefYxpnhJt9Gh+FGhe79AcMka3a67k5yUeoyG+iUTxOgOfyZLaN6H46vkmVN5LK+vvW7ZjVE6msr22C6z8nn0TMf0JMfL1Yp6z6OXoDAprv4A1DJ23jFbEr3J6UsxDlaOz3+HdQUFrS5SdhnssQzwHBZ6WKOO5EwOW0vv303vsF8IypccrH02ob+LbIvkmLoBe+h2OXsr+B2XjqPzIFpXh+OQz6hPNpQUeB6gPIE6jrUn1eUxM0bPXOvpA1VynWUFPiBxKkwsXrg8Y/mHJITWnZwVfjT+3pqFn0zdxm6BH9TP6JrDPkD6D5fkmPD8oyiGWUV5cNa6Z7JvYXdI+zzexm95j2xTvld0xK3AX2Xbom0iR448yWtnaEX0TK2VrwM/RGuDFe+fXertbjvXffrwL8xecNYC/P4E84e9WsG2H/NquZw7/siPnq545NiHoaQj6QnwN+wCvws31FX9QB0EfF9Z/p/BNNMQ7ytZm34HV//Ux9R0oHnm+g9Ax9B9r38HY+w5aglalx7OdMQ75QjFh5fcpfQfbyd4fFNYBASuxzh7sO2CdPZH95ersBxze3SpobYky9h3cKvDcKvC0RBnPnRiwlA7JvhDey8UyHNvsO0A7K9R38LeRfAf/CvTGj1fwHXj+AdTT9lEZjk+DkXguLfA4QH1A+baaWf/4xDExxfCOXv9V+oDytan5omJc8LyaMjmUyDYO1gcM/7DkkJrTSlc3/tyWhp5N38EhQY/qZ/QdKH8BwhrUd4ByiGUU2ggc14BrZojvANtXxXeg7Eq7V74DZZeNg++gTEbfdbT7Drajqm2/ADL6ng7Mrdr2yn8zLnu6RlvVPd17j17/VXJY+Z+Ur1HZZcgrpi/Etm8BXoWb6yv+KHuG23/haLbZ/hDbXn2Lkm37RYDJtr2Xs5DIPg3+dinnLIR+u/TS0W5765wFLaPX4tAzcM6CGrcqfpjtgKoyYNxh5fcpcxZi5hlspxiDxLHCwbY9xwonivt2Y4X3ObxT+64tUcY5C1VtIizjuRMDlopd3UfvKX1JxfywbY/rdqje+DlHu+8gvqq2/X7QGx/twAzJWVD7dsru55gBtf+w3b9J+gVHr//G+CbpbkFPiBxKZEsH6wMcn5RaDqk5rfZQhuGDzf8pX4PqZ7TtVZ4Cwho0ZwHlEMsotT+q9hZCchaUvzIkZ0H5Jex+QrTP29dRvBhWzkKZjP6ao913sB1Vcwp+8FgX5qs7MPfS+/kv5xRguzinAM9hYZ8AngUzjFx35OleognbmNj22VwnLAcF1wl17kmT6uN9lnX70Z59x9Hrv2qdUOewTDu8awh6FO+sn8flnADmXeg5Af/X0Swa79TYZ1hIv5pHU1T/Xx29/pvP0V862osP54zJVTXXeJynOYuo21czoq3Toq3NrH8OoGydomc/evT6r+qrqudSNQQ9oztffeGGOV/d+yYayjC2pVT+oMoV3S6w8nv2j6BfCdfzXzjai9Pew/Uc311vd8ux/hNHuzDfCvcmN9TavivrhWVlv9x5R535GVNmoJ2UEa5bBE+aJTzxxi3OLWxPUT/jXDf8ai28JSvHvQOePUy07q5Iq/LZKf+zOgdgtiKt/B2P2Yq0qv2zWYdWtfcWSutGe7i07hC0qv2JXYCPYSL9aqxn4p0i3aIpaGV5gvV/5+j137x87Vgv/Z6ul1pPVvsrnp4cur/y3qPXf1PpeqnPB2P7MIaPXNn2Vqb8bjwWtmss9gePXv+NEYs9KehRvNtJvEt0/sYm7/YJ3rUc3qFvbZ/gnT37y6NZNN7tFPSkOB9qO8V3DgrroIA1jPylMloR/wzRGpkeN0broMO72wStLVHGup7K27pN4GmJMrY1YsBSsXwc+4rzfCeVqZwsta/GaxHqMWjb7DnWfQfXcbRtlA7Htv/XHuvC3Ee6CuoGLH+9eFCUhfupDMenwUg8lxZ4HKDcVrHMzax/fOKYmKJnd3T4puR21RznvYKeEDmUKBYy2H9i+Iclh9ScVucuGH8OpaFncz/pdkGP6mfcT1LxoQjL209SOVxKDrGMQr9Ai8pwzeT9pD0l7eP9JCU7lJ7JNs+EaJ86Y0PBNxgx9RzF71AZvXSs+w62o0hGr7e75Vj/mSCjV0lGo63s7SvMZr2w7b0HAPaVY71tVvs9aNM2CNZk51/+bLegi3GvAe6nbRF3fin/lY1L9hXiu+grVOvbHqLfyl4F9D90rPh9tu1GbZ8YbVXtk+c661zVc3AmBT0NQR/PE7wfVhyK4ud+QQ/z69NorB4E/ihZuIP4oOJfDjp4DxBeFTOs4lsQL/eFtXNHQf19RIPV/yyg4e0bvTDVmW1IF/tGFc0zFWmeCaD5cwTNw4gbxL5TPGH8OA5wjhxw6rM/ieEfpPrIIzWf19tZDw+t/jXg4RMbGmazBCb3Ywb1USdiP7N3BhLiVzL6QFaOW8XPcH+E0urZ0Yhf5djdWpFWnk+3VqRV6dq3OrRiO26rSOtGe7i07hO0NrPisYO49gka8B3U97D+Vxy7/pvLJ9Mhit7Bfr+FyqzuVwt47OfOL9PplW+a7QR1Hi7CZ7mSX96eHOvK+C7qysp+KJJlSo/Gd5lP3wB8er2DL4Wvg+VLqP1q9VUuIs4t3kfFMX8oANaMg1vZtocc3EgXvsu4mU57z8blRLtbhr6i/JqEspj+jnzd+tWNLh0sg6bavbzx5E1+hfBS9WOL6iPvqvoA2O8a4gPA8YvzpZH1j5eq834G4O6heeida7uZr368+/4PO++zPazOQd7u+ZE/0Wl/jPxIlSPQEPTxnj/eD8vGLcunbBTw6+dpHO8H/kwUtB3vy2xBxruP8CqbTK2hiJfpsXbuKKjPOoTVfwvQwDbZbNbPB6SLdUhF80RFmicCaH6HoHkY35/Bviuy13m84TmVysbi+px/xPBD9B6Vc8xj/t8DD58osMWbJTC5H7OsP0bK4GB9ZbsrX5SS0fuyctwqT4v7I5TWMvuRz0RB+kLsR6R1o91b/2BFWmPYj8M6U0HZUxxjg8/Q96t8Ghx/9IfHrv/msuX3jvXCZb+3+u4Sw3sPwPvAMd2+/EK7KKSeGuOso6BOgHwomktopxWN/x2Z1jmK/GB/KmSuipuydiif/T7Abbzx9DDugw9CH5i+V1XHw1yY/EJ7AvW//JqEsnhryeKisid6vrMBeEP6mOWA509BmeOdB6P4g+c4DZs/PXkl7d72Kr2j6vqj1nBlN3GOs9oDxTUJbZ4n67S7749yvPXYD+3eNpWtqVXX86Kzi/N7jvFR8dlKno3OH1B9/rZK2lSVn3zOpTqTXslm7geUzSy30ZbHNc3krtdfDXjGNn9DtAPzLFXeI+/leDmY+C77CG4DH8Hc8WJ8KfLkWc8PzX22+t55jNh+w4161cEAWBMO7jK9knErvZJpyQSdeA7ek7ja3bLhyErt6+v51mG7t92h39jweKn6UZ2dyf740Pxx79sXRfnjOH5xvjSy/vFSdd5PAFw7A0PNJ9YDrex1MI+Xjxe/z3qgavd2j7+4v9P+GPEXSpY1BH0hvr5Rx180Cvi1TuO4LP6C21gWf8F4DxDe0PgLxBsSy4D1i2y4ZwMNKeIvJirSPBFA8/MEzXX8RbX4i38APEwRf+HpsuMWf+HRGjP+4mAJrRvt3vq3VaS1bO/3INGq9n6HFRPbzPp5uZdw4jO0S5T+w77sLwR94HOP98L1YidOF8D7fID3suO6ffmFdlFIPTXGWUdBnYB9fWouKV8Dj8EdmdY5DlD7rf6XCZmr7En2IykfLfKmShztK6APXjegjuf5+kbpy+rJlQS8IX1c1S7ks6Owvufra42QPzF9oYqfag1XsQ6nCZby46gcrnEbbz32Q7u3TaFnQYau517sCO//bsV3ajSO2/zdX9Kmqvxk+1zlBSrZzP2AspnldtH+1evIVlL9hbqAZ/Pbu3heuvK98f6ud5Y6vss+gjfA+vFWx9eX4nsXrOeHfsPA6pfFqzYItxdbq2B5vr4yvZJxK72SackEnbjf/CSudrdsOLJS+/p6vh3a7m13aJ6zx0vVjy2qj7xTe+js60Odzss/Ltr3w/GL86WR9Y+Xrfj6/pa+OxPi6zt3ovv+E44eyOcm3oi+vl+rfX2VfH3vGpGv711j4Ov7z9vQ1/cHta+vj+dVfX3vq319ta8Pym40X9/fgV7/0Qi+vr8FeJMndPvyC+2ikHpqjLOOgjoBnyE7LF9fo9MW5etT+djqLCnUHY03VXx9O0HHO0fvh+p4eK5sftW+vtrXhzBQpte+vtrXF8rPcfX1oWzmfkDZHOrrM7nr9RfqAqG+vp9zvjVblPsS6uuz+kuwfjx8ohgf+/pwjHLsnucHVDqtJ6NVfp3VjxFb58HyfH0x/IxMSyboxDPLnsTV7pbZs1H4+nq+B9TubXfo9689Xqp+bFF95F2Ir0/ZTMoP6MVco33+MM37WL6+b6N5H5LD+4swj59/ovh91gNvxBzeTwO9vM7h7aeH+fViGsfDyuF9MfTTqHJ4Hxc2HPev8nnm16hyeF8iaK5zePV8Xm9nPTy0+l8CPKxzeItprXN4e+UI/hoefjYOObzfAPrA15zohTtIDu+rAd63n9Dtyy+0i0LqqTHOOoo6m96bSylyeL810NfHuWA7BWzkjaeHcR98J/TBLw6o43m+vjqHt87hRZle5/BmbjxA6Hpe5/D6bUqZw6u+eaJkc2gO7y+SrRQrh/e5jq+P7QY8tzDE12f1fxnWj99xfH3ed7nYD7hX0Kn26PZQG5SMVt+rs/plemiDcHt6qILl+fpi5A8zLZmg095Tc9t4MwpfX8x9EcVL1Y+8D4e84zmK/ad0bt7bU75rtS+P9vnvJPL13UvzHvnFOSz2XrMA53q7t746U7AJz7hvyr4taPiNVpSfId8WRJ6xXr67Iq3KjzfotwW972vnF/t59lSkVelnKn7T21sJpXWjXY7bo9XTfRStar40s/6xzLEzCAvr4T1/a9jq/zmsY3ef7IXbpHfUN1ObWf94QZ4UwZp1YO0pgNWgZ9g+9Q3JKapv7cvb+te0ZitZoexB/g4j+/V5XPHctP43m5nrsL1q9f8ebObfhzUlv3Bts3Yk1ltXU9tVZXOH1ygVwzRCO0nyp+nwR62BnmxR375WeqfSz3l9UbhxzfHspFGON+QB8zP0G9ZV1+tWVr4GNgUstV4rfuL3IvNrst1Lw1rn+cKWLs1PpDGEn56eX8ZP9utifT4LHnU37gd1rhSuZV6fNOCZp2M2Ae7rj1y/V7Yezyv85n2IjlmmjzCPle6Ea5XhN1qLvktVhBvnS9E6FkprDF3Iw420VskbULSG+jyVbV60p1ZE60a7HLdHa5ktz7QqW76Z9Y9l9U2JvYIGteaw7rIKetdnko45QTQgL5tEO47fW6hM+U6UfDUYo5CvXgyf56cz/mD9sjHqfeNzDGJwk6/nZd9l8vyeLBsVbqXjj9t67unj3tqRXyHy2/vGA8dOIKyt6Juj1N9jjs89Dg+QR16Oi9JFed4r/wfKYa9PGvAs1Af3faQfqRg0Xk+KfO9FeRovhvXk3Sd78eE6wOuHiguxWJ991J61zt8LW7xYXmNcl4rdUbEMPec+0rPP7bRfxeepOavWFBXTyToX0qfGB+tcSi/x9v3K9gW82GeObx00ZymU1rLYmANEK/KS45NRp+J2XciK28w+WeQV6/0qbme7f9f6K5xxX/W71iFn1Kr82vxab/fWPwR4FW6ur/iD5y8cKGj/q6D9HO+J76jxyXuaVv9rAeZ6B6YaXzyGEn1P2x1Dar5VHUPf5IwhJUNU3L13hoWatxwXfmAEvFN9WZV33+7wTtkm+x3e7Rb0zIr3GgW/hoefNQnWbRFhHYoI6/aIsA4LWDbW7oDnEcfaSgitiH+GaI1Mz2KD8Bk9zB/m3Z2C1pYo433EOwWeOwWeliizva+YsJRMOkzv4TxnWxjH9sMEE7/5Z3aIilt6qPNerqP/JNka6kwJfHej3S3H+s861YX5RtL7VeyHWrtuozJcRw5RGeopBsPmUqKxu8BjF+U24jTamln/3MZxP0XPftGR20qvVd+LVHmhHPPNei7yLpEcWh1UDiXSgV05pHQJ48+daejZzDu5S9Cj+jmfU3uy/j5D+gwWfvd4vX39V8khjh/y8g9RD+bzxHDNNH+mp39g+0ymebJD6UrsI1D+9tDcf4MRU89R/A6V0b9NMlrZEOoMDLYhfhd8M/9J+Gkago6q/ibc5/s28jd5+RybZ+DDOvIHJ4vfZxtb2Rzb3Y5+X0Q7WuVaNwR9ajzx2Xg494fFz0OCHubXf6dxfBj4o2xT3ku4XeA97OC9nfAqe987x0n1hbWzKG/nNqLB6n8EaOD8TnWmHdLF/kFF876KNO8LoPmjDs2HHJpRxnHf4Rg+5NRnvwjDvz3TPCny27DMtfofhzZy/uVtgmbPH6XO+PLOGyj7/rqnb3P7vfPF8ov9tocr0urZg4h/r6DvjqwcN9K60e6tf2dFWpWOhnrXYaIV6bN31fkSjYJfw8PPPBnP+ZfIS47Vx2cYz3OHaBOfDXYA1us9p3rh8vls2Gd7C+DtA3h3n9Ltyy/MVQmpp8Y46xC4ZnP+pZpLSm/lMbgj0zrB7dR+q39Hpy0q/xL3IFnn3ilgI288PYn74Cj0wTq9H6qDeXGeqJ/l1ySUpd4nxj6bArwhfcxyQMkZHON8PjPW9+I8bh0hf7zzbpReUHX9wTX2EPFHyYdG1t8PvJbllxeXMMrx1qPft3vbVLamVl3P2UZHfvKesbKFlTxT/DQax23+emep51dVfnIelvKvKtnM/YCymeW2iv1Cuev1V1G+LJbhu+hLUP4VbDuvD8oW4TMErP4nwfrx6KlifCl8way3hvr3rL7SBVEP2kO4Ua+6MwCWlzNYplcybqVXMi2ZoNPeG52s1PmXuD7y3A7dL/J4qfqxRfWRd1V9pLyPE+IjxfGL86WR9Y+XqvMez+H4yQIfX2j8uxezaXCwflkMLI9lL0676tknByrSGnpmbkh8Uxmt7Gs5WJHWsvgm75szt1akdaM9XFr3CFqbWfHYQVx7BA0qhm+K6r8C1qrvPFVMj5dXsJtoUXuoWJ99RVb/lWD7vXdDw2wKmPll42p057ksPJr6WzllZ5F6spllitrjUN8OUPw0GkfBz5hnFCj+e2cNqz13j59eXKc6n0qdo8Extd/u+EfQZuSxoHKQcc577WiIdpTtfZ2mvS+VA9PI+mXThIBbdD7ia0F27T/diw95yX4aJReH9Z0e9b0cpV81s/5x1uOboGc/BONiKeB7OmpeqPwIPodQyWEcHyHru5c7FHN9L/vmCM/JWyvSWiaP+Zsjak8oE3i4XacKypRucMHByXmMyFfOR1DrynTWv66kmCNmN+AcUbEYTaqP9/nF+21vduZI1fiifYKehqAvZF/rdsCrcHN9xR+0pw4WtP/t0P4HC/bTpzI9licIptV/AmByXLaat8OKSVA88mISQsfQO50xVDUmQe0pq3nL8QepY9oV71RfVuXdb0Vco5Sdr3TERsGv4eFn2zmWelBYdwhYw4j3K6MV8c8QrZHp2YyH9Pyfinee3wzLeP9B+efuEnhaouxZ7fiwlEziOHMVg6RiHjkuG32vHPOHuWwY8/ffyC7BeLkJ8e5Gu1uO9b/2dBfmh8i/4X13r6q/3crUN+cSxxYv8NhFuY04Md6G5zaO+yl69teO3FY6sNrDU+f8WT0vByaxHAqOy2Y5lEgHduWQ0iWMP3eloWczLvtuQY/qZ4zLVrHYCMuLy/a+SeZ9A1rtK3jxByxfitpXJS5b6UrWL8rm9+xUrpuXDzsuu0hG7zndfQfboWR0fs9+X6t/K8jofXC/n+Cr82qwTZ5vCs8X+HBnAHo5yEzjq4Cu208Xv882trI5trsdfU+n/THsaPW9+4agT40nPicB5/6w+OnF9Fn9MzSO7wD+KNuUY38OC7x3OHgPE15l76tYEcTLfYExdar+IaLB6s8BDRzjfKvgA9LFvkRF876KNO8LoHnJofl2h2aUcdx3OIZvd+qzX4ThH840T4r8Nixzrf5laOMTBbHnzSzMH6XiiLx9rLK4QU/f5vZ7MUz5xT7eOyrSWhYPw/q/Fw9zRwmtG+3e+ndVpFXpaKh33UG0In32rtq3bBT8Gh5+5sl4jstGXnJeJj7DuGyVCz1F9V8A6/Unne6Feyu9g33WKoD3yQDvs07r9uUXxrCF1FNjnHUIXLND5pKXl2D82pFpnYDj3K3+pwuZqPYWWeduCtjIG09P4j74R9AHrxpQB0P/TX4Nf1+7epxsWR8PmkvSEvW9uOxRxr16cRRKL6i6/uAaezvxR8mHRtbfD7yW5dfo4yg0P3v0+3Zvm8rW1Fh5APk9x1EoW1jJM8VPo3Hc5q+XB5BfVfnJsZTKv6pkM/cD4mW5XRSX/aoCmx9pRTudbfK9oh3oS1C+WY5pLvMzFNnw3wDrx+sdfCl8way3hvr3rH5ZbDTH56nYaA/Wfgd3mV7JuJVeybRkgk57b4QxZ3Ju95xZ0u7lTeh+kcdL1Y8tqo+8q+oj5X2cEB8pjl+cL42sf7xUnfcY+8b7PPitEOXjW2/31lf7xk14VjUu2/vuVUhctvd9jQMVaU0dl420hsRtebSmjstGWjfaw6VV2Tcq9oq/JcvjORPvsO/O6v88rFXvOl1MD589iuOVz3dQcdmef97qvxVsv5C4bJQDXlz2cM5L3l5x2epbB3Vctj6nMiQuW/FTrVNMa5Gfm7+BZPV/y/GPqHhaFceE34l81+nydjREO9TeF8L9Wtr7Qt7j9wfyv/Hs7hT7KUYX7msgTqOtmfXLvZ7z4+nZHzj7U03BR7VWqLxWHqdNwM99omS71f9jkO2fINl+I/bH+4fUH2qOePlZZd+osb5UfcP5e/ie6dDTWf8cT9FvJl+w35RcaWb98qjnux/07C+cftvt8M5wZZm2K3Y7vJsl3rUS826f4F3L4R3qbj1rHj37WETezQp6PFheXrDSrWdF/d1Z15f0JV/6ki96aUbXDvqbA2qMsANUzxYqq1tEYKsAPuJt0LsZ/c2HC02IOvx3S8BHQe0JrtAFuQlw1+7W+EMNYOXs94ReWWI4GxQ4cdmRpHCrpEyrf3dFWo+I+ugQ4Q1NpO9IRVo32sOltSVoVZuiPB55jGTiHd7Es/r7773+m4+7U/cW08MOPRwDRZtNqARhfTYqrf6hDn40Kkf30aeFi1Udf2p8eI6/svHBhyfg+OV51xKwUOizUWPv78h0H/Gmt9U/Dn3kJZuyg7EpYOOY89oRKkMR7ns7BKvxykFiqYOw8dBhJV8xIIj7FmUz98UF6AtWKNSGkVICVN/xxgTKDmXU8Fix+ssgW36aZIsKVkscuLzA8xT7QwXFNLP+OYlzfIqeXXH6Q601SjZ4c8mTM3sFLKt/j6h/N9XJMt0391AZvsfG6D1QlqLfjnbgYb8hzruh/Vgf7/Nrip6tO/12t8M7w5VfyhjlACre+FK/hoefMR6E9az29d+9WX+7uY+OQVmKPjregYd9hDiPQnuwPt7n1xQ9e77TR0fhvQnxzOsjq6d4xwkVxxPz7kTWz7vjWTHvTkCZ3SPv7NmnR+RdU9AzK94bdHzPZv3t2SqskxFh3RsR1n0Clo21M/A84lgLTrI0/DNEa2R6NpObzhA9zB/m3VlBa0uU8dp5VuA5K/C0RJnJ2ZiwrOwo0HkfvYfznGHi2OYky3vhPU7gQV0QE3i+lPRx04uULZdfG+1uOdb/C9D9/gnpfqhrHc16y3A9P0Flx6DsJJWhnDQYNpcSjd0FHrsotxGn0dbM+uc2jvspevZKR27jWjkhnvE4uUfQMyveG5IcCk6yZDmUaA125dA9gq/Gn7Np6NlMsjwn6FH9jEmW2GdIn8HykiyPQn0OLkI5dJzKTkLZMSrDNZN9wveUtI+TLFF23EPvHRW0W78oe+GowK3gG4zZrJ/mRsGvweRn3rwMldHfRTL6aKdOqL/N6v8bkNHfSzIa3zdbw/OpTlPdVLLW+IWyVgXENbN+/mK/TdGzf+XI2qqHKSg/neIdb2yN2n5m3h2FMrtH3tmzH4vIu1lBjwfriIDF7cX6s079Y4H1SzfCdtHfLPRQsOJlmyNWl09hYcfcUYLDDSnaMNtFcPHdjP7mzYaJrP8qezcUdn6hs9DqKWcmwvOcwphh9FZyCh+FejYReHB/GITkz91b/P6N4mh5a2JHS0PQpxYtjphA5WNY/Dwh6GF+/Tsaq/cCf5RiwnP4pMB7r4P3JOFVmdzKOEC8R4kGa2fRZtBxosHq/z9iM4j7F/mAdPFGsKL5roo03xVA8286NJ9waM7vOTPb+gLH8Amn/lH4W8E/mWmeoGJ3VMDnMfmfoI2cyX1c0Gww82u9nUmeZFnYpvdJUV8ZDkqGcvsVbmUc8NwLpfU+UR/nHjsgkL77KtLK4/2+irR6DjJFK7bjTEVaN9rDpfW4oFU5udlRweM5E+8c7dzzHPkArOsfvrcXLr+D/c7Z5Vb3gwKeytgxVGwA5hcGNH24wMjLL+WIYx1IyXs0HpVBwvMPdSK1LqBzEOt/FHix+75ifEez3rIYzr97qQ2hDh2rr5y6OH/4S3Y4rs8GwLrLwa2cPWcd3EgXvsu4mU57TwXXoPM0vyahLKYDUAXXoJyZavfyJnSDwOOl6scW1UfeVXWKseM+xCmG4xfnSyPrHy9V5z0G+bBj3wIGUA9oANz1dm/92EGFXkBZSFChl7FRNVCvLEDCCyq8pyKtG0Omda+gVQUVIo1qjGTiHbZNrP49nTGcj7ul+4rp8QJLYwUVnuzgLwsqxCCk/JqEsohyL3lQYdn4YLmnHIDc/whrK0GFnP1i9eehj7xMKS+oEE/zW7qvvB0N0Y6yUwK/mPxHCv+0aHcKf4XxoujL3Eabmus9442ePQB9sdXMnL2CHoYVGlRo9ddAtnwuyZYbMcjzIac/YgR5Mn+fA/g+s6D/i3QGtnGVDuAFKpadKmH1vU0qDzeO1RCdYStBlbzxg+9zUOWNuKH2Gc64rTfUuvfIO3v24oi8qzfUgCj+REJRA2+0DbXPJYVILeQILzRTbeOuXripjUpPGUb8IQtEVaPySEVaj4v6KMjYUEP6jlekNWQzxaP1hKh/3KEV23GiIq0b7eHSulfQmtoAfiUoqd83oAE8S7QMagB/jTCAGabahM0v76iWIRnM8miRng3sdm+byjY3qm5YsdGJTj2WKcrQxPngHdViNI6CnzEdEIr/yCc+zgx5zRm6VR0QhifUAWH1v3tAB8SsgI1z3mtH6HqLcH+lcy6cl6HLGb7vBln0r+4rfp8DWEbtwMCMZpa7ngPjRxzlWWWX4jMvgIV1Ly8rH++HZcgpfqosP+bXG2msHgf+TBS0He+PCLzHHbxHCK8KYFE6BOJletS8x/q8aWv1f1bMe+5f5APSxTqXonm2Is2zATT/okPz3Q7NqCNw3+EYvtupz0evMPyiExZQZ2kJ+Dwm3wFtfCJAZ8E5vN7OJE+yLEy/jHFqg4db6QM890JpLdOFOXLb09vLaN1oD5fWOwStzay4PxDXHYIGfIedy1b/t2CtfPd9vXD5HeTlWSqzuu8S8GxtuaULftOPwI5aLEMYPB/zq6pegaclfD3pFSiHinTcIsf9LJRj/fcAL/7yvmJ8HOSgMuHV3OPxg2OL56XS+T1nrwos42AZxI1z694AWJ4TrSxIjXGrIDWmJRN02nsjtPVkUAjKjal2b7s92y2/Qnip+rFF9ZF36viyWSpTsksFg7WoDMcpBoX8Jc37WdGOBjzz5v0swH2M5j3iZ9+GlV04033/Y/cVv2+8H5fseT5RCcd+zxijZ59w7AmlKygHutqwZpmkdLEG1ckv4ycGLA2Ln+cEPcyv6TO9deaAPxMFbcf78wLvnIP3POFV9oTSPRAv02PtLLInThANVn8WaGDd/IjgA9LF9oSi+ZaKNN8SQPN+h+ZzDs35PdsH1hc4hs859bENCv75TPMEdY8jAj6PyduhjU8UBP03Mz2H19uZ5EmW+UEQzBOsjzwx/EqGcvsVbhwnbE/MVaR1XtTHuXeOaEX65ivSutEeLq0nBK3NrLg/ENcJQQO+Y33G4+4+WCsvnOmFy+8gL9mesLrnBDz2VeUX2xPqM7cIg+djflXVK+zdHO6bOgqQ8R7lEMvystPFboFyrL8KvHjumWJ8PA5QbztPZUcEncqe4LG+lHUv5afmsbss6i9RHcSNY3c5ANYtDu4VUX/ZwY104buMm+m095Q9gcl9+TUJZaO0J1Q/evaE4qXqxxbVR96pAPRbqAxlA9sTOJ+OUBmOU7Qnnkvz/hbRjgY88+b9LQD3W5x5b/JpisreBPP4U515bDEWah5bvemsfx6n0I2Nl6ijKtupmfXLjp69S3r2maCnbDXY7xZBT0PQF2Jr4LweFj9PCHqYX4/ROD4P/JkoaDvenxN4zzt4zxHe0ORbxMv0WDuLbI3jRIPV/1xHbz8s+IB0hcSLNCvS3Ayg+Qsdmk84NOf3bDtYX+AY9mwT3s9k+GzbYhvUWCpKvv1Sx9Y4LmjGObzeziRPsixsbfd0bsSvZCi33/PX5xfbGucr0qr0fbXO7RX0sQ55voRWHu/zFWlVegGuraxHIn1LFWndaJfj9mgt0y2ZVmzHMsBEPMwzbgvSoNYdtnFeDWv+m8guYn0f+/0UlVndbxTwQnQIXLNNF1X6KuoX+TUJZfHWQ/0ZURwvU4C3aBxj/arj2MZhK+sfN4cd/mz64LLh8+cWhz9KZ/LmjloHUUay7u2tHwq38tWM23iLGVtXth55Sbgs45WNUpQI+2Sddvf94cTWaX4ijSH89PwGZfxkuxHrc8w8fzoK5WF+FcUmmM7HddifZfV/EvSh36fYul1AA4+FaaddyteFst8bMw3RxjK7djfZtUrXZZxF/qwmlGP9X4A17LfOFOOztqv17QiVqUN8lD7FtpbSzTy5WeaLbRBuz2+sYHl+4LI1jXEr3YxpyQSd9t7o5PVCZf3A07HzK4SXqh+VfjBPZeqzbGqf+zyV4XximYDjFPe7fovmfVO0owHPQvNbPtAhoIo/62lnu++/+yb3Z72n9mdV8me9f0T+rPePgT/rv21Df9af3wT+rI/W/qyx82dttHvrj8KfpezvRsGv4eFnnoyfgjrMS87jxWdoU8yJNvE+8iys17vO9sJl/xX22ekCeLcAvENndfvyC+2WkHpqjIf4s7y55Nl7xq8dmdYJzlH7rf7BTltULlWovYe6nfHG05O4D+6APngavR+qg42rPxD7bArwhvRx1dgk9gdifRuXij94iMWw+eP5A5VeUHX9wTWW/YFKPjSy/n6o/YF6Pef4BXUoXyPr7zdPno2bP9CbvydK2hTLH4jrq5LN3A8om1luF/niTO56/YW6QKgv7sfJJk/hi9uA9eNFZ4vx1b643vq1L6578dy+WXxxL6J5H8sX93U070P0wN+Aefyoo0d6ejR/iAB5ksJ3ZHyNncfyEtDLt5rHcljQ0xD0hfjicF4Pi5+eT8zqfxmN43ngz0RB2/F+TuCdd/DOEd4YeSzKhsP6J4gGq//lwobj/kU+IF0heSzNijQ3A2j+Kofm8w7N+T371qwvcAyfd+qX5bGw3MY2qLFUlMfyz6CNW81jUbaft/dc1b+lYuk93MoW4rkXSmvMeK35Elo32r31lyvSWhaPP0+0qnh8FWvQKPg1PPzMk/Hsi0NeHiGc+AxtCqWfcH7L98F6/Z3ki+P4ApXrw/C+B+C94axuX36h3RJST41x1iFwzWZfnJpLni/a+LUj0zrBHLXf6v9AoC/Os/fmAPcbzha3vyhf+EehD35jQB3M88UNJ5ekum+krI+r2m3sa8L6ni/uRol9UvzENZZtFyUfGll/PyhbzPMdjXK89ej37d42la2pVddz9v0iP2cIltrLV/JM8dNoHLf5W7YHV5WfbD8jPz1fHPcDymaW20X7S79BtozqL9QFPJscP6j4kOOLYz9WWZ4n++Ks/rtg/fivji/O2h7ib1PnICldkO3E1HmeKhbfg+X54lLmeSKd45rniesjz23PPsivEF4OmueJPmLWuVGnYx+et0+ifKM4XxpZ/3jZii/uOM17nE/si7OyzzjXff/PHT3S06P5cHzkSQrfkTqLBHFi/Av3Q48vmJ79teOLU7qJWne8M4Magr4QXxzKvmHxU/m0mV+mwPH8nci0PcRtnBd4lxy884RX+eKUfoB4mR6cl6o+x6ds+g+BhrcXxF8hH5Au9sUpmpsVaW4G0Dzt0Dzn0Jzfs28Nz+pQY4brs3+e4bMPFtugxhL74jZ9R9DGJwr8jc1Mz+H1diZ5kmVh+75ltiL7t9S64uFWthDPvVBay3QgPmfD04GWSmjdaPfWX6lI66qoj2v5EtGK9Nm7ap+/UfBrePiZJ+PZF4e8PE448RnaFMuiTRz3eS+s18fP9cI9Tu9gn50ugHcK4C2e0+3LL7RbQuqpMc46BK7Z7Isr8+8Wjf8dmdYJ2Ldp9S8ImVjV3kM/oPHG05O4D1agDz6D3q/qyxy3uC/PN1LWx4PuH7REfc8XN0pfhxd3pPSCquuPskHUOTQcF6f8gLgmeb6jUY63mLEeg/p+83vOZdhKnOEo87i9+ev5fvOrKj+9c5I8Xxz3A8pmlttFvrjPIFsm1plrf3T79fuUvrjPgfXjZeeK8dW+uN76tS+ue/Hcvll8cS+jeR/LF/cWmvec159fHN/6pzCPv+pc8fs3Q47q14BeXueo9tPD/PoWGsfKn+PlqA7qA/wWxxenfKaIN1aO6r9w/FrjmqP6XQ7NJxya8/uQ851POPXLclR5Tcc2qLFUlKP6WscXp3zgMXNUvX13xK9kaNH51gjLiwuKnRvA+pfnNy2Lb9lo99aPfY5ZiN9w2DmqyMvQHNV50SbWu38W1uufJl9c0Rlr+f2pAnj/BuC9/ZxuX36h3RJSb6s5qmV+iKLxX5SjWrQ/8dZAX5yXo4pxym8/V9z+otyEJ6AP/nRAHWw75qhW9TUNGqeUXzdDjqoXp4QyXdknpwhWnaNavp579t4FglXnqJbzk3NUkZ+xclQngAZc0/6UbJlYOaovc3xxODd5fQjxxVn9/w7rx8T5YnzW9q3mqKpcD6NV6ZVbOX+kQbi9/AwFy/PFxfADMi2ZoNPeG52s1L44XB95bnv2QX6F8FL1Y4vqI+94jmL/qf1v3lvC+eTlqPbklZ3vpTGWL+5TB/DFfd757vvT54vfvxl8ca1O+2tfXJgv7g4ax8Pyxd0B/TQqX9wRoGG7+OJOODTfKL64M9DG2hdXTOswfXE83kfhiwuldaNdjtujtWyvlWlVe61NwsM847aovW8cX+x/eiqs+Z93vhcu+4s8f57VXRPwQnSI7fD9A09f9c5Iya+q45h9SThuvO8fbMY9Z8Pnj+dLGub3D1h+1t8/KF+P2F7xZLzyTdxs3z8Y1JeUX88m3GyboTzML17fjYem83Gdopjbx0EfivX9gyJ/1ued123Msq35sw4MwZ/1xbCGvbr2Z/XAqv1ZT161PwvK0J/16kT+rD8/dP2+ij/rozCPv/km92d9R+3PquTPet2I/FmvGwN/1g9sQ3/Wj9wE/qyfqP1ZdWwZlN1osWW/Cuv1O8gXNUhs2a8AvN88r9uXX2i3hNTbLrFlvyFk4lZiy37zfHH7i2LLfhv64KMD6mB1bFkdW1bHltWxZbH5ebPEln00kS/up8kmT+GL+3tYPw7MFeOrfXG99WtfXPfiuX2z+OJsvjSy/vGyFV/cP6d5H6IHvnyu+/7hueL3b4bvHxzttH/cvn+AetKw+HlK0MP8OkvjWPnijgg4dj+oL+4s9NNWv39g7Qz9/oHVvwA0DPv7B4rmZgDNyw7Npxya8/sQX9wpp37Z9w+KfFGol4R8/+AKtHGr3z84BWWe/515gvWRJ+zfUr4CD7eyhXjuhdJa5os7RbRW9cV54z32uRxbjS1DWjfa5bi38q2GKrFluIaExpapdYf9T8+DNf/lc71wPX/eBJVZ3RcIeCE6BK7Z43p+/zBjy9hXguPmiMOfUcaWebE7Smfy5o5n26NM8vRrDzfKVM/3Ma7n95etCVXXI8+XxDJe7UWH+pKMxnHzJZ0qaVNVfhbF6uUXx5Z5e5P5xeu78bAotqxo//WloA95sWVV/FlFezQvn9NtzLLqdi1+Q+CTHH8W+4IGPbfsn8Ia9l2OPyvWuWWeH1zpZp7cvNn9WcOR19vLn4V+VvZNoN7F/iycTywTcJyiP+u7Evmz7h3An/VxmMevvcn9WT9U+7Mq+bN+ckT+rJ8cA3/Wm7ahP+vnbwJ/1i/V/qzanwVltT+r35/1H2HN/3gEf9b/J+DV/qzan1X7s6rzs/ZnxeXnze7P+psh+rM+nsif9YHbrt+HxGcN6s9qXujiO3yhGJ/nz+L4rFOCzkHjs2p/1vWr9mdt3Z8VGp8Vst7ifGlk/eNlK/6sX6V5r+YT27ifCfP4ngvF7xue6ax/PqbwsRif0dehfNoqN6VnjNGzU502Kp+VWt/wGY+LpqCnIegL8VnhuB0WP9VcYX7N01hdBv54vi+Wj4h32cG7RHiVz0rZpIi3aL+jyGc1RzRY/WWgIcT/g3SxDa9oPlKR5iMBNF92aJ53aM7v2QdlfYFjeN6pz37XsrUT2+D5xHhMPg3ayD6rOUEzzuH1diZ5kmVh63eZ7sD+ilNO+8vWO9ZpY3/zZ55oVb6VUFp5vK9UpLXsu5dMq/ruZSitG+3h0jonaG1mxWMHcSmfFb7DOZBW/1NhXbc1vugd7Hf2WVndFwp4nn2jdCD+9tFx8R7CZ7mSZdX1I/T9v5r0I5SnPDdRX/L2Raao/ouBT19+oRgfywnUI3n8KBmi7CJeV9U4RZ7zuL4o6vPcQtw45i8GwPJ8BZdE/YsObqQL32XcTCd+I/dJXO1umfFmFHYRyqCpdm+7PXmTXyG8VP3YovrIO843xf5T3yxcoTKcT2wX4ThFu+jLad4rn2QDnnnzHr9L+Kgz73mf38reD/P4q5157PnoMQeXZWEKHd/4XHTmidHWzPrlCspYlv1f69hMKE88GaNsafZFIX0hNlNqG1Tx87ygh/n1GhrHSu8+LuDY/aC22mscm8lbQxU9OC89G4v3vb7dsT+OCz4gXaxDKpqbFWluBtD83Q7N5x2a83u2gZT9cd6pz7E/DJ/jO7ANaiyxzWT1X+fYTMpXgXN4vZ1JnmRZ2NqubF/ly1EylNvv7SnkF9tM8xVpDf3udohveL6E1o12b/3lirTGsO/Uvk+j4Nfw8DNPxk9BHeblccKJz3CvZUm0ifXun4P1+o1k77DvE/tsogDezwC8d1zQ7csvtFtC6qkxzjoErtl8hkxZPEbR+N+RaZ2gyI/0S0Imqn0wa4faB5sD3O+4UNz+IlvqV6AP3j+gDubFSYzyjBRv37qsjweNTWqJ+t4ZMjfKPrTip4o1VjbPBME6IWDhmuTt649yvPXo9+3eNpWtqVXXc+OR4ief+7eVM3mMxnGbv96ZMPlVlZ9sdyM/p6gMZTP3A8pmlttFMQrvT2ST3zqEGIUPwfoxOV+Mr45R6K1fxyh0L57bN0uMgs2XRtY/XqrOe4xR+Mit1+9t7KC8Yl3X2tsswMn+AiWbvHGufFfKN+jl4nm4UaayXu75NhStobGJSgc+HwBrK+sT88nzX6RaG/dm/XOE99PYzsD+PEV1Oa77uGivGqeMi/Hg31h/l4DvxRY26L38qjov7d18Xn5jwLyczvrbn8Lvam1E/6c6M7QpeNITX03PTnZkmvJjKz7iM5a304KehqBvULk1LXCHyi3vTNUQuYXtZrl1vCKtyl5Str8adyeojHOisAxhFtGgfKb5tdHulmP9ZRgv793QMIt8ptbHo7MDFy5tJztwK99qGo4dqPk5zLNEi+LlPRmEsHB88rzG+HE1Tw0ey9RnwRxhPyH6TtiGbVakfZA1beNW3cYiubze7q0fW9YZfiXP2F5UuNW3tqz+qYq0lumTbNsqOyGUVl7vzlektUzOMK2e/llG68aQaT0saG1mxWMHcSk90vOrW/0Xd+ZsPke+ar6YHu8MA/aL4h6LZ0uxPn3VWWNVPADKT2+NHVJO2qJaE3DM8JrgjQ9rK9Yv8+2zHw99CyxT1Bqr1gTFT6NxFPxEGkPWWBV/4vHfW2PVPorHT5Xjx7QWxXSzzWn1X+Gssd5e3ISAjXPea0foeotwJ8mGVPoDr1dFPl2UJ1j/a0B2fYxkF/aPjVPlm0V9kfs4hT1rc7Lo3A48G4LnMM5/3qP9JseeVeuWkjPe2TsNQV+IPav8zZ4dUeZv5pgL5W/2cKv9OQ+3R2tZzIUXn4vvIh7V7xeo7jzVVd9lUDhZ50S+NqlMxWVOE+2p5ojFp+IcQZzL1H6MZ8X42Cl69v3OHFF9j894jnix1kgfj+H8Wm/31r8IeBVurq/4g/HRSwXt/2FoP8cE4jtqLJ8gmFb/xwDmegemGl88hhD2sMaQmptVx9BPOWNIyRt85o0hT1Zw7PDSCHin+rIq734+4hqlzv9ROnej4Nfw8LMmwVqNCOtiRFiXIsK6LGDZWLsCzyOOtZUQWhH/DNEamZ7FBuEzepg/zLv7Ba0tUcb2wv0Cz/0CT0uUPasdH5aSSZfpPZzn7MPDsf0wwcScEotRUfbcQ533cn3+t8kuwdjEEL+91f/ChS7M/0Q2gtK71dq1SmW4jlykMtRTDIbNpURjd4HHLsptxMlnZOHcxnE/Rc/e68htpQOrfCSVC8Rxx6wTI+8SyaHVQeVQIh3YlUNKlzD+3J+GnhWj5wFBj+rnff/7356sv8+QPoM1Ce+vt6//KjnEMSwohzjXDPVgzjHFNZPPFJoraZ/JtL0OfZ6uZP2ibH7PTuW6ebmKTRpUB/DiCMtk9EdJRisbQsVKsA3x9+DH+Vvh02kIOqr6puzdHO6vHbx+r2T9XAGNL4F15BPzxe+zja1sju1uR+/o8CKGHb0k6GkI+tR4snvjJ879YfHzoqCH+dVa6G3XZeCPsk2PEx8uCbyXHbyXCK+y9718cNUX1s6iPeFVosHqHwQaOJ9OnR+DdLEvUdF8viLN5wNoPixoTjzGLnNfK54wfhwHOEcuOfXZ78LwL1N95JEaqyzTrf5R4CHnGK4Kmj1/lzo/QOlCzEOsj3zw9PlLWTluHIfsQ75ckVbP3kT8ewV9V7Jy3EjrRru3/v0VaVU6IOp1l4lWpM/enRV4GgW/hoefeWsI5xgiLzkeHZ/hntQV0aYpqn8Z9IHlhV64y/QO9tmpAngXAd4zFnT78gvzMULqqTHOOgrqBCFzSenFPAZ3ZFrnuETtt/pPFzJXfQ+AdfqmgI288fQw7oMN6IOX0PuhOh76h/IL981R/8uvSSiLt5YsLVY9U6Ssj3lMKDmDY3xT7xH1vRzDlRHyZ8nhj9I7qq4/ag1X/jH2Eyr/ivK1jdt467Ef2r1tKltTq67n7ANAfnJ+jbK1lTxT/DQax23+XixpU1V+cq6R8t8q2cz9gHhZbqPvAte0l5CtpPqrKE4Jy/Bd9FUo3y/ryGV+jCIfwZfA+vH1C8X4UviaWW8N9R9afaULoh7EsYqoV90fAMvLiyvTKxm30iuZlkzQae+NTlbqHENcH3luh+5HebxU/dii+si7qj5Y3icK8cHi+MX50sj6x0vVeY9nTfA+kvf9qPxab/fWV/vSTXhWNebXyyEOyY/zYgrnK9Ia83ybMlpD4sI8WmPGhZXRutEeLq1HBK0qtovP5eHxnIl32N60+t8Pa9VbForpYdmL45Xzds4DrglRn31FVv+HwPZ7b8GZW00BM79Gn1u1WNme8MaHtRXrl8UZ8pklqBewTFE5fqFnlgxnjUwfR6/4j3zi2AZ1jpbHT+8MMlyb1Bwp+u7Umx3/CK59PBbU+RU45712NEQ71N4awn2I9tYQP/dD7Dwlo2nQvPetnFvHuNW6zrSofHJuz3FBz2EBS9lcvI8UK7a/4fQx8+SYwOmtnUqHOUZ1EDeuVfMBsDw7pOo5K0gX+7PtvSlBJ7dHreGHBSyll/P3LWP18Zcd6G3rDNTjMwCwPSn2XW1O4P4n4pwB/vEc6slxpmfvdfaxZ7J+PuIz3oOYFvQMS84hPtYtvXNBVG4AyzvU5ZCujXa3HOv/mdDllC4xpDztldRn+oTaUGqviseJGnNevorxsGh/2+DxuP8fji7hnR10uCLtoXJnBtoxf0DDDbXXq841ta6fErSp9YZ1a4Ub+cI28HxFWsvG2imi1bPXy2jdGDKtM4JWJc+RRjVGsqxY7k1R/Z2L13/zcXfHYjE9nr1+jGhRuYxe7rPV393BXyY3ja7EcvNK1fNC1PjwcufKxgfbYCpGz5M9np9M2WDYRyw3rf4h6COWm8rnYmXHBGwcc147BpGhf7X/+r1ng02LdqfQ3aztqLupPOem4JXd59cUPTsBfcG6m9KB1fmKymZiPeiYgOXZL0qusozIL9U3LBPVuPHymw2+54fLL5Pt7IebC5RBRtcodLdhnqfA8xjlU8iZRZ4fyHhY5Afi/H+rf9mRQWrNCjk3LpbN+Ib9Gu5WdDdvrpXZSRyng/OJ/RQKt3fGzlxFWkPHmrLN5ivSujFkWpWvQuluoefW4DvWZ1NU/3mgu714sZgetnmVTGW+otzE+kW626cGys0hnWNbWXfzbKD8qjo+jGdKbvK8U7LnGDzjeYfn0qo+Yrlp9f+RIzfVtzeVTEVZ9+LF8nYMIkNfQrob8h5jYVGmh8pXRaMnB9SeAM4tPlcFeRXil0T7sWh9DKW1TO/yzltj39qxElpDzjDbSozAMaLVixEoozX1WsC0qnWrmfWPZc7RR1hYD+/ZLrP6L4e14LWLvXCbRAPy8hzRjuN3gspwLFms+Ojscx0j6Mn42Od5Wvu8eL7R+X01f6Yd/ijbu6qPXq0VIXs2CrfSPRU/cS8mvyahLDU/e85Xbve2yVs78itEfiufjDqjimE1BSzkscfP4eho6cfnEYcHyCPvO13q7Die95g3c6xzj3LY65MGPPP0oybAvUT6kTrrmteTKYET3+X15IdgPbl9qRffMcELtU5bvWF9n9Lkb9H3KY22Zta/hvfsh9Gzf+342dScVWuK8oOyzoX0qfERsndyTOC2+jH3Tsp83azLLlWktSx+cJ5oRV5yjtsxwMHtOp0Vt5n9jcirJpUp3/ywzvmyWLfQc74wNq4np4Kevc0Z91XP+fLGEtLH4zK/1tu99VcBr8LN9RV/MHZ7vqD9vwrt59xxfEeNzxME0+q/E2DyWXE4vngMpT7vTPFIzbeqY+g/OGNIyRB85o0hnv9YhvoL83VYvFN9WZV373Z4p2yTOYd36lxtFQvSKPg1PPysSbBWIsLaTufOJT7fKvisOMM/Q7RGpmfzjCYvD1bx7oqgtSXKjsE9liGeKwJPS5Q9qx0flpJJl+g9nOdsC6vzE1TukNkhxj+0aR7qvPfkd8TI1lD7nyq/g33E/3ypC/MvaU9B5UKptWuFykJz+wyGzaVEY3eBxy7KbcTJeSg4t3vy1ejZ3ztyu+rZQCqHZ1a8NyQ5FHxWHMuhRDqwK4eULjGMMz3zfyr/U/UznhWn8jQRlndWnMqtVXKIcxFRD+acZ1wzQ86Kw/aZTPNkh9KVQs6KU3rjOJ0VVySjDy5138F2hMbJWf07QUYfgvvbCX6sfJYL5G9Sui3T+A1A15Gl4vfZxlY2x3a3o091XoxhR88LehqCPjWe+AxtnPvD4qc6P5f5NU/jWJ0HtiTgWP2LAu8lB+9FwqvsfZV/iHi5LzbPCSyov0I0WP1loIHPilsSfEC62D+oaD5fkebzATRfFjQnHmOXua8VTxg/jgOcIxed+ux3Yfh85gTySI1VlulW/+nAQz4rbkXQ7Pm71Fk9ShdiHmJ9db6sktF8bojC7Z2VdakiraHnLu0V9PG5fmVnPm20e+tfqUhr2Xkil4hWdZ7IrMDTKPg1PPzMW0OmoA7zkvP58BnuM10WbZqi+p8O+sCnLvXC5bPIsM+OFcB7IcB7ZEm3L7/wXJ2QemqMs46izjrz5pLSi3kM7si0znGR2m/1P1vIXBWvxTp9U8BG3nh6GPfB49AH3zCgjof+ofzCfWjU//JrEspS70Njn00B3pA+5jEx6Nld+eXFkSyPkD/zDn+U3lF1/VFruPKPHSNYyr+ifG3jNt68s83K1tSq6zn7AJCfvCetbG0lzxQ/R3mWoTd/V0vaVJWfnJuu/LdKNnvneLLcVrFlKHe9/lJ5YOyrwHfRV6H8N6wjl/kx+KwHq/+tsH78iIMvha+56AzpLAuTWWVnFnPMvXdmsYLl5eyU6ZWMW+mVTEsm6LT3Ricr9VlxuD7y3A7dj/J4qfpRfc+Iv3UU6oPlfaIQHyyOX5wvjax/vFSd95hP8JGCmP7Q+Po6fylO/lJIrJdHa+o8eS/XKjWthwWtqXOt3gZr1e8tFdMzjFyrXwHbj8+KUzGEBjO/xvUb4Z494Y0PayvWL4sd5PwmdY4cjxeEpeIcR7dGLibPg1D8V+fmhJxTMKxct//s+EcGyXX7vaXydjREO8py3X5i3/V7FcvNbbOyh5e77//RUvH75gtUsoj3gk7Re2udvxe2eHE/4p6MkrvNrH989eS707P3O3trOK7UWPPi/5FXTB/3N94P6xvqip9zgh7m10doHKs9pWMCjt3PC7xLDt55wqv21pQ8QrxMjzq7BOuzvWn1/8rZWzsm+IB0Vcl3DKW5GUDzx5y9tURj7DL3teKJGm9eHLeqf4zoZ/hF5yuH6kubfbTc5SHvramzdQ1mfq23e+srm8E7M7PMZuBzlbA9bDN4+Yj5FZJz4dFapjd5fhg+X9rTGfJro91b39tfV7R6PlHEr3w/9q6K12kU/BoefhaSQ9bM+nl5jHDiM9xb877ZY/VvB33gwHIv3GP0DvbZdAG82wDe8WXdvvxCP2RIPTXGWUdBnYBz2QbNOSo6X6ZoX+sekBesO+IYsHaoPED0pRpvPD2M++AU9MHD9H6ojuflaA/nXPDqOdplfVzVd1B09mR+jWuO9hGHP1XPbA6NlVSxAXymlvID4Zrk2cKjHG/jcl4W+39Cz01X/DQax23+zpW0qSo/2f+uYleUbOZ+UDnanBuVX7immdz1+qsBz0LjaT+fbH5lBzDOqUzbOk0ox/ovgPXjc5eL8YWcCeP53r2YYKNV6ZWezCr71kODcKNetRIAy/NFl+mVjFvplUxLJujEXI4ncbW7ZcORlXpvLeY3O7x9duSl2gfjmBh1fqc6B4P3z9SZQl4+Kc6XRtY/XqrOezy34aEBfH2/A/P4Hw+oB94ovr6Xgl5e+/r66WF+vZLG8bB8fa+EfhqVr++fCRuO+3fcfH1fL2iufX3VfH2vqX19ta8Pym40X9+PgD7wAxV8fecK4L0B4L0x0Nf3xhvI1/eTkX19bxzA1/cz0Ae/U/v6Nq/a19ff3lS+vnMEq/b1bc3Xd5Zg1b6+8fb1/U4iX9/EEHx9fwjrx0drX18PrNrX9+RV+/qgDPW1jyby9f1R6/p9FV/f1ZXu+x+/yX19zQ4val9fmK9v90pvnWH5+nZDP43K19cCGraLr+9WQXPt66vm67sLeFj7+opprX19vXIEfw0PPxsHX98K6APzK71wj9E72GcXCuAtAbynrej25RfaRSH1touv7wEhc7fi6zPeVPH1PQh9cJXer319vpypfX0+P0N9fRcIVu3r25qv7zTBqn194+3ru0q2Uixf32vJ5i/KMeb1oYqv7wth/fialWJ8nq/vGJWpca50QfZX1r6+fjprX1+Xl1v19R2DMvb14XzitU6du4DzpZH1j5et+PpeTvMe28S6ro2BZgFO9keotXkCnlU9T8M7nyDkPI2Qb8qH0hq65u7NivvVg7WVMyeYT0jXUmLc3G51zizXZTuD+wPL2I/COHicMi7Gg3+rNQjheet2g97Lr6rzEnPrP7b3+r3ng/fG+i54VnWe8XrizTPP56hwe7qtwq1kJdOixg+3R/WxOkdIyXbu41g617udPmaco+CzB8v7FmSZbGTcSjYyLVOCziKZX9THvNZ64yVWH7/Z6WOjZ1rQk2J/xtqI+yTHBN1NwZMe+4qevc3Z71J8VHq22uv05HqI/qHmzJzA7Y1btc6oOcNreuiZZiFzRtEa6mPy1mE1/9j2QpgTBTRMCRrya6PdLcf6/y+MFz4DytuvyS/vDKjh+B8WLlU9s9OzHa2tWD90H0HZKCzHlG6AY8fz5wznjF7NT88/VraPE2K7e2dqIa+LZBDCwvHJ89pg78h8XZ1l6h87/n7UTVhvmahI+yBr2iv39sK19hTJ5fV2b33VH56sK5sPht/zf3i4vf67WJHW0POy9wr6ir7HUEQrr3eXKtJa9j0CptX7HkEZrRtDpnVe0NrMiscO4poXNKjvUPH+5cfAv3nrajE93j7wTqJFfZMD6xd9k+N/OWus+iYHrkfeGmvtGMW5gDHPzi07A5l9fXhGcdEZ0ghLfTdE8dNoHAU/Y57brvjvnTOOvObzrBU/ve9QqG//qG8zTlH9/Z0btcYq/72V7RSwcc577QhdbxHuN++5fq/8eebnGZdvLRttStZ63xk7An2x1e8F7xL0eOuU5yuruveC+PgMd7WGKD2AbUn8jsqEoMvW1imqfx/w9L0w959sS7uLYzjfOlhYUTII9SuWQZ4ulV9VdQT+FgfKoBCfl/oWB4+rHZmWf+zHsvrLjgxSZ/6rPecQ2kPlDsaEruzRcEP1fLU3V3WuLQvabM4sQhmvyQo38oV154sVaS3T8735fakirRtDpnVO0NrMivsDcc0JGvAd6zOOKX52h0H5uPuHq8X0sJ6PY4D3tlBPnxD1WXe2+s8LlJvov82vSSiLKDevjPobT8Yz/saTmndK9izCsxDdDfuI5abV/wxHbnrfDFa6Co45rx2DyNDndAaOGsvWD6a7sa91rfP3whavBrUddTe1jqjY4J4YDHr2eETdrSnoaQgaQvbAymLHrc9U37BMxPcWqQzlG8dMePZ7fplsZ73giwJlkNE1Ct1tXL77FaL/ePajislW6xyP+1c4MghlGNuPuyrSPojc+bvdGm6o7rYo6KgaF6LkuM2ZBSjjOalwq5heb557tJbF8vH89mL5ymjdGDKtSldqZsX9gbiU7obvWJ+x7vYa0N1+wNHd2E+PY4D38lFPnBD1WXez+t+xDXQ3HDMsN9X4wPpVx4fxTOlGPO+U7FmAZyFyE/uoSG5+vyM3UR9hvVPlCOCY89oxiAw90JGhap98F7XNyvZd7L7/o6vF79s+nZonuI/NPEmhF1qfheqF2Mc4Pqbo2U9F1Au9HE9vbcN74yfKtGHxc1HQw/z6BRrHy8CfiYK2473S75cdvEuEV+VBY/8q3jI91s6iPGheQ6z+LwmZwP2LfEC62JejaG5WpLkZQPMTgubEY+wy97XiiRpvNg5wjiw59eeIfobP4wp5pMYqr9dW/9eAh5wHvSBoRhmx3u6tr3QxLy6kTGc1/CFx1Aq3t3YuV6Q1ps66XELrRru3/mpFWkNtObUvYu/OCjyNgl/Dw8+8NWQK6jAvPd0YbTcvJsDq/zHoxn+w2gu3SD/K76cL4P0hwPtvq7p9+YU5YyH11BhnHQV1Ao5TKPvOYdH4L4qL4rxyq/9nju6IY4BjfXcK2MgbTw/jPvgQ9IHpe1V1PKNH2SajzKPEPpsCvCF9XNX/xrYJ1vfyoIcTg1I9b1fpHVXXH7WGK981f99ExRoov/u4jbce+6Hd26ayNbXqes4xKMhP/r6Jit9W8kzx02gct/m7WNKmqvwsOscA11clm7kfUDaz3MZ9TVzTTO56/YW6gGfz27s53P/SUVRNZis7gHGG5kFb/dvBRzB/sRiftd3Lk1FrC+utnp6v9EpPZsXIRfZgeb7QMr2ScSu9kmnJBJ323uhkpc6DjpljoHip+lHtt3AcDerErHOjTsd7OMpXqPZPUF+bp3kfKw/6bTTvQ3x9r4d5vDqgHnij+Pqe0ml/7esL8/U9RON4WL6+h6CfRuXrew7QsF18fc8XNNe+vmq+vk8DHta+vmJaa19frxzBX8PDz8bB1/dFoA+85GIvXM/Xd64A3hcCvJdf1O3LL7SLQuptF1/fPxEydyu+vpdfLG5/ka/vK6EPXl/7+jav2tfX395Uvj7+vknt69uar4+/b1L7+sbb1/f6RL6+r3B8fZyDZWMm1Ndn9X8E1o+3VfD14Rjl2EnPD6h0Wk9Gn4VnVfXQBuG+0c48NN7UZx6G+fqUzaT8gCxL1DqI86WR9Y+Xrfj6XkjzHuca+/qsbO5S9/1/e7H4fdYDca7ieGJ+pfBNGc+LvseB3xngPupZW+jZrzu+PiWblV7UErwrOlsu1NeH42hY/FwQ9DC//hONY+XPOS/g2P2iwOt932SR8Cpfn5ebruixdhb5+jjH3ur/ruPrOy/44J1vomhuVqS5GUDzex1fX6Ixdpn7WvFEjTd1XpanA7DNyvCLzgdFvQdhsK/P6v+J4+ubFzSjjFhv99ZXtpant3i2BOJXMpp9owq35+tYqkhrqN2s9LuQ75sgrRvt3vorFWmN+X0TxNMo+DU8/MxbQ9jXh7xk/yI+C/2+idX/e9Dr/4Z8fexLwj67UADv7wDejku6ffmFdlFIvUF9Vd5c8nKxVE4Iwuf87821sNOWMl8f6447BWzkjaeHcR9Mg443R++H6nier2849oT2FWCfTQHekD6O5XvJL8/XN5ycLM2fsw5/lN5Rdf1Ra7iKdeDvm6i9c7XXNG7jzfNNla2pVddzL3bkNME6K2ApeTZuvmhv/i6UtKkqP41Hip+er8/bh2G5XeTrM7nr9RfqAp7Nb+/mcPc7vj62G2zMhPr6rP4KrB+fdKkYH/v6Tgua1T4cn+mr5oAno0/Ds6p6aINwe3po7Bxnxq38jExLJui099TcNt6Mwtfn5QN7a21+hfBS9WOL6iPvQnx9qA95ebqsC6g4VZwvjax/vGzF1/ehTmC3mmvs67Oyr4d5/CmXit/n81tYR1zr/L2wxcvaZ3xFPxDiNNqaWX8/9Oxl0rNPB92b/XkoMzw50sr65RyvvUhfiD8vtX9U8VPF3DG/HqGxugD8mShoO94P6kd8BPqp6veKmR5rZ9XvFV8Vdhr3r/Jr5lfI+fw7K9K8M4Dmzxc0j+v3ilUc3LxT/zTRz/BDchYQRtH3iv9P4GHI94pRRqy3e+srm8bTD5T9pfYxlIzmfVyFG8ch+zO8+FJFa6itovS7orjMIlo32sOlVflJm1lxfyCu84IGfAd1bqz/KliLv/5SL1x+B3nJfjar+7UCHtsy+WU2SZm98vW0Fqj1sgHPPL3F3s3h/mPSW1TcRINoK7JXdkI51n8N8OKHLxXjY5sE9UJv7vH4UT54o1Xpud6ZlqntlZ0O7nGwV/Dc5/yahLKb1V5BXXgnlSnZpWyS01Sm/HY4XxpZ/3ipOu93AtyHad43RT173+RVswDneru3vvKleOuD0s88PzjOffapKNwob3ndja0jsAxTNqqHG2mtkoOiaE2tIyCtG+1y3B6tMc71a2b9Yxl5xm3BesqeZP3+bbCOfYB0hCbRoPqd2zKV9fPlk9oa9wcA9xOOz8/mrtpz4zNDOcaA+5nnCuc0cR1ul9V/J+j0vw8yPr9wrUE/R35NtnvpW+s8X9jSNfp9K+OdinG1sTdu+1ZNhz8Tor3eXFe6K/r3eV/Ak/cKN64B3j7LKMcb8oD5qdYwz6ceun56ftNG1t9v3vo5Ot+25ifSGMJPrF+Vn0U5YPnF9hzqUtwPKI9R5/tAIh/1LsdHbbSxHfsZl7vvf9jxUfO6o/zF5gvjGJG1zt8LW7x4fUe/p4rLUD6FnnWAnn3U8V+rMab27pVM4zwRpC/Ef41zeFj8nBf0ML8+QeNYxRyeFXBYP6ma8/4Jx3+t9FjEy/RYO4v816zzbPphL3dpYP/1WcEHpIv1fs9GCaW5GUDzLkFz4jF2mfta8USNN/QLKtumKK+mUQC/yN5BXxfCYP/1pn0CPHyi4MyBZqZlxHq7t76yNT09wIt36aFRtIf9956dm19FtkEoraGxXZ695+FGWjfavfWXK9IaI09e6X2Ngl/Dw8+8NYTjUZGXHAOLz1AHUWc3cH7KvaAPHL/cC5fjHbHPpgvgnQJ4i5d1+/ILfeEh9dQYZx1Fnb3jzSVv/0ad96H2x9g2viBkrtId2SYq0h2NN54exn2wAn3wGfR+qI5n9IybXRAzt3rQ+MD88uJRR5kr7dmhSu+ouv6oNVzl4/E5k1vJlR7lePP8SGVratX13Mtv5Fx+5XNR8mzc/E7e/J0vaVNVfvKeDPKT41FDYk6V3FZ7vyh3vf5CXSB0f3fC2ecpivGoGo/6ObB+vOxyMb6QfRy1tmx1f7eOR71+1fGoYfu7qHsX+fqQHrW/y/O+aH/3ZTTvY/n6/qjToVV8fe+HefxVA+qBN4qv72tAL699ff30ML++hcbxsHx93wL9NCpf37/Yhr6+76p9fX08r+rre13t66t9fVB2o/n6fg70gTdW8PVdKID3MwDvHYG+vnfcQL6+X4rs63vHAL6+X4E+eH/t69u8al9ff3tT+fo497z29W3N1zdDsGpf33j7+t6fyNf3WrL5m4Jue9/GTKivz+p/CNaPySvF+NjXh2OUY6Q9P6CXk6Zk9Aw8q6qHNgi3p4cqWJ6vL4afkWnJBJ32nprbxptR+PpwPvLcrnomr/ftauRli+oj70J8fcpmUn5AliVqHcT50sj6x8tWfH1fTvMe5xr7+qzspVe6789cKX6f9UCcqziemF8pfFOp8tL3ddofIy99RtDTEPSF+PpwHA2Ln3OCHubXnTSOVe7xaQHH7i8IvJ6P8QLhHWVe+j1AQ4q89GZFmpsBNJ8UNA8rL/2CwxM13mwc4By54NTnfQ2Gz+Nq0Lz0c8DDFHnpnt5yQdRHPni5sSHnfHm+jvmKtFb1SyJ9IX5JLy89tj4Y4pecFXgaBb+Gh595awj7+pQNg22yZ8pnhO/z3t8zQR942pVeuOxLwj47VwDvQYD3vCu6ffmFdlFIvUF9Vd5cUvlCPAZ3ZFrnYF+n1X+OkLnKnmTdcZeAjbzx9DDugxdAH7x0QB3P8/UNx56ofo5iWR+H5PTiGGebH+t7vr5Rnos44/BH6R1V1x+1hreyYvnQyPr7wdtrGrfx5vmmytbUqus5+5GQnxwnOSNgheY/jtIX7c3fuZI2VeWn8Ujx0/P1efswLLeLfH0vJVtJ9RfqAp7Nb+/mcJcdXx/bDYP6+r4S1o9vH9DXN01lym+ictWL4hyyLI4e2iDcnh4a+9wFxq3OXWBaMkGnvTduvj6cjzy3vbU2v0J4qfqR9+GQdyG+PpSrF6hM+aeVjxDt829P5OvbM90L1+hG2xPPiFlv99Yv22tg/nu56Gp+Kz+/h3sanrHufa4irUqvQf2D5Q3SV3Q2bxGtIb4cj1ZPZ1C0YjuKfCBFtG60h0vrtKDVsy2UvxbpV2M9E+/wPuiMqK/GLq97/zesewfv76Vf+danBexh+WuVHVjV//0mx/+t9BW17ioZa/WG5SNRuvpW8SCsZ7Wv/yp9hcfCBSpb6/y9sMWL11EcC8pPqvxGuAaz3+IdzlhQcmDO4d2EoEfxrkm8Sx3jrGKN5x3eoe7Ws49Jz94ZkXcqhlfFnQw6vtW+7FZhLUaEtRQR1rKAZWMN80AijrWVEFoR/wzRGpmexQbhM3qYP8w77xuNWMa6nvqG06rA0xJlJmdjwlJ785z3g/OcYarvHluZ+kat8Q/1mIc67+V6xfvIPlC5d0qH6zuf5/4uzD91fMQh+y6ePWplOD4NRuK5tMDjAOW2yuNqZv3jE8fEFD37sCO3VayJmi/Kt4TffC2TQ6tpeLcaKocM/7DkkJrTyg9g/LmYhp4Vo+eSoEf1877//W9P1t9nSJ/BmoT319vXf5Uc8mIRWUZV/f6Vp39g+0ymebJD6Zls8yj/q/LPKvgGI6aeo/gdKqN33N99B9uhZHR+z7EDVv8QyOhpsifxfbNplK3JsR2bfheAPXt/b5t3iTajTZsRLIN9TtDEeA8C3v0V8Tayfr4r3xX7xHYKmnO439tBqNY2zn+zshcC/XfcX/w+23Wjtk2Mtqq2ydFOG9Uap+anksXKruP4EqRPzRG7N37yuahrnb8Xtnh5/FwU9DC/ztJYXQb+KDnI+3JLAu+yg3eJ8KoYN7UPofzWDWrnjoL6RXlKF4AGjnFT8VxIV8iZ1acr0nw6gOZlQXPiMXaZ+1rxhPHjOMA5suTUZ3lUpCM0BI/UWOV1yurfDzzkGLcFQTPKiPV2b321b4N7pFVjsdhGwfaE5IjiOOR9huWKtMbIEQ2llefTSkVay76l7Nl3qxVp3WgPl9YFQavKiWUfF4/nTLzDcV1W/5NBb3gh6VH8DvY758ta3U8R8Lz4N5V/wDbCnHgP4bNcyS9vP471ZHwX9WRlOxTJsiIduijW8EXApy9z8KXwc7B8CbVdrf5FUR/nFu+h4pi/GADLy9NUdu1FBzfShe8ybqYTv7v+JK52twz9RPk1CWWpYxFQBk21e3njyZv8CuGl6scW1UfeVbX/2ecaYv/j+MX50sj6x0vVeY/5hu8jf2NI/vnvwTx+xf3F77MtjDYpxlWyLExhQ1hfFZ0xZLQ1s/6+7ckRpmdtxyZTsQ/4zMtV45hLpI/3+/F+WHuXip8XBD3Mr2+icbwA/JkoaDveqz3TBQfvPOEd5IwhpgfXTVW/yF/xGscmOyf4gHRVPWMohOZmAM3f4dhkicaY+z1M5ZPksYRzZN6pf47oZ/g8rpBHaqwWnTH0fY5NNidoRhmx3u6tHzsunnUtbA/H6HkxuvnFNtlCRVrLYi4vEK1K9/Nwe/NpqSKtZbngrKd6Z06W0brRLsft0Vpm6zKtytZtEh7mmZqDWVa8rrFN9lOgU/we2WRsd7H/Fsus7psEvBAdRcWvKX14lHkhXh6+GsdV8/Cx/zkvBMfNOYc/CyPkj5eXoHQyb+6odRZlJMcZq3MDPNwoU708j1GOtx79t93bprI1oep6ZDziPC0l41VcM/LY46fROAp+Io0h/FQ2Qyg/i86wzS/eX1ZnLnp5xRgrPyHqFOWyvxv0od+nvErcL+WxMO2067RoF8p+b8w0RBtVDP9ZaO+LaL+yKJ6Z1zxlL3DujtX/Y1jD/ub+YnxenDmf06NyIgc9p8cblzf7OT3Gm/qcHp2D4/k+OOcH51PIeovzpZH1j5eq8x5zdy7v6oWr7LeqZ8QiHVVz4EJ85R5uz35brEhrzDNiy2gNsd88WstkBNPq2W9ltG60h0urio9VMh7PPGGYHLfFYz0T73hxJFlWPHbZ59R64Prvk/7lB3rpV3Frw4rrUfEgXlzPkuATttee3dZpY4y4HhWXMSveaxT8Gh5+5sXIcixejLh/FQ/5rPb1X7W/x2Nhu8Yxn3TGQtU45tOCHsU71FWY1hS8uyh4t+rwDvc6Lwre2bPzEXl3TtDjxYBXHd+zoj1bhXUpIqzLEWFdEbBsrN0PzyOOteDcHcM/Q7RGpmczZv5+oof5w7x7QNDaEmWs6z0g8Dwg8LREmcnZmLCUfXCF3sN5zrY/jm3O3bkM7/FahHoMxoU/64HuO7iOo42udDj2Qb8NdJXnkK6CugHLXxUf4sVvWBmOT4OReC4t8DhAuY04jbZm1j8+cUxM0bP/w5HbODe8+dLK+vlq9ULk0ANpeBecu2P4hyWH1JxWcTPGn6ekoWczd+epgh7Vz5i7g32G9BksL3cH5RDH4KAcYhmF8UCrVIZrJvtWl0vax7k7SnYoPZNtHrW/p/b/FHyDEVPPUfwOldFfQDLa2qFkdH7P++9W/6tARn8RyWgVT+DFJ7Mv+6UA+0sf6G3zedFmtGkzgsXx8EgD430F4P3yingbWT/fle+KfWJF5+TsJV+4soO4T94C9P/TB4rfZ7tu1LYJ74eH2iZf56xxan4qWazsOo5FR/rUHMF9L5Znw+LnJUEP8+tbaaxeAf4oOcj7FZcF3isO3suEV8WJqbhdxMt9Ye3cUVD/ItFg9b8DaOA4sRXBB6SL/aKK5vmKNM8H0Pw9gubEY+wy97XiCePHcYBz5LJTn31JRTpCQ/BIjVVep6z+64GHHCd2UdCMMmK93VtfxTl7MeaXRX0V+6xk9OWsHDeOQ95nuFKRVs+GRvx7BX33V6SV59P9FWlVevb9Dq3Yjgcq0rrRHi6tFwWtzax47CCui4IGfAd1Paz/M6A3vIX0KH4H+51zDq3uzwt47OPOL87dQd8+2wjL4j2Ez3Ilv7z9ONaT8V3Uk5XtUCTLinRo9INg/SeAT787ZD8Hy5dQ29XqP0XUx7nFe6g45p8SAGvewa3s2qc4uJEufJdxM532nopFQD9Rfk1CWepYBJRBU+1e3njyJr9CeKn6sUX1kXdV7X/2uYbY/zh+cb40sv7xUnXeY4wD+zBVjgjGPYTkEDTgGfO/7Ixmw69iaUO+YaFi9zzcHq0x4t6Vj2AXlSFMPoNf7XWbToz++hR2l/kQivJk5oFvWB/v84t9Eh907FjFcyUbQ2JlkT7uv/xab/fWV/n78059xR8Vy8Dt/x+OfajyYrFdJwim1f8owFzvwFTji8dQ6ngHxSMv3iF0DH08YryD579T+ZnDyo9TvPPO9gzl3cRTinmnZOqcwzuVc618so2CX8PDz3gPczudKTkorBUBK7HPMniPm8+FSxQb454Lt+Lw7qKgVeliHFetfFsXBZ6WKOM97hiwlEzycr85ZxzHNu9xe/sn6LPH/ZMjT+m+U7Q+4bsb7W451v+xp3ZhHuvA9NankLMZVOynshkNxnb3/5915HZV/7/y34bIoUTnLwbvcRv+Yckhz/eNfE3sp97c41Y+VtXPuMdd5MfG/Q271tvXfz3dSMkhllEqj9XzbbF8KWof73Er+pSeifVQv1ffUUEYCr7BGHZMbJGMfgbJaBWHhPuuvHdg9S+DjN4gGY184HxXdf7djWy/Ps+RwzeD/foPoP2x7NdPB5g3g/36j5wxVNuvPu+u1vZrNFi1/VrbrzFhjZv92o5kv94ButHX1Pbrk1dV+/Wba/u1tl8FPbX92vvuzWa/viGS/fqvn9KF+aMEU53ZgfvavF+Oe8F4ZsfbOhu0Sr5fKKDrEKwdP/mU4vfZrla26rDOy1d5yuos5ap5yj/rrAHqnAJ1roRaAzh3TZ3jh2OIzw5N9J0bl5/Lgh7m19tpHK8Cf5RPg7+/tSLwrjp4VwivsvG9c+5UX+AZtKo+50VY/V8BGt5ecA498gHpCjnbYa4izXMBNL9T0Jx4jF3mvlY8Yfw4DlQ8sKrP/jqGz+fEI4/UWGU5bvV/E3jIMcxLgmaUEevt3voqZ8qLtSs755D1dHVGs4db2TfcH6G0lp0nHhJH6eFGWjfavfUvVaS1LDZ8lWhF+uzdWYGnUfBrePiZt4ZMQR3m5QLhxGf4nSNlx/M5le8HPeW/PKUXblGMcX5/vgDenwC8jzxFty+/MI44pJ4a46yjqG/oeHNJfT+Rx+COTOscHJtt9T8kZK46C471+GkBG3nj6WHcB38JfWD6XlUdzzsrFPW//JqEsnhriT5rsMcXC3hD+pjlQNm3Pfi8L6xv41LxZ3GE/Jl3+KP0jqrrj1rDVa46+wbV2VvqW3/jNt567Id2b5vK1tSq67nxSPGTzz9X9rWSZ4qfRuO4zV/vbL78qspPjoNHfk5RGcpm7gf1fTIvpwblrtdfobnJGCP/BsffW3TmXJHvoshHcAR8BKtPLcaXwr/Men6oz9Dql31bhs8PVTk7HizvmzpleiXjVnol05IJOu290clKnRvTcw5Yu5c3nn2QXyG8VP2oclUuUVmo35X3ukL8rjh+cb40sv7xUnXe4zcu2o6vrmge/zDM4wccPZBzQG5EX98zOu2vfX1hvr7n0jgelq/vudBPo/L1vQBo2C6+vhcKmmtfXzVf34uAh7Wvr5jW2td3/W/1a3j42Tj4+l4K+sAXP7UX7iC+vi8FeK98qm5ffqFdFFJPjXHWUVAnwG+wF82lFL6+rxQyt0X0Yjtagl7UHV/51OL2F/n6XgV98MMD6nhGT+3rq319WL/29YWvqbWvb/v4+lA2cz+gbA719f1wIl/fM4bg6/sJWD/+be3r64FV+/qevGpfH5ShvvZvE/n6OM/Z4tJDz8E5L+howDPmv8pTwTXd+x4XywXMYeH8OwVzOuvvtxR+MOMv+qMQJ387BmUf9ivH4v+241dU/YDPvPwfqzcr3msU/BoefsZ41Hm6SuYP+3s0Nu9C89twnUE7mW2k9zh9FON7NIp3O4l3o84vHTQ38E8i8m6noCdm3Hed39avP0QcazddfhvbYeOa34Zyx8tv20llg+a37YL3MHfiE6QP2fqKNgm+u9HulmP9r3xaF2azc+/lqNT5bf35bbd0+Fbnt9X5bUhPyvw25S+o89uulw87v61IRp94WvcdbIeS0fl9UX7b00FGnyYZje/z3pGVPaXzjs0F1Ksj+iUvevZTWttz6WKonCo66wHpnhFlk1ug9fLlx69du/r46uLqY8tLjy5e4TXbaOVn7Dso83mwzEtjQy4tK/8Y2hj5NQllc1Q2BWVGYz5WDxH9ac4pWVoO4T/ib4n6vK9Z9fwRxMO6byis/VnvuOW5zbJJ+bO8/Fd7N5c7b99x/b5KTNzLQW4942nF77PvY9T2u9FW1X5/tqMHqjVM6SvK94G8YvrUOmL3xk9c84fFzyVBD/PrU2l9VLFNal/d6i8LvCsO3mXCq+Le1H4q4uW+sHbuKKi/SDRY/U8DGjjubV7wAeliH7Siea4izXMBNP9DQXPiMXaZ+1rxhPHjOMA5suzU57WS4XPcF/JIjVXW5az+o8BDjntbFDSjjFhv99ZXcQen4RnrD2Xfgmc7HtvD+4cKtxf3s1KR1tAYkr2CvqIYxSJaN9rDpVXtjakYa/at8hjJxDscu2T1vxTWYluXi95R3/fmtf2fCHi855Ff/O2bon39lxfYSvml/FmstygZjTaYsktD9vURLvrYsP4/BV5815B9aKn39TmWreq+vmfPlO3rM+56X797Vd3XN16G7OuH+pZi7Ot/F817ZfuEzvs5gMv+8ZOdstB9/TOCjgY8Y/6rc4bOQB3Dr/buOZ9D4T4Jz3htPVuR1nOiPtJwhmg9CWX8nR5sI8cgIEzOfz8n8JkuifZsCnvFxgnaDedFG5tZvwzH8cl7KT/u2H+K5/iM7b8zgp6GoE/5gdbbvfXR/6pwc33FH5QJZwva/0bHrsJ3JkS7ThBMq/8zAJPPB1ZjdlrAHtYYOid4VHUM/aIzhtQ8V/4/NYY4Rg7LOH7i7Ah4p/qyKu+ecHinZOoZh3c7BT2z4r1Gwa/h4We8Pz4XEVbMuI4Y+TcGa0HASpzjGhw/YfhniNbI9GzuWypfzYLDO2UPKn2L/b7K5lUx9Co+geMnYsBSMol1RJznHD+BY5vjJ1R+V9ne3HtI71Trkxc/YfVf9vQuzD8i28/Tqby4TvXtQ2UXGoztni/+AUduV80XPyfoCZFDifyXwfEThn9YckjNaaWPJs5r3oyfUD431c8YP1GU94z58Hatt6//erqRkkNFeSk4T738SpYvRe3j+AlFn9IzsR7q9yh7lO2h4BsMjpm3MvVrMPkZz0vEESqjs6d338F2hMZPWP0dIKMnCGas/dHn0P6osgWYri8DuqafXvy+F9vPa8B2je1vddofI7b/nKCnIegL2TtNHYev+Kn2PPu+S0DjePMbn5n2afDeqYr/X3TwLhBe7xtAWaZ5y32BfnpVv/DMLKCB907PCz4gXeznUzSfqUjzmQCaTwiaE4+xy9zXiieMH8eBOn9D1Wd/HcNfpPrqWxwIg+W41T8LPOS90wuCZpQR6+3e+mp/Sek/zEOsr2JglIzmc2cUbmXfcH+E0urtdyJ+b6/Jw420brR76y9XpDU0d3uvoI/joxFPo+DX8PAzbw3hM0OQlxzriM9Qlik7forqPwP0gac+vRdu0bkg+f3pAnhrAO+5T9ftyy/chw2pp8Y46yioE+B5j0VzyYutM34VxavweSpW/2Ehc1tEL7ajJehdANzPfXpx+3mf3MqeD33wZQPqeEaP2r9E/S+/JqEs3lqizxzo8cUC3pA+Zjng+cVQ5rREfe/MkLkR8uecwx+ld1Rdf9Qa3sqK5UMj6+8HXsvyC22eJ+u0u++Pcrz12A/t3jaVralV13Pe90Z+niRYyr5W8syLmx63+evlXORXVX4ajxQ/+cwQlM3cDyibWW6jvwLXtC8r8CMgraExBps+hfw/kufqjAHGWeS7KPIRfAWsH//CwZfCv1wUN5plYTKrLN7QO2dsOQDWWQd3mV7JuJVeybRkgk57b3SyUscWeecBlcVDhvBS9aM6D4jPsgr1u/JeV4jfFccvzpdG1j9eqs57/BbYe2ifB9t0qnM/RWXvgnn83U8vfp/9T6n34m2Mhu7Fo1zp0W/o2escf17Vvfhdgp6GoI/9t3g/rNgixc/zgh7m14/SWFUxO2cEHKtfFrPDeOcIr/LnqXUS8XJfWDt3FNQvspH+b8efd0bwAelif56i+WRFmk8G0PxGx5+XaIxd5r5WPGH8OA5wjsw59XlPieGH6DYIo2hf5s2OP0/FuKGMWG/31ld7BCjbi+YL1lf2vJLRc1k5bhyH7M/w/OSKVs+2QfzK91Lkqy2iledTWRx+VTuAacV2LFSkdaM9XFpVbEEzKx47iOucoAHfsfHFc+Q3QG94F/kE+R0VP8N6yG8KeGxb5RfnbRwH2OyLOSXeQ/gsV/Kr6l6rvZvD/dyOwajik1mWoT6m1qSTUI71fw/49JGnF+PjuMpTUObJEG8esHxR4xR5XtWX1iTcKg/Fg3XSwV2298C41d4D05IJOjG250lc7W6Z8WYUdhfKoKl2L288eZNlYbxU/ajiAdl+Qp3+JJWhXGM/opJRyl7DMxU/QvP+pGhH6Lw/CXCfSfMe55rJLp7HL17rvv/XTy9+3+SbZ9Ntd5vsf0a0yU4JehqCvu1sk+1c623XsGwywztKm+yWtS4NKWyyXRVp3hVAc2utn+baJqtmkx1a6/IwhU3m6S3jZpN5tMa0ycr2AjfavfVj64MhecmzAk+j4Nfw8DNvDZmCOsxLzrfBZ0Vnc3AcltWfX7v+m8uWs2u9cAexp+YA3pU13b78QrsopJ4a46yjKJ3Om0vqfGweg0Xf7+Lcd6t/ce36r4qxQJuRdceTAjbypopv/Slr3fdfTO+H6nhGz+jsCb1Hi302BXhD+pjlgJIz6hwq76wGxR/8zt6w+XPK4Y/SO6quP2oN9/KVGll/P/Ball9eTMAox5sXs1K2plZdz739v2mCdUrAKjrv/8k67e77o4xZ8ebv+ZI2VeWn8Ujxk2MsUDZzP6j9Es9HiHLX669Qm9/effIch04Sj8lsZQcwziJfH8e0W/3PXevie+VaMT4+wwDXFi+/mvVWT89XeqUns8p82Oxv8/ztCpbnP4/hZ2RaMkGnvTduvr6Y8WiKl6ofOf4ReadipDg2Q8UoKT8gz3scp6iv2XxpZP3jpeq8x3yqP6B5H6IHfnit+/7XrhW/7+nRwz5Hwvgaeo4E9gOuH+wL+edr139TnSPREPSF+PpS56cpfs4Jephf37nW26554I+yh4p066I8LsZ7gfAqX5/SDxAv9wXOS1Wfcwis/veudWlgX99ZwQekK+R7SDMVaZ4JoPn71/ppTjzGLnNfK54wfhwHOEe8/T7eX2D4RXv6qPcgDPb1Wf0fXuvy8ImCPLpmpmXEeru3vtJN1f4B8xDrK70oJLbW04vzi30d8xVpDY0VD9Gx5kto3Wj31l+sSGuM3K9ZgadR8Gt4+Jm3hrCvD3nJOef4TH3nF9/nsznetnb9N5ctv7DWC5fjrdX3pBjeWwHeO9d0+/IL7aKQemqMs46COgH7+sr8x0Xjf0fm7yVwDuuvrl3/LfP1efYk+hmNN54exn3w62vd9z9M71f1lSp7AvW//JqEslH6XqrmC4XuT3hnV4ybL+WMwx+ld1Rdf9QaruLP2de3lfyfUY63Hvuh3dumsjU1lm85v+ezCVQsgpJnip9G47jNX8+3nF9V+cn2ufo+jZLN3A8qlq1s/8rkrtdfg8T1fQ/Z/DOCbsZZ5OvjeCCr/9G1Lr7dDxbjs7Z75/Eofx77+pTMtTYovdKTWanj+mYc3OMQ1zccWbm94vpUDJzy9XFcn8oPVL4+1NdsvjSy/vFSdd7PANyXDuDre96D3ff3P1j8/o2ST3V7p411PlVY7N5xGqvDit07Dv00qti900DDdsmnOidormP3qsXuLQEP63yqYlrrfKosKM7wRsyneujB67+5fDIdougd7PdJKrO6Dwt4fI5FfnE+FdoaoflUz6M1LZbd9e6OAzdlPtU/AD59wYPF+Op8qt76dT5V95pq9/LmZsmn+gKa97Hyqd5E8x7nmvW1lZ2GMo6DuhfKOFfqPihLYR8YD1FPR5xGWzPrlxk9/mR69rIOz5W9dS+8NyGeeXHuyCumz2CdBljr7d76aj/+Xqe+4g+O3dMF7f9qaD/bMfjOhGjXCYJp9dsAk7/lguOLxxDCHtYYulfwqOoYerUzhrCPVb97Y8jqqXnL/o403/r2eaf6sirvXuPwTsWWnnJ4t0vQEzOfJeZ+uYob3iqscxFhnRewEsfdBH/LxfDPZP1rbUR6Nr+hELpHxvGi+K7av5mEeyxDPCqWVOVtPKsdH5aSSbyfrHywrDvl18MEU527a/xDveehznu5HvPjD3bfKVqf8N2Ndrcc6z/zGV2YP9GB6a1PSv85Q2Woi7Btg+PTYAwrTjLVOf4/58ht5X9Q86WV9fPV6oXIoQtpeBf8LRfDPyw5pOa00keNP/Np6Nn8louyy1Q/78u633IpOo/eYHnfclG6kZJDLKNQD76PytS51yxfitpnMm2vQ5/SM7Ee6vcoe5TtoeAbjNmsn+ZGwa/B5Gc8LxFHqIz+Dw9238F2KBmd37OP2+r/fw92Yf5HghnLLt5FdrGyBZiuNVg7/vODxe+zXa1sVZunvG+w1vl7YYuX8cvGP64BiNNoa2b986Unr42evddZA+6D9ybEM28NQF4xfWoM2f2wcjkUP1XcJvPrz2gcq/2o+wQcXleL1nLGe57wKhtf5YggXu4LPBdZ1S863/iDQAPvVd4n+IB08d6KovlURZpPBdD8EUFz4jF2mfta8YTx4zjAOXLeqc/+OoZflKuAchxhsBy3+n8DPHyiIOekmWkZsd7ura/2qJX+wzzE+irnSslo3g9RuL1zFuYq0hoaV6lsipA8CaR1o91bf74irTHyJGYFnkbBr+HhZ94awrkHyMv7CCc+Qx+SsuOnqP5e0AdmntEL9z56B/tssgDeLMA7/AzdvvzC/cKQemqMs46COgHuWxbNJfSDFY3/ou9nFeV73dZpS9m3XFiPV7lkyBtPD+M+uAv6YI3eD9XxvG+5oP6XX5NQFm8tSR9bP+i5D/nl5R6MMlb+Xoc/Su+ouv6oNVztGbJvcCux8qMcb965GGVratX13Mtl51wOZV8reTZu5+B48/dcSZuq8tN4pPjJuQcom4vOElFyG/0VuKaZ3PX6C/0AbPOfFO1A/4Ty93LOcpnvoshH8CxYPz77GcX4UviXWc8P9Rla/bKYuZOE24uZU7BOO7jL9ErGrfRKpiUTdNp7o5OVOgYG10ee2559kF8hvFT92KL6/397V/Mi2VXFX3V11XRPf39MIoJuJjMm4qK+P8DFkO42Eb+zyEYXefXxFkpAwUSjBN4iexcKQsRFdoouwoAiioqKKIoMEtRkECQQ8A8QXEhAp2bqpH/16989773prqoRchmo6rrn3XPuueeee87v3vsGdVcUd+W9rjy4K9ovzpdSdNZeis7769Du92neo0+ysa5Q3cswj0ePh5+3tdqwgatQNw/8yfqIOBDyNNlWhE5QdxX67fMQezOep+6AqHtEu6QT1hXLx/gtfjd9Ml5+Y/p37ZzF0+c1IQ/r68uBNaosdMR9RPsMnUdhvteJr8LzPGxcjYX1M3T3IHTO86siT+PxRT2gXIznKZnXCsq8lkPmF4XMc7axHo+10gnzRztQ58UU/WWSn9vn82ioI2WrjOcZ/UugQ8bzHhEyo484Tmfp1fke3P8LzRekRz1wfID9uR5l81brCo9HXlnV/ofaA1Rx4aMFZT1JFyur2h9YicLjgbweETKou41sd9+Ctfhlwtn4Gd4bxTqj/bZoz9auS6fNnznPr876Yxveepl3jxLvTL48rVDvKWQfgHGM8uX8XkSjfwV08ZPHw/wsxtih57Pmnpfn8LxUOAfqnG1XYTLqvp+XR3ltefdgPPxC8Ua5+KwenwNEOe05la+YbpaRr6DfqKSzulHjqPZ/PV2qcVT5A+OMGAvzmTTlu/LcsVZnM3C+lKKz9lJ03uN7EZ+neZ8nX3n/0enzv3DyFfNvVqdyB4uLUF/ziL1N5xgDI0+TTa0vuC5yrPdbJ5e5Cs+VxW9sa5eFPCUhX55cZt7ntJU+rwt5WF+3yI7VnvxV0Q7HHKH7Gcz3A8RX5TIq7kG+PBaY7yv6aySD0b/m5DJXhR5QLs5lvJg2r8yrOWR+3cll5mRjPR5rpRPmj3aAc8SLARg/4fZD8THGPdgG5zJG/w8nl7kmZEYfcZzO0qvcxHvPiorRPWwY+8O5nJcXTQrnMo8WlNVby5G/h2N7vL359MGCsmbFZO/s2wv5QmdkQrKepNm8PVmz9l9YVuwHn9tW715VfQlhQWZfvBf+L8gNLL7g59mn27zFOqP9t2gvT4yCMYHFSSoexvhlUlbTWZluTH+vnavovTkvHlZ2XDQexvE3O1Tx8FVHP48uUT+XHf2omMybO2qdRR/J+xS4frD/VLzRp3p7wcu0t5n4N53tU9aaUHQ9Mh2ps1bs4xX2gTr29GkyLkOfKGMefaqcIa8+Ob9UZ7ZYn6UoH1bJ+DjThPDx90798UQ3t+nsFZ6fYFtYc/oVwsvM93s2cz94WZvyZoyl+Tw1rl8qX+AzekZ/DfLsDx+F+fH5MLXeKvyXsbTQ3RGce1GUz2/OGy/zcOYHAS9bjL/+/8LLEMddpTpcUxkvU3vt3nqL86UUnbWXovN+Fdrdo3m/A3RmBxWqexHm8eNH4ecRYy1N+2h188Bw9qbtIZaCPE22FaLH79hf++1J8O+Mie3Ac2XxG9vTupCnJOTLg4ntQ92i9Lkv5GF9PUW2egj6KYu+8xw9EHwPHb4HxFdhYji+Src8FtbPECa2RzIY/dMgA2NiO0IPKBfn8ErmzYIyb+aQ+bNC5jnbWI/HWumE+aMd4Bw5cOh3SH5u/5DoUUfKVhkTM/oB6JAxsT0hM/qI43SWfh/qjN7byzsQ9KgH46989EGUzRvtkGPmw4KyXhH0OAb7JCvKd6WgrDyfrhSU9SFBf8WRFfvxUEFZT9LFyronZF2JwraDvPaEDPiM2RfPkechbniRMDF+BsedMTGjfUG0x3tPk8JnEbahbRszq9sSz2H77FeiqHj8Zc9O2n2idO+7jQv6a56bGI+pNWkT6pH+JdDTd47C/NhPbEEd24/yIVaHMRf7V2WnqHO264cFPc4tzn3Q5h/O0damw/s9gv5hhzfKhc8yb5bTnlN5l/22jLwLfVAlndWN52+iKJ8u1TjuEj3qzurQd21SHfqhK1SH82mH6tBOzX5xvpSis/ZSdN5vQrtXnXnP+wNWt3F8+vwrzjzmPYAtIYPFd+gL55FDmJ4xlkeeJttKdNavoI9l3/89JydDf+L5mF2hO9QVy5cnJ5t3jqv0uSvkYX3dJDveB/2URd95/t5vLnjTycm8NVSNBc5LL4erEP2PnZxsKzqrB5SLY0gl83pBmddzyPwzJyebk431eKxD+fou9dHsAOfInkO/RfJz+6EcDuMebINzMqP/tZOTKawFfcRxOku/C3V5YgeVuyssSvnovSibN9oh52T7BWXNyh93SVaUL0/+iLKepLP0hwVlvYj8cUvwKQU+jQ//5q0hFaBhXW4RT/wN94MUpsFx/W2I6/9yNNsuY7c4ZuVAe69De28d6f5NCuZFeeiUjXOMgjEB6iE0l7bht5D9VyMdc4RwsDeFz1X7eNYPtY+3B7zfOgr3P5Sr/RPGYIPeAZw3xvPOeWD8NymrUHdxa4neJ8YxqwDfPGPMfsDDU9Dn7Ap67x0K20vUz6ajHxV3FF1/1BqucqoytbUt2sI1yTuXsEx7m8kf0tk+Za2pRddz05HSJ7+TQuWQyp8pfZqMD9r83c3oU1F9cl6P+qxQHfpmHgf0zey3FUaIftcbr/vJ+f82/a7uAXHekHXGInSXYR8wgseOw/w2SJbLQmZvT1hhfdvUB+WjvTMWWXEo421eHKra8vBzFYceOLxRLnyWebOc9tyDdsZiZv87ndVN1t5FHl2qcVTY2wHVbUDdOtUp7JpxfBULoJ1ifv4Yzft10Y+8834d2r05/T7Pce327mFEd2Wdtm++g8sq1CN9fdp/9AX2uXoOOZNuXE+acRK349GoNYz3qf0IdLcxB/5xt9kbNlrD7qDdjJudhfPvNQa1JGnFtaQ+ro26tYX3P2mNu41+3BwlybDR7y+a/7CXNDrNYb/b7zbi5hL6Xx83+8OkXr/DfTTothbNv9Pq1Hu9uDfsDJN+azhYNP9xf9RtDnvdQWM87La69UXzT9rtZq9TT1qNXqM1GowWzb/eGA3jQb3VGrZGjUFzuHD9t8dxpxfXB8lg1O0MFz7/2smg1m00Ot1xkgzuTIZF86+NWvV+bzy882/cbjYWbn+jXqtVi0ft4R0DvDMWnYWP/6DV7w76w3ZtVOvX+80s/pP47EMUi9haHcoHGNMz+mcgH/jB9LvFK1XgXwp8RlE+/LMKNBwPXhKyY1xykt77tP0NvAt+Y/pZO1epJyYP502Ym6+RPtYCtJPy8XSW9rJD+wmi3XBoP0W0mw7tp6e0pjfElm9MP2vnKvHYbKUCMtn4Tsb8WbLTbZC3LJ5lOzX6H4KdfpHyVnzebFC9Z6NKdFUhC46x2V2F6J+b8lf7RionqMBvbPvqfgbm4WvUH+wD25TNo68tUL4yyXdJyKdyWeM551y2pXJZ1EElzd9fpZ8NQY/rA78nA/PVS45+FvT+EamfiqOfS6K/Re0HbaRM+kHdVakO1x6e87z+TcpH0lMa9tVG/w3wK98NrKmlSPsH3lcyeUP3w1gGo/8mzNfbtJdfJRluTP+una/01VywwvdKUfdWh3a8QnVqr9PqEHfBtZUL4xKoi4mePgexCtNZUWO6QjyyxrQCbTE9tsd29QqMKZ/PYLu6Mf27dr7SUXGbFavj9zVjneoX2wnOWWUnRcfUdFFkTC1OndigwqBL9N0wPBVzTAqv80b/qrOOevtnk1J0P9LkUbg57+/bGP7IkS/rnEVRbJ3XeYWtm3xmK6+Bb/3p8Wn7KEtV9Jf3380u/wzt/fx4lsZs8BbQ/JJozGf9CWh+RTTmu/4INL8JyK5yhNCduN9N25j33SzOHdkWUCY7f6J0H0Vn5w7b0MfSe5+8/4fPTfR3+zhMt/MA0XEd+4NJeSK996l0h7oJtbXntLUXaKsUnR23KAqPXd7+co71d7D5tynH4r07rEPfyzmW8r3qvBfr+s2CvvcizoJ4vtdry+Od5VfZ7yu/urxzKDo/QB1U0vz9VfrJ2lf1zuGjvbN+9peon4s8x6T06Z11QN3xGR5cE3g+qzM83hlSdW55R7TP8/o/Ii5WGOE2tP92AENCWStCVoVNYbvPgiwXhaeWT07bf4bs4kHDU41+DXgoejvjbs+EMNJJ+eSUNgsX3CCfrs6zeLig0ceg7+3p9zy4IOYzeXBBzJN5zTL6gyl/tWYZzUqgTb5HoHAlD2dRZ5A2RB+98zweb7Rd9gVbBWVV81ed11fnWtmvmK2/z9H9RcvHmKw6X+bx9vCGnYKyeucUkb+K4+zZJeKz3WWfy2SMEddWD59dzDlLrR8Pn62K/nr2o/Bc9IcbpB9l6w+a/VQd/Xj9VfpRvhB14OH73v5HdYn6uUh8fy1DP95dCD7DW4K6ovg+xyRGfwzxwVMnus1SpNfkovg+y2D0T8LatCB8P2ZsFovC8EtUh2suY8G4FjK+j+vLefD9/+bEgnlMFb7vjanC9zE2DOH7T8OYvovv3ytZ+H7eMbW8CfF9Zav2Hc9A5MH3jX7sxIxGsxJok+N1FTPi2sF+U8V5OHf4jL06r8wx8Bec/uwUlC8rruQYWMWVEfGpir5wPG92+BXw2186mW2PMXbMPz+TztYZ7XM0R+f1XgOFv2OcxPMJdfPCSTE6zoW/Djq7Sbmw2stVc4tzYdS1shueW0af5sjHVgJt5rlT790TuYicyOON/ovXk72Css4bmz7PfRr2QUXvdSMmwXo6LCjrRd3rvvt8elq3oDs1Mg5HHVTS/P1V+sl6vxfH4fhuHQ9HP1yifrz3mitcxbMfNS+9O0B592GWaT9bjn6y/FbR+8DefUsPB9haon48+1F4qWc/Kr7DHGmf9KPWFJXnhv4PV+SDa+NHA/2oRhr3Db0r6lWRv6i9BXwH+M0AZo+y5t2HwXZtL+DCz9U36r1ap9Gut0bjetJqLvpcfyMedOPGIO6P+s16r71w/v1uMoxH/VHSbSZxEi/8XlurHXeHcbde77fq41a9vfB7Ze3OYHhHiNq4PvmzkcX/nTMS6Wk9+rJJuTT9295zxfSIFyD97yE2/wP4qbu0gt+E7g2HrhT4vNuG+G01nf1tPT1LX07P0hvvy+lZGa1uA+rQz07K5vRv1Be2ZXJUiP6vkL9Myho8Y8/vCv5rxH9GbvEb+nluqyx+wz3MW+S3sO8XuLbVTbYqtY+/sWxvAIZy4X6t1+v0G4NaqzsaJqPF+9VW0o07SbfWboxa48Yo06/9D79gg5/1fQoA",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "7": {
      "source": "use crate::cmp::Eq;\nuse crate::collections::bounded_vec::BoundedVec;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// We use load factor alpha_max = 0.75.\n// Upon exceeding it, assert will fail in order to inform the user\n// about performance degradation, so that he can adjust the capacity.\nglobal MAX_LOAD_FACTOR_NUMERATOR: u32 = 3;\nglobal MAX_LOAD_FACTOR_DEN0MINATOR: u32 = 4;\n\n/// `HashMap<Key, Value, MaxLen, Hasher>` is used to efficiently store and look up key-value pairs.\n///\n/// `HashMap` is a bounded type which can store anywhere from zero to `MaxLen` total elements.\n/// Note that due to hash collisions, the actual maximum number of elements stored by any particular\n/// hashmap is likely lower than `MaxLen`. This is true even with cryptographic hash functions since\n/// every hash value will be performed modulo `MaxLen`.\n///\n/// Example:\n///\n/// ```noir\n/// // Create a mapping from Fields to u32s with a maximum length of 12\n/// // using a poseidon2 hasher\n/// use std::hash::poseidon2::Poseidon2Hasher;\n/// let mut map: HashMap<Field, u32, 12, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n///\n/// map.insert(1, 2);\n/// map.insert(3, 4);\n///\n/// let two = map.get(1).unwrap();\n/// ```\npub struct HashMap<K, V, let N: u32, B> {\n    _table: [Slot<K, V>; N],\n\n    /// Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the HashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, let N: u32, B> HashMap<K, V, N, B> {\n    /// Creates a hashmap with an existing `BuildHasher`. This can be used to ensure multiple\n    /// hashmaps are created with the same hasher instance.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::with_hasher(my_hasher);\n    /// assert(hashmap.is_empty());\n    /// ```\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = [Slot::default(); N];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    /// Clears the hashmap, removing all key-value pairs from it.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(!map.is_empty());\n    /// map.clear();\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = [Slot::default(); N];\n        self._len = 0;\n    }\n\n    /// Returns `true` if the hashmap contains the given key. Unlike `get`, this will not also return\n    /// the value associated with the key.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// if map.contains_key(7) {\n    ///     let value = map.get(7);\n    ///     assert(value.is_some());\n    /// } else {\n    ///     println(\"No value for key 7!\");\n    /// }\n    /// ```\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        self.get(key).is_some()\n    }\n\n    /// Returns `true` if the length of the hash map is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// assert(map.is_empty());\n    ///\n    /// map.insert(1, 2);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(1);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    /// Returns a vector of each key-value pair present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let entries = map.entries();\n    ///\n    /// // The length of a hashmap may not be compile-time known, so we\n    /// // need to loop over its capacity instead\n    /// for i in 0..map.capacity() {\n    ///     if i < entries.len() {\n    ///         let (key, value) = entries.get(i);\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:entries\n    pub fn entries(self) -> BoundedVec<(K, V), N> {\n        // docs:end:entries\n        let mut entries = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries.push(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    /// Returns a vector of each key present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let keys = map.keys();\n    ///\n    /// for i in 0..keys.max_len() {\n    ///     if i < keys.len() {\n    ///         let key = keys.get_unchecked(i);\n    ///         let value = map.get(key).unwrap_unchecked();\n    ///         println(f\"{key} -> {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:keys\n    pub fn keys(self) -> BoundedVec<K, N> {\n        // docs:end:keys\n        let mut keys = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys.push(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    /// Returns a vector of each value present in the hashmap.\n    ///\n    /// The length of the returned vector is always equal to the length of the hashmap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let values = map.values();\n    ///\n    /// for i in 0..values.max_len() {\n    ///     if i < values.len() {\n    ///         let value = values.get_unchecked(i);\n    ///         println(f\"Found value {value}\");\n    ///     }\n    /// }\n    /// ```\n    // docs:start:values\n    pub fn values(self) -> BoundedVec<V, N> {\n        // docs:end:values\n        let mut values = BoundedVec::new();\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values.push(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    /// Iterates through each key-value pair of the HashMap, setting each key-value pair to the\n    /// result returned from the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If this is not desired, use `iter_values_mut` if only values need to be mutated,\n    /// or `entries` if neither keys nor values need to be mutated.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Add 1 to each key in the map, and double the value associated with that key.\n    /// map.iter_mut(|k, v| (k + 1, v * 2));\n    /// ```\n    // docs:start:iter_mut\n    pub fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = f(entry.0, entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, mutating each key to the result returned from\n    /// the given function.\n    ///\n    /// Note that since keys can be mutated, the HashMap needs to be rebuilt as it is iterated\n    /// through. If only iteration is desired and the keys are not intended to be mutated,\n    /// prefer using `entries` instead.\n    ///\n    /// The iteration order is left unspecified. As a result, if two keys are mutated to become\n    /// equal, which of the two values that will be present for the key in the resulting map is also unspecified.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Double each key, leaving the value associated with that key untouched\n    /// map.iter_keys_mut(|k| k * 2);\n    /// ```\n    // docs:start:iter_keys_mut\n    pub fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = HashMap::with_hasher(self._build_hasher);\n\n        for i in 0..N {\n            if i < self._len {\n                let entry = entries.get_unchecked(i);\n                let (key, value) = (f(entry.0), entry.1);\n                new_map.insert(key, value);\n            }\n        }\n\n        self._table = new_map._table;\n    }\n\n    /// Iterates through the HashMap, applying the given function to each value and mutating the\n    /// value to equal the result. This function is more efficient than `iter_mut` and `iter_keys_mut`\n    /// because the keys are untouched and the underlying hashmap thus does not need to be reordered.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // Halve each value\n    /// map.iter_values_mut(|v| v / 2);\n    /// ```\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..N {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    /// Retains only the key-value pairs for which the given function returns true.\n    /// Any key-value pairs for which the function returns false will be removed from the map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// map.retain(|k, v| (k != 0) & (v != 0));\n    /// ```\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..N {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    /// Returns the current length of this hash map.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// // This is equivalent to checking map.is_empty()\n    /// assert(map.len() == 0);\n    ///\n    /// map.insert(1, 2);\n    /// map.insert(3, 4);\n    /// map.insert(5, 6);\n    /// assert(map.len() == 3);\n    ///\n    /// // 3 was already present as a key in the hash map, so the length is unchanged\n    /// map.insert(3, 7);\n    /// assert(map.len() == 3);\n    ///\n    /// map.remove(1);\n    /// assert(map.len() == 2);\n    /// ```\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    /// Returns the maximum capacity of this hashmap. This is always equal to the capacity\n    /// specified in the hashmap's type.\n    ///\n    /// Unlike hashmaps in general purpose programming languages, hashmaps in Noir have a\n    /// static capacity that does not increase as the map grows larger. Thus, this capacity\n    /// is also the maximum possible element count that can be inserted into the hashmap.\n    /// Due to hash collisions (modulo the hashmap length), it is likely the actual maximum\n    /// element count will be lower than the full capacity.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(empty_map.len() == 0);\n    /// assert(empty_map.capacity() == 42);\n    /// ```\n    // docs:start:capacity\n    pub fn capacity(_self: Self) -> u32 {\n        // docs:end:capacity\n        N\n    }\n\n    /// Retrieves a value from the hashmap, returning `Option::none()` if it was not found.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    ///     let x = map.get(12);\n    ///\n    ///     if x.is_some() {\n    ///         assert(x.unwrap() == 42);\n    ///     }\n    /// }\n    /// ```\n    // docs:start:get\n    pub fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, value) = slot.key_value_unchecked();\n                    if current_key == key {\n                        result = Option::some(value);\n                        should_break = true;\n                    }\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Inserts a new key-value pair into the map. If the key was already in the map, its\n    /// previous value will be overridden with the newly provided one.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(map.len() == 1);\n    /// ```\n    // docs:start:insert\n    pub fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.assert_load_factor();\n\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n                let mut insert = false;\n\n                // Either marked as deleted or has unset key-value.\n                if slot.is_available() {\n                    insert = true;\n                    self._len += 1;\n                } else {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        insert = true;\n                    }\n                }\n\n                if insert {\n                    slot.set(key, value);\n                    self._table[index] = slot;\n                    should_break = true;\n                }\n            }\n        }\n    }\n\n    /// Removes the given key-value pair from the map. If the key was not already present\n    /// in the map, this does nothing.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// map.insert(12, 42);\n    /// assert(!map.is_empty());\n    ///\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    ///\n    /// // If a key was not present in the map, remove does nothing\n    /// map.remove(12);\n    /// assert(map.is_empty());\n    /// ```\n    // docs:start:remove\n    pub fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n        let mut should_break = false;\n\n        for attempt in 0..N {\n            if !should_break {\n                let index = self.quadratic_probe(hash, attempt as u32);\n                let mut slot = self._table[index];\n\n                // Not marked as deleted and has key-value.\n                if slot.is_valid() {\n                    let (current_key, _) = slot.key_value_unchecked();\n                    if current_key == key {\n                        slot.mark_deleted();\n                        self._table[index] = slot;\n                        self._len -= 1;\n                        should_break = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // Apply HashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(_self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % N\n    }\n\n    // Amount of elements in the table in relation to available slots exceeds alpha_max.\n    // To avoid a comparatively more expensive division operation\n    // we conduct cross-multiplication instead.\n    // n / m >= MAX_LOAD_FACTOR_NUMERATOR / MAX_LOAD_FACTOR_DEN0MINATOR\n    // n * MAX_LOAD_FACTOR_DEN0MINATOR >= m * MAX_LOAD_FACTOR_NUMERATOR\n    fn assert_load_factor(self) {\n        let lhs = self._len * MAX_LOAD_FACTOR_DEN0MINATOR;\n        let rhs = self._table.len() * MAX_LOAD_FACTOR_NUMERATOR;\n        let exceeded = lhs >= rhs;\n        assert(!exceeded, \"Load factor is exceeded, consider increasing the capacity.\");\n    }\n}\n\n// Equality class on HashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, let N: u32, B, H> Eq for HashMap<K, V, N, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    /// Checks if two HashMaps are equal.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    ///\n    /// map1.insert(1, 2);\n    /// map1.insert(3, 4);\n    ///\n    /// map2.insert(3, 4);\n    /// map2.insert(1, 2);\n    ///\n    /// assert(map1 == map2);\n    /// ```\n    fn eq(self, other: HashMap<K, V, N, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    let other_value = other.get(key);\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, let N: u32, B, H> Default for HashMap<K, V, N, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    /// Constructs an empty HashMap.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    /// assert(hashmap.is_empty());\n    /// ```\n    fn default() -> Self {\n        // docs:end:default\n        let _build_hasher = B::default();\n        let map: HashMap<K, V, N, B> = HashMap::with_hasher(_build_hasher);\n        map\n    }\n}\n",
      "path": "std/collections/map.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "50": {
      "source": "mod utils;\n\nuse std::collections::map::HashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\nuse utils::cut;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_CAP: u32 = 8;\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> HashMap<K, V, HASHMAP_CAP, BuildHasherDefault<Poseidon2Hasher>> HashMap::default();\n\nfn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nfn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"HashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"HashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nfn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"HashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nfn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"HashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nfn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    for entry in input {\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"HashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nfn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New HashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"HashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nfn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"HashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"HashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nfn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nfn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = cut(hashmap.keys()).sort_via(K_CMP);\n    let values: [V; 3] = cut(hashmap.values()).sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = cut(hashmap.entries()).sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib hashmap documentation\nfn doc_tests() {\n    // docs:start:default_example\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: HashMap<u8, u32, 10, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: HashMap<Field, Field, 42, BuildHasherDefault<Poseidon2Hasher>> =\n        HashMap::default();\n    assert(empty_map.len() == 0);\n    assert(empty_map.capacity() == 42);\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n    let mut map2: HashMap<Field, u64, 4, BuildHasherDefault<Poseidon2Hasher>> = HashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    let x = map.get(12);\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries.get(i);\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for i in 0..keys.max_len() {\n        if i < keys.len() {\n            let key = keys.get_unchecked(i);\n            let value = map.get(key).unwrap_unchecked();\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for i in 0..values.max_len() {\n        if i < values.len() {\n            let value = values.get_unchecked(i);\n            println(f\"Found value {value}\");\n        }\n    }\n    // docs:end:values_example\n}\n\nfn iter_examples(mut map: HashMap<Field, Field, 5, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    },
    "51": {
      "source": "// Compile-time: cuts the M first elements from the BoundedVec<T, N>.\npub(crate) fn cut<T, let N: u32, let M: u32>(input: BoundedVec<T, N>) -> [T; M] {\n    assert(M < N, \"M should be less than N.\");\n\n    let mut new = BoundedVec::new();\n    for i in 0..M {\n        new.push(input.get(i));\n    }\n    new.storage()\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
