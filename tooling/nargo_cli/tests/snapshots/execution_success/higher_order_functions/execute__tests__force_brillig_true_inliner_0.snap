---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "w",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "field"
      },
      "visibility": "public"
    },
    "error_types": {
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/8VWbUrDQBCdpFnTKAXRA/jfPyY2/UAQisaCIN4hWHqOHF2DM/ZlOltauosDZbs7u2/evpmdNqFfS/jTWwZr2mRtxWN5nlUBscrE4HnwEtaBTx4LHlPwjwJevDC4hMJflvWioP07B+Q/LRgzpj6CGQG/zBnnrdvh67v0NqHh48AzY/bL92s409sasOV8TN1+8j6PrFt1S36tpOZeO/qzQHGngt2Ex26vOH/3nhwFjDUT7CxOfmZSr472TXwXsCa5El8OvDDH2kZqjnfqtSwhpt6n+WCtCrd4OahqzdcZPFLlk713ip+DMyH70w3gkooV+Y3XE3VnMnKG9dV0Q59VX8fWkKydWkNYq86DKXPUNFU4iXGu7w/Sf7Ju6F/xenmGLZa7Py8jxne0rw/Gd2r/A88vgb+M2Rk8t4u22k7bbTtrN5v6q9V1SaCh7qMYXzjr31KpD/2eiILV86NgX4THrnR/eOaxjzVXOuQHdGi6oU/2PtFQnzHgxe43Yw9/meObE22tnp6DJisPZkr+d3wsps7FO+x5UXEP1WTT2XhrHv+z95PB1/cbavXGBDT58GCmBqY7EdPqp9gnvgEqDVjIeQ4AAA==",
  "debug_symbols": "pdTNjoMgEAfwd+HMQb7BV9k0DbW0ISFoqG6yaXz3HZy67R66B/biT8X540yid3IOp+V6jPky3kj/cSenElOK12MaBz/HMcPdO+nqgRnSM0qYRdwG7xCGcEQgElGIJj0HDGIRtyE6BFIEwBGBSEQhGjGIRSBFUiIBRYmSiEI0YhAo0JRo2MgAsGYBg1jEbRh4JQfUVrp1pWQfyHEuIdR5vEwI5jb5EvJM+rykRMmnT8v20G3yeXP2BVY7SkI+gxB4iSnUs5U+q7v3pUyyRzHTz3LVVK8b6p3YX95J2VJv3F5vW/bnQtpHABeKv0tQfyRwu7cAp6ohgamfGarGHvSzB/Euwf67B9vSwwGu/BDLr29/rUkl+lMKj8vLkoeX1flr2lf2f8dUxiGclxJq0ssPBI4fklNpDmvd7Rs=",
  "file_map": {
    "50": {
      "source": "fn main(w: Field) -> pub Field {\n    let f = if 3 * 7 > 200 as u32 { foo } else { bar };\n    assert(f()[1] == 2);\n    // Lambdas:\n    assert(twice(|x| x * 2, 5) == 20);\n    assert((|x, y| x + y + 1)(2, 3) == 6);\n    // nested lambdas\n    assert((|a, b| a + (|c| c + 2)(b))(0, 1) == 3);\n    // Closures:\n    let a = 42;\n    let g = || a;\n    assert(g() == 42);\n    // When you copy mutable variables,\n    // the capture of the copies shouldn't change:\n    let mut x = 2;\n    x = x + 1;\n    let z = x;\n    // Add extra mutations to ensure we can mutate x without the\n    // captured z changing.\n    x = x + 1;\n    assert((|y| y + z)(1) == 4);\n    // When you capture mutable variables,\n    // again, the captured variable doesn't change:\n    let closure_capturing_mutable = (|y| y + x);\n    assert(closure_capturing_mutable(1) == 5);\n    x += 1;\n    assert(closure_capturing_mutable(1) == 5);\n\n    regression_2154();\n\n    let ret = twice(add1, 3);\n\n    test_array_functions();\n    w + ret\n}\n/// Test the array functions in std::array\nfn test_array_functions() {\n    let two = 2; // giving this a name, to ensure that the Option functions work with closures\n    let myarray: [i32; 3] = [1, 2, 3];\n    assert(myarray.any(|n| n > 2));\n    assert(myarray.any(|n| n > two));\n\n    let evens: [i32; 3] = myarray.map(|n| n * two); // [2, 4, 6]\n    assert(evens.all(|n| n > 1));\n    assert(evens.all(|n| n >= two));\n\n    assert(evens.fold(0, |a, b| a + b) == 12);\n    assert(evens.fold(0, |a, b| a + b + two) == 18);\n    assert(evens.reduce(|a, b| a + b) == 12);\n    assert(evens.reduce(|a, b| a + b + two) == 16);\n    // TODO: is this a sort_via issue with the new backend,\n    // or something more general?\n    //\n    // currently it fails only with `--experimental-ssa` with\n    //  \"not yet implemented: Cast into signed\"\n    // but it worked with the original ssa backend\n    // (before dropping it)\n    //\n    // opened #2121 for it\n    // https://github.com/noir-lang/noir/issues/2121\n    // let descending = myarray.sort_via(|a, b| a >= b);\n    // assert(descending == [3, 2, 1]);\n    assert(evens.map(|n| n / 2) == myarray);\n    assert(evens.map(|n| n / two) == myarray);\n}\n\nfn foo() -> [u32; 2] {\n    [1, 3]\n}\n\nfn bar() -> [u32; 2] {\n    [3, 2]\n}\n\nfn add1(x: Field) -> Field {\n    x + 1\n}\n\nfn twice(f: fn(Field) -> Field, x: Field) -> Field {\n    f(f(x))\n}\n// Fixing an ICE, where rewriting the closures\n// during monomorphization didn't correspond\n// to an internal `if` type\n// found by @jfecher:\n// https://github.com/noir-lang/noir/pull/1959#issuecomment-1658992989\n// issue https://github.com/noir-lang/noir/issues/2154\nfn regression_2154() {\n    let x: u32 = 32;\n\n    let closure_if_else = if x > 2 { || x } else { || x + 2342 };\n\n    assert(closure_if_else() == 32);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
