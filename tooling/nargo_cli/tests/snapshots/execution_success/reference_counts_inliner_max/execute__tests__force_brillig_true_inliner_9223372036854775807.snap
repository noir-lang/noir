---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n\n        // Difference from min & 0 inliner settings: we fail to remove an inc_rc here\n        assert_eq(refcount_1, 2);\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
