---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8222435832483736686": {
        "error_kind": "string",
        "string": "There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before array_refcount call)"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "16406258251777617968": {
        "error_kind": "string",
        "string": "after refcount_1 we clone once in passing array to copy_mut, once to arra_refcount after, and once within copy_mut"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1, true);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call, true);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array, rc_before_call, true);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call, true);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call, true);\n    assert_refcount(*array2, rc_before_call + 1, true); // array should be copied from previous dereference\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1, true);\n    assert_refcount(*array2, rc_before_call2, true);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], mut expected: u32, expect_copy: bool) {\n    let count = array_refcount(array);\n\n    if expect_copy {\n        expected += 1;\n    }\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n\n    // This is currently copying the array due to the inc_rc in the array_refcount call above\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1 + 1); // array was just copied on the previous line\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n\n        // `5` here is higher than in other inliner settings. This is likely due to references getting optimized out,\n        // and mutations being optimized and removed so the original array ends up being aliased more.\n        assert_eq(refcount_1, 5, \"There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before array_refcount call)\");\n        assert_eq(refcount_2, refcount_1 + 3, \"after refcount_1 we clone once in passing array to copy_mut, once to arra_refcount after, and once within copy_mut\");\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
