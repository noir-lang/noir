---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdnfbho7EMfxd+E6F+uxx3/6KlVU0ZRWSIhENDnSUZR3Px57viQ9EihdbjKfAP7hNbbZXV43P3bfX3592x9/Pv7efPn6uvl+2h8O+1/fDo8P2+f947E/+rpZ7E/rf8PdpoVZZJY4S5pFZ8mzlFnqLG2UsCxeg1fxGr0mr72Z9Br666JV8Rq9Jq/qNXstXqvXNqssXj1PPE88TzxPPE88TzxPel6y2maNvZ1a7a/LVovX/rpqtc2aFq/Bq3iNXpNX9WqDZweeCqigOXQBAQiIIAEFJKsl2zFpBc2RFxCAgAgSUJAByZnkTHIhuViyfcJFQAQJKMiggAqaoy6A5EpytWT7tGoCCjIooILmGFN+gJwxte1jH5N7oII2IWOGDwQgIIIEFFhyNhRQQXOEBQQgIALLKYYCKrCcPsfE1sJEAAIiSEBBBgVUQHKUsSrEVkdohgQUZFBABT1Glg5bNBMByFheYstm1ORVvWavxWv12ma1JTNqby/BkICCHiFiKKA6bDVM9G6IjaWthokEFGRQQAXNYathIgCSbTWIjaWthgkFGRRQQXPYapgIQADJleRKsq0GsfGx1TBRQXPYapgIQEAECSgguXlytPUhzWBb72JIQEEGBVTQHLYaJgIQYMnBkICCDAqooDnGd8WAAGsuhgwKsObR0BxxAQEIiCABBRkUQLJt88ney7b5NB6JIAEFPSclQwEVNIdt8xMBCIggAQUkZ5IzyZnkQnIh2SZ2UkN02JYZ7SnbMmN/JNmUmAhAQAQ2Ytlg41MMFTTHmBIDAQiIwHKqQUEGBVTQHGNKDFhyMwiIIAEFGRRQHTZJ0mIIQEAECSjIoIAKmiORnEi2zTMFQwQJKMiggAoYXmV4leFVhndMJPt0xrQZjyjIoIAKmmNMm4EABERAciHZ9kObSMn2w4kKmsP2w4kABESQgAKSK8mVZNsGx5HaNphsStimN6EggwI45OaHrMsCLKcZBETQk3UxKC/OoIAKSA4khwAERJAAyWEEvr3dbTj3//Z82u3s1P/DxUC/RHjannbH582X48vhcLf5Z3t4GS/6/bQ9jvq8PfVne693xx+99sCf+8PO9Hb33nq53LRvIt647yLn5vrp9mnJ3r4v7RXtS6R9iWVF+7oUb1/DmvYlc/yl6Jr2lf7XJa3pfz73v13sf7nSPp3fP6cV7fv5u7fvp6yX2rfPzJ++g57by5/tw5UB6OfFSg/6qezFiHA5QhNjqKmuCcjnLuQrPbh6EPp+EDmviiiJkewnoReHcrlxKlztQhQGsn8Suuoool13eoTkNUdh1zbzKD58Fqs2hLhmQabzx9C/i9e0LwxA/85b0V7tdH1OZr24IUu8cUVLunFJi968pO0C5aYlfS3gU0v6+kF8aklfjbh5SWs4D4Nc/Ha92oXPLenrEbcu6X6fkXHotxrbmoR+i42Efi9rVcL5i7rfnlzVh2R3LmZCvyBZk6DpfBT64WzrbxIan0W/axjXJMR4TuiXuKsScj0n1DVHcfu66Pc8zyNZllVHURoLo9/LXDWr2/tItrQm4cO5Z14zCi3TgVbWvH8TdriWVr1/pf+txdv6/7/29/2/7cP+9MdPI2+WdNpvvx92/u/Pl+PDh2ef/33iGX5aeTo9Pux+vJx2lvT++0r/8zUWvYst3/d7I/2//p1Xl3v7LcSe6pfiMdlTdlX3VftdURW5f7OO/Qc=",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
