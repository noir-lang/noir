---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdndThs7FIbhe8kxB+N/u7dSoSqlaRUpCiiFLW0h7n37G6830C0los4J64HEHx6P7cxMXjc/dt9ffn3bH38+/t58+fq6+X7aHw77X98Ojw/b5/3jsf/1dbPoR+s/3d2muVH8KGGUOEoaJY9SRqmjtLW4ZbHqrHqrwWq02pv5Xl1/X1D1VoPVaDVZzVaL1Wq1jeoXq5bnLc9bnrc8b3ne8rzl+Z4XVduoobdLqv19WbW/r6pWq23UuFh1Vr3VYDVa1djpgGMGBVTQDGkBDngQQAQkJyXrWFIBFTRDXoADHgQQQQIkZ5IzyZnkomSd2eKABwFEkEAGBVTQDJXkSnJVss5SDSCCBDIooIJmaOSsM1une53bKwqooA34dYqvcMCDACLoyUVVwVkooIJmcAtwwIMAlKNALYSBCpTT55rXWhhwwIMAIkgggwIqIDkopwkBRJBABgVorS9CM2jVDDjg13XmtW7WGq0mq9lqsVqttlG1ZNba23snRJBAj/BeKKACdazPYq/V4HWkWg0DESSQQQEVNINWw4ADJGs1eA2LVsNAAhkUUEEzaDUMOOAByZXkSrJWg9ck0WoYqKAZ9Akw4IAHAUSQAMnNkoPWR1gE7b1OiCCBDAqooBm0HAYc8ED9iUIcJy7oc2IggwIqsLMctEAGHFDHvJBBAerY+p5mCAtwwIMAIkgggwJI1jYf9b+0zcf1LwFEkEDPiTp2TeOBCppB2/yAAx4EEEECJGeSM8mZ5EJyIVkTOyYhGLRlBr2kLVOI65RIggMeBKARy4LGpwgVNMM6JVY44EEAyqlCAhkUUEEzrNcPK5TcBA8CiCCBDAqoBk2SuAgOeBBABAlkUEAFzRBJjiRr84xOCCCCBDIooAKGNzG8ieFNDO86kXR21mmz/iWBDAqooBnWabPCAQ8CILmQrP1wnT/aDwcqYGppPxxwwIMAIkiA5EpyJVnb4Hqk2gajpkSjq9r0xl8yKKACO+S0LMAB5TQhgAh6clqEzJsLqIBkR7Ij2XkQQAQJrMlvb3cbLv6/PZ92O137f7gb6PcIT9vT7vi8+XJ8ORzuNv9sDy/rm34/bY9rfd6e+qu9s7vjj1574M/9YSe93b23Xi437ZuINe67yLl5+nT7uGRr35f2RPsSaF9CmWhfl2Ltq5tpXzLHX0qaaV/pf13iTP/zuf/tYv/Llfbx/P9znGjfr9+tfb9mvdS+fWb+9B303N7/2d5dGYB+YZzoQb+UvRjhLkekyBimWGcC8rkL+UoPrh5Eej+InKciSmQk+0XoxaFcbpwKV7sQPAPZz0SaOoqgG1CL8HnmKHRzM47iw7mY2hDCzIKM59PQP4tn2hcGoH/mTbRP7jyZ/cyGmnSPMdqnixu6rtdv2hF8unFL8PnmLcGXG7eEawGf2hKuH8SntoSrEZ/bEq5GfG5JX4+4dUn3B40cR3/W2GYS+iM2EvqzrKmE8wd1fz451YeoJxcjod+QzCSkeD6K9OFq628SGueiPzUMMwkhnBP6Le5UQq7nhDpzFLd/1PVnnueRLMvUUZTGwujPMqdmdXsfyRZnEj5ce+aZUWiZDrQy8/+bZ4dqcer/V/rfWrit//9rf99/2z7sT398N/KmpNN++/2ws19/vhwfPrz6/O8Tr/DdytPp8WH34+W0U9L7Fyz9x9dQ0l1o+b4/G+m/9c+sutzryxC91G/FQ9RLuqv7mvpT0eT9/Zs69h8=",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
