---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
