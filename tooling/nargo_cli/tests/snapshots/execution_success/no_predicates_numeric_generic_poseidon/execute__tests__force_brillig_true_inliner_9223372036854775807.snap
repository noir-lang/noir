---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dz4skSRWOyq6a7q6ZrMr+OT0/PC7szarp6ulRD/bizIDIwnrw4O6ppnf74EXw4DkFF1RYWBEWT4qKohdPHv0TBC8qLHhRwav/gIgdM/Gqvvzqq+is7YzuTpiAoaoiXr734sV7X7wXGdvbca/awfm/TvjeDZ9Z+PT9u67ajPYkfI4u18YN8hql0rHTAh2zFui41gIduy3QsdcCHW+1QMf1Fui40QIdN1ugY78FOt5ugY53WqBj3gIdBy3QcdgCHYsW6LjVAh23W6DjToM6et2szkml724LbLrXsE1Nx7Xwff/83133qs6cdeBkskDsE2+f2PrE0SdmPvHxiYXfuP3G6DceD+weOD0w+cD3geUd1zuGN/Ye8F6qABjxd8EDNsPvjCZw0pCRN0luk/yfjI7ONl21Naz/4aarLmqz/MePjX83jf6j9cDneVnl70iu9b1bzm35LjyDNO8BzXtEY/NJs96T1PZ6lLuqjdTcemlkH3ZIHtocx0x+36X0zVeHPyjP9GH7ZGSf9TT6jIz/RiL+Nt9NMV+0/zrN93Yafabmi33Qh33xThrZL+r6osnvk66pfPGOW1wbtI/5Ym405VyfTRrrlovzsLEejNn6er97DvPDMdQH8cF8tXCLvmJ6J46baeK4Gb+Om1l7HTcwljpucqdzDefm65wirz3PO6ev85Cbm4coH+axbrk4D+XDtr7ow7nTvmV0X4fv3wAafAbn0BFzSFl3nPvvaWL/PVx1DdZo7KI1SBzfp2nrvtHhjlvuQ+YP66WbtTWyJ9rIbLaB9DS2CWPdsiqnH353QQ7yMj16RP9O+D0Mn7fgGXu+EPJvkfyK3qIPbcS81kSf0fvzlK+G737/sH3sK+WcX5OYbfyfpuE/Nf7P0vA/9DbyMfZ9OBvC+HPNyRoZhiKm8/52yyWZ56Tu/mby+y7pfjvb326RPmwfxE+uF+zZQowhxuMYylkXcq6KV+4W599Z8mlyuI/loO/0SE7M5xLVYLV9zuRflc+p9Yv53IbQtRBj7CcbQs6GkHNVvHi9fTsJn6PV2pQ7cqET+xmeize4rkd1/czk94WNrupsQK0Z1+74bCHG2Df6Qo6qc9vEi89NUp+v8jubpvmnOutQ50ouAf9EZ0cTrvlxrf1+9iH0+3+zWsnpetjy3B7R/7oz5/mD0Hd95w3j2ph10997pMHQ8aTOvqfynFyMGa9B+I2+g/QbMEekx+/2PPZ9Ej4LwZMxMXeL88E+rOM+prmpHK6OHyHfwmm/Rh2VzVGOYdlQPG/Ppnwn6v1DnUchbvxsyZxw7TOisXGk/xhw4xeRefdoTNn3qt7lzc6aXDxmMrfor+iLjKG/DZ+e14+yqu0UbqicunDLbVenVsnT2K52rWLyr6pWyWva1Ww3ELoWYoxxaSDkDIScq+LF6+3bSfhcyZLnWME9udCJ/WwI/ddRq5j8vrBRCj8bkj7L1sxsVwhdCzHGvlEIOYWQ0yZe5qM58bZx9WlyuI/loJ51cLKJfGBAcvIG5SB+r5OcQYNyMF6strO9mWPbuXncFzR2En6PLtnMz7YCP9ybVSxlRI/ffetR31/Dp9qbVWwPI7ZbE/pclG996qoyP2u+9WZnzvPvoW8onh8QL9MZ4wXpN0me0f8jfKbOzbaBryNZ6p0+2vZfNNcM5sL5uW/Pyupcjb4Ptv136BsK2V0aQztynou+ktMYntlcTd24eJ9tWQ5sumVEj9/Rhtb3n/Cp4mzV9wIqlnLxXIdsd9POUROdzUXPUTNh18S52ySWK6h19tg8cItrhvoZL8QtO2tTOUCHxnDf5ncTXCvhGOLnbeKfRebnv3P9j76R0Rj6uL2fit2TmMVtWdX9JPSPLtcmPm4/yuZ6oG1865VVW3SFLdR5mNGrOhh52PmkWj9eW34XjDp3xJhfR2X3nGQYvdo/eH9B+gHsH2+E70oe7x+xc5J1oaeNIV7zfq9ymti6qJgdEg3KxngtavDKIrK3BH0RkY164bMsexmuqPjCPNe3Lo2dhP7R5dqRiq/KflpW563WEenr2FKtY0H0aDuFq7F6iN/FqRpG4ar5L8ZLDGMxBmP3PfGMmHPDpuOC8RxjsqAxfI5jGf2dYxlrIifoOXc3+nEwiu37mGOnzt23aQ64j6sa61lZnYPRfw0wdUKYivZkTEX7MKaiz/M6oN68DjturuOaW4w3noPRfyno7X3jVxD7viEG2XyuY483XV/qX1bnjX/0Zk3Qc8zsCfpdoDGbFUTP8YO/kReuX5/oZ/cOl9Bj3Y30z2GNfpNV9cO42yHdEQcZP9W7M4WD26Dzt4MeuVv0cax53ya8LGBeq8TXdyC+3kkQXwMaw/ia3QN1Vds2jU/sx4hBKNN0y9yiz2IM9Kjvm+A7XPNuw3Nroi92bmp0uXiuQ7bbTWO72jWvye+7pHvNOIZJ6jza7LOXRp9Zzbsv9FHrjDUvrhnqZ7xUzXvT9g20eZ19Q61R3X2Dc0m1byjMZlxGzN6mMcTsPo0hZhvGIWbH9qxM8FVnxpgT25mxwlyuWU0fhf+8PyD9dwH/P+osl8f4jxjP+L8t9LQxxFvOr9T6Y37F/qJiDn1iSLLRl/Zr8Ir56l1Bvx+RjXrhsyx7GS6ouDfbXEfNWtkPy6ptYnHsWx1bqnUsiB5tt2rc79IYxhNjAvqp+S/GS8ct+ouKQY57FZ8qt8uBpzpPeVpW6U3fzOk7VEzP7xoYkzhO1R3DDcGf78d8EuaFdRDr7Fy9ujz2Ph71GbrF9eXYXHZf7iXvcpFn2ngby3ir3K8r69vCt896phF7l7/qXlfnPfqyfZDvqg0iMtV8L/IV87OYr8R4dSKyL7I1y0a9ihqyMRc3W3Pc/T4o6G35305VnqrjLGfeIj1Pwu/RJZvNx3AW6zF1HpkRPX7H+VrfHwBnuB5b9R6Lqu+V7fheZ6qzNpvHjrDddsR2mHdVznqo748N2k6dhaq6obPk0+RwXwyf+A7QToNy0IZ8N2G3QTmq5jE5ew3KwRxrk+SoM3yPH3/qzPsxXtWdcd+elvNxpH+YzXn+mTAJMRB1xOcxz1N3mVjeX4KM6zwLv8i2fyPbxu7j+/asrM7V6P8HeP8p2RZlM56pPFfVe7s0ps7Mzc5YE6XAQasFEAdRJp/pYe2AdUeP+v4ZwcFVz/TUWW+dM727aWxX+0zP5F/VmZ6qA1Uea/Y5SKPP7EzvntDnojM9XDPUz3jF7rGoPFvtPVyf1n23wvdYBpH5+e98jwWxg8/10cdj91gQH3zrwth1nlXG7iD4xnm9wgDOl52br4M6E1P3WPAcwHJ19d8A4nuuD8N3tRa7Ts9z2X/jhXsO0mewX9/LlsvjPQVtwnvKttDTxhDDOQfAv11a55xQxTHGJp9RYgzfq8ErVmvfF/T3IrJRL3yWZS/Dmpt2TljZY8uqbdQ6In0dW6p1LIgebaewdkBjiLV3aQzjiXFYvcPBeInhrnrvoPLFAfDlfFFhUsw3Y++slG9uifldNpYxf3OCnvN5o38jTCZxLiDz+QOaA76vU3nCs7I6B6P/MmDqm4SpqpZX9mRMRUzgdUC9eR0sPnBfuBuZg9F/Puh90d0Wm8917PuIm4xBMXz2jWPmgaBHnGG8eABjW8RL5Ry4fny3Be+JKHrc25H+i7BGfLcFcZAxEnGQ37PUzTkPQOdTWhf0cayD3yK83Id5rRJfZxBfTxPE1x6NYXwZD8Mn3PNT1MHmg4hBKNN0y9yiz2IM9KjvbfAdroPV/o19XAfvC31y8VyHbHc/je1q18Emv++S7jXjGCbtC7uafR6k0WdWBz8U+qh1xjoY1wz1M15177Zc576BNq+zb6g1qrtv8N0WtW8ozGZcRsw+oDHEbH4vp+4nIGbH9qy6uSvembFzZIW5XLOaPgr/eX9A+m8B/n8vWy6P8R8xnvH/QOhpY4i3nF+p9Y/VOirm0Ce2STb60sMavGK++jlB/zAiG/XCZ1n2MlxQcW+2uY6atbIfllXbxOLYtzq2VOtYED3abtW4v09jGE+MCein5r8YLx236C+xs0KV22Et/BbUbb51yzldU+t6/GT+P98xnzLs4NaFcaT/YdATc3D7vMz/FPPseDo+O5yeTY+m778/OZ1yfemb+dDtBPKnx4dPTh9NTo9fHB1ODx9fKF/9HV+MU9/Ww2/8W8FIb/x6RP9jwOefUO3YE/I83S8jdJ0lny95iL5uWe1Tf0MY/7ay0c/+xk25qKON3YYxxBDf7oTfaC/kZXr0iP7nsIf5hn8P2Z4vhPwNkl/RW/QhhjGvNdFn9H59fkpxg3NvOld+KZP4Yx/rZr6TIq5Ojx6/OJ0cTUcfjP3PR1cd1+eij0+nx+PxFybjDybjo4vk/x97EQMq8XoAAA==",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
