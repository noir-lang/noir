---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
