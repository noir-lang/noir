---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "to_hash",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "array",
            "length": 10,
            "type": {
              "kind": "field"
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "enable",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "boolean"
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 3,
        "type": {
          "kind": "field"
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tdndTtxIEIbhe5ljDtxV1X+5lSiKCJlESAgQgZVWEfe+Xe56DbsSEeloT1IPYfobe/x5Zmx+nr6evzx9/3x9++3ux+nDx5+nLw/XNzfX3z/f3F1dPl7f3Y7//Xna/J9upw/p4tTzHGWOOkebo+8jbVvMFFNiakyLmWOWmDMtpbFefI7Hq0+LmWOWmDVmi9nnlC1miikxI08iTyJPIk8iTyJPIk9HnvlMMcf67HM8vvgcj28++5y2xUwxJabGtJg5pu//5qiggR7IG0hAgAIDI7j69GB/RXMFDfRA2UACAhSUueOlxmwx+5w1XqAaL1CVmBrTN8yPaM2ggAoa6IHmW+avf0tAgAKbh6DlmCVmHJrWYvY5+xYzxZSYvmG+qXuxd1TgG+aHe6/3gOz93pGAAAUGMiiggkiW5DnVIUCBgQwKqKAB38I+4GfARAICFBjIoIAKPLk4RrKMaomfCxMJCFBgIIMCWsBrLMnhy8Xhy9VhIIMCKmigB7zHEwkIILmQXEguJBeSC8mF5EpyJbmSXEmuJHvDxRwFVNBAD3jDJxIQQI43VrwkXtkJAQoMZFBABQ30CfX2SnEIUGAggwIqaKAH9vftHR5YHb68OQqowJd3Rw94aScSEKDAQAYFVEDgXpLk6LNjSkmUkiglUUqilEQpiVISpSRKSZSSKCVRSqKURCmJUhKtJFeSK8mV5EpyI7mRTEnU3wYnDGRQQAUNRP20k0NJlJIoJbFtAwkIUGAggwKiJEZJjJJYSkCAAgMZFFBBnx2zvSTNocBAlMQoiVESkwaiLaYbSECAAgME+me9bo4EBCgwkEEBFTTQA5lkf6vU5BCgwEAGBVTQQA/4WTBBciG5kOx9VnH4Y9QhQIGBDPzZzeHP5QXw9k4kIECBgQw8x4+yt3eigR7wN8aJBAR4snfD3xgnMiigggb6RPbOT3hgcygwkEEBFTTQA975iQRITiTvX3K7I4MCKmigB/avujvi5c0iQIGBOBmzd95GtfL+zXZHAgL8u1tyGMiggAoa6AE/LyYSEECykWwkG8lGspHs54WNQmY/Lyb8V6N12Wts5hCgwEAGBVTQQA9Q/ryXf4cABQYyKKCCBnqgkdxIbiQ3khvJjWQ/C/Y99bPA/FB65yfY5c4ud3a5s8veefPj7p2faMB3eVS9eOcnEojksikwkEEBFTQQL2bx8k8kQHLaA5+fL05cb35+fDif/XLz1QXouCy9v3w43z6ePtw+3dxcnP66vHnaH/Tj/vJ2n4+XD+O3o7bn269jjsBv1zdn1/PFy+rt7aXj8zsWjw/wY3l+9/rxiRfrx0fVwvqqrK9aF9a3rcb6llbW18L+15pX1je2v222sv3l2P7+5vbXX6y34/mLLawfl5axflxEvbW+v6c/4zvCsV7ev//v2f5frU+N9ap/1h9deX6zY/+tr6yvyvq2sv3Zv4zt63N+8/z1K9m3AopfiO8B5dULKO8PeFeD/Cj9XxXKiUOYZeUtaNxh6Mce1JUtGAntSGhtJUGOwzBuVOhSQn5JKGUloW5GQn31Zvo7CcfZMO4HLL2S0o5tGFf3Kwkq1GG8kHkpIemRICuvZLajkbbShnedk79YP240cxzS1vpKwrinSsK4q7mUcHwyjvvSS9tgfg9jJoyL3ZWEbMde5Fdfb34nodOFcZ946VioHgmal/Zi3HU5EtrSXpTjrBq3rJe2oXYqPe5Kr5wTqb+8Dt1WEl59VSsr7wy9sAG9rjx/F87KbkvP39j+3vXPtv8/6z+Nny6vrh/+9derZ096uL78cnOOH7893V69+u3j3/f8hr9+3T/cXZ2/Pj2cPenlT2Djn486Lsg066dxj2z8ND6y2/bJ/3Q1fpBxnSpW/MdxpfMxZ7nI2T49+4b9Aw==",
  "file_map": {
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "50": {
      "source": "use std::hash::poseidon2::Poseidon2;\n\nglobal NUM_HASHES: u32 = 2;\nglobal HASH_LENGTH: u32 = 10;\n\n#[no_predicates]\npub fn poseidon_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    Poseidon2::hash(inputs, inputs.len())\n}\n\nfn main(\n    to_hash: [[Field; HASH_LENGTH]; NUM_HASHES],\n    enable: [bool; NUM_HASHES],\n) -> pub [Field; NUM_HASHES + 1] {\n    let mut result = [0; NUM_HASHES + 1];\n    for i in 0..NUM_HASHES {\n        let enable = enable[i];\n        let to_hash = to_hash[i];\n        if enable {\n            result[i] = poseidon_hash(to_hash);\n        }\n    }\n\n    // We want to make sure that the function marked with `#[no_predicates]` with a numeric generic\n    // is monomorphized correctly.\n    let mut double_preimage = [0; 20];\n    for i in 0..HASH_LENGTH * 2 {\n        double_preimage[i] = to_hash[0][i % HASH_LENGTH];\n    }\n    result[NUM_HASHES] = poseidon_hash(double_preimage);\n\n    result\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
