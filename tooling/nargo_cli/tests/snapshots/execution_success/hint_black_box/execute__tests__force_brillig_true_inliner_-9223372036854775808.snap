---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pZjNTis5EIXfpddZtF1ll82rIIQChKtIUUC5MNII8e5Tp6tPh7nS3TgbzpfQ9al/XLY7X9PL4enz1+Px/Pr2e7q7/5qeLsfT6fjr8fT2vP84vp39269pxp+cpru0m3KOkAiNKBE1wiJaRJ/u8m6SOSJF5Ai3iIdGlIgaYREtoi+hc0SKcIt6SIRGlAi3FA+3VI8W0Zcoc0SKyBESoRFuMY8aYREtoi9R54gUkSMkQiPCUsNSw1LDUsNiYbGwWFgsLBYWC4uFxcJiYbGwtLC0sDS3NA+J0IgSUSMsokW4pe+mPkekiBwhERpRImqERbSIsKR5XhMjZgZgzCSAEJRQCJVghEZwb/LRktJMSIRMEIISCqESjNAINGeal1EugEwQghIKoRKM0Ah9BYz7AJqFZqFZaBaahWahWWgWmpVmpVlpRkckBSihECrBCI3QV0B/BMBcAJkgBCUUQiUYoRH6CuiZAJorzeicVAEwG6AQKsEIjdBXQB8FJEImCIFmo9loNpqNZqO50dxoRn+lBhCCEgqhEozQCH0F9FtCp6DjAjJBCG7OaCJ0XkAlGKERekBGCwYkAmZcTMfowQCYM6AQKsEIjdBXQA8GJALMAhCCEgqhEozQCDArFpaZkAgwF4AQlFAIlWCERugrLGtPBSRCJggBZgMUQiUYAeYG6CugBwMSAeYOEIISCqESjNAIfQX0oODBoQcDMkEIWDeX5bcQKsEIWD/xmNCDC6AHAxIhE4SgK6B3BI8JvRNQCDDjMaEvBPcZ7RDfKL8phEowQiP0FTCwBc8CAzugBQiGsRgA5gao/AYHd0Aj9BUwVpeDMVYDMkEIFGKsBni5ztijzIREwIYjAYSghEKoBCM0Ql9B6MFg02UjxIOFBwsPxhgLSASWK09j2fvAoxRijAUYoRH6CnjKuuy4CqESUKWARugrYKYNSIRMEIIS6MEsqgXAgxsPbjwYoyWgErZyngZGy+LpFGLyDMgEISgB5RhImCG1fn/vJu5wHz8uhwM2uD+2vL4Rft9fDueP6e78eTrtpn/2p8/loN/v+/OSH/uL/9cHxeH84unC1+PpAPreXavnv5cmTJ5LsW8EtvIyVF8H6jOWl6Xep8Ub63Wg3sfaWi/WR+qLsb7NN9aP3H+tvP9q9cb6kesvM+9fySPXr/1an26sH3n+pfD6Sx2q12u93VZvI/evdI6fmtJt9UPPr7RrvdxYPzJ+u7H/ex+5/l6v9SPPv5e01ZeR+XPGq1JMoHOyIcPWAo5DBn8jpiENPQV/392WAX+3G1pHEm+kYx4ySN8MJY2dQ7saxs6hXg02ZPAdBQ06jxnMNsPQnOCvWTwHx7FVed6WZR9dQ4Zsm2FoZc8/tgZ5aG7zF762GaQPGUrdDEPrg5flGw0i2530ff2QochmKGXIYNtVjO2z/CWV84NjHjJsS43j0DlcNzs+wQztljVfe/OP/e6Df9o/Hy//+9H7G67Lcf90OqwfXz/Pzz/++/HvO//DH83fL2/Ph5fPywGm6y/n/jZyL77bkZof8HOmf8y++c2W8NHfXu51Tjud5eEbJ/Mf",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
