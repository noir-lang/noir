---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+VbzW4jRRDusWfs2I43KxauSHCBU2THdpwVSKwEgYgT4sANiVlngxAnJCSQuFhwQELiCTjxKpx4AQ5IXHiGfYHdSbrsbz5/7ozt6XVW21LU4+6a+uuvqnpmOom7aYn/K1rq+4ZbbUbzyPeD3dqwRl6DmHomkfQsOTlx65vN/e4vOnR/Mdys0eAOya2T/9lg/LAj7KtR/1EHeEbgf2L80zj8B23P55N5mb8juU2iU/cYzQXQXBBN35WTAPKxOcSq3X/w/O/ILa9f99cd4hcDP6hT3f5/IPRvgG1F+3AeR7bx/wj4O1d/bJ/H0X/B/+M4/Cc9j7W3kzLWsjhYODX8t9xqs7k2jJndNncAeiGeuDXpN9pU8Hg3WfJlOtYH81Kb5BvP1MtkesN5RvRv+d783YJ76sT/a8DXkazIeTePbNtU4YXX7gDGGEtYl9EH3BSWzKZNsYRxxVg2noglpGcsGf2x783fiNHYWGoH7EtJr5cBB6g/tzpxgHhjHGybU97z/T5zCtuHdLFri6oHTaGrye+6qPlvyOtp+rB/GuS7ltD1vphL6Lol5LSEnFed15HbW64amB6Wq1JhB+rWcKs5HfNcRmOf+b7IKe8nZdsVDrOA71KhT+Qac6bytbU66nYb/PPBlnUb5a9by1DdNvovfW8+xToQO1+brCqxEGs/kZAu6D+UybFwIOxA/9rYzPexYqHKnqcTx3e5ye661WZzPaFz1TgxvTeNE1wblL9uX4P06/Y13/k+sk9lnJisKnESK34T0mWd/zhOOsIO9K+N/eD72DUj0rpNjH8vDv+R+aIrfIE2mXzOCzaveuPFcyar61ZxF2OPqmwLrXMX9OF6qHh1N+TVEXMx1rQTsBvl9wO6KjuSGn3yKvG6S3WzaPyu4BD02qWmfrFBTUU/c01VNQHpuaYa/R++jxxnsqaarCOh7wvaPw0Ys+g/zmfOLWtqV9iB/rWxP32vairnfh4L1VSj61fwXaR6OElIXhPs6Ak7TJ9+HH0WufzQrfoVfdAn3+H6JWt648VzJqvrosbPMGRbKLdinuKcoXgdbshrn2uKvu6TbX1Br2LL6JrzVV7WpzB3SHPZfNUnRaz/mJT9EykGZ1yPsPXdqi+4jt0DvdCf3FQdQ3u3rWO8bioPh+qY0f/l+8j+lnXMZKk6xs8+seprQrqg/9T+qiH8hDk7o7G/fV9HHcuEPuqsBGNVvcfY9RkrpF/R7DyCre0ecuBibS1WcW1R5iHYw7F9D2zKaOwf36u13bRG9IQ+ffCJNfNr8a77X1eWmYKeTboXMZIR/YNkyfM/PxaKyYR4V805Rv+/72OfW1I5x2SpuNkV/8p2tYa7ylF4iOzLicoXjmzkbz44x+c+nCvbyPY7oDGbijj7pUK9PHLaFyhfYTf0jdjon/o+8rdYiV3O3bExpfzIdUe9zw19w95Wv9B70btw1kph/kD4pirm8azVvjHf9oLuAuZNx6IZTmPGA8qMfM5zrOLGkf3se5xb992fm8Kb2VQVbz23uo94I1ny+JUwE+kb6OI5V51rwD0V15+2oFf1S8VVm+bUuYOqcji3Ws5oraE3fvyt9k3w/W/+Wj03sB9SoR/i43x+03OM4b24F128T50v6epa7+nZzZ7+Wtf50g+MZ5SfEf07ngE/s5s9j7bU82qaD69G+VU+yS8vx7Occ1nRLMb4zHDMelm0UJ7E54njZMkXcVP1ecLoR8mS59Bfh95V91z4+3AoxtU5EY691hr6Fulv9GeBWErF/ewv1K9qLGWg63EkjObT0dnsZDybPp6M8tHpVhiNvecM1fnCN+eEUfXMi/fauxCuVZ8CRi8CGDUdEaOhPZbCqPJB1fpg9Co+2hVkq31zKD4Uvjk+Pg/ER1PcH6o1uFYcH+grrDXnIP9F51C1Drw/fFnPPn4Fft31HEtD6HNb/bmsqf58A7H9dcX6wzy+BV/chb0s+nPXvazKIWovm24oh/PLtnvZ7wP5pcr/EqF+29RfxGHR2vMy3+sexjLge6030tNcB+bSeVlO1/+2uGZepkdG9D8Dxq9tgHvs/vtCfovkl/QWY4hB5tUUY0Zf+PQnfxPvKwx36nlbvVfFelz3/mg2OX08G0/ywZNh8fPktv1R3fKfi57O8ulw+HA8fDIeTm6T/wwrSIBIMT8AAA==",
  "debug_symbols": "pZjRTus6EEX/Jc99iD22x+ZXjhAqUI4qVQX1wJWuEP9+vbOzU+6ReHFf2Iu2s9QkM7HTz+n58Pjx++F4fnn9M939+pweL8fT6fj74fT6tH8/vp77q5/TjD8xTHdhN8XIMEZiZEZhOKMy2nQXd5PNjMCIjG6xHomRGYXhjMpoS6SZERjdknoYIzEyo1tyj24pPSqjLZFnRmBEhjESo1u8R2E4ozLaEmVmBEZkGCMxaCm0FFoKLYUWp8VpcVqcFqfFaXFanBanxWmptFRaarfUHsZIjMwoDGdURre03dRmRmBEhjESIzMKwxmVQUuY5zXRMTMAPRMAJkiCLCgCF1RB94beLSHMgiCIAhMkQRYUgQuqQOYo89LlBogCEyRBFhSBC6qgrYC+J8hsMpvMJrPJbDKbzCazyZxkTjInmTERIQGSIAuKwAVV0FbAfBBgzoAoMEESZEERuKAK2gqYGYLMRWZMTigAmB2QBUXggipoK2COCEEQBSaQ2WV2mV1ml9llrjJXmTFfoQJMkARZUAQuqIK2AuYtYFIwcYQoMEE3RwwRJo9QBC6ogkaIGEFCEOCOi9sxZpAAswGyoAhgToAqaCtgBglBEAUmSAJ5MF8xA1BVAFFggiTIgiJwAb6PA9oKy7qyAMwVEAUmSIIsKAIXVAHMDUvbLAiCKMC6hbOK+SJkQRFg/VqWyCpoK2C+CFjHIiAKTJAEWVAELqgCmHHhMF+EIIgCmHEtMF+ELCgCmHGZMF+EtgLmixAEUWCCvF5ujBVBDeBqJFcjVTVSVSNhrJYmwVgRkiALisBXwBQYegNTQGgEQ8+bA3CkFeB6peqVtgIamxAEUWAroI2tAYIgCrDtmAHdnAL2NvP6CjozLbudKDBB0oezoAhcsAnbCsuGZ9k3JUEWoDwBXFAFbQW0HyEIosAE8qC1UsauTB8u+nDRh9FRhCxQedHXQEfRIyE6ihAEUWAr4J6ZcClxz0zl62s3aWf68H45HLAx/bZV7RvYt/3lcH6f7s4fp9Nu+md/+lg+9Odtf17yfX/p7/bLcjg/9+zCl+PpAPraXavnn0v7zmAt7gv4Vp6H6stAfcSysNT3W96N9Wmgvl/btd68jdRnV32db6wfOf+p6PwnLzfWjxx/nnX+chw5/tSu9eHG+pHrn7OOP5eh+nSt99vqfeT85ab+KSHcVj90/XK91tuN9SP921zz39rI8bdyrR+5/i2HrT7/VI975I83sOQydIxjiu0kdmxDiusc923c0EIw41mNK8EcfMiwzXLHIUN/JJchDLVTf+De1rP+cDm0IAZdz45xyGBtM+Qw9h3q1TD2HcrV4EMGa9qW9Gf7MYP7Zhi6ufXnPH2HjmPbi3nbX/TuGjLEbTjD0BYlftvjxKGbdH8qrZvB2pAhb/eHOLTQ9bJ4o8FsO5P9MWLIkG0z5Dxk8O0oxjaM/QZz7eq/trz3/b/90/Hyv9+rv+C6HPePp8P678vH+enbu+//vukd/d79dnl9Ojx/XA4wXX/07s8hv8zLzmq5xy+R/d/YJyS2jH8D3m1pZ63cf+HL/Ac=",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
