---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pZbNbqswEEbfhTULe8Y/475KFVVpSiskRCKaXOmqyrt3Bs9As+jG3eQ7juHE9jiGr+5teL19vIzz+/mze3r+6l6XcZrGj5fpfDpex/PM3351Tj4odU/Qd5RrUI2yRnE1fA2ogTVCjVijWkq1lGop1eKd0/SaoImarELJqJk0c03P/UGS21GS9Umy1ASn6TXZnyVRM2iynySTZtZkX5EsNdFpek3QRM2gGasXk6b6kDRLzeA0vSZooqb6QtRMmllTxxd0fFHHF3V8kX3eCaBBMIgG7PReIBuQQVFIzoDFXiqTwAANgoGYpTopGWQDMigK2Rl4AzAQs1Q3B4NokAzEI5UnuVhKTHKNrLls3wry67KasoUrFAXZxhXk12XF1q0sy7Ju5hWCQTRIBtmADGRj80LBurNX8AZggAbBIBokg6zgxQMC3gAM0EA8KCCeIJAMsgEZFAX5b1TwBmKOAmgQDKJBMsgGZFAU5F8C8X7vOztUXq7LMMiZ8uOU4bPnclyG+do9zbdp6rt/x+m2XvR5Oc5rXo8L9/K6DvMbJwvfx2kQuvf73e73W7nARe/m1cZNEB8N/ncDTw/MANRkQG8zYPQtBpJ9XA0E1GIojsxQfPirAUqDgZfBDMgHYovBlbAZXGgy5H0MLjbNIubNkFtqgbDtSQRsGkOAzRCwqRapbLPI4NsMfjc0VTOT2wzUVE3K2zpQaTPEbUdRbKoF7bWgmJoM8gBTQ1stHgxNs8hlnwWkpjMq43ZGUdMZRXE7qynFPxtKkyHss8juwXDg1vE0Lg9vyndxLePxdRq0+X6bTz96r/8v1mNv2pflfBrebssgpv11mz+eIcQeUjr0HT+Bn7PryR3kdVe6EHtAkqaXJi835Hi4y8C+AQ==",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
