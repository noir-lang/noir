---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/91Zu48bRRiftXf31l7f2UkgPCPBf+D1210kkksuz7sk/AFr3xlqKsqlQKJBQqKhoKGiQkggRItET4tET4tEjwQ7l/ns337+xs5xO3fajDTa2ZnffO9vHrueel5u5NUzbZ89dX9dFQthb5pn93wlKZFW15WMXgVkrJUoo5atptz6vV4Bm/ol27Th2KZBBWwaVkDGnQrIGFVAxkYFZGxWQMa4AjK2KiDjrgMZXci5p8rdd0jGtmnrZyevV/J6Na/X8vpKXl/N6/W8vpbX1/P6Rl7fzOtbeX1bPT8rLgmg8vqwoDd0vWHqTUgv8noR1YuUXgR0kukg1kGinbAH80sTSq0c8a5p0IZbg/ESDx5Jg/Etk/6kOxpIB4YS5e83DM3ADf0F0Q/d0O/uGDr72Yo+6kJ86wzH5+BF5w5g7lgwdwFz14I5AMyBBXMPMPcsmPuAuW/BPADMAwvmIWAeWjCPAPPIgnkMmMcWzCFgDi2YI8AcWTBPAPPEgnkKmKcWzDPAPAOMLg3AK1V2Dg9GjnOgv6uKcS/ptuOG98Bj/JRa2RzHiH9TOV1vEo/xI3m4fWg/2CVMtpLHY2N+tq4HjQUwRv7Ve94+4HhskRzkGxd7Ux53U8dx17vEuOu/jHHHx/xsXY+zxh3GFo+7ugNb5HE3cxx300uMu/RljLs6G/OzdT3OGndok4CN0cdlXWgv1jSOgN77MB/jGPXzBP3cxvZw2GA6lH1ePuu6wH2H/vHBnvvMPm72nJV9XNhf2+eaRX5q67KTqWWpM3uijchmEeLZWAPG/KzIp2nefeCDtEiOgOEPzTvde0OYQ/M7Av+Q8S/ILfShjTitutBHeJ3XB6at7+x0B30vW9Er+w6qyy039HtE/7Yb+qcf53SOzcimyun+N6Z1FNd8KjQWAW+PjeE3ixobazKZcSyGMVz/eJF+GOJe8SHQ5TiuB+6bERuTztQYr36mCrrcNP3dc5TxZPVBjdaKQK3rjPwDhv/AvKOt6XmeH06LcZos+ukiHabHx4N5epXR16UGdpJiFu3tqdJitks+C0GWizmzJd3/e2ZzlL8bz2yh4CuyT+RGnoXH6KM8kWAfaR1B3+E6EgAtxEegI193miBHwPo+Ns+OQJPHbkPQB/twv/uI6SbdLV4kjpBuR5ArZHzCEvg4vvN0O2o9H4gX+Yf2g0/MU2N/ZPK5il+iz7/Fl0Q/4fcW1F/r+Sn022If7zx0juKx/SfQ/My02wLv0MJPbeFH+Bj41AX6KD/iPzdP7cd/TFuKDZov7dNoty+YHj7wle54t7KiXIT/DWh+adpkNzwDhxZ+CvjVBH7czqGA5/Ij/ivzRLt5Aj/Jd7dfQAb0Xc0iw9eCDJLvakw+fs/leczx22wUWeT7BuT717QlHy7vLWp93yhzzeO54oM+TUH/GsNjG/Wlvm9B35pXtKEUE9jH95e6II/Le35eppvssykeCf8d6B8Y/betF9+rop02rRcSb8L/BDR/gDbtV22BFt4vOL2fQZeI+VI64+FdwZY/iOdnK5RRWrfbwryAjWEM83UxFmRoCjJQu2XeQwue6AUM/4t5SuuitIdibtnWkV+BZgRxdapLtppPtnF5V9R3Dy1HzOK7cL7Ninq3YKwu4Hm87Ar4FmDIZh2Gx9iRzqnc39Je6UEf7VNSDtNcKYeleJfWurPGppQfMRvDeTw/MNZ4fkg+igUZuI9CC57oBQz/u3lK+YE5Jfmd5wfh/wCam/KDbHMZ+VHYN7Oi3lK8I57Hy56Axxwgm3UYflt+cH+XlR/8TBxvocv13RabxEvKgRYbw3k8PzDWeH5sW5N8ht8D/SX88t8Gw/9lnlJ+YE5Jfuf5Qfi/geam/CDbXEZ+oI95fkjxjngeL20BjzlAuncYHmNHyo8W47PtjsrzQzrX4F277G+ng2E6nqfjJJkOkpNBMtz27bRs/r3JZDTtzbqD8fF8cTzoXzT/dNyfzHuD+Xg27Kf9UXrR/MfJbHQy6qWjvEznJ8lF858PR7N5HgTdk0S/9rbxl/7d4fqgC/3/w/+DiMf7CeLbhoCO9ytsDQoEfhr3zgacZ3me0hD6/KzYJ/03xP+phCfezWxdRhqLYQzXLl1a5h3thbRIjoDhbxgC5BP8B0rzOwL/iPEvyC308f+psYCPBbz2z3UzaXmvAd5l/1s45cnoYx+XjWJHx/V/QbmxkhU4AAA=",
  "debug_symbols": "nZbNbuowEIXfJess7PHfuK9SoSqloYoUBZTCla4Q73498ZzQLq5UecP3mTgHM4xN7t3H+H77fJuW0/mre3m9d+/rNM/T59t8Pg7X6byUd++dkReO3YvtO04VXJE3ZFNhK6jCVfiKsMGaQhJGZVKyMldao7RKUjqlV2qe1TyreVbzrOaR5pHmkeZRyXNCrwzKWOnKdS8s4yAs+VHIylzpjdIqS14SlvksLPOzMFcGo7RKKZoRcRAPCZAIkR9BqhkYklWigVgIQRzEQwIkQpAckRwlWSqVDMRCCCI5Uq0kk6VcbPUdJoh8ulSQPSRAIiRB5NOljFuDiWwttomFEMRBPCToMnKEJAhDdKlkDMRCCOIgkpNEEoQhWUU6torksAhBHMRDAiRCEoS3jiHpXKF07karJKVTemVQRqUsrLQWOQOxEII4iGwnIxIgEZIgDMkq0vRV7LY7yJPSKb0yKKMyKVlZEsPj0Xc4d96u6zjKsfPtICrH02VYx+XavSy3ee67P8N82yZ9XYZl43VYy9WyonH5KCyBp2kexR79827z/1tLn2W9m4x3e0D4dQIRExKImxKcxTcoalsSWBqxJjBxU4J3e0IyLQnZMBIy5YYEZwIq6Ux0TQkJayg1DS0J5azdE1JLJR3tHeXK7mpJ8LQneNdUyZgtEhKlloTEZk9g35SQ92/BFFsS+FkHDm0J8u+CNbT1g3l2lGuqpMn+2ZO+aW+m597ktt0d9lOO48+OOpTRcJzWH4+AD8lap+F9HnV4ui3Hb1evfy+4gkfIy3o+jh+3dZSk53NkeXmlmPqy9EPflf+J12R6Ngd59iuDzL01TkZ2m2h7iu7wkHX9Aw==",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
