---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "nZbNbuowEEbfJess7PHfuK9SoYrStEKKAKVwpauKd78z8TehXVyp8oZzQuDgYMfK1/A2vd4+Xo6n9/Pn8PT8Nbwux3k+frzM58P+ejyf5N2vwekL5+HJjwOXBm6oK6pr8A3UEBpiQ1rhnZCUGSwgg7XRO9CDBAYwguh59Dx6Hj2PHqFH6BF6JL2gjGACc2OQ81Epx0kp/axksDZGB0q/KAkMoPRZmcAMSq8qGayNyYEeJDCAsXVTAtFLBWSwNmYHepBA9HIEE5hBjC9jfBnjKxhf0Tl3KmQSTKKJzr1OfskmxYRNKoR1LenMsDchk2ASTZJJNikmbFIh1crVyutK1Vle1+oq0SSZaEdWADn9cFKJ9k4y0V/PKsWETSpEF3QT/fWiQibBJJokk2xSTBjD0JW9ii7tJt7Ehqqru0k0SSbZRDuyFCg4E29CJsFEO1UlmWSTYsImFaI3RxO/3kWkd8fKAEYwgRksIINSTPf7ONj+9HJdpkm3p28blmxjl/0yna7D0+k2z+PwZz/f1g99Xvanldf9ImdlbU6nN6EE34/zpHYfH992//+qLKaKb8t6CFsg/bpAxGQF4q5C8HYFor6nwLqkWoGJuwoxbIXiegrVsRUq1Y6C/A1WCLI/9xRcjVvBxa5CeYzBpa6rSGUrlJ65CLStySD3Z08h0laIoWsucvVWKNQ1F4XdVuCuuSh1uwqm3FPgx//Aqa+ge6uNIXXdWeVxZ3HfvZm2PYrzz9ncydH+cFx+POjdtbUc96/zhMP32+nw7ez178XO2IPiZTkfprfbMmnp8bQoL8+UeKRSd+Mgu/xzcSO7nT7hyUHl0bugR14/yHmUa9zddVz/AA==",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
