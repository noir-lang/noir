---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "nZbNbqswEIXfhTUL/3vcV6miiqakQkIkosmVrqK8+53BZ0i7uFLlTb6PACeDPXa4dx/j++3zbVpO56/u5fXeva/TPE+fb/P5OFyn88Lf3jsjH5S6F9t3lCuoomwopsJWuApfESriBmuYTpjADBJYKq0BLehADwYQeRZ5FnkWeRZ5DnkOeQ55jvO8MIARTJWezwchH0ch5ychgaUyGJDzs5DzSejBAEYwgZxXhASWymhACzrQgzKsRiSqJJWsQvU3YqlMBrQgakzITAGMYAJRY0KNCTVm1Jhl3mVys1PxKkFFypQBz0klq5BKgZD0k4w+WRWn4lWCSlRJKlmFVAqkaHLR5K1bZYa3ft0kqEQVyeHZd0YuTiJBv4kq8utZJKuQSoFIU1exKhJIIl4lqESVpJJVCGVId28i7V3Fqmip0uFVgkpUSSpl63LnDSgpRcSpeJWgIivPiCSVrEIqBSLLo4rd1pGT9bHRgwGMYAIzSCAnxsej73SHeruu4ygb1Lctizeyy7COy7V7WW7z3Hd/hvm2XfR1GZaN12Hls1zRuHwwOfA0zaPYo3/ebf5/K7dSwd3cDX4PiL9OcI6cJjhqSvBWn4DVtiSQtGFNIEdNCcHvCdm0JBRDmlBcaUjwJupIepNaRpIHUmvwvMc31ZCfCSY2JZTwTAhNTxHznpBbZtO7vas9r/CWhOD2hOCbZjMVqwnZNc1FJrMnUNNI5rI/BbnUkkDyt6AJTSNJz5GkmJrWZtz3KEqlKSE/Vzf97KgDHw3Haf3xsviQrHUa3ucRh6fbcvx29vr3omf0ZfOyno/jx20dJen5xskfry5S73I59B3/T7xm05M5yFsiHxTqrfFyZOVCSj1XeHhIXf8A",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
