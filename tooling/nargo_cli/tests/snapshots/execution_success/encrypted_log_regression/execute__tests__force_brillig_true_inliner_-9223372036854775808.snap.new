---
source: tooling/nargo_cli/tests/execute.rs
assertion_line: 309
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "ndnfrqIwEAbwd+Gai5lpp536KpvNiUfxhMSo8c8mG+O7L2wWOLFlCd+NCepPSvtJ6fRZ7ZvPx9dHezqcb9Xmx7M6nnfbe3s+dUfPV119Xtvjsf36+P52Rf2Lhb/fv122p/7wdt9e79WGE6W6ak77aiPkXfcLh/bYVBul18+6sggYA0xabxIBhgEjgHGA8YDR9YapiERMBiSWo4CgiCBDUAIQE4IYQYIghyCPICQRjCSCkUQwkghGEiFIIgRJhCCJkHIiHNOAHHOGPIIUQQFArtx7xnFAJpah8jWZdyOKlKHyNSWyASVJGQoIiggyBBVT7kiHGDkKWYx8MeXdMA1nct0VZIgRJOXmxQmRZsghyCNIERQQFBFkCJpJRPIT8u9ICUGMIEGQA7KnHkFIIhRJhCKJUCQRmgAUCEGMIOQeEWYSoXFEMZs1gkeQIiggqJwIGR/mnbi8IwxBCUCREMQIKifCy4i8y2bC6BDkEaQICggqJyIkHlCU7BYWDUEJQEYIKnd5NBqRZRNAuabgYhp7zyS8o3KBYOFM5QrBEioH1lin5mUpL9cIlpBHkCIoICgiqDy4Nv01TPPBTeuRECGI12dPSBDkEOQRpAgKCIoIMgQlAM0UZv67+pSZwswCmlmy6liqs5AypAgKCIoIKi9ZLU7LcMs7IgFopjCzgHh9lUBmCjMLyCHII0gRFBAUEWQISmvRqzv6tb22289j82/j4/A47b7tg9x/X5q3LZHL9bxr9o9r02+OTPsifbK6h9BaNHSN6QcyUm3UTzL9R8lqJtcf9WmSQLUE6RrQNeIP",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
