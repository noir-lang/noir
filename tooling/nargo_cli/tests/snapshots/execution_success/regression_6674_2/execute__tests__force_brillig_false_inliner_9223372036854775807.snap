---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "11890127694861652393": {
        "error_kind": "string",
        "string": "equality"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/91aP4/TSBQfr+0k3sRxdPcJ7hvEib1Zui2uuvLK67yBlU666sqrjHTVtYeQkCj4BAgJiYJPQElPQwMSEhIFoqFiZ5mHf/vyi+OwnhUw0mrG8968P795b/5lA9OUwNWRuUIRISPXSNz3AdDD878T9z2/WskTpbdP+cfzokiIfz3av0yczMCP/LnI94T/fOjk/Fo38tEX0Ts6/xtDe2Ka+PDlv8yfT/9/bvF57Hx9qXwVuunRjhR8M2AL6o38YFAGSp8BO5Am+g+VrX2vCYHSJ/ZofGQeBLuY2DojNIwlpKGemOj5HmVlhseOLQkZ12duiR8DJy8ifqBtB4of28aNwb5fXG1z9DWM2RY7UQt2IbEnJeOCLbUxmznD9LB5aMv9ffXInA6UnhP3Pb9iYXgNlB/DHvyYKVkB8XHkx8cvew6eHXqSnYvsQ+V73/LHfrDJZY5xPmX+bb2Efszz2DR5iGNHQEf+ZyDzyLW77JGe1rLOe6Tov649ku0RbXvkkNjalmuB2czpkPR1ydtvVVZGZEeKxvbWhMj0sX/KWTsiPqJtB4of28Y0OSZ9v7ma7Z/7nj0OiD0MO332mHjGLiXYTVqwS4EmbcRO+n43/WEXmm7Y6bhLPWM3NZvYpS3YTYEmbcRO+v4w/WH3tXE39YxdRrCbtmCXAU3aiJ30nZr+sGNxl5JxVz3DsXlg5wg5s9g9/0/ox/Wu6zlC+B+CzL9cu0t8fK9r+t+u9r0uIU2vS77vkww7Npf7YveP2Y5dSLALW7DT71W29HnPY3Okz3rbcus29CN2+57R74DMf107I+N1fHg6E8+1PxgfofJZsNSxg/mg/f3P1Sw+9Lzpvrb4CFqwixR2nt5BF21rBJtL9q6k9wwZFxPeRNGE939XW4zfuLaNXfbGh/fOu0ov2y/iFtuE/z7IvKf4d2EjOcbyLwa5t107M3yvQZ2THX7o3BT+B6629LdKZkr8YHcm4Z8SfnYOzMzmeitjhT+sG5rolFiIgNbn3d1i8A7s0BjEdXd/GT4Z4Z8qHltmih+xYut5qmSwuy7Ggo4/pMlYzBX2JoA59UjpZ7E4VDxCR/4nIPNxB5+65hT6JOdFFoM679MdfuicEv6nrmY5xWIGzxr7xsxQ+YOxIGNZTuHvcrZEQPOdU5fufHV3fxk+M8KfKR5jmryZAS1VNJx/nZcTogdjQccf0mQs5gq7W+i3JP3mgTScZ/2OPlXfyJson4dmu8/yjfGPNun4F/7nrsb4ZzEovv/oMajXbhaDgcIEZSHmY8Uv4wem/d1Kr1EvXG2xiYPL9uH5a6psZ3e9NtsDYvuuc4/8NuAzLlbHn+8BF7bWDUZ45zJKf6z4X7lv/RuNYHjylXaerar8bFmdVWV182axrn5S8m3B/z3oW3+1Wh6vF8V6dVouq+XR9esv54vl8aIoF8WyzKsb161/XR6drouymt/K7edil37J9UHd0HGds2XovuWuqflFXqz43wvv+d8H1/5yLqk39Vm+KNjOF2ypL2SQvqi+3JfUm/xhvckvug/rTRuFNgYarsG2TNw34oWyxI5Y8QdOgMzJCMbI+BnRP1L6L9lN+nAP0LJC0if8dn4+ijxXo+99//Z3oVPJxz5tm8SOj7w6T6nVulrl+Y0iv1Xk5a68+gQg6rkVtSgAAA==",
  "debug_symbols": "1ZxhTxsxDIb/y33uh8RJHJu/MiFU4ECVqhaVMmlC/Pf1TlxhPUhUM1fOl2m35bWfRe/ZzhTutbvvb18eb1abh+1zd/XrtVtv75b71XZzeHp9W3S3u9V6vXq8+fzHnRt+8WFc//y03AyPz/vlbt9d+Zzdous398Nv2R8iPKzWfXeV3Ntithghvq/FAJ+XXi86H3XDJ93wqBs+64Yn3fCsGh6cbnivGx50w+u+taD71oLuWwu6by2c+9YOGhJo+HxNcAKNF2hAoAkCTRRokkCDAo3AB0HggyDwQRT4IAp8EAU+iAIfRIEP0jf/Hs6ThqIrl4EM+L42Qz4N/zUSR5jCcwynmiTQoECTBRoSaPh8DTqBxgs0INAEgUbgAxT4AAU+QIEPUOADFPggC3yQBT7IAh9kgQ+ywAdZ4IMs8EEW+CALfJAFPiCBD0jgAxL4gAQ+IIEPSOADEviABD4ggQ9I4AMW+IAFPuAvfQAuTK0eXK6cDjxQmhIED5XFkY4DR/K1yInxuJhPRw4O7aLHdtFTu+jYLnpuF53aRedm0b1zDbP7htnbbajema7t+DHH4GyO8U61zIwZWDuDd+oZvHoGUM8Q1DNE9QxJPcN/GHZCOv6HYqB4uTrkc8Ps1DA7t8sOrmF23zA7NMweGmaPDbOnhtkb7qtgur6X5/ugWmfGDEE9Q1TPkNQzoHqGrJ6B1DOwdoZ47rwzir4ZNHjKBIfdn4lAIgoSUayK/r2jMIqSRIQCUTI9YiIeSz/ibGuT6VEH6aP0E87YTbfcyr6bPspW2E0fZSvstkedIjvarjPER3aejWlo+ihbYTd9lK2wN1zf0fRRtsJu+ihbYbfdV8vstvtqmd12Xy2z2+6rRfZsvK8W2Y331SK76Xs35Vksm74CUt53Mn0VobzvZPpyX4U9Nsxu+wpImd12nSnO72T6gl+F3fQNvwp7w/WdTV/xq7CbvuJXYbfdV8vstvtqmd12Xy2z2+6rZXbjfbXIbryvFtjBuR//yC7FaS1h5cRHftoSinMUbwcF7KCES6JwnszCxDOUaAcl/Rzlu10/FwXtoGQ7KHRJFIh+KrUYZihsBsU7OyjeDgrYQQl2UKIdlItWW6DjBRmeo6AdlGwHheygsBkUcHZQFKvt9dvh6fdyt1rervv3rw8+vGzuPn2McP/nqT/5LuHTbnvX37/s+uELhR8fJxy2DAIvAN1wtBkfIS4AeHj049+GBYR0yHrI/Bc=",
  "file_map": {
    "50": {
      "source": "use std::mem::zeroed;\n\npub struct BoundedVec4 {\n    storage: [Field; 4],\n    len: u32,\n}\n\nimpl BoundedVec4 {\n    pub fn new() -> Self {\n        BoundedVec4 { storage: [0; 4], len: 0 }\n    }\n\n    pub fn push(&mut self, elem: Field) {\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n}\n\npub struct PrivateKernelCircuitPublicInputs {\n    pub l2_to_l1_msgs: [Field; 4],\n    pub public_call_requests: [Field; 4],\n}\n\npub struct FixtureBuilder {\n    pub public_call_requests: BoundedVec4,\n    pub counter: Field,\n}\n\nimpl FixtureBuilder {\n    pub fn new() -> Self {\n        FixtureBuilder { public_call_requests: zeroed(), counter: 0 }\n    }\n\n    pub fn append_public_call_requests(&mut self) {\n        for _ in 0..4 {\n            // Note that here we push directly, not through a method call\n            self.public_call_requests.push(self.next_counter());\n        }\n    }\n\n    fn next_counter(&mut self) -> Field {\n        let counter = self.counter;\n        self.counter += 1;\n        counter\n    }\n}\n\npub struct PrivateKernelCircuitPublicInputsComposer {\n    pub l2_to_l1_msgs: [Field; 4],\n    pub public_call_requests: [Field; 4],\n}\n\nimpl PrivateKernelCircuitPublicInputsComposer {\n    pub unconstrained fn sort_ordered_values(&mut self) {\n        self.l2_to_l1_msgs = sort_by(self.l2_to_l1_msgs);\n        self.public_call_requests = sort_by(self.public_call_requests);\n    }\n}\n\npub unconstrained fn sort_by(array: [Field; 4]) -> [Field; 4] {\n    let result = array;\n    get_sorting_index(array);\n    result\n}\n\nunconstrained fn get_sorting_index(array: [Field; 4]) {\n    let _ = [0; 4];\n    let mut a = array;\n    for i in 1..4 {\n        for j in 0..i {\n            a[i] = a[j];\n        }\n    }\n}\n\nunconstrained fn main() {\n    let mut previous_kernel = FixtureBuilder::new();\n    previous_kernel.append_public_call_requests();\n\n    let mut output_composer = PrivateKernelCircuitPublicInputsComposer {\n        l2_to_l1_msgs: [0; 4],\n        public_call_requests: previous_kernel.public_call_requests.storage,\n    };\n    output_composer.sort_ordered_values();\n\n    assert_eq(previous_kernel.public_call_requests.storage[1], 1, \"equality\");\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
