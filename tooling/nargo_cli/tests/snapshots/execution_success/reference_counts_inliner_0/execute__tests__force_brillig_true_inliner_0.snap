---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8222435832483736686": {
        "error_kind": "string",
        "string": "There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before array_refcount call)"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "16406258251777617968": {
        "error_kind": "string",
        "string": "after refcount_1 we clone once in passing array to copy_mut, once to arra_refcount after, and once within copy_mut"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dS28cWRW+1dXlV8dxJ4GfEGXbD7vbRkJqFGeSYSZxHiTOy0n64fawQQjBhgUqiRV7JBYseIgF0iwGaSQkJCR2bNgACxDsQEIsYIXYsCNl31N9+utTt6vS59rlkY9kVde9x9951LnnPupWVWAmFNhj1SxABPKb8OS4as8rrD6p6tnzxmLUXAW5mvjbjc72qmCfov7tVYsZ+MFvEL4n/zeWLc5H8QSf20JyV97+1djvppnEhy/76fr5tP+aw2aKnZvxpM4oX9uEdmM/thH+LYvvQ/f3/PgmzQu3/fgmxb+j75sU+30/urcI/8v6uqfYH+hjbxL2h/rYHcK+y3weqOG30ni/5wc/9fueH/wh4d/3gt9O9X/gB79N+A/94PcJ/5Ef/BHhf8ULfifNOY/94Kf+f+IHP80N+37wtwj/qR/8LuE/84OfjmOf+8HfIfwXfvAHhP/SD36a3w784B8S/is/+GPCf+0Fv5v2X2/84Kf5v+8HP80/Az/4af4Z+sFP88/ID36afw794Kf5Z+wHP80PR37wR8ncNZm3/sFOVNbN9LzPsN+e55ybAcgzFp+XcflrxusaQzMAeaQP+ofq15kOqGsd6hKi+Wcg1IVCmQvrjiIWzZ/Wzaz9QcbRmNlrxeVsmFnfYFxVWZ3mfJ9kRRavynyCMklnzs9/G/ubl92yx6Qd/TmYtq/odcBY5v4J/fhna12wkYjqlsy0XbxumfHTugTVrbA6XBPhFMI5tzfB+CvLT8hHlCfGIsDv2fPGgkSyyE88xlBmQhUz69clZksEZY+ZL3zEmMt3GyY7Bsivy4DZs+eNBYlkURxxvy4LvqsAP8ZgBGWv7FHyK78eoVDm8usS+GfJj3+2pXZGRHX8XgK23TXQi9fVGFbRtkv25m27nnNcIT9xe9FPCfF+2+TwBc9jP6lMcJGPKE8e8xRPzvaGMhMq2t6+xXxxVnlsRagjv64CZs+eNxYkkkVxxP26KviuYmbbJ4/BCMq+Y4+SX/n1CIUyl19XwD8rfvzTl9oZEeYjKY9dAr14HW9rRfMY2Vs0j/Gynj02FqM2zi+4bM/XJ/fcjOSvGa/5vOmKbSlnSP0d/W9dqAvg95ogZ02QUxfqcG62CBbNzagO5+IJlamtJoR9KW+rUlwZ5htO2B6L9KVSX+HZT86cL/VBRXP+T5kvMOdjO8WyrPm/1F+6fFfz47shxgonzOtSzr8s2JM3xvh+jt/liDEptxD/GfowjT/yIY8/qS+tmNn2yf0fQdmnzE9nFX+e+pfC8Yf9zGVH3YZga97Y5HOJfxeIzUCo9+zD3GMGKjut9VxpniHFpmtsWTez8bEbT/iwLhTKKg6s24pYtN9Gmhvh+qxkK8UJ5tuePW8sSGQjtRmep7jMS8xWbGP0O6EIyn5vj1KeKurXUNDH5bsNk90fkV834P969ryxIJGsusXjft0QfFcBfv47oQjK/mKPkl/59QiFMtec83IO320IumK8XoG6nj1vLEikx1WLx/16RfBdBfj574QiKPu7PUp+5dcjFMpc8VoH/9S9+KfZWhdsJKK6ayCb132O1V2Cus8zrKJzebJX834CtvmePW8sSK62K+WZom33P8wXp70OF8A5l8NzBPaBpPuSwM/x0Nb/MVu/EE7zS32OpPO6mfUpxgJv33qx0OoEIM8YeRxF8teMz/Y9GUddBX2ycpHU5ul/61CXEO6luCbIuSbIkbDuKWK9UMR6roh1oIj1RBFL0/cPS6rXUBFL8zr2FbE0Y/WpIpamv/YVsTTbUFnzxEARS9P3mvGlqdcbRSzN/LVXUr1GiliabUizbWu2oWeKWGXttx8oYt1XxDqyWDTn4fMAnHPjvLdnzxsLEtlBc+eqYAfXrQL8/HdCEZTtBSdHab4ozQOuOnxXF/TBNbuPrYxkrvfI/qZ5BH+Q21Z53t/X2g5AHtnKy7j8NdBV+Xqnc7AI9EH/4BxsSdC1DnUJ4fNYRffC8brHilgDRayhIpamv14qYt1VxHpUUr3GiliasfpKEUszVg8UsTTb45Ei1p4ilmas7itiHSpivVbE0rSxrH2Hpo1PFLEu8v1Fe7xoj+Vpj9in5R2vu2TXHfzLOfkvMV2+/o2vfu2bBggflHgvw5AbwEebTYiX3zik/+W/ycDrRjbkupH1WAFcxOfnN4ysk/Q7C+P6HBnXocxY22giS3x0sefdcIyA/xNb4ftBtqtgA5clbcijgMLNZEZPpy7dpA/jWT/RwxPV2Is/NpM4+6I1SlqAiEAnjQbOMXbjkyMmF+5raTN4lfkHr5niZo8m+eSKmSVpIwi1X9dGkEDACuGc27TIZnBcoKuAPj173liQAjNtI2//GBPGTBbopFyVUARlvw0mvlh0M25d0MdvHDW20T9c13fqwPB1jxR4xsgdEQnGDofecietOnJHFOkYPDtTfFJI0p1oXuN6xBJgFlbN+E3G3e2TRnSsr8WPjGxjldVz/j9ZAL5Tn47VBfQcd/vNcbs/7m/1R6PNYR870YQqzE/a8vvd9vawtTnsDrba/XZnrnzpjR9SfAcCTujArgMWT26UfPnABQc7hP03W5F0dv/MkcwqrOx2PM1PmEvGnXBRh3+whEq7xiT7AjOrq9TR4P+QDllvCkC9iP+HlYm8f8E1xPyTkN+OLf+dEZJ/3t/agiv9UocVCnIkrMeKWANFrKEilqa/Xipi3VXEelRSvcaKWJqx+koRSzNWDxSxNNvjkSLWniKWZqzuK2IdKmK9VsTStLGsfYemjU8UsS7y/UV7vGiP5WmP1KfRXElavMzzxhNcEO3Z88ZClP+pG5J/Wm88kRaMJZ/j2/n4/9ahLiHMHdKdpGVBjoR1TxHrhSLWc0WsA0WsJ4pYmr5/WFK9hopYmtexr4ilGatPFbE0/bWviKXZhsqaJwaKWJq+14wvTb3eKGJp5q+9kuo1UsTSbEOabVuzDT1TxCprv/1AEeu+IhbOH6SNEef97cTftw7QeDtxKOjjwgoELLSX84cO/tWc/AvvSiNDbgAf7krjO2wCk23g9QxDzvuuNLqJ6PNG5Y/tD8+vGRN3rJEsvNkt6RKo6dLpnN0jas1mAPIM2GlA/nl/RA0XLBbZpntPEeuFItZzRSzNx340t0hr+v5hCfWS8k1ZYkJz27zmY4tlja8jwJIWwKXcVmi3IoHzcxyghExJTvN2K2bhB4BF9diBfpa/4/NHx2i76J2OQNDnvHzHh8fbWXzHp2zb/StMtwh0kuKC82O7lQZDHGM3PjnWBX769rDn3cOF4ighigfpe1Ckc95YIb68W/px5yP3f1buknZvSrtT8REKP3caJ3mN/Jb1zRXSrWJm2yv3eQRl/3XkNSkeeRnmtaqgj+dHkrpSXBFhfuI6St8/CqGOv1+/aF4je4u+T5T7qQJ1ywL+aX2nIM2tZhILXCbpVjGzfuUrPBGUReHETxh/RVcAI0EfFxa/brfjaX7Sb0ng53hoT43ZQzvDPfftO9I3qoik7w9EUFcT7JLece+7b/f4mOCWNG7gOTyhajytu5JscdwwNdZkcrNiVcq7GKucn2PsxifHusnOedLYFB/t5PHLx4DHcuNZzPP++OW867AbnxylOxAfQp20gynPe5Crgg5S3nIt1pYp/ySEY8Jahv1I83LMuz7mmTV/JpkBYKDPK4I+nsfhqj7n+iNpjMN9PNW2udXvDvvdZnNns3m42dya91QbfdNgKWa2xdP/s2zPaYyD/IQXAf+XLHMyVrjJ8tExryAv4Xvo4AsyjscYQlk1ni5bjWf5w3iWn2SvxbM6Ul2N1fF8mtAle879xbFIjwj49ywzXZMV9j/0/3VB/grIn9JbKMO4rgn8NYE/uT53LAPFLbdd+0bIsUzA52WoG8XOxffZ3X7l8kgf9A+uZUljHLxLntCteMKX1We41gB5Xdm/zy6NYYjvs7zm+5Fjbqqx5pvHd57aR+H1YGwnedaD0TakeWOLPN8wc43npPEZ+tfTmNgZm1KOKRqb33bEppTzpHXn+jv6zvW0/nlfD/2uw69F10MDQR8XFr9GuB5F+mW9qSDKsOd7jvUoT2uGhdejAqirGdlvSFL+4N+ALfJ9Th4fpFueOD/rdVeM87zrrj/wHOcu39Fv6VvH/NrgPJvbxv+X/x/amRCtxUTA+yPmg1+E01jz1tRc6y6roBuuFXMbPwDdiPdnTLdPQTf6f+k1UQntxtP8PFcaQYebGTr8nOnwy4I6vA+YxP8xw/wV5CPuQ82xDvaLRTcrfsJ0/jWbe6mvaTS7O9vjneFOp9tsdZrd035T0Gin1W51Ozuj5min2RgNTv1NRcOd9qg7fru2s90YvvXFacvvtpqD8daovdnttw6HncPTln/Y7h8OhuPNQWe7M2i0G/Pk/x+aDwzIyZ4AAA==",
  "debug_symbols": "3Z3djlPHEoXfZa7nouu/Oq8SHSEgJBppBBGQIx1FefdjJmxP4t22VWUaavoGYWZ/i9pTq5fL+89/3v3y7s0fv716eP/rh093P/38593jh7evPz98eH949edf93dvPj48Pj789uqf/3zXvvwh7Wn7T7+/fv/l5afPrz9+vvvJ2v3du/e/HP4CB/rXh8d3dz9J++s/93cCwe0xuD0Ft+fg9hLcXoPbW3B7D27fY9trsL8a7K8G+6vB/mqwvxrsrwb7q8H+arC/GuyvBftr4/761+2h9VMAowBFAY4CEgU0ClgU8CjQg4C3KBDttEc77dFOe7TTHu20Rzvtw04DbQsI5HQF+bDVAHok8J/E/W5TB/m6qROeiveJ4r3NFIeZ4jhTnGaK80xxmSmuN4pr6183VaFTcZsp7jPF+0RxaG2qOkxVx6nqNFX91mWqclQ3vbLoOnzdtONzIYh/FyJVCtEqhViVQrxKIb1IIdCqFBILticE4wjFEY4jEkc0jlgc8TgydqpvrcS2Q3DsKfEjQpeNcmjTZqrD71J3+jBZHyfr02R9nqwvk/V1sr5N1vcb9Y23BWkddup9pjq1qeowVR2nqtNUdZ6qLlPVb12v1m37DNtkp25T1X2qep+pzm2qOkxVx6nqNFWdp6rLVPWpa5WnrlWeulb51rV69khc8JOQtCqFQJVCsEohVKUQrlKIVCkkFmxPiMURjyM9jGiLIxBHMI5QHBk6FYk2RHiHDD2FYEdkF97jawAuIxZHPI70MDK+HuAyAnEE4wjFEY4j8e5bvPsW777Fu2/x7nu8++PLBKhtaUm4O0Q3vlAAFY/IbiGPLxW4jHAckTiiccTiiMeRHkbG5/dJtu6T+A6BOIJxhOIIxxGJIxpHLI54HOlRBFuLIxBHMI5QHOE4InFE44jFEY8j8e6PT8WRbfMxdd0hEEcwjlAc4TgicUTjiMURjyPD7jNsyc9kp8j4pBnzNidL+9ecvP90xIR8lP+yxYk+TNbHyfo0WZ8n68tkfZ2sb5P1/Ub9w4S2DbyHAWeXruPTZt9On9pkfZisj5P1abI+T9aXyfo6Wd8m609evzR5/fLk9cuT1y9PXr88ef3yzeu3Ex/1HS5vfBgdt/HtMN/t5jeW71rMoYStmEPO74rRSsVYpWK8UjH9uxZDejwiSH56CB2lfddi2Pvz4fx2eeOzZ3FiJ3xQYP1dxPV3kdbfRV5/F2X9XdT1d9HW30Vffxf78ruo6083uv50o+tPN7r+dKPrTze6/nSj6083uv50o+tPN7r+dGPrTze2/nRj6083tv50Y+tPN7b+dGPrTze2/nRj6083tv504+tPN77+dOPrTze+/nTj6083vv504+tPN77+dOPrTze+/nTT159u+vrTTV9/uunrTzd9/emmrz/d9PWnm77+dNPXn2768tMNteWnG2rLTzfUlp9uqC0/3VDj9Xdx+emG2vLTDbXlpxtqy0831NafbmD96QbWn25g/ekG1p9uYP3pBtafbmD96QbWn25g/ekG1p9ucP3pBtefbnD96QbXn25uftbYC9jF9acbXH+6wfWnG1x/usH1pxtaf7qh9acbWn+6ofWnm9ufxFh/F9efbmj96YYKPbGNuFUqBioVg5WKoUrFcKVipFIxWqkYq1SMVyqmUgJLpQSWSgkslRJYKiWwVEpgqZTAUimBpVICS6UElkoJrJUSWCslsFZKYK2UwFopgbVSAmulBNZKCayVElgrJbBVSmCrlMBWKYGtUgJbpQS2SglslRLYKiWwVUpgq5TAXimBvVICe6UE9koJ7JUS2CslsFdKYK+UwF4pgb1SAvdKCdwrJXCvlMC9UgL3SgncKyVwr5TAvVIC90oJ3AslMLdCCcytUAJzK5TA3AolMLdCCcytUAJzK5TA3AolMLdCCcytUgJDpQSGSgkMlRIYKiUwVEpgqJTAUCmBoVICQ6UEhkoJjJUSGCsl8Br3wBpv+2je/rnp0y4ucZfI5V3k9XdxibtELu/i930zEWvHXXTZBYNXKqYXKuY73x55pZiJbyZP+re/P7gd9bvu9GmyPk/Wl8n6OlnfJuv7ZP0+V/8b3El2Wf/W9YsNZcuHxpR8p3oqBeuUQnVK4TqlSJ1StE4pVqcUv7kUPo6dTe2bjZ2Xq+4vseqbbzD7MVXDi6waX2TV9CKr5hdZtbzIqrVo1RcPE4i9yKqrvjdernr43ii0qQv76UQ/vu/uMgJxBOMIhZHxDQAqWyPUdh9oxpfpX0YsjgzdhKDHSQ58B40vwMbDphuEtDsAMr5Q+hpEGYgzkGSg4S8cCTcrIAntoPGv/PLphfEVl9cgzECUgTgDSQbSDGQZKNWnHodkfGXZNQgyEGYgykCcgSQDaQayDOQZKOMIyDgCMo6AjCMg4wjIOAIyjoCMIyDjCMg4AjKOwIwjMOMIzDgCM47AjCMw4wjMOAIzjsCMIzDjCMo4gjKOoIwjKOMIyjiCMo6gjCMo4wjKOIIyjuCMIzjjCM44gjOO4IwjOOMIzjiCM47gjCM44wjJOEIyjpCMIyTjCMk4QjKOkIwjJOMIyThCMo7QjCM04wjNOEIzjtCMIzTjCM04QjOO0IwjNOMIyzjCMo6wjCMs4wjLOGJ8kO5HPARYxgf/fkwpVqcUr1NKL1PK+NkcP6YUqFMK1imF6pTCdUqpk7ZeJ229Ttp6nbT1Omnb66Rtr5O2vU7a9jpp2+ukba+Ttr1O2vY6advrpG0vk7bayqSttjJpq61M2mork7bayqSttjJpq61M2mork7bayqSttjppC3XSFuqkLdRJW6iTtlAnbaFO2kKdtIU6aQt10hbqpC3WSVusk7ZYJ22xTtpinbTFOmmLddIW66Qt1klbrJO2VCdtqU7aUp20pTppS3XSluqkLdVJW6qTtlQnbalO2nKdtOU6act10pbrpC3XSVuuk7ZcJ225TtpynbTlOmkrddJW6qSt1ElbqZO2UidtpU7aSp20lTppK3XSVuqkrdZJW62Ttvpd0/bSs0ZUqU4pXKcUqVNKNOKeoHEYXXyqq565IeYydOaGmCsQZKChPS6us/FNKpcRjSMWRzyO9DAyvtnhMgJxBOMIxZF49z3efY933+Pd93j3Pd79Hu9+j3e/x7vf493v8e73ePd7vPs93v0e734Pd99aiyMQRzCOUBzhOCJxROOIxRGPI/HuQ7z7EO/++GKvS9OMjS/KuowM+wJCxydci5wOCza+oOca5BmoJ6Dx5SzXIMhAmIEoAw1XKTTbHAQAe0gykGYgy0CegXoCGp9yvwZBBho7AvAZwr6DKANxBpIMpBnIMpBnoLEjgPoRkn89ODJ2PMHGZxC/oT5M1sfJ+jRZnyfry2T9Hn5XHp9GuYxAHIlPGBKfMMaH+S8jEkc0jlgcGecTqm5WIcDTfBofML4CjQ/tXoMgA2EGogzEGUgykGYgy0AZR2jGEZZxhGUcYRlHWMYRlnHE+Lgj0PG540AKO0gzkGUgz0BjR9Dxmc8H6PRR3jY+AnkNggyEGYgyEGcgyUCagcaOYDwalmn3mWB8RPIa1BPQ+KjkNQgyEGYgykCcgSQDaQY64wiWIyS8gzwD9TjkrWUgyECYgSgDcQaSDHTGEYZHaPf9it4sA51xhPIzhPkPId76XH1ok/Vhsj5O1qfJ+jxZX4L6T9CZg8vPa072a+7cweXLUPTgcnT3+1z98CHrqD5M1sfJ+jRZn+fqn7kCVJ+vMzmcUT419ZlrNa9AnIEkA2kGsgzkGagnoDNX1F2BIANlHKEZR2jGEZpxhGYcoRlHaMYRmnGEZRxhGUdYxhGWccSZZxIbHL9q63DOZweNHeHHiER320GagSwDeQbqCejMU26vQJCBMANRBuIMlHGEZxzhGUd4xhGecUTPOKJnHHHm6ZYdttkDO+3G8DPPobwCcQaSDKQZyDKQZ6Aeh/qZpwVegcaO6Hr84r/uewgzEGUgzkBnHCH4DNEO0gxkGcgzUE9AZ55odgWCDIQZiDIQZ6CMIyDjCMg4AjKOgIwjMOOI8Qd5akeImu2hoSOI2rZyiUB3EGUgvg71HSQZSDPQ0BHEbXvPJQbbQZ6B+lUIT+fyPr5M7RoEGWj89e/tePEDN91l+fgytWsQZyDJQOOv/gbbPtUwuO8gy0CegYaOYMLtCOrh5NKuT+Nrz65BkIEwCv11ePXf1x8fXr95fPfpwHz54R/v335++PD+68vP//t9+8mbjw+Pjw+/vfr944e373754+O7V48f3n752V37+sfPjv3epR2KeXqvZJV7tqeXX/anM9931sP/evif/w8=",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1, true);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call, true);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array, rc_before_call, true);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call, true);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call, true);\n    assert_refcount(*array2, rc_before_call + 1, true); // array should be copied from previous dereference\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1, true);\n    assert_refcount(*array2, rc_before_call2, true);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], mut expected: u32, expect_copy: bool) {\n    let count = array_refcount(array);\n\n    if expect_copy {\n        expected += 1;\n    }\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n\n    // This is currently copying the array due to the inc_rc in the array_refcount call above\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1 + 1); // array was just copied on the previous line\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n        assert_eq(refcount_1, 2, \"There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before array_refcount call)\");\n\n        assert_eq(refcount_2, refcount_1 + 3, \"after refcount_1 we clone once in passing array to copy_mut, once to arra_refcount after, and once within copy_mut\");\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
