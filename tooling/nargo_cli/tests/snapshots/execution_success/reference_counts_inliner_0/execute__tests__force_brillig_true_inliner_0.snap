---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6055981641117986912": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array with an RC of 1"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dO48jxxHuIYdcclcHEXbo0FjIgQDztRzSgIEFbuWTLd3tPXy799q742MpK5ENw4kTewJHDgw4dObfZcCB4USZAClQoETXu1PD4sfi7Myyam9OYAPEcLp7vnp0VfVjemYCt0hBcgzdBolAblcvj83kvMLKfdFhct7eLHWaQFcTf9geDJuCfIr895oJZmCD3yZ8I/23dxKc38ULfC4L0W28+e2x/x23sA8r+an9LOX/cYbMZDu340WZU25bn45iG9kI/6ME34L3X9noJo0Ld2x0k+J/rK+bFPvXNrx3Cf83+ryn2J/oY/cJ+1N97AFh32U6D9Twu6m937PBT/V+bIM/Jfz7Jvi9lP8HNvg9wn9ogz8m/Ec2+DPC/60J/iCNOY9t8FP9n9jgp7Hh1Ab/gPCf2OBHhP/UBj8dxz6zwR8R/nMb/Anhv7DBT+PbmQ3+OeG/tMGfE/4rE/wo7b9e2+Cn8X9sg5/Gn4kNfhp/pjb4afyZ2eCn8efcBj+NP3Mb/DQ+fGaDP/NzVz9v/XMyUbnllud9jv03nnP2A6DnEnyex+nvOtM1hk4A9Igf1A+V32I8IK8tKPOJ5p+BUFYV8rKwPlbEovnTLbcqf7Dm6NxqW3E6TbeqG03bIV6lRT4qqzHaAZTVWX0+t8ZUhXMuk/ejvzI/wnqU3nerukAfCwH/MDlvb5YOUBc8oS4kPe0AX87l1xPJlFdPZbIZn2hNR7IZ7ssuhy64zQwrC1ysR2lrM8VshucdJsf2ZqmH8Z3TNm6D3H0j0d91pr6T9o0h8LOun5FiMF3bcuvjc+BWba8q5FXWYPmEfeMmWNQ3UhmOhXwqkz/6hHGL+6NkV47phif0xyJxC8doPjXdarsr6mkg6YJSVmyisgYrK6onksljTHLoCfsizpukQ6pnrMM20SUdhm7VZzhvFbfaH3D91yAvdgs9/aOyjIexDvPQT0OBnzz2ZxQjC9sfxspGRllTkDWvbfKxxz8L2GYglFuP0fL2e5R3U3NCaX4l2abk13Qt2q1PR/Gi3rr+NRToSFh3FLHonp00DqXr3nfrZaUyaZxINoSx+DA5b2+WhuhPPEn+hP3ALivjsmGSfI1k0pgbYlzksZjXrwP/oUDLVufdQV6/Jfq7zlmOmVK/3QF+1vmAFIPp2pZbtSdc/2sIdBoCHQnrniLWc0WsZ4pYZ4pYJ4pYmrp/WFK+popYmu04VsTStNUnilia+jpVxNL0obLGiYkilqbuNe1Lk6/Xilia8eu4pHzNFLE0fUjTtzV96KkiVln77QeKWPcVseh+Ms03+DwA15b4GNhibYnmXqEgB+etAvX5f59qkPdtcpTWlqR5AM/LWlvaAXpBcv4o+ePnX98leXnWTmzW7rrDAOiRrDyP07+ptRNp/Z3ziHOwHYHXllttM9xDWLSNedljRayJItZUEUtTXy8Use4qYj0qKV9zRSxNW32piKVpq2eKWJr++Jki1rEilqatnipinStivVLE0pSxrH2HpowniljbeL/1x60/lscfsU/LO17Poh1m1G/krP8e4+UPf/z8iz85SHiDjza+oCAfQD26uUl1+Y08f443LUnAfScLsu9kPhqAy691cP6Bk3mS/q/D2L+Cxj7k+eRlpYlsANdedcMRJ8SnyR/rTSo/Ahk4LWkDCBkUbl5wejxFdJO3Gi/rkuhe6DM20Uff29l/2cYOdOIa8MQ3qFSF+nkcnGMcxZdHDC5c19IGuhrTD7aZon5UN9BxP8BUhXMu0yYb6HCBrgL8HCbn7Q1T4JZl5P6PNuHcYoFOilU+1SDvi2ChC4vNX8Z2NET9cF6v1YHhTnQyPCcIwgljh3M7XsXDDiBPx8GvM1amuLta4p3SVc71TQ7n2nO2wTgaXjrRBb8Jfs3JMoasnNf/SwLAdyHRMdyAz3k07sx74/n4YDyb9adj7ER9qjA9eZ3SU2Iau5QIGwcNvaTAB+C/JZl5VtFtdg7lX0XHnfdGfpK5815quyI7733CVeFNdss/VsSaKGJNFbE09fVCEeuuItajkvI1V8TStNWXiliatnqmiKXpj3lWHPJiHStiadrqqSLWuSLWK0UsTRnL2ndoyniiiLWN91t/3PpjefyR+rQ8T2Hwsbni3CX3UxhE/6aewpD0mvUURl3gtQVlPmF8kBY26wIdCeueItZzRaxnilhnilgniliaun9YUr6milia7ThWxNK01SeKWJr6OlXE0vShssaJiSKWpu417UuTr9eKWJrx67ikfM0UsTR9SNO3NX3oqSJWWfvtB4pY9xWxaI5A91OkNfomXBc4m5u8dFM7FOTgvFWgPv/v3OJ+DuV9mChAuslbdH4VCvxkYQUCFsrL67/Tu5TWCbjvZEH2nczHu7JLqbdmx0DRG45RUmD82iZxlxLRwhus0mtVAjVeBoO3tyjR6QRAz4GcDuhvFyUWabso8fYGXT/0RQkp3pTFJjQnVC8UscpqX3hDtSpgbbxDjcD5OQ5CqoxJnq7aobYOPwAsKi+yQ8m6o8cOhQ9IpHdjVdxqh8s7oxrkfZ4xopYamueh0QQCP1lYFZZ3J16uT/zVhfocD+X5PZOnn1Qy3tr6Vt9pSzJ5efO8E6xsW8m5DdSAp6tsBuODNOjiGEfx5VG6w0bfYjJ+B6HadnHOc15bobyi28Wz4p7NwD7/u0Ix7nE/43qsQd7fc8S9wF0/7t0Syug6379o78AdR73htNufRpOD3rg3uNYO3FDg9Ye8mvQv49UkSXcB/JdWjritYb9ICyp1Jy9M7ICsVP/fGf2iUawr/K7MGpTtCnJdJ9aV4PsAhXURlkgXzun2fxd8xgu6NUbXpzBe5l2Jtjj+WIoPjC62VVWoj+OPplCfYxzFl8eWW21vPrfBOEE0s96XK+mV6pXtEUEp5kmxNW87HMWXx5ZQ/1Mo49gYp6VxTlZ/IMVp6RE7bt+GMSaSbJqSFH9wbKn1HvDrPoq4br5PNAPAQJ1L80PjJ81Udc75xyTpnOptH/907j8ZYzlse7SjrLEc1dtL9OdTPV5cy+OtTzvxsnxYn9844vX/lxT4cd3/oS1rAj1f7+uMesGa4wWGkBfGy3nNeLV+NV6tT7R341UeqWyPlfG+wKf3knOuL45FfNSg/leJ7NQmDXYNXd8S6DeA/hLfQh765J5Qf0+o79vny+SExm5cdu2bThc0AZ/nIW9kO9tv9mXrldMjftbFD3zqmF/bcqsx7KN4UW9df5e17sDLyv7NPmn8RfXyrDMZtXHhb/1hW9czyrRe7ZDnuypZ4ylpfIT6fRe+91Z0fMS/L1Xku0m8rYi3rO+RlGUtlHgruhb6k+pCTzh2Kvqdl6rAj6S7AP5Lc0LeNjjW57Lxa/l1KKdPNB/EjTs/ZTqIqstY0s3TvHO/OvCG9624jJ8Ab1T3Z4y3XwBvdL00nvbpKF6uz8ffTuDh9hoePmQ8/LIgD3cAk+r/nGEe5sAMc2D2YG3Taj4jbcCyXN/vH4yj6TjqdEb9znm/c3DV+r46/U40Gs5H09Eg6nQHneim6c9G3V43Goxmndmo055Nbpr+eDrqzaL5m3YYtqdvdHHT9A/67Ul30ouig8583h60r6L/PcCK5Ie1jAAA",
  "debug_symbols": "3Z3dbhTJEoTfxddcVGbWX+6rrI4QsOzKkgWInyMdId79jC16zE7XzCjDFITrBu2s+0tnk9HRQfXPfL356+3rL/+8vH339/tPN3/8+fXm7v2bV59v3787fPr67cXN64+3d3e3/7z88X/fpPs/SnrY/tOHV+/uP376/Orj55s/Wnpx8/bdX4f/kAP99+3d25s/Svr2nxc3RYLba3B7C26fg9uX4PY1uH0Lbt+D23ts+xqcbw3OtwbnW8fz7d+3l2SnQI4CJQrUKNCiQI8CHgTacMyieSNyOSWGgxZJR6L+SLzYbVqTfd+05tMpN51Z3GYWzzOLl5nF68zibWbx/tTiuW3Fa768aXf5vqnr40Gk+tCHc/TRE0kfQtKHkvRhJH1kkj7GdtbK1ofXkyO9jz2q6JFoV9ppdWtH/LR4m1m8zyzuE4t7mllcZhbXmcXticVdN527ncYxzzOLl5nF68zibWbxPrO4TywuKU2tLlOr69TqNrV6nlq9TK3+5AM1b4nca8JDgKTG0khnacRJGpHE0oiwNKIsjQyNTXUL5pr76REvQ7dSkSPiO6TEkRpHWhzpccTDiKY4InFE44jFkfj0NT59jU9f49PX+PQ1Pn0bT9+3k6pJ3SHj6Zd6RNoO0ThicSTHkRJHahxpcaTHkeH0rWzTt6KnSE5xROKIxhGLIzmOlDhS40iLIz2OxKdf4tMfX9m06hviaYcMp5/TpuRsskOG08+2nfez98upQpNvCUQPh9Kufp5cv0yuXyfXb5Pr98n1fW798fXiSP2DWx3rd7+ysZVt0Vptd61YxhejpzVT0jFNFNn/zegvbabqcUy1oYv0wX+UVFt/F/P6u1jW38W6/i629Xexr7+LvvwutrT+Lsr6u7h+umnrp5u2frpp66ebtn66aeunm7Z+umnrp5u+frrp66ebvn666eunm75+uunrp5u+frrp66ebvn666eunG18/3fj66cbXTze+frrx9dONr59ufP104+unG18/3fjy6UbT8ulG0/LpRtPy6UbT8ulGU15/F5dPN5qWTzealk83mpZPN5rWTzeyfrqR9dONrJ9uZP10I+unG1k/3cj66UbWTzeyfrqR9dONrp9udP10o+unG10/3ej66UbXTze6frrR9dONrp9udP10Y+unG1s/3dj66cbWTze2frqx9dONrZ9ubP10Y+unG1s/3eT1001eP93k9dNNXj/d5PXTTV4/3eT1001eP93k9dNNIXpjmxZlasaYmslMzRSmZipTM42pmc7UjBM184vfmXmlGSYHrkwOXJkcuDI5cGVy4MrkwJXJgSuTA1cmB25MDtyYHLgxOXBjcuDG5MCNyYEbkwM3JgduTA7cmBy4MzlwZ3LgzuTAncmBO5MDdyYH7kwO3JkcuDM5cGdyYGdyYGdyYGdyYGdyYGdyYGdyYGdyYGdyYGdyYCdyYEtEDmyJyIEtETmwJSIHtkTkwJaIHNgSkQNbInJgS0QObInJgYXJgYXJgYXJgYXJgYXJgYXJgYXJgYXJgYXJgYXJgZXJgZXJgZXJgZXJgZXJgZXJgZXJgZXJgZXJgZXJgY3JgY3JgY3JgY3Jgdd4Brblrd/W04+bPuziEk+JXN7FJZ4SubyLSzwlcnkXf+3JpKXjxk381Bh+8aOcV5oRpmaUqZmJJ5OH+k8/P3jZ6mvKu/plcv06uX6bXL9Pru9z65c0ub5Mrq+T6z/5+FU7nqkOAQ88Uz20knlaKTytVJ5WGk8rnacVp2nl6Y+DaWnHVlr5abHzctfyLLvWZ9m1Pcuu87PsujzLruuz7Lo9y647adcXlwme/vzd7+i6sZ4bL3c9PDcW3SJ9yXqa6MfP3V1GLI7kOFLCyPg5DT38q26bxOFvaAcNf8+Vdejx3f3XIAeg8d3y1yBBIEUgQ6CMQMicxndHX4MaAiGKcEAROSUEEgRSBDIEyghUEKgiUEOgjkCIIgRRhCCKEEQRgihCEEUIoghBFCGIIgRRhCCKUEQRiihCEUUooghFFKGIIhRRhCKKUEQRiijCEEUYoghDFGGIIgxRhCGKMEQRhijCEEUYooiMKCIjisiIIjKiiIwoIiOKyIgiMqKIjCgiI4ooiCIKooiCKKIgiiiIIgqiiIIooiCKKIgiCqKIiiiiIoqoiCIqooiKKKIiiqiIIiqiiIoooiKKaIgixutSv+PFr3m83vV7WjGeVjJPK4WnlcrTSuNppfO04jStjN8r9Xta4XHbzuO2ncdtO4/bdh637Txu23nctvO4bedxW+dxW+dxW+dxW+dxW+dxW+dxW+dxW+dxW+dxW6dx25Jo3LYkGrcticZtS6Jx25Jo3LYkGrcticZtS6Jx25Jo3LYkHrcVHrcVHrcVHrcVHrcVHrcVHrcVHrcVHrcVHrcVHrdVHrdVHrdVHrdVHrdVHrdVHrdVHrdVHrdVHrdVHrc1Hrc1Hrc1Hrc1Hrc1Hrc1Hrc1Hrc1Hrc1Hrc1HrfNPG6bedw287ht5nHbzOO2mcdtM4/bZh63zTxum3nctvC4beFx28LjtoXHbQuP2xYety08blt43Lb8Ure99H6JUpymlZp4WhGeVsYWd/GlnOXMAzFXoIJAFYGGort4yIwfUrmMSBzROGJxJMeREkdqHGlxpMeR+PR7fPo9Pv0en36PT7/Hp9/j0+/x6ff49Ht8+j0+fY9P3+PT9/j0PT59j0/f49P3+PQ9Pn2PT9/D068pxRGJIxpHLI7kOFLiSI0jw+lfCiZ1fKvXRWR885G07N8ZabWdhIU6vk3oGmQIlBGoIFBFoIZAHYGGR6mo6gZpTqfQ+LaLa5AgkCLQWBHi/gjJDsoIVBCoIlBDoI5ADkB2RhFHixAtZQcJAikCGQJlBCoIVBForAit5Qj1f71kMbZyUcdX5X5ifZ9bP6fJ9WVyfZ1c3ybXz8H6D1BBoIpADYE6AjkAlYRAgkDxcDdeSbyIjFf8LiMSRzSOWBzJcaTEkRpH4tF+/O4ZOaxFbpI5LK+cSma8qHcFGi/rXYMEgcbOWaw/QrvDYLy4dw3KCFQQqCJQQ6COQGcU0Y/QIbidQj0hkCCQIpAhUEaggkBjRdTHOR3OcTuoIVBHIAeg8fLfNUgQSBHIECgjUEGgM4o4vsteDieVHdQQqCOQx6GWEgIJAikCGQJlBDqjiJ6PkNsOqgh0RhGtPkLoFdGH+n1yfZ9bX9Lk+jK5vk6ub5Pr52D9B+jM2u3jMdf2x9y5tdvLUHTtNrr7fXJ9n1v/zOLxz6svk+vr5Po2uX4O1n+ACgJVBGoI1BHIAcgSAgEXw9qZ++n6441JXXc2d+bOtytQRyAHoDP3fV2BBIEUgQyBMgIVBEIUURFFVEQRFVHEmTcS9+Ohob2lHXRGEccEoK678/KZdwdfgQyBMgIVBKoI1BCoI5AD0Jl3sfqjInyviDNvTXXfvjzMkuwc9sz7Ta9AhkAZgQoCVQRqCNQRyAHozPsir0CIIhxRhCOKcEQRjijCEUWMV4Us5Ueoyg4aKsLUt8PdbPel5G28KnQZ6uNVoX9DbQcJAikCDRVhdvx2dsup7KCMQOU61HdQRaCGQOMvPU22QYddSjvIAWi8KHMNEgQafxm0HC9J5UOa30GGQBmBxt9ErGU7fWbdXTHr44WOa1BDoB6Fvh0+/ffVx9tXr+/efjow9z/88u7N59v3775//Py/D9tPXn+8vbu7/eflh4/v37z968vHty/v3r+5/9lN+v7Hn83sRSv50MyDZqy1F9b1/uO9Gu7Tatdy+K2H3/x/",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n        assert_eq(refcount_1, 1, \"borrow_mut_two should create a fresh array with an RC of 1\");\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
