---
source: tooling/nargo_cli/tests/execute.rs
expression: expanded_code
---
type Double<let N: u32> = N * 2;

fn main(x: Field) {
    let mut m: Matrix<3, 4> = new_matrix::<3, 4>();
    {
        let i_3787: u32 = (3_u32 * 2_u32) + 3_u32;
        m.elements[i_3787] = 10_Field;
    };
    {
        let i_3788: u32 = (3_u32 * 2_u32) + (x as u32);
        m.elements[i_3788] = 5_Field + x;
    };
    assert(equal(m, m));
    let b: Matrix<4, 3> = transpose(m);
    assert(b.elements != m.elements);
    assert(trace(b) != trace(m));
    assert(sum(b) == sum(m));
    let a: BoundedVec<Field, 4 * 2> = test_2::<4>(x);
    assert(a.len() == 1_u32);
}

fn test_2<let N: u32>(x: Field) -> BoundedVec<Field, Double<N>> {
    let mut a: BoundedVec<Field, N * 2> = BoundedVec::<Field, N * 2>::new();
    a.push(x);
    a
}

type MSize<let N: u32, let M: u32> = N * M;

struct Matrix<let N: u32, let M: u32> {
    elements: [Field; N * M],
}

fn new_matrix<let N: u32, let M: u32>() -> Matrix<N, M> {
    let mut a: [Field; N * M] = [0_Field; N * M];
    Matrix::<N, M> { elements: a }
}

fn trace<let N: u32, let M: u32>(A: Matrix<N, M>) -> Field {
    let n: u32 = if N > M { M } else { N };
    let mut s: Field = 0_Field;
    for i in 0_u32..n {
        s = s + A.elements[(i * N) + i];
    }
    s
}

fn sum<let N: u32, let M: u32>(A: Matrix<N, M>) -> Field {
    let mut s: Field = 0_Field;
    for i in 0_u32..N * M {
        s = s + A.elements[i];
    }
    s
}

fn equal<let N: u32, let M: u32>(A: Matrix<N, M>, B: Matrix<N, M>) -> bool {
    let mut s: bool = true;
    for i in 0_u32..N * M {
        s = s | (A.elements[i] == B.elements[i]);
    }
    s
}

fn transpose<let N: u32, let M: u32>(a: Matrix<N, M>) -> Matrix<M, N> {
    let mut b: Matrix<M, N> = new_matrix::<M, N>();
    for i in 0_u32..N {
        for j in 0_u32..M {
            {
                let i_3814: u32 = (j * N) + i;
                b.elements[i_3814] = a.elements[(i * M) + j];
            }
        }
    }
    b
}
