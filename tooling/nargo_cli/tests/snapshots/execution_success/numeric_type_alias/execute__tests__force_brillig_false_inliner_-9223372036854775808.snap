---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": [
    "func 0",
    "current witness index : _73",
    "private parameters indices : [_0]",
    "public parameters indices : []",
    "return value indices : []",
    "BRILLIG CALL func 0: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(0))], q_c: 0 }), Single(Expression { mul_terms: [], linear_combinations: [], q_c: 4294967296 })], outputs: [Simple(Witness(1)), Simple(Witness(2))]",
    "BLACKBOX::RANGE [(_1, 222)] []",
    "BLACKBOX::RANGE [(_2, 32)] []",
    "EXPR [ (1, _0) (-4294967296, _1) (-1, _2) 0 ]",
    "EXPR [ (-1, _1) (-1, _3) 5096253676302562286669017222071363378443840053029366383258766538131 ]",
    "BLACKBOX::RANGE [(_3, 222)] []",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(-1, Witness(1))], q_c: 5096253676302562286669017222071363378443840053029366383258766538131 })], outputs: [Simple(Witness(4))]",
    "EXPR [ (-1, _1, _4) (5096253676302562286669017222071363378443840053029366383258766538131, _4) (1, _5) -1 ]",
    "EXPR [ (-1, _1, _5) (5096253676302562286669017222071363378443840053029366383258766538131, _5) 0 ]",
    "EXPR [ (1, _2, _5) (268435455, _5) (-1, _6) 0 ]",
    "BLACKBOX::RANGE [(_6, 32)] []",
    "EXPR [ (1, _2) (-1, _7) 6 ]",
    "BRILLIG CALL func 0: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(7))], q_c: 4294967284 }), Single(Expression { mul_terms: [], linear_combinations: [], q_c: 4294967296 })], outputs: [Simple(Witness(8)), Simple(Witness(9))]",
    "BLACKBOX::RANGE [(_9, 32)] []",
    "EXPR [ (1, _7) (-4294967296, _8) (-1, _9) 4294967284 ]",
    "EXPR [ (-1, _8) 0 ]",
    "EXPR [ (-1, _10) 0 ]",
    "EXPR [ (-1, _11) 10 ]",
    "INIT (id: 0, len: 12, witnesses: [_10, _10, _10, _10, _10, _10, _10, _10, _10, _11, _10, _10])",
    "EXPR [ (1, _0) (-1, _12) 5 ]",
    "MEM (id: 0, write EXPR [ (1, _12) 0 ] at: EXPR [ (1, _7) 0 ]) ",
    "MEM (id: 0, read at: EXPR [ (1, _10) 0 ], value: EXPR [ (1, _13) 0 ]) ",
    "EXPR [ (-1, _14) 1 ]",
    "MEM (id: 0, read at: EXPR [ (1, _14) 0 ], value: EXPR [ (1, _15) 0 ]) ",
    "EXPR [ (-1, _16) 2 ]",
    "MEM (id: 0, read at: EXPR [ (1, _16) 0 ], value: EXPR [ (1, _17) 0 ]) ",
    "EXPR [ (-1, _18) 3 ]",
    "MEM (id: 0, read at: EXPR [ (1, _18) 0 ], value: EXPR [ (1, _19) 0 ]) ",
    "EXPR [ (-1, _20) 4 ]",
    "MEM (id: 0, read at: EXPR [ (1, _20) 0 ], value: EXPR [ (1, _21) 0 ]) ",
    "EXPR [ (-1, _22) 5 ]",
    "MEM (id: 0, read at: EXPR [ (1, _22) 0 ], value: EXPR [ (1, _23) 0 ]) ",
    "EXPR [ (-1, _24) 6 ]",
    "MEM (id: 0, read at: EXPR [ (1, _24) 0 ], value: EXPR [ (1, _25) 0 ]) ",
    "EXPR [ (-1, _26) 7 ]",
    "MEM (id: 0, read at: EXPR [ (1, _26) 0 ], value: EXPR [ (1, _27) 0 ]) ",
    "EXPR [ (-1, _28) 8 ]",
    "MEM (id: 0, read at: EXPR [ (1, _28) 0 ], value: EXPR [ (1, _29) 0 ]) ",
    "EXPR [ (-1, _30) 9 ]",
    "MEM (id: 0, read at: EXPR [ (1, _30) 0 ], value: EXPR [ (1, _31) 0 ]) ",
    "MEM (id: 0, read at: EXPR [ (1, _11) 0 ], value: EXPR [ (1, _32) 0 ]) ",
    "EXPR [ (-1, _33) 11 ]",
    "MEM (id: 0, read at: EXPR [ (1, _33) 0 ], value: EXPR [ (1, _34) 0 ]) ",
    "EXPR [ (-1, _15) (1, _21) (-1, _35) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(35))], q_c: 0 })], outputs: [Simple(Witness(36))]",
    "EXPR [ (1, _35, _36) (1, _37) -1 ]",
    "EXPR [ (1, _35, _37) 0 ]",
    "EXPR [ (-1, _17) (1, _29) (-1, _38) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(38))], q_c: 0 })], outputs: [Simple(Witness(39))]",
    "EXPR [ (1, _38, _39) (1, _40) -1 ]",
    "EXPR [ (1, _38, _40) 0 ]",
    "EXPR [ (1, _15) (-1, _19) (-1, _41) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(41))], q_c: 0 })], outputs: [Simple(Witness(42))]",
    "EXPR [ (1, _41, _42) (1, _43) -1 ]",
    "EXPR [ (1, _41, _43) 0 ]",
    "EXPR [ (1, _37, _40) (-1, _44) 0 ]",
    "EXPR [ (-1, _21) (1, _23) (-1, _45) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(45))], q_c: 0 })], outputs: [Simple(Witness(46))]",
    "EXPR [ (1, _45, _46) (1, _47) -1 ]",
    "EXPR [ (1, _45, _47) 0 ]",
    "EXPR [ (1, _43, _44) (-1, _48) 0 ]",
    "EXPR [ (-1, _23) (1, _31) (-1, _49) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(49))], q_c: 0 })], outputs: [Simple(Witness(50))]",
    "EXPR [ (1, _49, _50) (1, _51) -1 ]",
    "EXPR [ (1, _49, _51) 0 ]",
    "EXPR [ (1, _47, _48) (-1, _52) 0 ]",
    "EXPR [ (1, _17) (-1, _25) (-1, _53) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(53))], q_c: 0 })], outputs: [Simple(Witness(54))]",
    "EXPR [ (1, _53, _54) (1, _55) -1 ]",
    "EXPR [ (1, _53, _55) 0 ]",
    "EXPR [ (1, _51, _52) (-1, _56) 0 ]",
    "EXPR [ (1, _25) (-1, _27) (-1, _57) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(57))], q_c: 0 })], outputs: [Simple(Witness(58))]",
    "EXPR [ (1, _57, _58) (1, _59) -1 ]",
    "EXPR [ (1, _57, _59) 0 ]",
    "EXPR [ (1, _55, _56) (-1, _60) 0 ]",
    "EXPR [ (-1, _29) (1, _32) (-1, _61) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(61))], q_c: 0 })], outputs: [Simple(Witness(62))]",
    "EXPR [ (1, _61, _62) (1, _63) -1 ]",
    "EXPR [ (1, _61, _63) 0 ]",
    "EXPR [ (1, _59, _60) (-1, _64) 0 ]",
    "EXPR [ (1, _19) (-1, _31) (-1, _65) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(65))], q_c: 0 })], outputs: [Simple(Witness(66))]",
    "EXPR [ (1, _65, _66) (1, _67) -1 ]",
    "EXPR [ (1, _65, _67) 0 ]",
    "EXPR [ (1, _63, _64) (-1, _68) 0 ]",
    "EXPR [ (1, _27) (-1, _32) (-1, _69) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(69))], q_c: 0 })], outputs: [Simple(Witness(70))]",
    "EXPR [ (1, _69, _70) (1, _71) -1 ]",
    "EXPR [ (1, _69, _71) 0 ]",
    "EXPR [ (1, _67, _68) (-1, _72) 0 ]",
    "EXPR [ (1, _71, _72) 0 ]",
    "BRILLIG CALL func 1: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(-1, Witness(21)), (1, Witness(27)), (-1, Witness(29)), (1, Witness(31))], q_c: 0 })], outputs: [Simple(Witness(73))]",
    "EXPR [ (-1, _21, _73) (1, _27, _73) (-1, _29, _73) (1, _31, _73) -1 ]",
    "unconstrained func 0",
    "[Const { destination: Direct(10), bit_size: Integer(U32), value: 2 }, Const { destination: Direct(11), bit_size: Integer(U32), value: 0 }, CalldataCopy { destination_address: Direct(0), size_address: Direct(10), offset_address: Direct(11) }, BinaryFieldOp { destination: Direct(2), op: IntegerDiv, lhs: Direct(0), rhs: Direct(1) }, BinaryFieldOp { destination: Direct(1), op: Mul, lhs: Direct(2), rhs: Direct(1) }, BinaryFieldOp { destination: Direct(1), op: Sub, lhs: Direct(0), rhs: Direct(1) }, Mov { destination: Direct(0), source: Direct(2) }, Stop { return_data: HeapVector { pointer: Direct(11), size: Direct(10) } }]",
    "unconstrained func 1",
    "[Const { destination: Direct(21), bit_size: Integer(U32), value: 1 }, Const { destination: Direct(20), bit_size: Integer(U32), value: 0 }, CalldataCopy { destination_address: Direct(0), size_address: Direct(21), offset_address: Direct(20) }, Const { destination: Direct(2), bit_size: Field, value: 0 }, BinaryFieldOp { destination: Direct(3), op: Equals, lhs: Direct(0), rhs: Direct(2) }, JumpIf { condition: Direct(3), location: 8 }, Const { destination: Direct(1), bit_size: Field, value: 1 }, BinaryFieldOp { destination: Direct(0), op: Div, lhs: Direct(1), rhs: Direct(0) }, Stop { return_data: HeapVector { pointer: Direct(20), size: Direct(21) } }]"
  ],
  "debug_symbols": "tZbLbqswFEX/xWMGfh+7v3J1FZGEVEiIRBSudBXl32t8NiQdGFVUnXglmL04fmBxF+fmOL0f2v5y/RBvf+7iOLRd174fuuupHttrn67eH5VY/h7GoWnSJfHSn1K3emj6Ubz1U9dV4l/dTfmmj1vdZ471kHplJZr+nJiEl7Zr5l+P6pmW5aiSCmGl9Rp33887veS93JO39md5/8zHPXlj1rzakdcyIK91sX6/Nf64LoBTe1ZAryPQjkr5sDUCFReB1C9z+EUQywIKHnmKpfjm8+Xz+aYk2JoAWmZQU3ELKF0WxLWAaNyeFQjrCsTiHlL2Fwt4zkDcs4mNdMgbVR4AbZ0itJxBSoawpwS1lqDLJcRfLUGWSvib/tWndvhyeAuZprsSKrc6tya3Nrcutz63lNuQ28gphFM67R2V4ml7KMOwDMdIilSXIkZgxAwtGcmSFkdrhmFYhmN4BjECI2YYyWCLYYthi2GLYYthi2GLYYthi2WLZYtlizXzaiRa0IEeJDCAkekkqEANwufgc7Mv7X0Hn4PPwefg85Lv8/B5+Dx8Hj4Pn4fPw+fh8/ARfAQfwUfwEXwEH8FH8BF8BF+AL8AX4AvwBfgCfAG+AF+AL8AX4YsqH71x1qVDOs46/5hfgaGtj12Dj5DL1J9evknG/7elZ/lquQ3XU3OehmZ+BXJfeik+AQ==",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "type Double<let N: u32>: u32 = N * 2;\n\nfn main(x: Field) {\n    let mut m = new_matrix::<3, 4>();\n    m.elements[3 * 2 + 3] = 10;\n    m.elements[3 * 2 + x as u32] = 5 + x;\n    assert(equal(m, m));\n    let b = transpose(m);\n    assert(b.elements != m.elements);\n    assert(trace(b) != trace(m));\n    assert(sum(b) == sum(m));\n\n    let a = test_2::<4>(x);\n    assert(a.len() == 1);\n}\n\nfn test_2<let N: u32>(x: Field) -> BoundedVec<Field, Double<N>> {\n    let mut a = BoundedVec::new();\n    a.push(x);\n    a\n}\n\ntype MSize<let N: u32, let M: u32>: u32 = N * M;\n\nstruct Matrix<let N: u32, let M: u32> {\n    elements: [Field; MSize::<N, M>],\n}\n\nfn new_matrix<let N: u32, let M: u32>() -> Matrix<N, M> {\n    let mut a = [0; MSize::<N, M>];\n    Matrix { elements: a }\n}\n\nfn trace<let N: u32, let M: u32>(A: Matrix<N, M>) -> Field {\n    let n = if N > M { M } else { N };\n    let mut s = 0;\n    for i in 0..n {\n        s += A.elements[i * N + i];\n    }\n    s\n}\n\nfn sum<let N: u32, let M: u32>(A: Matrix<N, M>) -> Field {\n    let mut s = 0;\n    for i in 0..MSize::<N, M> {\n        s += A.elements[i];\n    }\n    s\n}\n\nfn equal<let N: u32, let M: u32>(A: Matrix<N, M>, B: Matrix<N, M>) -> bool {\n    let mut s = true;\n    for i in 0..MSize::<N, M> {\n        s = s | (A.elements[i] == B.elements[i]);\n    }\n    s\n}\n\nfn transpose<let N: u32, let M: u32>(a: Matrix<N, M>) -> Matrix<M, N> {\n    let mut b = new_matrix::<M, N>();\n    for i in 0..N {\n        for j in 0..M {\n            b.elements[j * N + i] = a.elements[i * M + j];\n        }\n    }\n    b\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
