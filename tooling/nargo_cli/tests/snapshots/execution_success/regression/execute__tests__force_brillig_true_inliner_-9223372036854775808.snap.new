---
source: tooling/nargo_cli/tests/execute.rs
assertion_line: 309
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "u",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      },
      {
        "name": "v",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14514982005979867414": {
        "error_kind": "string",
        "string": "attempt to bit-shift with overflow"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dTagkVxW+VdXV/+91z0wycSZCDAoKKna97vdnFrb4kpn8mkkyycJFeO/NvIU7UUEi0SKSnSuRLEREiEQEwYVKNoq4EMGFuBmIulGJElRcaBDEhc6dqdP99VenqvtN39uvJ9MXmu6ue+o7555z7rm/dSswN1Pt+ifIflfo216PzWQS2mH23ZsvJQ6xer5kDG4DGcPbQMboNpCx4kFGH3LGt4mc1dtEzponOU2dhLYV1VYE62jWiFZBNVOcpKDvzaJyI/sfQr7DipU0iK9L/J3e5nZDKZ9D+fsNM9lwOcbfEfyqH/ye+MIn0zE+lkX4RkTH9wRA8yTQPFlAcwloLhXQPAU0TxXQPA00TxfQXAaay0ATAs2zQPMs0TQA0xjXPjo48mzjzTWT71xJWYR3zQ/vrYD4GTPWOeYJ/6bxWp+SgPiJPKwfiXdrQpOO5Qkor5LmyyF5MeSJfW2Mvh/o2LdiyhNZbHomncyLIO8y5VUgT3za8v4QyLGb/fbr4zfjMJbFdRw7o8iPvGyqpWN9iN4iuBaD/m7oB+kprwF5lXSSTzP7XwE+iCVyxET/wex/J/uuwj1yf1fhXyX+E3Ir11gvDYW+odBb/31f9rtlxn2DT6STeMPsuzdnEvw9wA884D8I+JEH/If86GfUd7rgR/4R/kXAr3jAf9iP/BuC/0jqxX8Ggv+oH/k3Bf8xL/pPRv75uBf5N0b4T3jR/07PxiDbhl3MApTnvsyOtKs4xpIkeTieCSivCXkcgzFF9B/LZHk/EY5xmY7lwX5Ug/KwvymycT/ApmH23ZsvbXLZY0WOgPKE9iLJ58nGvdOAaxRe3B/T+o4SjzumvE+CZS/Cepiw8P4q6cTT+KEvstZLZEX+HUVv9cXIOhBZG8eUtQ55XIfLsGyS+N9RysZ1rmwM1vCjk5nHYMJ/UWOwaXoNSXdNRdaukhfQ76bCp6nw0bBCh1g1h1h1h1gcR1h/w+x/b750pI0BHeInWmxxiH+otT0O8Q8aBbZ1hL/DfRRj8jEI/eIkYpDwbxqvMTEpqzeoH45BLUXWrpLHdail8GkpfDSs0CFW1SFWzSEW9w88zRPtc1uCSbMxz8W1IY/XLgyVHxOWyZa1G41xmY7lQV8S2WLKeyn79j3PpvWPQ+Ltp/042PHbfuwcaWs57vC3PLdPV7f8tk9HntunK/taP9ihfftaG+dQPyP/afnBH+mn7QX/4Krgr3nB74/8c90L/mBUvzpe8JMNwe/6wR/55ykv+NsDwT/tx767gn/Gj35G/de7zDhx//VuuO5wLjMJiJ8xev9V+DdJVl/917tJHtYP91/PKrJ2lTxuw88qfM4qfDSs0CFW7BCr6hCr5hCr7hCrsaRlbDrEajnEajvEWnOIte4Qq+MQq+sQ65QjLJt4zWkeuU4vqVxnHMq1l66wVlgrLBdY3Be1aZh99+ZKyagP/y4zlttdvzLZlX7iOZNPknceeN9FefdCHvbFOWnzY1Im2//5wDHmxzAmnqe8eyBPZOuQ7IjhdxzR6wVUVtkjxjxFttDk7S2/bYrp2lvZt9XhG9H4HsQ0pnysoLU1d5F+UHeBM/3sDtaUMgbE+xxcP4kxnvBvGp91cTzGO0fysH54jHdekbVriutuQHnI57zCR8MKHGKFDrFih1hVh1g1h1h1h1iNJS1j0yFWyyFW2yHWmkOsdYdYHYdYXYdYpxxh2cTjsnnkOr2kcp1xKNdeusJaYd25WH7X2Y8/DjtLeTgOw/4pJ20chvsUfn+L+xRENt6n8ED2Y5n2KRhnfJPCPc44Dg0oT2iHpBtP+y9V3cRmEXZJtnjMjulW/PNft+ifbA/BrGQf9g95BoZt9sjKZrk0zWb/XpDN5LkZttkzd7jNeG7Mpr10UlZM0+z5nxOug8+v7JmzJz7zxmlZ7FlUPz+9RPbk/oML3kdHR31tL5cr/O3rDER2mYOJzXguuU36xPKueZDHJpFnnfCZZwTyovyfyQxh5+A+m/3m5/EQ39J9voQuUugWZZPGFJsES2YT7q+K/F8Em7xIum4W2OTLJXSBQifXpV5GICPak3FaoEO5jvORDSqT0H8FyvTyAvwC7RATPvPkuWyZjw6Bnmnwd6jg4/pG2XNAPstbAXlCRf6Y6L9KdvF1No7WPrCOVvF7tvj9NahXX58xfr8yY/x+Zcnid2XJbFIhm4j83wSbfGvG+P3tErqKQrfo+P0dKNNrt3n8rhD9rPF73vj6/SWKr1xmF7yvV+VNn3UTY0UddFwWL7VnI3z4aIfwmSfHb5H/h1CvfkwxAOvo6Oyi65/XS+gihW5RNmlOsUm4ZDbhuWSR/6dgk5+RrlsFNvl5CV2o0HGswviN9uQ19TboUK5r8T4m+l9AmX65AL9AO1QJn3lyfJX2COM3YyC91j5g/K6ZyfJW/ZR3wPJj+6CdkcF9uV+TXbhfNnQjp9o+1GfQaUDy2FR2zl5k9PYZcSPSAdsuLNCHK7vt9MZ+qvU/tbNWtDx+9r8IL1bwWOehgsv8ME876BvpuX/6u8wIln8A59FqMXOY/e/Nkaa1EbwPBuXpepCnBzY/RfjMMyAdivx/gHj6p5LYL/iW7s0SukChW5RN2lNsEi6ZTbjdFvn/Cjb5O+l6rcAm/yihCxU6jvHYbqM9eZ5vHXQo13Fs1qYyCf0/oUxvL8Av0A41wmeeRfEI223GQPppbUzDTJbX05jlcNZ2m/1O6P9LdvF0torabrOOYg86up42WEcGdKS1P9o5eVhn2DdY7kjRZYVoArqO8auof4x509p5zS/MFLnw/lApu0av4dcVeva7WsbA0laoHfcxtpo2V6eNdxcVq7h9YJ48/hb51zId2vjayX5rc3CCb+lOldBFCt2ibNKaYpN4yWwSk01E/nvAJudI1+0Cm9xbQhcrdGXtuNYuC/3onGq4ro3XY6K/D8p0/wL8Au2gtePIk9txjF9afOTxnBaXcQzH8VTysJ3FMTnHO6F/P+ntJM4qXZb1qYDkWba1bJH/w+D3H6E6WrQ+lZTQBQrdsqxPxUtmE46vIv822GS3pC1DmzxQQhcrdBwbfK9PfQzK9PEF+AXaQYt/2rql0GvrU0VzOBxLtXESz59KXtH6FPeFhP4C6a1C9wwd6U2Lr8IL339QSd3z3965aTeb5N0Tscnv3UP+MdE/nukJfRfLMbxFOY+295Oj/v7R/ub+lSuDw33Wk00h6AnPaI+M7ouov8jk/QnfZaJhRPSbfRJ1h+f1s8/jmilj2yTvuuA10+fIJ09izVR7Jwy3v372UiYzPzs9eueJ0e02dCLP+NnpmORh/fCcoR+7Jbk1JpSnquhHbFnWn8W1ZW2uAuM3t2d4ljuv9V7NlNIlTJv20kkZtPco8dyLyWR5ntpmtE1Q8C24fE1wu0b3a5RR0zliXUhvfneU+6sFWC2TjzE2yb5rbS3IfobZ/95cKcmtBUWKjBr/JuiPMTR6HnMxfpP44/14L9KUyVfmx4LDfffvQZ/qc2Gx/Nxu2CS25zpVNWO7Ig2P+YT+CzDHJWtVWjx+MB3jv1DQB8X6jPfKuyBiov8SlP9F+P3bY+Brttbe94DyXCiQ5yWQ4bszyIB8Hi3AfBn0W6tMYjYUObVYwXUA6bU60CEZ8N6Ocl9cwEfmiW0SG2pxSsYIGFvQVzm2+DmnNcmN2yJFRo1/B8rLGBo9zxMwvuBp7+DD9QSbKpDnsl9jfaFJ9RnPNI/TyTLgMzORQs++uK7Qo574jHnUJ+tPqwfo6xzr5P6qQo94vH75jZL5fD9nE499cuQLJl9HNP6iL/TJtRJ6HuczvuBpPslzAhXI8+2TGCfYJ9uQp7WB7JOaD2vn3nfNdH/V9rNiu8BtJLfBL9C4is+nGWb/e3OlsX9xf4ZlY/4t0KHmQ0zP/R3GF7xZxnJ+1m9nH8sJ/0WN5bT4po3ljvu+IFfv0rFpL11hrbBWWCus2bDK5i94Dsgm6cPZtvEaja14rpPv5bGV0L8F47U3lPGj9h5DXkPCODzMvnvzpQ3hJf0Gbc1WdBzR/8BMzvuw3IyN9xoFq8hG2pwRt9O+1idYLjxLVJu/DpVyoD54TvvP0M/ns0TR3mVtcdfkfUfotDm0ornMorX2v4G/rpGM2vxFoMhY1r/Q5rM0mzcoD++LC/gUzQsUvScwMPn5Cpt4XCd9yKI5rKK1ybeVOSzGnHXe806em8B3mdlUgbw7bW6iYfI+7MMf2iQn10/mvwZl1mzO9NPGbYK3bPMCWEfZH7T+ixbDWT9IXzbGQn3WKU9rS7UYrrUzWn9IWy9D3GsQ2y7S3APOhQQF38bkx8A2cTuHWA+lk3yK1gHOUplxP4xmF+7HCf290RjzXPZb67vhHoaOydujaN+vMbO1o1q7q9lFe19yfQassIT3tDaceWt7dpg3nl2EsnI7XVVk0p6jYl9hXLwPy6GtvWjzZ7jPSXxL24NR9qxipMg/69o12kK7Psz+9+ZKG7l9o7GivzLdov7Rx4v2eGxkujzJ5x7L1s797jed/Xx84b+o94hr8Qn1w3s8/Nht7I9azNLGEdpz8UV9f2wLtLXKkOjxt9yP14aZ4bomHzf30kkZtJiK13CPx0ejybKhbYKCb8Hla9y2anth2KY3ypZ99+ZMhsoqOsRYWac8of0VtMUXKG546gurz1do7RY/ey/0z4HMj5b0H1j3vH9v6KQ8+efycX6D2ytj9D362GbFdO0StI08v8G+ydfK9h9xPMb7hk50s9HT9pzz3rGGIpMt+4+orBgnhA7PnS96Z3i1gL7Ivz4F+q7QOKWqyNCg+0+qPRP+TUUfPtoz7T3qqB9e52orsmpjMI472niurfDpKnl76QprhbXCWmGtsFZYK6wV1jsbSxuD8nM3OOcg83OW5lXqb+O5Wtp8xePpOB/pX4fx2Wsl4zN+Bhixh9l3b76UsA7kvzb32VHyggIZA+NnDIlnV2hzmyJbaPJ2xjkMfvbgByVjyBDuK5u71tbIuY+vPVusjfPEHjjOK9tjyWsgiHdj3YT8rGz+W1un1uqE0OM8Ba8n2cT1QOh/AjrnZwG0uh7ANfbBaXtdeb+/tsasrfnhOaY2VSDP5RhWW/ObmPdLp+tH27M0q37EvtpeYD43TFs/0PxDi7Uio3ZeD/r8q8eYt/L1jGZZzOG5FJuOG3N+43neqmxNSYsXOP97jWIO6j8iDPQ1XJN0/bzy/nZ/53BjcLh9sNnf728d63nlZVkj/uMx14g5dgr9X6AP8eZqjXi1RmzGvqX5PdrwYobXmoH2sQJaoZPyN6GMgo9YDUV2+xlm/3tzpUHubAxcM9FiFz+X+D/Q3Xsquj6wvD7i28bOztbuxkFvsH3l8OjKoD8tvrnmP9jc3z7c306S3UFydZBsLpr/4ebWweF1IXpXkxvqmMZ/dB52Os7HvptNtey/tN1ML3gx0a9nPmDrVRf84Qatws/S3VdCd9y2ppJOXmukefoozdML72aal1HyWpAXE5929h/1hVgiR0z0787KLjapwz1yf1fhXyf+E3Ir1zDeMlakXMM+zd2ZjKN1LeDtev3nBk/Cx2ssm/iOl3q1u3W02+8fJP3dK1d3k61p9er/XolaTuW1AAA=",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "global NIBBLE_LENGTH: u32 = 16;\n\nstruct U4 {\n    inner: u8,\n}\n\nimpl U4 {\n    fn zero() -> U4 {\n        U4 { inner: 0 }\n    }\n\n    fn from_u8(x: u8) -> U4 {\n        U4 { inner: x % 16 }\n    }\n}\n\nimpl Eq for U4 {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nfn compact_decode<let N: u32>(input: [u8; N], length: Field) -> ([U4; NIBBLE_LENGTH], Field) {\n    assert(2 * input.len() <= NIBBLE_LENGTH);\n    assert(length as u32 <= input.len());\n\n    let mut nibble = [U4::zero(); NIBBLE_LENGTH];\n\n    let first_nibble = U4::from_u8(input[0] >> 4);\n    let parity = first_nibble.inner as u1;\n\n    if parity == 1 {\n        nibble[0] = U4::from_u8(input[0] & 0x0f);\n        for i in 1..input.len() {\n            if i as u32 < length as u32 {\n                let x = input[i];\n                nibble[2 * i - 1] = U4::from_u8(x >> 4);\n                nibble[2 * i] = U4::from_u8(x & 0x0f);\n            }\n        }\n    } else {\n        for i in 0..2 {\n            if (i as u32) < length as u32 - 1 {\n                let x = input[i + 1];\n                nibble[2 * i] = U4::from_u8(x >> 4);\n                nibble[2 * i + 1] = U4::from_u8(x & 0x0f);\n            }\n        }\n    }\n\n    let out = (nibble, 2 * length + (parity as Field) - 2);\n\n    out\n}\n\nfn enc<let N: u32>(value: [u8; N], value_length: Field) -> ([u8; 32], Field) {\n    assert(value.len() as u8 >= value_length as u8);\n    let mut out_value = [0; 32];\n    if value_length == 0 {\n        let out = (out_value, value_length);\n        out\n    } else if value_length as u8 < 31 {\n        out_value[0] = 0x80 + value_length as u8;\n\n        for i in 1..value.len() {\n            out_value[i] = value[i - 1];\n        }\n\n        let out = (out_value, value_length + 1);\n\n        out\n    } else {\n        let out = (out_value, 32);\n        out\n    }\n}\n\nfn bitshift_literal_0() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 0;\n\n    bits\n}\nfn bitshift_literal_4() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 4;\n\n    bits\n}\nfn bitshift_variable(idx: u8) -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << idx;\n\n    bits\n}\n\nfn main(x: [u8; 5], z: Field, u: i16, v: i16) {\n    //Issue 1144\n    let (nib, len) = compact_decode(x, z);\n    assert(len == 5);\n    assert(\n        [nib[0], nib[1], nib[2], nib[3], nib[4]]\n            == [U4::from_u8(15), U4::from_u8(1), U4::from_u8(12), U4::from_u8(11), U4::from_u8(8)],\n    );\n    // Issue 1169\n    let val1 = [\n        0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41, 0x12, 0x13,\n        0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let val1_length = 20;\n\n    let enc_val1 = enc(val1, val1_length);\n\n    assert(\n        enc_val1.0\n            == [\n                0x94, 0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41,\n                0x12, 0x13, 0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00,\n            ],\n    );\n    assert(enc_val1.1 == 21);\n    // Issue 2399\n    let result_0 = bitshift_literal_0();\n    assert(result_0 == 1);\n    let result_4 = bitshift_literal_4();\n    assert(result_4 == 16);\n    let result_0 = bitshift_variable(0);\n    assert(result_0 == 1);\n    let result_4 = bitshift_variable(4);\n    assert(result_4 == 16);\n\n    // Issue 6609\n    assert(u % -13 == 0);\n    assert(u % v == 0);\n    assert(u % -11 == 4);\n    assert(-u % -11 == -4);\n    assert(u % -11 == u % (v + 2));\n    assert(-u % -11 == -u % (v + 2));\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
