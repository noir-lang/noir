---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "u",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      },
      {
        "name": "v",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14514982005979867414": {
        "error_kind": "string",
        "string": "attempt to bit-shift with overflow"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "global NIBBLE_LENGTH: u32 = 16;\n\nstruct U4 {\n    inner: u8,\n}\n\nimpl U4 {\n    fn zero() -> U4 {\n        U4 { inner: 0 }\n    }\n\n    fn from_u8(x: u8) -> U4 {\n        U4 { inner: x % 16 }\n    }\n}\n\nimpl Eq for U4 {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nfn compact_decode<let N: u32>(input: [u8; N], length: Field) -> ([U4; NIBBLE_LENGTH], Field) {\n    assert(2 * input.len() <= NIBBLE_LENGTH);\n    assert(length as u32 <= input.len());\n\n    let mut nibble = [U4::zero(); NIBBLE_LENGTH];\n\n    let first_nibble = U4::from_u8(input[0] >> 4);\n    let parity = first_nibble.inner as u1;\n\n    if parity == 1 {\n        nibble[0] = U4::from_u8(input[0] & 0x0f);\n        for i in 1..input.len() {\n            if i as u32 < length as u32 {\n                let x = input[i];\n                nibble[2 * i - 1] = U4::from_u8(x >> 4);\n                nibble[2 * i] = U4::from_u8(x & 0x0f);\n            }\n        }\n    } else {\n        for i in 0..2 {\n            if (i as u32) < length as u32 - 1 {\n                let x = input[i + 1];\n                nibble[2 * i] = U4::from_u8(x >> 4);\n                nibble[2 * i + 1] = U4::from_u8(x & 0x0f);\n            }\n        }\n    }\n\n    let out = (nibble, 2 * length + (parity as Field) - 2);\n\n    out\n}\n\nfn enc<let N: u32>(value: [u8; N], value_length: Field) -> ([u8; 32], Field) {\n    assert(value.len() as u8 >= value_length as u8);\n    let mut out_value = [0; 32];\n    if value_length == 0 {\n        let out = (out_value, value_length);\n        out\n    } else if value_length as u8 < 31 {\n        out_value[0] = 0x80 + value_length as u8;\n\n        for i in 1..value.len() {\n            out_value[i] = value[i - 1];\n        }\n\n        let out = (out_value, value_length + 1);\n\n        out\n    } else {\n        let out = (out_value, 32);\n        out\n    }\n}\n\nfn bitshift_literal_0() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 0;\n\n    bits\n}\nfn bitshift_literal_4() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 4;\n\n    bits\n}\nfn bitshift_variable(idx: u8) -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << idx;\n\n    bits\n}\n\nfn main(x: [u8; 5], z: Field, u: i16, v: i16) {\n    //Issue 1144\n    let (nib, len) = compact_decode(x, z);\n    assert(len == 5);\n    assert(\n        [nib[0], nib[1], nib[2], nib[3], nib[4]]\n            == [U4::from_u8(15), U4::from_u8(1), U4::from_u8(12), U4::from_u8(11), U4::from_u8(8)],\n    );\n    // Issue 1169\n    let val1 = [\n        0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41, 0x12, 0x13,\n        0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let val1_length = 20;\n\n    let enc_val1 = enc(val1, val1_length);\n\n    assert(\n        enc_val1.0\n            == [\n                0x94, 0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41,\n                0x12, 0x13, 0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00,\n            ],\n    );\n    assert(enc_val1.1 == 21);\n    // Issue 2399\n    let result_0 = bitshift_literal_0();\n    assert(result_0 == 1);\n    let result_4 = bitshift_literal_4();\n    assert(result_4 == 16);\n    let result_0 = bitshift_variable(0);\n    assert(result_0 == 1);\n    let result_4 = bitshift_variable(4);\n    assert(result_4 == 16);\n\n    // Issue 6609\n    assert(u % -13 == 0);\n    assert(u % v == 0);\n    assert(u % -11 == 4);\n    assert(-u % -11 == -4);\n    assert(u % -11 == u % (v + 2));\n    assert(-u % -11 == -u % (v + 2));\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
