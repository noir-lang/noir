---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 5,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "u",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      },
      {
        "name": "v",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 16
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14514982005979867414": {
        "error_kind": "string",
        "string": "attempt to bit-shift with overflow"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "global NIBBLE_LENGTH: u32 = 16;\n\nstruct U4 {\n    inner: u8,\n}\n\nimpl U4 {\n    fn zero() -> U4 {\n        U4 { inner: 0 }\n    }\n\n    fn from_u8(x: u8) -> U4 {\n        U4 { inner: x % 16 }\n    }\n}\n\nimpl Eq for U4 {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nfn compact_decode<let N: u32>(input: [u8; N], length: Field) -> ([U4; NIBBLE_LENGTH], Field) {\n    assert(2 * input.len() <= NIBBLE_LENGTH);\n    assert(length as u32 <= input.len());\n\n    let mut nibble = [U4::zero(); NIBBLE_LENGTH];\n\n    let first_nibble = U4::from_u8(input[0] >> 4);\n    let parity = first_nibble.inner as u1;\n\n    if parity == 1 {\n        nibble[0] = U4::from_u8(input[0] & 0x0f);\n        for i in 1..input.len() {\n            if i as u32 < length as u32 {\n                let x = input[i];\n                nibble[2 * i - 1] = U4::from_u8(x >> 4);\n                nibble[2 * i] = U4::from_u8(x & 0x0f);\n            }\n        }\n    } else {\n        for i in 0..2 {\n            if (i as u32) < length as u32 - 1 {\n                let x = input[i + 1];\n                nibble[2 * i] = U4::from_u8(x >> 4);\n                nibble[2 * i + 1] = U4::from_u8(x & 0x0f);\n            }\n        }\n    }\n\n    let out = (nibble, 2 * length + (parity as Field) - 2);\n\n    out\n}\n\nfn enc<let N: u32>(value: [u8; N], value_length: Field) -> ([u8; 32], Field) {\n    assert(value.len() as u8 >= value_length as u8);\n    let mut out_value = [0; 32];\n    if value_length == 0 {\n        let out = (out_value, value_length);\n        out\n    } else if value_length as u8 < 31 {\n        out_value[0] = 0x80 + value_length as u8;\n\n        for i in 1..value.len() {\n            out_value[i] = value[i - 1];\n        }\n\n        let out = (out_value, value_length + 1);\n\n        out\n    } else {\n        let out = (out_value, 32);\n        out\n    }\n}\n\nfn bitshift_literal_0() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 0;\n\n    bits\n}\nfn bitshift_literal_4() -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << 4;\n\n    bits\n}\nfn bitshift_variable(idx: u8) -> u64 {\n    let mut bits: u64 = 0;\n    bits |= 1 << idx;\n\n    bits\n}\n\nfn main(x: [u8; 5], z: Field, u: i16, v: i16) {\n    //Issue 1144\n    let (nib, len) = compact_decode(x, z);\n    assert(len == 5);\n    assert(\n        [nib[0], nib[1], nib[2], nib[3], nib[4]]\n            == [U4::from_u8(15), U4::from_u8(1), U4::from_u8(12), U4::from_u8(11), U4::from_u8(8)],\n    );\n    // Issue 1169\n    let val1 = [\n        0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41, 0x12, 0x13,\n        0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let val1_length = 20;\n\n    let enc_val1 = enc(val1, val1_length);\n\n    assert(\n        enc_val1.0\n            == [\n                0x94, 0xb8, 0x8f, 0x61, 0xe6, 0xfb, 0xda, 0x83, 0xfb, 0xff, 0xfa, 0xbe, 0x36, 0x41,\n                0x12, 0x13, 0x74, 0x80, 0x39, 0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x00, 0x00, 0x00, 0x00,\n            ],\n    );\n    assert(enc_val1.1 == 21);\n    // Issue 2399\n    let result_0 = bitshift_literal_0();\n    assert(result_0 == 1);\n    let result_4 = bitshift_literal_4();\n    assert(result_4 == 16);\n    let result_0 = bitshift_variable(0);\n    assert(result_0 == 1);\n    let result_4 = bitshift_variable(4);\n    assert(result_4 == 16);\n\n    // Issue 6609\n    assert(u % -13 == 0);\n    assert(u % v == 0);\n    assert(u % -11 == 4);\n    assert(-u % -11 == -4);\n    assert(u % -11 == u % (v + 2));\n    assert(-u % -11 == -u % (v + 2));\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
