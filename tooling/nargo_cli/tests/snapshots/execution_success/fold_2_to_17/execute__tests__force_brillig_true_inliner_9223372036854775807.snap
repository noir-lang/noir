---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "1022744040332520509",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
