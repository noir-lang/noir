---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
