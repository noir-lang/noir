---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tZndbts4EIXfxde+IIcc/vRViiJwEqcwYDiBmyywCPLuy6PhcZoFRAhSe5PzORaPxfmhSPt993i8f/t5d7o8Pf/affv+vru/ns7n08+78/PD4fX0fGn/fd85/Antb9zvgjcRk2ASTdQkmWSTYlInieYSzSU2F20STKKJmiSTbFJM6iTqTLyJuai5qLmouWhzCU2ySTGpkyRn4k3EJJhEEzUxl2QuyVySueR2SWrS/lmatH/W/a44E28iJu1K75u2S700rabVdfVdpWvoGrtq19Q1d+1+FX7tjrxzBE8QQiBEghISAb4OUAi1g3cEOEeAEOAMjV21K2wrIBMKoXYQR/AEIQRCJCiBztKcBXclhVA7oGoNPEEIgRAJSkgEOgc6Bzqjkn0BeIIQAiESlJAImVAItYPSWemMmhYEE3UsyBEqWRB21PIEqGYDT8CoBMCoDCiE2iE7gicIIRAiQQmJQGeUv+BW0QAToAUMPEEIgRAJSoCzAjKhEGoH9Isg72gYA0R+egvdi+ygZwyUkAilhwX9ElpUBd1hEAiRoIQ+ZXGZUAjwaf0n6A4DT4BzAPRgio8EJdDZ09nT2fc0iTiCJwiBzkJDdEGIgNoBXWCAG0sAIWDKGIUuMFBCImDda9kR1HyoAE8QQiBEghISAU8EByiE2gE1b+AJQggEPGWQC6ztBomQCYVQO6AvDDwBw5EUtENEWNAOE6AdDDxBCIEQCUpIhEygM9ohtsoUtIOBJwghECJBCYkAZ+QL7WBQO6AdDDxBCIHApFQmpTIpeIoYoFraZwW0A+IT0A4xAxIhEwqhdvA9dMF7ghDgUwCRoAQ4V0DmxYXQkxKEzkJnobMEQiQoIRHoLDRE8eNBHFD86gCJkAmFUDvE/pgO0ROEAB8YTluYCZQA5+mazIsLoT//g9JZ6ax01kCIBCUkAp2VhtjLKDKI3YxBJODGkGXsaQww5QQohNoB7WCAnRayjOJXJA7Fb5AImVAItQOK3wA+SDeK3yAQIkEJiZAJzTkhFyj+CVD8Bp4ghECIBCVguGA3iosDIBAiQQmJkAmFUDug+A08gc4o/jRteSNBCYmQCYVQO6D4DeCMLTCK3yAQIkEJiZAJPSlRelJicARPQC7wWWiHKT5oh5SwNXcETxBCIDB0kaGLDB2KP2VAIdQOKP6ET1eGThk6ZVKUzkpnpbMyKcqkKJOSmJRE5zQZfnzsdzzf3L1ej0ccb3478LRj0Mvhery87r5d3s7n/e6fw/ltuujXy+Ey6evh2t5tpXS8PDZthk+n8xH0sf8c7eaHemwqpsFtN3Qbrl/H+/nxAWvKNL5V0ef4/GW8zI9vWwveQNtc1DmHMO+g2HlNBhrcmvE19/HJ65oZSPicQZQ1DtknOuT5OeS/6eBTYhW1bXpZ45BzoEOus3Hwg2LMkcWUY1pjULFHmQyqljUG7YDKW2jnUF0ThupYj+04MBuG0T3cCrKdA2ZbUgc9iXPwZNAerrMGaWNT+7y5q3Gm3NTWQ4MlfT2cxLLG9tv7UuSvWizs7aHFsuYW3djcI4NFzT0yWNjcwzhs7m75TKfEueYchsGxrqusi2NiFGrWjYnI6zqrnegYhHZMW9ecpd4s3GwiwvZyGFr4cOus9gXaOotbOtoXkuvuItyWuobr7kLlNhGNeZ1FurWGlrpuIp/dFWR2IlE2rjIjg0WrzMjgT5RViPEWB82rprFklRgaLFklFgZysEq4jVMYGiyZwsLtZF51NFi2zsnmZQ6H5Y31OLRYtsyNLRYtc0OLZcvc0GLZMje2WLTMjSeyaJlLfuMyNzJYtMyNDP5EWS1b5obTWLJGDA2WrBELA/k/gx/t1eHhdP3yG/YHnK6nw/352F8+vV0efnv39d8XvsPfwF+uzw/Hx7frEU6fP4S3P99j1n2s6Qd+G8XL9v1XzB4v21dN39W5vTr58YGb+Q8=",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
