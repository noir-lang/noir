---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tZjdaiM5EIXfpa99IZVU+smrhBCcpDMYjBM89sIS/O5bparTnlnIsmjZm5yvY9fXLblaLftreVtfrj+eD6f3j5/Lw+PX8nI+HI+HH8/Hj9f95fBxkv9+LUH/pLw80G5JbFEsqkWz6CNysIgWZJGWhySRLdiiWFSLZtFHsFiyRLQgizSiyFGVkKMmkS3E2SWKRbVoFn1EDRbRgiySRbYwSzVLNUs1SzVLM0szSzNLM0szSzNLM0sTSwySzbNb9uAZPckzeWZPr49B3xAVEiADGFAAFdAA3SEGQATAHFVICgwogApogO5AARABBEgAFSYFLc8K3SEFgJazAgESIAMYUAAV0ADdQXvRAELtOT2VNt3I5tktve+iN170zoveepGzJ3u6j93H7mP3FfEVzehJnskze7Jn8ayezVKbNg4gQAJkAAMKoAIaoDtoGxvA3GDWZo5VIQMYUAAV0ADdYfT1gAggAMwd5u5mGh3cFPQUXaECGqA7jA4eoKtMUND1KSowoAAqoAG6gzaugXpIgQAJkAEMKIAKUHNS6A7a0wYRQIAEyAAGqDArNEB3GMvqgAggQAJkAAMKAOYMs3Y8yS1B2vIGEUCABMgABmB6GdPLmF7G9Ba/+Um7nIoCAwqgArRcO0FX6wG6XhtEAAESIAMYUAAVAHOFucHcYG4wN5i1+UkbUptfIY3+ka5L2i0pKBAgATKAAQVQAQ3QHbRbDGBOMI8VUM8+VsABDCiACmiA7jBWwAERQACYM8wZ5tEtOtLxUI763I8AAiRABmDIjCEzhqy9kcb+oTvowmig5qSAIRdMZsFkFpgLzAXmgsksmMyKyayYzApzHcLbbbdgh/N8Oa+rbnB+2fLIRuhzf15Pl+XhdD0ed8sf++N1vOnn5/408rI/y6uiXE9vkiJ8PxxXpdvuXh2+L406Y6NYltutnH+vj9/Xy+fg9TmWe3391+fv1espfHv+f6gnfVJYPeWJ+qQP/FEvn+l39fz/jZ9kI4EByEN/zpA3Q8lThh63SQx9xkDpbsg0YygNXSwLb5ox1Hsr1DQ1k1S2a5BFf8aQQoIhxTh1Da1vhjAzk0wQ8NQs8HZHlsgzd3Qg3BLyLWDKEBM+B/ki0KYMZbsG2TTOGNI2DYJT18C0jYJznTKUvhlanxpF2AzyuJ8y5LwZeGoUZbur5NvE1DXUirtKvjfQ1FPmPg+dZgw1o6Fqnlnne8Yy33lmDnpAO3aaOv92Q/TK/+36/1b/JEf718P5tx9rbmo6H/Yvx9UP36+n119evfz5iVfwY8/n+eN1fbueVzXdf/GRP4/Uw07W0yf99UAOmXcl6IFsrB6T7OzlKf5000v5Cw==",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
