---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tZjbaitHEEX/ZZ710JeqvvhXjDGyPT4IhGx0pEAw+vdUddUenRNwCB3y4r3GUq2ZbtX0tPS1vK0v1x/Ph9P7x8/l4fFreTkfjsfDj+fjx+v+cvg4yX+/lqB/Mi0PabdktigW1aJZ9BEULKJFssjLQ5YgC7YoFtWiWfQRLBaSiBbJIo8oclQl5KhJkIU4u0SxqBbNoo+owSJaJItsQRZmqWapZqlmqWZpZmlmaWZpZmlmaWZpZmliiUGyeXbLHjyjZ/LMnuTp9THoG6JCBhCAAQVQAQ3QHWIARADMUYVJgQEFUAEN0B1SAERAAmSACrOClpNCd8gBoOWskAAZQAAGFEAFNEB30F40gFB7Tk+lTTeyeXZL77vojRe986K3XmTyZE/3sfvYfey+Ir6iGT2TZ/YkT/YsntWzWWrTxgEJkAEEYEABVEADdAdtYwOYG8zazLEqEIABBVABDdAdRl8PiIAEgLnD3N2cRgc3BT1FV6iABugOo4MH6CoTFHR9igoMKIAKaIDuoI1roJ6kkAAZQAAGFEAFqDkrdAftaYMISIAMIAADVEgKDdAdxrI6IAISIAMIwIACgJlg1o5PckskbXmDCEiADCAAAzC9jOllTC9jeovf/Em7PBUFBhRABWi5doKu1gN0vTaIgATIAAIwoAAqAOYKc4O5wdxgbjBr8ydtSG1+hTz6R7oua7fkoJAAGUAABhRABTRAdxgroJ5irIADEiADCMCAAqiABugOBDPBTDATzAQzwTy6RUc6HspRn/sRgCEzhswYMmPI2ht57BYqoAF0yFl3EAEQATAXmAvMBeaCySyYzILJLJhMbRsDfEwV5jqEt9tuwQ7n+XJeV93g/LLlkY3Q5/68ni7Lw+l6PO6WP/bH63jTz8/9aeRlf5ZXRbme3iRF+H44rkq33b06fF8adTJHsSy3Wzn/Xh+/r5fPwesplnt9/dfn79XrU/j2/P9Qn/RJYfWJJuqzPvBHvXym39Xz/zf+JBsJDEAe+nMG2gyFpgw9bpMY+owh5buB0oyhNHSxLLx5xlDvrVDz1Eymsl2DLPozhhwyDDnGqWtofTOEmZnkBAFPzQJvd2SJPHNHh4RbQr4FTBlixucgXwTalKFs1yCbxhlD3qZBcOoaOG2jYKpThtI3Q+tTowibQR73UwaizcBToyjbXSXfJqauoVbcVfK9IU09Ze7z0NOMoRIaqtLMOt8Jy3znmTnoAe3Y09T5txuiV/5v1/+3+ic52r8ezr/9WHNT0/mwfzmufvh+Pb3+8urlz0+8gh97Ps8fr+vb9byq6f6Lj/x5TD3sZD190l8P5JB5V4IeyMbqMcvOXp7iTze9lL8A",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
