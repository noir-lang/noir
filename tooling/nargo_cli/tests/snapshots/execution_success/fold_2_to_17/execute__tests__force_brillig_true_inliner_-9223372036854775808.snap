---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tdvdattMEAbge/GxD3Z3/nZyKx+lOIlTDMYJTvJBCb73yiWSW+9aYV6qkxIVPyuseS3tjqSP1eP2/v3H993h6fl1dfffx2r//LB52z0fhq2P03p1f9zt97sf3//871U6/0P0+/OvL5vDefP1bXN8W91lyuvV9vA4/FVp8E+7/XZ1J+m0bj5KUj4/ylkvH7XTt/WKeMnBZcnBdcnBbcnB65KD+4KDc1py8Lzk4KU7uNunKOmvwc+CwoLDQsJCw8LCooZFN3Ql6ygKXwlJYZHDokSF3tgHyUjyOXl/JUtv7IV4MsrXhgDDfeN5+jrJr40ARgFjgKmA8bixBJgMmAIYAgyQAwNyYEAODMiBATkwIAcVyEEFclCBHFQgBxXIQQVyUIEcVCAHFchBBXLgQA4cyIEDOXAgBw7kwIEcOJADB3LgQA4cyEFOCUEZQf0SFbogLg3qfyetaUTqdI1yQlBGUEEQIYgRJAhSBBmCKoKQRJR+ce0yCzZKDSoIIgQxggRBiiBDUEWQA4gSgvrFLTrFqFiL+oecEo2Icm6QIsgQ1D/kpfqEUnOG7bdKvkD9FshXKCOoIIgQxAgSBCmCDEFIcYWiHYMsHCcSJxonFic1TsKdn6wpTnKclDiJV1/j1dd49TVe/X5HhvLYYCLVE9xMzf3ezT8b3Zccvd8P+mej50VHL4uOTouOzouOLouO3s27lPFaIu0sq9+imiX9DtU8yXFS4oTihONE4kTjxOIkXv0ar36/LyU6TnuluSOQ+22peVLihOKE40TiROPE4qRf/elumGZpiEdJ6Tej5kmOkxInFCccJxInGicWJzVO4tXP8eqX/q34VMbLWE7aooyg/q3zofkwosy1QYQgRpAgqH8bfVg1TKi2B+LGoxVTmYY/mz1RQlBGUEFQv05SpqMnbA1iBAmCFEGGoIogB9CNh2hEfULVG5QRVBBECGIECYIUQYagGz/3NCEqze9JEoIyggqCCEGMIEGQIsgQVBGEJEKRROiNRDBPSJoTixYEEYIYQYIgRZAhqAKXT0WmBIZMCQyZEhhwo6z0H/wZmpDTRU2t3ZMhqCLIAdRvrWSzceE39GtKgzKCCoIIQYwgQZAiyBBUEeQAciQRjiTCkUQ4kghHEuFIIhxJhN94EvlyJfTSohpH1L8Dbzyu7oybx+b7Sy7n8clfl9qQEicUJxwnEl/m042l1hfIEFQR5ADihKCMoIIgQhAjCEkEI4lgJBGMJIKRRAiSCEESIUgiBEmEIIkQJBH9pdbsebW/0PI0Tlu9tMTDZ7z+0md2L/2FzzzhOJE40fjXtzipcdKvy9QzdWsC01/qzJMcJ19diDskfiG2+IW4v/6aJ/HqW7z6Fq++xX+V/VXXPIlPw2p8GlaD1T8NW/9vjrvN/X77+b7u0/vh4Y/Xd99+vmyv3uR9OT4/bB/fj9vzO72X13nPx4RSWlPJ386PeQ+bwmvx88b5y9NwBqbCwz6H/f4C",
  "file_map": {
    "50": {
      "source": "global len: u32 = 2450 * 2 - 240; // for just under 2^17 gates\nfn main(x: Field) {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    let z = foo(x);\n    assert(val == z);\n}\n\n#[fold]\nfn foo(x: Field) -> Field {\n    let ped_input = [x; len];\n    let mut val = poseidon::poseidon2::Poseidon2::hash(ped_input, len);\n    val\n}\n",
      "path": ""
    },
    "57": {
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
