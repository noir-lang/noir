---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "z",
        "type": {
          "kind": "integer",
          "sign": "signed",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": [
    "func 0",
    "current witness index : _2",
    "private parameters indices : [_0, _1, _2]",
    "public parameters indices : []",
    "return value indices : []",
    "BRILLIG CALL func 0: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(0))], q_c: 0 }), Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(1))], q_c: 0 }), Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(2))], q_c: 0 })], outputs: []",
    "unconstrained func 0",
    "[Const { destination: Direct(2), bit_size: Integer(U32), value: 1 }, Const { destination: Direct(1), bit_size: Integer(U32), value: 32839 }, Const { destination: Direct(0), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(4), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(5), bit_size: Integer(U32), value: 0 }, CalldataCopy { destination_address: Direct(32836), size_address: Relative(4), offset_address: Relative(5) }, Cast { destination: Direct(32836), source: Direct(32836), bit_size: Integer(U32) }, Cast { destination: Direct(32837), source: Direct(32837), bit_size: Integer(U32) }, Cast { destination: Direct(32838), source: Direct(32838), bit_size: Integer(U32) }, Mov { destination: Relative(1), source: Direct(32836) }, Mov { destination: Relative(2), source: Direct(32837) }, Mov { destination: Relative(3), source: Direct(32838) }, Call { location: 17 }, Call { location: 18 }, Const { destination: Relative(1), bit_size: Integer(U32), value: 32839 }, Const { destination: Relative(2), bit_size: Integer(U32), value: 0 }, Stop { return_data: HeapVector { pointer: Relative(1), size: Relative(2) } }, Return, Call { location: 194 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(5), op: LessThan, bit_size: U32, lhs: Relative(10), rhs: Relative(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(12), op: Sub, bit_size: U32, lhs: Relative(11), rhs: Relative(1) }, JumpIf { condition: Relative(5), location: 25 }, Jump { location: 27 }, Mov { destination: Relative(6), source: Relative(12) }, Jump { location: 29 }, Mov { destination: Relative(6), source: Relative(1) }, Jump { location: 29 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(7), op: LessThan, bit_size: U32, lhs: Relative(10), rhs: Relative(2) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(12), op: Sub, bit_size: U32, lhs: Relative(11), rhs: Relative(2) }, JumpIf { condition: Relative(7), location: 35 }, Jump { location: 37 }, Mov { destination: Relative(8), source: Relative(12) }, Jump { location: 39 }, Mov { destination: Relative(8), source: Relative(2) }, Jump { location: 39 }, BinaryIntOp { destination: Relative(4), op: Div, bit_size: U32, lhs: Relative(6), rhs: Relative(8) }, BinaryIntOp { destination: Relative(9), op: Xor, bit_size: U1, lhs: Relative(5), rhs: Relative(7) }, JumpIf { condition: Relative(9), location: 43 }, Jump { location: 45 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(4), op: Sub, bit_size: U32, lhs: Relative(10), rhs: Relative(4) }, BinaryIntOp { destination: Relative(5), op: Equals, bit_size: U32, lhs: Relative(4), rhs: Relative(3) }, JumpIf { condition: Relative(5), location: 49 }, Const { destination: Relative(6), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(6) } }, Cast { destination: Relative(4), source: Relative(1), bit_size: Field }, Const { destination: Relative(5), bit_size: Field, value: 340282366920938463463374607431768211456 }, BinaryFieldOp { destination: Relative(6), op: Sub, lhs: Relative(5), rhs: Relative(4) }, Cast { destination: Relative(7), source: Relative(6), bit_size: Integer(U32) }, Cast { destination: Relative(4), source: Relative(7), bit_size: Field }, Cast { destination: Relative(6), source: Relative(4), bit_size: Integer(U32) }, Cast { destination: Relative(7), source: Relative(3), bit_size: Field }, BinaryFieldOp { destination: Relative(8), op: Sub, lhs: Relative(5), rhs: Relative(7) }, Cast { destination: Relative(9), source: Relative(8), bit_size: Integer(U32) }, Cast { destination: Relative(7), source: Relative(9), bit_size: Field }, Cast { destination: Relative(8), source: Relative(7), bit_size: Integer(U32) }, Cast { destination: Relative(9), source: Relative(2), bit_size: Field }, BinaryFieldOp { destination: Relative(10), op: Sub, lhs: Relative(5), rhs: Relative(9) }, Cast { destination: Relative(9), source: Relative(10), bit_size: Integer(U32) }, Cast { destination: Relative(5), source: Relative(9), bit_size: Field }, Cast { destination: Relative(9), source: Relative(5), bit_size: Integer(U32) }, BinaryIntOp { destination: Relative(5), op: Add, bit_size: U32, lhs: Relative(1), rhs: Relative(6) }, Mov { destination: Relative(10), source: Relative(5) }, Cast { destination: Relative(5), source: Relative(10), bit_size: Integer(U32) }, Cast { destination: Relative(11), source: Relative(1), bit_size: Integer(U32) }, Cast { destination: Relative(12), source: Relative(4), bit_size: Integer(U32) }, Const { destination: Relative(4), bit_size: Integer(U32), value: 2147483648 }, BinaryIntOp { destination: Relative(13), op: LessThan, bit_size: U32, lhs: Relative(11), rhs: Relative(4) }, BinaryIntOp { destination: Relative(11), op: LessThan, bit_size: U32, lhs: Relative(12), rhs: Relative(4) }, BinaryIntOp { destination: Relative(12), op: Equals, bit_size: U1, lhs: Relative(13), rhs: Relative(11) }, BinaryIntOp { destination: Relative(11), op: LessThan, bit_size: U32, lhs: Relative(5), rhs: Relative(4) }, BinaryIntOp { destination: Relative(5), op: Equals, bit_size: U1, lhs: Relative(11), rhs: Relative(13) }, BinaryIntOp { destination: Relative(11), op: Mul, bit_size: U1, lhs: Relative(5), rhs: Relative(12) }, BinaryIntOp { destination: Relative(5), op: Equals, bit_size: U1, lhs: Relative(11), rhs: Relative(12) }, JumpIf { condition: Relative(5), location: 80 }, Call { location: 200 }, Const { destination: Relative(5), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(11), op: Equals, bit_size: U32, lhs: Relative(10), rhs: Relative(5) }, JumpIf { condition: Relative(11), location: 85 }, Const { destination: Relative(12), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(12) } }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(3), rhs: Relative(8) }, Mov { destination: Relative(11), source: Relative(10) }, Cast { destination: Relative(10), source: Relative(11), bit_size: Integer(U32) }, Cast { destination: Relative(12), source: Relative(3), bit_size: Integer(U32) }, Cast { destination: Relative(13), source: Relative(7), bit_size: Integer(U32) }, BinaryIntOp { destination: Relative(7), op: LessThan, bit_size: U32, lhs: Relative(12), rhs: Relative(4) }, BinaryIntOp { destination: Relative(12), op: LessThan, bit_size: U32, lhs: Relative(13), rhs: Relative(4) }, BinaryIntOp { destination: Relative(13), op: Equals, bit_size: U1, lhs: Relative(7), rhs: Relative(12) }, BinaryIntOp { destination: Relative(12), op: LessThan, bit_size: U32, lhs: Relative(10), rhs: Relative(4) }, BinaryIntOp { destination: Relative(4), op: Equals, bit_size: U1, lhs: Relative(12), rhs: Relative(7) }, BinaryIntOp { destination: Relative(7), op: Mul, bit_size: U1, lhs: Relative(4), rhs: Relative(13) }, BinaryIntOp { destination: Relative(4), op: Equals, bit_size: U1, lhs: Relative(7), rhs: Relative(13) }, JumpIf { condition: Relative(4), location: 99 }, Call { location: 200 }, BinaryIntOp { destination: Relative(4), op: Equals, bit_size: U32, lhs: Relative(11), rhs: Relative(5) }, JumpIf { condition: Relative(4), location: 103 }, Const { destination: Relative(7), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(7) } }, Const { destination: Relative(13), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(5), op: LessThan, bit_size: U32, lhs: Relative(13), rhs: Relative(6) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(15), op: Sub, bit_size: U32, lhs: Relative(14), rhs: Relative(6) }, JumpIf { condition: Relative(5), location: 109 }, Jump { location: 111 }, Mov { destination: Relative(7), source: Relative(15) }, Jump { location: 113 }, Mov { destination: Relative(7), source: Relative(6) }, Jump { location: 113 }, Const { destination: Relative(13), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(10), op: LessThan, bit_size: U32, lhs: Relative(13), rhs: Relative(2) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(15), op: Sub, bit_size: U32, lhs: Relative(14), rhs: Relative(2) }, JumpIf { condition: Relative(10), location: 119 }, Jump { location: 121 }, Mov { destination: Relative(11), source: Relative(15) }, Jump { location: 123 }, Mov { destination: Relative(11), source: Relative(2) }, Jump { location: 123 }, BinaryIntOp { destination: Relative(4), op: Div, bit_size: U32, lhs: Relative(7), rhs: Relative(11) }, BinaryIntOp { destination: Relative(12), op: Xor, bit_size: U1, lhs: Relative(5), rhs: Relative(10) }, JumpIf { condition: Relative(12), location: 127 }, Jump { location: 129 }, Const { destination: Relative(13), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(4), op: Sub, bit_size: U32, lhs: Relative(13), rhs: Relative(4) }, BinaryIntOp { destination: Relative(2), op: Equals, bit_size: U32, lhs: Relative(4), rhs: Relative(8) }, JumpIf { condition: Relative(2), location: 133 }, Const { destination: Relative(5), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(5) } }, Const { destination: Relative(12), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(4), op: LessThan, bit_size: U32, lhs: Relative(12), rhs: Relative(6) }, Const { destination: Relative(13), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(14), op: Sub, bit_size: U32, lhs: Relative(13), rhs: Relative(6) }, JumpIf { condition: Relative(4), location: 139 }, Jump { location: 141 }, Mov { destination: Relative(5), source: Relative(14) }, Jump { location: 143 }, Mov { destination: Relative(5), source: Relative(6) }, Jump { location: 143 }, Const { destination: Relative(12), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(7), op: LessThan, bit_size: U32, lhs: Relative(12), rhs: Relative(9) }, Const { destination: Relative(13), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(14), op: Sub, bit_size: U32, lhs: Relative(13), rhs: Relative(9) }, JumpIf { condition: Relative(7), location: 149 }, Jump { location: 151 }, Mov { destination: Relative(10), source: Relative(14) }, Jump { location: 153 }, Mov { destination: Relative(10), source: Relative(9) }, Jump { location: 153 }, BinaryIntOp { destination: Relative(2), op: Div, bit_size: U32, lhs: Relative(5), rhs: Relative(10) }, BinaryIntOp { destination: Relative(11), op: Xor, bit_size: U1, lhs: Relative(4), rhs: Relative(7) }, JumpIf { condition: Relative(11), location: 157 }, Jump { location: 159 }, Const { destination: Relative(12), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(2), op: Sub, bit_size: U32, lhs: Relative(12), rhs: Relative(2) }, BinaryIntOp { destination: Relative(4), op: Equals, bit_size: U32, lhs: Relative(2), rhs: Relative(3) }, JumpIf { condition: Relative(4), location: 163 }, Const { destination: Relative(5), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(5) } }, Const { destination: Relative(10), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(3), op: LessThan, bit_size: U32, lhs: Relative(10), rhs: Relative(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(12), op: Sub, bit_size: U32, lhs: Relative(11), rhs: Relative(1) }, JumpIf { condition: Relative(3), location: 169 }, Jump { location: 171 }, Mov { destination: Relative(4), source: Relative(12) }, Jump { location: 173 }, Mov { destination: Relative(4), source: Relative(1) }, Jump { location: 173 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 2147483647 }, BinaryIntOp { destination: Relative(5), op: LessThan, bit_size: U32, lhs: Relative(10), rhs: Relative(9) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(12), op: Sub, bit_size: U32, lhs: Relative(11), rhs: Relative(9) }, JumpIf { condition: Relative(5), location: 179 }, Jump { location: 181 }, Mov { destination: Relative(6), source: Relative(12) }, Jump { location: 183 }, Mov { destination: Relative(6), source: Relative(9) }, Jump { location: 183 }, BinaryIntOp { destination: Relative(2), op: Div, bit_size: U32, lhs: Relative(4), rhs: Relative(6) }, BinaryIntOp { destination: Relative(7), op: Xor, bit_size: U1, lhs: Relative(3), rhs: Relative(5) }, JumpIf { condition: Relative(7), location: 187 }, Jump { location: 189 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(2), op: Sub, bit_size: U32, lhs: Relative(10), rhs: Relative(2) }, BinaryIntOp { destination: Relative(1), op: Equals, bit_size: U32, lhs: Relative(2), rhs: Relative(8) }, JumpIf { condition: Relative(1), location: 193 }, Const { destination: Relative(3), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(3) } }, Return, Const { destination: Direct(32772), bit_size: Integer(U32), value: 30720 }, BinaryIntOp { destination: Direct(32771), op: LessThan, bit_size: U32, lhs: Direct(0), rhs: Direct(32772) }, JumpIf { condition: Direct(32771), location: 199 }, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 17843811134343075018 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 5019202896831570965 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return]"
  ],
  "debug_symbols": "tZfNTipBEIXfZdYsuqr611cxxqCOhoQAQbjJjeHdbzVVR3ExhjDeDd/BoT5quuzW+Rhexqfj2+Nq87p9H+7uP4an/Wq9Xr09rrfPy8Nqu9Gffgyhv1Ab7mgxcDCQgQ1iiIZkyIZiqAaziFnELGIWMYuYRcwiZhGziFnELNEs0SzRLNEs0SxRLazIhmKoBrXkxZDUUhRkUEtViCEaei9akXozouzdRGV1NmPuDennc++oKVXGQSnO6OxdaXc5O4uzOpuxBCc52SnO6HRfcV9xX3FfcV/tPr2PSk52ijM6u0/vs2ZncVZnM7bgJCc7xRmd7mvua+5r7mvdp+tHISAQAiN0Z+ohIiSEjFAQKkLzQAGBEBgBZoKZYCaYCWaCmWBmmBlmhplhZpgZZoaZYWaY+x5h/cWkvkssEAIjdHPpISIkhIxQECpC89B3jgVCYASYI8wR5ghzhDnCHGFOMCeYE8wJ5gRzgjnBnGBOMPe9xbqnqG8uC4TACN3ceogICSEjFISK0Dyct9k5EAIjwFxgLjAXmAvMBeYCc4W5wlxhrjBXmCvMFeYKc4W57zzRE4T61rNACNzD6bQYcHg/Hvbj2M/ui9Ncz/jdcj9uDsPd5rheL4Y/y/Xx/KH33XJz5mG516uqHDcvShW+rtZjT6fFV3WYLtXmvJha+ixPN9RzCDfUs1TUZ5qql+n6yqW4oErgT4O0b4b4wx0E6ee/rUEQjlOONO0QLuQKjV/rSHx9F5zLRRd5qour16JNGX6aRo24jVCmptFmT4PCL4yDaPY8fu7jyoG0/zkQEWwvSTI1EErzJ5J/YyJl/kTyL0zk+vW4aSQZiyH1lhPvsv6WE1ca6iOFmfW3fH/kz/oY5tUnuqW+Mupbm1WfQryhPklCfczz6tP3M/ZB3y2fV/tvT3Snbtqvlk/r0d++HjfPF1cPf3e4gifC3X77PL4c92M3XTwW6us9tbig1h76v8X6Vv9qLzjww6l//T8=",
  "file_map": {
    "12": {
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n",
      "path": "std/convert.nr"
    },
    "39": {
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        wrapping_add_hlp(self, y)\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        wrapping_sub_hlp(self, y) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        wrapping_sub_hlp(self, y) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        wrapping_sub_hlp(self, y) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        wrapping_sub_hlp(self, y) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n",
      "path": "std/ops/arith.nr"
    },
    "50": {
      "source": "use std::ops::WrappingSub;\n\n// Testing signed integer division:\n//  7/3  = 2\n// -7/3  = -2\n// -7/-3 = 2\n//  7/-3 = -2\nfn main(mut x: i32, mut y: i32, mut z: i32) {\n    // 7/3 = 2\n    assert(x / y == z);\n    // -7/3 = -2\n    let minus_x = (0 as i32).wrapping_sub(x);\n    let minus_z = (0 as i32).wrapping_sub(z);\n    let minus_y = (0 as i32).wrapping_sub(y);\n    assert(x + minus_x == 0);\n    assert(z + minus_z == 0);\n    assert(minus_x / y == minus_z);\n    // -7/-3 = 2\n    assert(minus_x / minus_y == z);\n    // 7/-3 = -2\n    assert(x / minus_y == minus_z);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
