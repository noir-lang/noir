---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
