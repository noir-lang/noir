---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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OSVTn1My9Tklpc8pKX1OSelzSkqfU7LBCSkfwe5zSkqfU1L6nJLS55SULqckmy6nJPd59g73efYO93n2DpsupyT3efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2Dvd59g73efYO93n2TmpwGgzHHdulH9hbgMs1773NulA4BojaAVg7QNIOIMoBrp9NUQtgtQM47QBeOwBpB7heySl3ODJ0U4e7ftrBZ7C5T+zUJ7Z0iX39tIPPYNs+sV2f2L5PbOoTu88p6fqckq7PKen6nJKuzynp+5ySvs8p6fuckr7PKXn9tIPPYPc5JX2fU9L3OSV9n1PS9zklqc8pSX1OSepzSlKfU/L6aQefwe5zSlKfU5L6nJLU55SkPqdk6HNKhj6nZOhzSoY+p+T10w4+g93nlAx9TsnQ55QMfU7J0OeUjH1OydjnlIx9TsnY55S8ftrBZ7D7nJKxzykZ+5ySsc8pGfucktznlOQ+pyT3OSW5zyl5/bSDz2D3OSW5zynJfU5J7nNKcp9TMvU5JVOfUzL1OSVTn1Py+mkHn8Huc0qmPqdk6nNKpj6nZOpzSkqfU1L6nJLS55SUPqfk9dMOPoPd55QU1CnJxN+XcjJHbNQpWcFWnJJbANENIMZoB7DaAZx2AK8dgLQDBO0Al7sOWc4BjrvX5fopDrUASTvA5UoONv8dBMuHANdPcagFsNoBnHYArx2AtAME7QBRO8DlSg5scgAxtcbFtF/86GH5Yjlz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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via(self, ordering: fn(T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn(T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn(T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32>(\n    arr: [T; N],\n    sortfn: unconstrained fn(T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
