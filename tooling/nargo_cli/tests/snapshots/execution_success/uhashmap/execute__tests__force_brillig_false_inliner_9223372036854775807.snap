---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
