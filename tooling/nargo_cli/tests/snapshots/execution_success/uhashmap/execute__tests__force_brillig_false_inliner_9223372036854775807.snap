---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
