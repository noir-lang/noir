---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
