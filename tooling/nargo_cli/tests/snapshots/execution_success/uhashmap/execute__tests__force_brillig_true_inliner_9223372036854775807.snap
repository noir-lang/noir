---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
