---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
