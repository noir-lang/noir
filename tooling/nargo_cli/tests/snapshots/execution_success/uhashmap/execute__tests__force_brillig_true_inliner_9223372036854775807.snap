---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
