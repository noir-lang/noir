---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {\n    __static_assert(predicate, message)\n}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
