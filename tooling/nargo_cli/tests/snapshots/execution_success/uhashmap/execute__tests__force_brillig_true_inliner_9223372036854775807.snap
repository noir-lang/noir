---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
