---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
