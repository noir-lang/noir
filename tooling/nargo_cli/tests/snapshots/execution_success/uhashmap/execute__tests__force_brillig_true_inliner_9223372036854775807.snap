---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
