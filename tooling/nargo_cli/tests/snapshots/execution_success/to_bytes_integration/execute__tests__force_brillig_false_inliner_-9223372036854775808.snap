---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "a",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "fn main(x: Field, a: Field) {\n    let y: Field = 2040124;\n    let be_byte_array: [u8; 31] = y.to_be_bytes();\n    let le_byte_array: [u8; 31] = x.to_le_bytes();\n\n    assert(le_byte_array[0] == 60);\n    assert(le_byte_array[0] == be_byte_array[30]);\n    assert(le_byte_array[1] == be_byte_array[29]);\n    assert(le_byte_array[2] == be_byte_array[28]);\n\n    let z = 0 - 1;\n    let p_bytes = std::field::modulus_le_bytes();\n    let z_bytes: [u8; 32] = z.to_le_bytes();\n    assert(p_bytes[10] == z_bytes[10]);\n    assert(p_bytes[0] == z_bytes[0] as u8 + 1 as u8);\n\n    let p_bits = std::field::modulus_le_bits();\n    let z_bits: [u1; 254] = z.to_le_bits();\n    assert(z_bits[0] == 0);\n    assert(p_bits[100] == z_bits[100]);\n\n    let _: [u1; 254] = a.to_le_bits();\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_to_radix"
  ]
}
