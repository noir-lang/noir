---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "a",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "fn main(x: Field, a: Field) {\n    let y: Field = 2040124;\n    let be_byte_array: [u8; 31] = y.to_be_bytes();\n    let le_byte_array: [u8; 31] = x.to_le_bytes();\n\n    assert(le_byte_array[0] == 60);\n    assert(le_byte_array[0] == be_byte_array[30]);\n    assert(le_byte_array[1] == be_byte_array[29]);\n    assert(le_byte_array[2] == be_byte_array[28]);\n\n    let z = 0 - 1;\n    let p_bytes = std::field::modulus_le_bytes();\n    let z_bytes: [u8; 32] = z.to_le_bytes();\n    assert(p_bytes[10] == z_bytes[10]);\n    assert(p_bytes[0] == z_bytes[0] as u8 + 1 as u8);\n\n    let p_bits = std::field::modulus_le_bits();\n    let z_bits: [u1; 254] = z.to_le_bits();\n    assert(z_bits[0] == 0);\n    assert(p_bits[100] == z_bits[100]);\n\n    let _: [u1; 254] = a.to_le_bits();\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_to_radix"
  ]
}
