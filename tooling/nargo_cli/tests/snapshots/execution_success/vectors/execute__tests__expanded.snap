---
source: tooling/nargo_cli/tests/execute.rs
expression: expanded_code
---
use std::vector;

fn main(x: Field, y: pub Field) {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    assert(vector[0_u32] == 0_Field);
    assert(vector[0_u32] != 1_Field);
    vector[0_u32] = x;
    assert(vector[0_u32] == x);
    let vector_plus_10: [Field] = vector.push_back(y);
    assert(vector_plus_10[2_u32] == 10_Field);
    assert(vector_plus_10[2_u32] != 8_Field);
    assert(vector_plus_10.len() == 3_u32);
    let mut new_vector: [u32] = [].as_vector();
    for i in 0_u32..5_u32 {
        new_vector = new_vector.push_back(i);
    }
    assert(new_vector.len() == 5_u32);
    new_vector = new_vector.push_front(20_u32);
    assert(new_vector[0_u32] == 20_u32);
    assert(new_vector.len() == 6_u32);
    let (popped_vector, last_elem): ([u32], u32) = new_vector.pop_back();
    assert(last_elem == 4_u32);
    assert(popped_vector.len() == 5_u32);
    let (first_elem, rest_of_vector): (u32, [u32]) = popped_vector.pop_front();
    assert(first_elem == 20_u32);
    assert(rest_of_vector.len() == 4_u32);
    new_vector = rest_of_vector.insert(2_u32, 100_u32);
    assert(new_vector[2_u32] == 100_u32);
    assert(new_vector[4_u32] == 3_u32);
    assert(new_vector.len() == 5_u32);
    let (remove_vector, removed_elem): ([u32], u32) = new_vector.remove(3_u32);
    assert(removed_elem == 2_u32);
    assert(remove_vector[3_u32] == 3_u32);
    assert(remove_vector.len() == 4_u32);
    let append: [Field] =
        [1_Field, 2_Field].as_vector().append([3_Field, 4_Field, 5_Field].as_vector());
    assert(append.len() == 5_u32);
    assert(append[0_u32] == 1_Field);
    assert(append[4_u32] == 5_Field);
    let mapped: [Field] = [1_Field, 2_Field].as_vector().map(|x: Field| -> Field { x + 1_Field });
    assert(mapped == [2_Field, 3_Field].as_vector());
    assert(
        [1_Field, 2_Field, 3_Field].as_vector().fold(0_Field, |acc: Field, x: Field| -> Field {
            acc + x
        })
            == 6_Field,
    );
    assert(
        [1_Field, 2_Field, 3_Field].as_vector().reduce(|acc: Field, x: Field| -> Field { acc + x })
            == 6_Field,
    );
    assert([2_u32, 4_u32, 6_u32].as_vector().all(|x: u32| -> bool { x > 0_u32 }));
    assert([2_u32, 4_u32, 6_u32].as_vector().any(|x: u32| -> bool { x > 5_u32 }));
    regression_2083();
    regression_merge_vectors(x, y);
    regression_2370();
    regression_4418(x);
    regression_vector_call_result(x, y);
    regression_4506();
    regression_vector_to_brillig((x as u32) % 3_u32);
}

fn regression_2083() {
    let y: [(Field, Field)] = [(1_Field, 2_Field)].as_vector();
    let y: [(Field, Field)] = y.push_back((3_Field, 4_Field));
    let y: [(Field, Field)] = y.push_back((5_Field, 6_Field));
    assert(y[2_u32].1 == 6_Field);
    let y: [(Field, Field)] = y.push_front((10_Field, 11_Field));
    let y: [(Field, Field)] = y.push_front((12_Field, 13_Field));
    assert(y[1_u32].0 == 10_Field);
    let y: [(Field, Field)] = y.insert(1_u32, (55_Field, 56_Field));
    assert(y[0_u32].1 == 13_Field);
    assert(y[1_u32].1 == 56_Field);
    assert(y[2_u32].0 == 10_Field);
    let (y, x): ([(Field, Field)], (Field, Field)) = y.remove(2_u32);
    assert(y[2_u32].0 == 1_Field);
    assert(x.0 == 10_Field);
    assert(x.1 == 11_Field);
    let (x, y): ((Field, Field), [(Field, Field)]) = y.pop_front();
    assert(y[0_u32].0 == 55_Field);
    assert(x.0 == 12_Field);
    assert(x.1 == 13_Field);
    let (y, x): ([(Field, Field)], (Field, Field)) = y.pop_back();
    assert(y.len() == 3_u32);
    assert(x.0 == 5_Field);
    assert(x.1 == 6_Field);
}

fn regression_merge_vectors(x: Field, y: Field) {
    merge_vectors_if(x, y);
    merge_vectors_else(x);
}

fn merge_vectors_if(x: Field, y: Field) {
    let vector: [Field] = merge_vectors_return(x, y);
    assert(vector.len() == 3_u32);
    assert(vector[2_u32] == 10_Field);
    let vector: [Field] = merge_vectors_mutate(x, y);
    assert(vector.len() == 4_u32);
    assert(vector[3_u32] == 5_Field);
    let vector: [Field] = merge_vectors_mutate_in_loop(x, y);
    assert(vector.len() == 7_u32);
    assert(vector[6_u32] == 4_Field);
    let vector: [Field] = merge_vectors_mutate_two_ifs(x, y);
    assert(vector.len() == 6_u32);
    assert(vector[3_u32] == 5_Field);
    assert(vector[4_u32] == 15_Field);
    assert(vector[5_u32] == 30_Field);
    let vector: [Field] = merge_vectors_mutate_between_ifs(x, y);
    assert(vector.len() == 8_u32);
    assert(vector[3_u32] == 5_Field);
    assert(vector[4_u32] == 30_Field);
    assert(vector[5_u32] == 15_Field);
    assert(vector[6_u32] == 50_Field);
    assert(vector[7_u32] == 60_Field);
    merge_vectors_push_then_pop(x, y);
    let vector: [Field] = merge_vectors_push_then_insert(x, y);
    assert(vector.len() == 7_u32);
    assert(vector[1_u32] == 50_Field);
    assert(vector[2_u32] == 0_Field);
    assert(vector[5_u32] == 30_Field);
    assert(vector[6_u32] == 100_Field);
    let vector: [Field] = merge_vectors_remove_between_ifs(x, y);
    assert(vector.len() == 5_u32);
}

fn merge_vectors_else(x: Field) {
    let vector: [Field] = merge_vectors_return(x, 5_Field);
    assert(vector[0_u32] == 0_Field);
    assert(vector[1_u32] == 0_Field);
    assert(vector.len() == 2_u32);
    let vector: [Field] = merge_vectors_mutate(x, 5_Field);
    assert(vector[2_u32] == 5_Field);
    assert(vector.len() == 3_u32);
    let vector: [Field] = merge_vectors_mutate_in_loop(x, 5_Field);
    assert(vector[2_u32] == 5_Field);
    assert(vector.len() == 3_u32);
}

fn merge_vectors_return(x: Field, y: Field) -> [Field] {
    let vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        if x != 20_Field {
            vector.push_back(y)
        } else {
            vector
        }
    } else {
        vector
    }
}

fn merge_vectors_mutate(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    vector
}

fn merge_vectors_mutate_in_loop(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        for i in 0_u32..5_u32 {
            vector = vector.push_back(i as Field);
        }
    } else {
        vector = vector.push_back(x);
    };
    vector
}

fn merge_vectors_mutate_two_ifs(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    if x == 20_Field {
        vector = vector.push_back(20_Field);
    };
    vector = vector.push_back(15_Field);
    vector = vector.push_back(30_Field);
    vector
}

fn merge_vectors_mutate_between_ifs(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    vector = vector.push_back(30_Field);
    if x == 20_Field {
        vector = vector.push_back(20_Field);
    };
    vector = vector.push_back(15_Field);
    if x != 20_Field {
        vector = vector.push_back(50_Field);
    };
    vector = vector.push_back(60_Field);
    vector
}

fn merge_vectors_push_then_pop(x: Field, y: Field) {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    vector = vector.push_back(30_Field);
    if x == 20_Field {
        vector = vector.push_back(20_Field);
    };
    let (vector, elem): ([Field], Field) = vector.pop_back();
    assert(vector.len() == 4_u32);
    assert(elem == 30_Field);
    let (vector, elem): ([Field], Field) = vector.pop_back();
    assert(vector.len() == 3_u32);
    assert(elem == x);
}

fn merge_vectors_push_then_insert(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    vector = vector.push_back(30_Field);
    if x == 20_Field {
        vector = vector.push_back(20_Field);
        vector = vector.push_back(15_Field);
    };
    vector = vector.insert(1_u32, 50_Field);
    vector = vector.insert(6_u32, 100_Field);
    vector
}

fn merge_vectors_remove_between_ifs(x: Field, y: Field) -> [Field] {
    let mut vector: [Field] = [0_Field; 2].as_vector();
    if x != y {
        vector = vector.push_back(y);
        vector = vector.push_back(x);
    } else {
        vector = vector.push_back(x);
    };
    let (mut vector, elem): ([Field], Field) = vector.remove(2_u32);
    assert(elem == y);
    if x == 20_Field {
        vector = vector.push_back(20_Field);
    };
    vector = vector.push_back(15_Field);
    if x != 20_Field {
        vector = vector.push_back(50_Field);
    };
    vector
}

fn regression_2370() {
    let mut vector: [Field] = [].as_vector();
    vector = [1_Field, 2_Field, 3_Field].as_vector();
}

fn regression_4418(x: Field) {
    let mut crash: [u8; 32] = x.to_be_bytes();
    if x != 0_Field {
        crash[0_u32] = 10_u8;
    }
}

fn regression_vector_call_result(x: Field, y: Field) {
    let mut vector: [Field] = merge_vectors_return(x, y);
    if x != 0_Field {
        vector = vector.push_back(5_Field);
        vector = vector.push_back(10_Field);
    } else {
        vector = vector.push_back(5_Field);
    };
    assert(vector.len() == 5_u32);
    assert(vector[0_u32] == 0_Field);
    assert(vector[1_u32] == 0_Field);
    assert(vector[2_u32] == 10_Field);
    assert(vector[3_u32] == 5_Field);
    assert(vector[4_u32] == 10_Field);
}

fn regression_4506() {
    let vector: [Field] = [1_Field, 2_Field, 3_Field].as_vector();
    assert(vector == vector);
}

struct foo {
    a: u32,
    b: u32,
    c: [Field; 3],
}

fn regression_vector_to_brillig(x: u32) {
    let mut vector: [foo] = [
        foo { a: 0_u32, b: 0_u32, c: [0_Field, 0_Field, 0_Field] },
        foo { a: 1_u32, b: 1_u32, c: [0_Field, 0_Field, 0_Field] },
    ]
        .as_vector();
    let mut foo1: foo = foo { a: 10_u32, b: 10_u32, c: [0_Field, 0_Field, 0_Field] };
    foo1.c[x] = 7_Field;
    vector = vector.push_back(foo1);
    vector = vector.push_back(foo { a: 0_u32, b: 0_u32, c: [0_Field, 0_Field, 0_Field] });
    let (new_vector, _): ([foo], foo) = vector.pop_back();
    vector = new_vector;
    // Safety: comment added by `nargo expand`
    let ok: bool = unsafe { bar(vector) };
    assert(ok);
}

unconstrained fn bar(vector: [foo]) -> bool {
    if vector.len() != 0_u32 {
        vector[0_u32].a == 0_u32
    } else {
        false
    }
}
