---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "priv_key",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "pub_x",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "pub_y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": [
    "func 0",
    "current witness index : _2",
    "private parameters indices : [_0]",
    "public parameters indices : [_1, _2]",
    "return value indices : []",
    "BRILLIG CALL func 0: inputs: [Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(0))], q_c: 0 }), Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(1))], q_c: 0 }), Single(Expression { mul_terms: [], linear_combinations: [(1, Witness(2))], q_c: 0 })], outputs: []",
    "unconstrained func 0",
    "[Const { destination: Direct(2), bit_size: Integer(U32), value: 1 }, Const { destination: Direct(1), bit_size: Integer(U32), value: 32841 }, Const { destination: Direct(0), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(4), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(5), bit_size: Integer(U32), value: 0 }, CalldataCopy { destination_address: Direct(32838), size_address: Relative(4), offset_address: Relative(5) }, Mov { destination: Relative(1), source: Direct(32838) }, Mov { destination: Relative(2), source: Direct(32839) }, Mov { destination: Relative(3), source: Direct(32840) }, Call { location: 14 }, Call { location: 18 }, Const { destination: Relative(1), bit_size: Integer(U32), value: 32841 }, Const { destination: Relative(2), bit_size: Integer(U32), value: 0 }, Stop { return_data: HeapVector { pointer: Relative(1), size: Relative(2) } }, Const { destination: Direct(32835), bit_size: Integer(U32), value: 1 }, Const { destination: Direct(32836), bit_size: Integer(U32), value: 2 }, Const { destination: Direct(32837), bit_size: Integer(U32), value: 3 }, Return, Call { location: 391 }, Const { destination: Relative(4), bit_size: Field, value: 1 }, Const { destination: Relative(5), bit_size: Field, value: 17631683881184975370165255887551781615748388533673675138860 }, Const { destination: Relative(6), bit_size: Integer(U1), value: 0 }, Mov { destination: Relative(7), source: Direct(1) }, Const { destination: Relative(8), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(8) }, IndirectConst { destination_pointer: Relative(7), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(8), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Mov { destination: Relative(9), source: Relative(8) }, Store { destination_pointer: Relative(9), source: Relative(4) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Store { destination_pointer: Relative(9), source: Relative(5) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Store { destination_pointer: Relative(9), source: Relative(6) }, Const { destination: Relative(8), bit_size: Field, value: 0 }, Mov { destination: Relative(9), source: Direct(1) }, Const { destination: Relative(10), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(10) }, IndirectConst { destination_pointer: Relative(9), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Mov { destination: Relative(11), source: Relative(10) }, Store { destination_pointer: Relative(11), source: Relative(1) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, Store { destination_pointer: Relative(11), source: Relative(8) }, Mov { destination: Relative(10), source: Direct(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(11) }, IndirectConst { destination_pointer: Relative(10), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Const { destination: Relative(12), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(13), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 2 }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(10), rhs: Direct(2) }, BlackBox(MultiScalarMul { points: HeapVector { pointer: Relative(11), size: Relative(12) }, scalars: HeapVector { pointer: Relative(13), size: Relative(14) }, outputs: HeapArray { pointer: Relative(15), size: 3 } }), BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(10), rhs: Direct(32835) }, Load { destination: Relative(7), source_pointer: Relative(9) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(10), rhs: Direct(32836) }, Load { destination: Relative(9), source_pointer: Relative(11) }, BinaryFieldOp { destination: Relative(10), op: Equals, lhs: Relative(7), rhs: Relative(2) }, JumpIf { condition: Relative(10), location: 61 }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(11) } }, BinaryFieldOp { destination: Relative(7), op: Equals, lhs: Relative(9), rhs: Relative(3) }, JumpIf { condition: Relative(7), location: 65 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Const { destination: Relative(11), bit_size: Integer(U32), value: 12 }, Mov { destination: Relative(12), source: Direct(0) }, Mov { destination: Relative(13), source: Relative(2) }, Mov { destination: Relative(14), source: Relative(3) }, Mov { destination: Relative(15), source: Relative(6) }, Mov { destination: Relative(16), source: Relative(2) }, Mov { destination: Relative(17), source: Relative(3) }, Mov { destination: Relative(18), source: Relative(6) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(11) }, Call { location: 397 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(7), source: Relative(13) }, Mov { destination: Relative(9), source: Relative(14) }, Mov { destination: Relative(10), source: Relative(15) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 15 }, Mov { destination: Relative(15), source: Direct(0) }, Mov { destination: Relative(16), source: Relative(4) }, Mov { destination: Relative(17), source: Relative(5) }, Mov { destination: Relative(18), source: Relative(6) }, Mov { destination: Relative(19), source: Relative(4) }, Mov { destination: Relative(20), source: Relative(5) }, Mov { destination: Relative(21), source: Relative(6) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(14) }, Call { location: 397 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(11), source: Relative(16) }, Mov { destination: Relative(12), source: Relative(17) }, Mov { destination: Relative(13), source: Relative(18) }, BinaryFieldOp { destination: Relative(14), op: Equals, lhs: Relative(11), rhs: Relative(7) }, JumpIf { condition: Relative(14), location: 97 }, Const { destination: Relative(15), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(15) } }, Mov { destination: Relative(7), source: Direct(1) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 7 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(14) }, IndirectConst { destination_pointer: Relative(7), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Mov { destination: Relative(15), source: Relative(14) }, Store { destination_pointer: Relative(15), source: Relative(4) }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, Store { destination_pointer: Relative(15), source: Relative(5) }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, Store { destination_pointer: Relative(15), source: Relative(6) }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, Store { destination_pointer: Relative(15), source: Relative(4) }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, Store { destination_pointer: Relative(15), source: Relative(5) }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, Store { destination_pointer: Relative(15), source: Relative(6) }, Mov { destination: Relative(14), source: Direct(1) }, Const { destination: Relative(15), bit_size: Integer(U32), value: 5 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(15) }, IndirectConst { destination_pointer: Relative(14), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Mov { destination: Relative(16), source: Relative(15) }, Store { destination_pointer: Relative(16), source: Relative(1) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(1) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, Mov { destination: Relative(15), source: Direct(1) }, Const { destination: Relative(16), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(16) }, IndirectConst { destination_pointer: Relative(15), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Const { destination: Relative(17), bit_size: Integer(U32), value: 6 }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Const { destination: Relative(19), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Relative(20), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(2) }, BlackBox(MultiScalarMul { points: HeapVector { pointer: Relative(16), size: Relative(17) }, scalars: HeapVector { pointer: Relative(18), size: Relative(19) }, outputs: HeapArray { pointer: Relative(20), size: 3 } }), BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(15), rhs: Direct(32835) }, Load { destination: Relative(7), source_pointer: Relative(14) }, BinaryFieldOp { destination: Relative(14), op: Equals, lhs: Relative(11), rhs: Relative(7) }, JumpIf { condition: Relative(14), location: 143 }, Const { destination: Relative(15), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(15) } }, Const { destination: Relative(7), bit_size: Field, value: 23 }, Mov { destination: Relative(14), source: Direct(1) }, Const { destination: Relative(15), bit_size: Integer(U32), value: 9 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(15) }, IndirectConst { destination_pointer: Relative(14), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Mov { destination: Relative(16), source: Relative(15) }, Store { destination_pointer: Relative(16), source: Relative(1) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(7) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(1) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(4) }, BinaryIntOp { destination: Relative(16), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Store { destination_pointer: Relative(16), source: Relative(8) }, Const { destination: Relative(7), bit_size: Field, value: 10456889356757736161582760391335869408742580538510966583040563008531594628700 }, Const { destination: Relative(15), bit_size: Field, value: 4714263418031017792755226781102360879566029698463912436805212494059649164343 }, Mov { destination: Relative(16), source: Direct(1) }, Const { destination: Relative(17), bit_size: Integer(U32), value: 13 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(17) }, IndirectConst { destination_pointer: Relative(16), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(17), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Mov { destination: Relative(18), source: Relative(17) }, Store { destination_pointer: Relative(18), source: Relative(4) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(5) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(6) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(11) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(12) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(13) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(2) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(3) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(6) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(7) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(15) }, BinaryIntOp { destination: Relative(18), op: Add, bit_size: U32, lhs: Relative(18), rhs: Direct(2) }, Store { destination_pointer: Relative(18), source: Relative(6) }, Mov { destination: Relative(7), source: Direct(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(11) }, IndirectConst { destination_pointer: Relative(7), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(16), rhs: Direct(2) }, Const { destination: Relative(12), bit_size: Integer(U32), value: 12 }, BinaryIntOp { destination: Relative(13), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Const { destination: Relative(15), bit_size: Integer(U32), value: 8 }, BinaryIntOp { destination: Relative(17), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, BlackBox(MultiScalarMul { points: HeapVector { pointer: Relative(11), size: Relative(12) }, scalars: HeapVector { pointer: Relative(13), size: Relative(15) }, outputs: HeapArray { pointer: Relative(17), size: 3 } }), BinaryIntOp { destination: Relative(12), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(32835) }, Load { destination: Relative(11), source_pointer: Relative(12) }, Const { destination: Relative(7), bit_size: Field, value: -7349266043899242844836273743257843180744506495159104166319746739537754653274 }, BinaryFieldOp { destination: Relative(12), op: Equals, lhs: Relative(11), rhs: Relative(7) }, JumpIf { condition: Relative(12), location: 213 }, Const { destination: Relative(13), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(13) } }, Mov { destination: Relative(7), source: Direct(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(11) }, IndirectConst { destination_pointer: Relative(7), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Mov { destination: Relative(12), source: Relative(11) }, Store { destination_pointer: Relative(12), source: Relative(1) }, BinaryIntOp { destination: Relative(12), op: Add, bit_size: U32, lhs: Relative(12), rhs: Direct(2) }, Store { destination_pointer: Relative(12), source: Relative(8) }, Mov { destination: Relative(1), source: Direct(1) }, Const { destination: Relative(8), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(8) }, IndirectConst { destination_pointer: Relative(1), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(8), op: Add, bit_size: U32, lhs: Relative(1), rhs: Direct(2) }, Mov { destination: Relative(11), source: Relative(8) }, Store { destination_pointer: Relative(11), source: Relative(4) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, Store { destination_pointer: Relative(11), source: Relative(5) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, Store { destination_pointer: Relative(11), source: Relative(6) }, Mov { destination: Relative(8), source: Direct(1) }, Const { destination: Relative(11), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(11) }, IndirectConst { destination_pointer: Relative(8), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(1), rhs: Direct(2) }, Const { destination: Relative(12), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(13), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 2 }, BinaryIntOp { destination: Relative(15), op: Add, bit_size: U32, lhs: Relative(8), rhs: Direct(2) }, BlackBox(MultiScalarMul { points: HeapVector { pointer: Relative(11), size: Relative(12) }, scalars: HeapVector { pointer: Relative(13), size: Relative(14) }, outputs: HeapArray { pointer: Relative(15), size: 3 } }), BinaryIntOp { destination: Relative(7), op: Add, bit_size: U32, lhs: Relative(8), rhs: Direct(32835) }, Load { destination: Relative(1), source_pointer: Relative(7) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(8), rhs: Direct(32836) }, Load { destination: Relative(7), source_pointer: Relative(11) }, BinaryIntOp { destination: Relative(12), op: Add, bit_size: U32, lhs: Relative(8), rhs: Direct(32837) }, Load { destination: Relative(11), source_pointer: Relative(12) }, BinaryIntOp { destination: Relative(8), op: Equals, bit_size: U1, lhs: Relative(11), rhs: Relative(6) }, JumpIf { condition: Relative(8), location: 253 }, Const { destination: Relative(12), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(12) } }, BinaryFieldOp { destination: Relative(8), op: Equals, lhs: Relative(1), rhs: Relative(4) }, JumpIf { condition: Relative(8), location: 257 }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(11) } }, BinaryFieldOp { destination: Relative(1), op: Equals, lhs: Relative(7), rhs: Relative(5) }, JumpIf { condition: Relative(1), location: 261 }, Const { destination: Relative(8), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(8) } }, BinaryFieldOp { destination: Relative(1), op: Equals, lhs: Relative(2), rhs: Relative(3) }, JumpIf { condition: Relative(1), location: 264 }, Jump { location: 390 }, Const { destination: Relative(1), bit_size: Field, value: 2 }, Const { destination: Relative(9), bit_size: Integer(U32), value: 10 }, Mov { destination: Relative(10), source: Direct(0) }, Mov { destination: Relative(11), source: Relative(4) }, Mov { destination: Relative(12), source: Relative(1) }, Mov { destination: Relative(13), source: Relative(6) }, Mov { destination: Relative(14), source: Relative(4) }, Mov { destination: Relative(15), source: Relative(1) }, Mov { destination: Relative(16), source: Relative(6) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(9) }, Call { location: 397 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(5), source: Relative(11) }, Mov { destination: Relative(7), source: Relative(12) }, Mov { destination: Relative(8), source: Relative(13) }, BinaryFieldOp { destination: Relative(9), op: Equals, lhs: Relative(5), rhs: Relative(4) }, JumpIf { condition: Relative(9), location: 283 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Const { destination: Relative(5), bit_size: Field, value: 3 }, Mov { destination: Relative(9), source: Direct(1) }, Const { destination: Relative(10), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(10) }, IndirectConst { destination_pointer: Relative(9), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(4), input1_y: Relative(1), input1_infinite: Relative(6), input2_x: Relative(4), input2_y: Relative(5), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(10), size: 3 } }), BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(32835) }, Load { destination: Relative(10), source_pointer: Relative(11) }, BinaryFieldOp { destination: Relative(9), op: Equals, lhs: Relative(10), rhs: Relative(4) }, JumpIf { condition: Relative(9), location: 296 }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(11) } }, BinaryFieldOp { destination: Relative(9), op: Add, lhs: Relative(2), rhs: Relative(4) }, BinaryFieldOp { destination: Relative(10), op: Add, lhs: Relative(3), rhs: Relative(4) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 15 }, Mov { destination: Relative(15), source: Direct(0) }, Mov { destination: Relative(16), source: Relative(9) }, Mov { destination: Relative(17), source: Relative(3) }, Mov { destination: Relative(18), source: Relative(6) }, Mov { destination: Relative(19), source: Relative(9) }, Mov { destination: Relative(20), source: Relative(3) }, Mov { destination: Relative(21), source: Relative(6) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(14) }, Call { location: 397 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(11), source: Relative(16) }, Mov { destination: Relative(12), source: Relative(17) }, Mov { destination: Relative(13), source: Relative(18) }, BinaryFieldOp { destination: Relative(14), op: Equals, lhs: Relative(11), rhs: Relative(4) }, JumpIf { condition: Relative(14), location: 316 }, Const { destination: Relative(15), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(15) } }, Mov { destination: Relative(11), source: Direct(1) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(14) }, IndirectConst { destination_pointer: Relative(11), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(9), input1_y: Relative(3), input1_infinite: Relative(6), input2_x: Relative(9), input2_y: Relative(10), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(14), size: 3 } }), BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(32835) }, Load { destination: Relative(3), source_pointer: Relative(9) }, BinaryFieldOp { destination: Relative(9), op: Equals, lhs: Relative(3), rhs: Relative(4) }, JumpIf { condition: Relative(9), location: 328 }, Const { destination: Relative(11), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(11) } }, Mov { destination: Relative(3), source: Direct(1) }, Const { destination: Relative(9), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(9) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(1), input1_y: Relative(5), input1_infinite: Relative(6), input2_x: Relative(2), input2_y: Relative(10), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(9), size: 3 } }), BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(32835) }, Load { destination: Relative(9), source_pointer: Relative(10) }, BinaryFieldOp { destination: Relative(3), op: Equals, lhs: Relative(9), rhs: Relative(4) }, JumpIf { condition: Relative(3), location: 340 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Const { destination: Relative(3), bit_size: Field, value: 4 }, Mov { destination: Relative(9), source: Direct(1) }, Const { destination: Relative(10), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(10) }, IndirectConst { destination_pointer: Relative(9), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(1), input1_y: Relative(5), input1_infinite: Relative(6), input2_x: Relative(1), input2_y: Relative(3), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(10), size: 3 } }), BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(32835) }, Load { destination: Relative(3), source_pointer: Relative(10) }, BinaryFieldOp { destination: Relative(9), op: Equals, lhs: Relative(3), rhs: Relative(4) }, JumpIf { condition: Relative(9), location: 353 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Mov { destination: Relative(3), source: Direct(1) }, Const { destination: Relative(9), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(9) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(1), input1_y: Relative(5), input1_infinite: Relative(6), input2_x: Relative(1), input2_y: Relative(5), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(9), size: 3 } }), BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(32835) }, Load { destination: Relative(9), source_pointer: Relative(10) }, BinaryFieldOp { destination: Relative(3), op: Equals, lhs: Relative(9), rhs: Relative(4) }, JumpIf { condition: Relative(3), location: 365 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Mov { destination: Relative(3), source: Direct(1) }, Const { destination: Relative(9), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(9) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(4), input1_y: Relative(5), input1_infinite: Relative(6), input2_x: Relative(4), input2_y: Relative(5), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(9), size: 3 } }), BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(32835) }, Load { destination: Relative(9), source_pointer: Relative(10) }, BinaryFieldOp { destination: Relative(3), op: Equals, lhs: Relative(9), rhs: Relative(4) }, JumpIf { condition: Relative(3), location: 377 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(10) } }, Mov { destination: Relative(3), source: Direct(1) }, Const { destination: Relative(9), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(9) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(2), input1_y: Relative(5), input1_infinite: Relative(6), input2_x: Relative(2), input2_y: Relative(1), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(9), size: 3 } }), BinaryIntOp { destination: Relative(2), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(32835) }, Load { destination: Relative(1), source_pointer: Relative(2) }, BinaryFieldOp { destination: Relative(2), op: Equals, lhs: Relative(1), rhs: Relative(4) }, JumpIf { condition: Relative(2), location: 389 }, Const { destination: Relative(3), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(3) } }, Jump { location: 390 }, Return, Const { destination: Direct(32772), bit_size: Integer(U32), value: 30720 }, BinaryIntOp { destination: Direct(32771), op: LessThan, bit_size: U32, lhs: Direct(0), rhs: Direct(32772) }, JumpIf { condition: Direct(32771), location: 396 }, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 17843811134343075018 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return, Call { location: 391 }, JumpIf { condition: Relative(3), location: 426 }, Jump { location: 400 }, JumpIf { condition: Relative(6), location: 418 }, Jump { location: 402 }, Mov { destination: Relative(13), source: Direct(1) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 4 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(14) }, IndirectConst { destination_pointer: Relative(13), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(13), rhs: Direct(2) }, BlackBox(EmbeddedCurveAdd { input1_x: Relative(1), input1_y: Relative(2), input1_infinite: Relative(3), input2_x: Relative(4), input2_y: Relative(5), input2_infinite: Relative(6), result: HeapArray { pointer: Relative(14), size: 3 } }), BinaryIntOp { destination: Relative(2), op: Add, bit_size: U32, lhs: Relative(13), rhs: Direct(32835) }, Load { destination: Relative(1), source_pointer: Relative(2) }, BinaryIntOp { destination: Relative(3), op: Add, bit_size: U32, lhs: Relative(13), rhs: Direct(32836) }, Load { destination: Relative(2), source_pointer: Relative(3) }, BinaryIntOp { destination: Relative(4), op: Add, bit_size: U32, lhs: Relative(13), rhs: Direct(32837) }, Load { destination: Relative(3), source_pointer: Relative(4) }, Mov { destination: Relative(10), source: Relative(1) }, Mov { destination: Relative(11), source: Relative(2) }, Mov { destination: Relative(12), source: Relative(3) }, Jump { location: 422 }, Mov { destination: Relative(10), source: Relative(1) }, Mov { destination: Relative(11), source: Relative(2) }, Mov { destination: Relative(12), source: Relative(3) }, Jump { location: 422 }, Mov { destination: Relative(7), source: Relative(10) }, Mov { destination: Relative(8), source: Relative(11) }, Mov { destination: Relative(9), source: Relative(12) }, Jump { location: 430 }, Mov { destination: Relative(7), source: Relative(4) }, Mov { destination: Relative(8), source: Relative(5) }, Mov { destination: Relative(9), source: Relative(6) }, Jump { location: 430 }, Mov { destination: Relative(1), source: Relative(7) }, Mov { destination: Relative(2), source: Relative(8) }, Mov { destination: Relative(3), source: Relative(9) }, Return]"
  ],
  "debug_symbols": "tZndTls7EEbfJddcbHv821epqiqFUEWKAkrhSEeIdz8ze7wSzsVGZUNu+BalXmw7HsdDXjZ3u1/Pv3/uj/cPfzbfvr9sfp32h8P+98/Dw+32af9w1H992Uz2JfTNt3CziZNH8Ige4pE8skfxqB7Nwy3iFnGLuEXcIm4Rt4hbxC3iFnFLcktyS3JLUotoJI/sUTyqR/Poc+TJI3hED7UkjeSRPYqHWrJG8+hzlMlDLUUjeohH8lBL0yge1aN59Dnq5BE8ood4JA+3VLdUt1S3VFuX6WbTppFhZBwpI9PIPLKMrCPbyOHrw9eHrw9fN5+ueU8j88gyso5sI7tnmCYgABEQIAEZKEAFGoA5YA6YA+aAOWAOmAPmgDlgDpgj5og5Yo6YI+aIOWKe60AMGtAHzNUwQwAiIEACMlAAMyeDBphZd2OYK2SGAETAzNUgARkoQAUa0AdY1TgEIAKYM+aMOWPOmDPmjLlgLpgL5oK5YC6YC+aCuWAumCvmirlirpgr5oq5Yq6YK+aKuWFumBvmhrlhbpgb5oa5YW6YO+aOuWPumDvmjrlj7pg75j7McZqAAERAgARkwMzNoAJm7gZ9wFyDMwQgAmqO8/tHAjJQgAo0oA+wGnQIQAQwR8wRc8QcMUfMEbNgFsyCWTALZsEsmAWzYBbMCXPCnDBbDcZokIAMFKACDTCz2PvsBAQgAgIkIAMFqEADMBfMVoMxGZinGGSgABVoQB9gFecQgAgIgLlirpgr5orZKi7aPrSKcwhABMxsm80qziEDBahAA/oAqziZDAJgd4L58iJAAjJgNwx7dazixJbOKk6yQXcQqziHAERAgARkoAAVaADmgDlgtoqTYiBAAjJg5mZQgQb0AVZxDgEwczcQwG5Jk0EGClABNado0AdYxTkEIAICmFkMMmDmZFCBBvQBVnHJJmgV5xABARKQgQKYuRo0wMw2d6s4hwBEQM3ZZmoV55CBAlSgAXZ7nK+5E6DmbHO3dz0HARJgZpup1aBDBRrQB1gNOpjZ9obVoIOZbcpWgw4ZKICZbYJWgw59gNWgQwAiYGbbG1aDDmouNmWrQYcKNIdk5VCigQAJyEABKmDD7T5v5TCDlYNDACJgZnl9vdnQ4vx8Ou121uG86Xm0E3rcnnbHp8234/PhcLP5Z3t4nv/Tn8ftcc6n7Ul/qk+9O95pqvB+f9gZvd5cRk/LQ/VUGoP1WDoPz389Xl/PMT7FtjQ+Lo9PuScEJV0mEMo6gywZ3plDSuc55LxiDVLpjG+yYnzpvAY1hKXx9Z3xkecvOayYf7W3DP/9svga9uXxesGvQ6AX+rbmCazI/QnqmhVshRXoMi2ND5/fhuGq+1CbTWEdpzKtWAftws6GLIsrGcrnV6JcdSVyYkNo39XXrESrPIM2G2nxZJo+fzRN11wJbZCoLe2M0oqV0LaH9wdtfFYZJDML7TUWd1XM1zuitKOJ50fodc0kkvWJbkh58ZiN7Z09pSt5Puj0jytpcUt8QFLXrEYql7nUtmY1cjlvilzWFJh2TGdDTasMLZy3douLlw9JV9xWLb25/kyrJtF4BG3VFqtL6hdsq49IVm2rLpe5pLDmNhgj7z/ahi2+pHbf+vRqfESyZjW0a7zMZdW9Tjs2LobamMXF1chfsRr5yquR02UueU25aw9HrWnPtnhopf4Vq9GvvBotXuYiq3qGKXN8auu4uLuyfMFqfESyZjW00z3PRT/6WLMaItRa0j8nLK7GV5yi+cqnqHZAl7n0Vf3gdK61MvXFi2f5ilO0rD5Ff+h329v96X+f0r6a7bTf/jrsxrf3z8fbNz99+veRn/Ap7+Pp4XZ393zamenNR7369bv0cCO9/Hi13/cf",
  "file_map": {
    "16": {
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n",
      "path": "std/embedded_curve_ops.nr"
    },
    "50": {
      "source": "use std::{embedded_curve_ops::embedded_curve_add_unsafe, ops::Add};\n\nfn main(priv_key: Field, pub_x: pub Field, pub_y: pub Field) {\n    let g1 = std::embedded_curve_ops::EmbeddedCurvePoint::generator();\n    let scalar = std::embedded_curve_ops::EmbeddedCurveScalar { lo: priv_key, hi: 0 };\n    // Test that multi_scalar_mul correctly derives the public key\n    let res = std::embedded_curve_ops::multi_scalar_mul([g1], [scalar]);\n    assert(res.x == pub_x);\n    assert(res.y == pub_y);\n\n    // Test that double function calling embedded_curve_add works as expected\n    let pub_point =\n        std::embedded_curve_ops::EmbeddedCurvePoint { x: pub_x, y: pub_y, is_infinite: false };\n    let res = pub_point.double();\n    let double = g1.add(g1);\n\n    assert(double.x == res.x);\n\n    // Test calling multi_scalar_mul with multiple points and scalars\n    let res = std::embedded_curve_ops::multi_scalar_mul([g1, g1], [scalar, scalar]);\n\n    // The results should be double the g1 point because the scalars are 1 and we pass in g1 twice\n    assert(double.x == res.x);\n\n    // Tests for #6549\n    let const_scalar1 = std::embedded_curve_ops::EmbeddedCurveScalar { lo: 23, hi: 0 };\n    let const_scalar2 = std::embedded_curve_ops::EmbeddedCurveScalar { lo: 0, hi: 23 };\n    let const_scalar3 = std::embedded_curve_ops::EmbeddedCurveScalar { lo: 13, hi: 4 };\n    let partial_mul = std::embedded_curve_ops::multi_scalar_mul(\n        [g1, double, pub_point, g1, g1],\n        [scalar, const_scalar1, scalar, const_scalar2, const_scalar3],\n    );\n    assert(partial_mul.x == 0x2024c4eebfbc8a20018f8c95c7aab77c6f34f10cf785a6f04e97452d8708fda7);\n    // Check simplification by zero\n    let zero_point = std::embedded_curve_ops::EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true };\n    let const_zero = std::embedded_curve_ops::EmbeddedCurveScalar { lo: 0, hi: 0 };\n    let partial_mul = std::embedded_curve_ops::multi_scalar_mul(\n        [zero_point, double, g1],\n        [scalar, const_zero, scalar],\n    );\n    assert(partial_mul == g1);\n\n    // Additional tests for validating embedded_curve_add_unsafe under a conditional\n    if pub_x == pub_y {\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 1, y: 2, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 1, y: 3, is_infinite: false };\n        let doubling = a1.double();\n        assert(doubling.x == 1);\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint {\n            x: pub_x + 1,\n            y: pub_y,\n            is_infinite: false,\n        };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint {\n            x: pub_x + 1,\n            y: pub_y + 1,\n            is_infinite: false,\n        };\n        let doubling = a1.double();\n        assert(doubling.x == 1);\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 2, y: 3, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint {\n            x: pub_x,\n            y: pub_y + 1 as Field,\n            is_infinite: false,\n        };\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 2, y: 3, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 2, y: 4, is_infinite: false };\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 2, y: 3, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 2, y: 3, is_infinite: false };\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 1, y: 3, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint { x: 1, y: 3, is_infinite: false };\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n        let a1 = std::embedded_curve_ops::EmbeddedCurvePoint { x: pub_x, y: 3, is_infinite: false };\n        let a2 = std::embedded_curve_ops::EmbeddedCurvePoint { x: pub_x, y: 2, is_infinite: false };\n        let res = embedded_curve_add_unsafe(a1, a2);\n        assert(res.x == 1);\n    }\n}\n",
      "path": ""
    }
  }
}
