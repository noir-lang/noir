---
source: tooling/nargo_cli/tests/execute.rs
expression: expanded_code
---
use std::list;

fn main(x: Field, y: pub Field) {
    let mut list: [Field] = &[0_Field; 2];
    assert(list[0_u32] == 0_Field);
    assert(list[0_u32] != 1_Field);
    list[0_u32] = x;
    assert(list[0_u32] == x);
    let list_plus_10: [Field] = list.push_back(y);
    assert(list_plus_10[2_u32] == 10_Field);
    assert(list_plus_10[2_u32] != 8_Field);
    assert(list_plus_10.len() == 3_u32);
    let mut new_list: [u32] = &[];
    for i in 0_u32..5_u32 {
        new_list = new_list.push_back(i);
    }
    assert(new_list.len() == 5_u32);
    new_list = new_list.push_front(20_u32);
    assert(new_list[0_u32] == 20_u32);
    assert(new_list.len() == 6_u32);
    let (popped_list, last_elem): ([u32], u32) = new_list.pop_back();
    assert(last_elem == 4_u32);
    assert(popped_list.len() == 5_u32);
    let (first_elem, rest_of_list): (u32, [u32]) = popped_list.pop_front();
    assert(first_elem == 20_u32);
    assert(rest_of_list.len() == 4_u32);
    new_list = rest_of_list.insert(2_u32, 100_u32);
    assert(new_list[2_u32] == 100_u32);
    assert(new_list[4_u32] == 3_u32);
    assert(new_list.len() == 5_u32);
    let (remove_list, removed_elem): ([u32], u32) = new_list.remove(3_u32);
    assert(removed_elem == 2_u32);
    assert(remove_list[3_u32] == 3_u32);
    assert(remove_list.len() == 4_u32);
    let append: [Field] = &[1_Field, 2_Field].append(&[3_Field, 4_Field, 5_Field]);
    assert(append.len() == 5_u32);
    assert(append[0_u32] == 1_Field);
    assert(append[4_u32] == 5_Field);
    let mapped: [Field] = &[1_Field, 2_Field].map(|x: Field| -> Field { x + 1_Field });
    assert(mapped == &[2_Field, 3_Field]);
    assert(
        &[1_Field, 2_Field, 3_Field].fold(0_Field, |acc: Field, x: Field| -> Field { acc + x })
            == 6_Field,
    );
    assert(
        &[1_Field, 2_Field, 3_Field].reduce(|acc: Field, x: Field| -> Field { acc + x }) == 6_Field,
    );
    assert(&[2_u32, 4_u32, 6_u32].all(|x: u32| -> bool { x > 0_u32 }));
    assert(&[2_u32, 4_u32, 6_u32].any(|x: u32| -> bool { x > 5_u32 }));
    regression_2083();
    regression_merge_lists(x, y);
    regression_2370();
    regression_4418(x);
    regression_list_call_result(x, y);
    regression_4506();
    regression_list_to_brillig((x as u32) % 3_u32);
}

fn regression_2083() {
    let y: [(Field, Field)] = &[(1_Field, 2_Field)];
    let y: [(Field, Field)] = y.push_back((3_Field, 4_Field));
    let y: [(Field, Field)] = y.push_back((5_Field, 6_Field));
    assert(y[2_u32].1 == 6_Field);
    let y: [(Field, Field)] = y.push_front((10_Field, 11_Field));
    let y: [(Field, Field)] = y.push_front((12_Field, 13_Field));
    assert(y[1_u32].0 == 10_Field);
    let y: [(Field, Field)] = y.insert(1_u32, (55_Field, 56_Field));
    assert(y[0_u32].1 == 13_Field);
    assert(y[1_u32].1 == 56_Field);
    assert(y[2_u32].0 == 10_Field);
    let (y, x): ([(Field, Field)], (Field, Field)) = y.remove(2_u32);
    assert(y[2_u32].0 == 1_Field);
    assert(x.0 == 10_Field);
    assert(x.1 == 11_Field);
    let (x, y): ((Field, Field), [(Field, Field)]) = y.pop_front();
    assert(y[0_u32].0 == 55_Field);
    assert(x.0 == 12_Field);
    assert(x.1 == 13_Field);
    let (y, x): ([(Field, Field)], (Field, Field)) = y.pop_back();
    assert(y.len() == 3_u32);
    assert(x.0 == 5_Field);
    assert(x.1 == 6_Field);
}

fn regression_merge_lists(x: Field, y: Field) {
    merge_lists_if(x, y);
    merge_lists_else(x);
}

fn merge_lists_if(x: Field, y: Field) {
    let list: [Field] = merge_lists_return(x, y);
    assert(list.len() == 3_u32);
    assert(list[2_u32] == 10_Field);
    let list: [Field] = merge_lists_mutate(x, y);
    assert(list.len() == 4_u32);
    assert(list[3_u32] == 5_Field);
    let list: [Field] = merge_lists_mutate_in_loop(x, y);
    assert(list.len() == 7_u32);
    assert(list[6_u32] == 4_Field);
    let list: [Field] = merge_lists_mutate_two_ifs(x, y);
    assert(list.len() == 6_u32);
    assert(list[3_u32] == 5_Field);
    assert(list[4_u32] == 15_Field);
    assert(list[5_u32] == 30_Field);
    let list: [Field] = merge_lists_mutate_between_ifs(x, y);
    assert(list.len() == 8_u32);
    assert(list[3_u32] == 5_Field);
    assert(list[4_u32] == 30_Field);
    assert(list[5_u32] == 15_Field);
    assert(list[6_u32] == 50_Field);
    assert(list[7_u32] == 60_Field);
    merge_lists_push_then_pop(x, y);
    let list: [Field] = merge_lists_push_then_insert(x, y);
    assert(list.len() == 7_u32);
    assert(list[1_u32] == 50_Field);
    assert(list[2_u32] == 0_Field);
    assert(list[5_u32] == 30_Field);
    assert(list[6_u32] == 100_Field);
    let list: [Field] = merge_lists_remove_between_ifs(x, y);
    assert(list.len() == 5_u32);
}

fn merge_lists_else(x: Field) {
    let list: [Field] = merge_lists_return(x, 5_Field);
    assert(list[0_u32] == 0_Field);
    assert(list[1_u32] == 0_Field);
    assert(list.len() == 2_u32);
    let list: [Field] = merge_lists_mutate(x, 5_Field);
    assert(list[2_u32] == 5_Field);
    assert(list.len() == 3_u32);
    let list: [Field] = merge_lists_mutate_in_loop(x, 5_Field);
    assert(list[2_u32] == 5_Field);
    assert(list.len() == 3_u32);
}

fn merge_lists_return(x: Field, y: Field) -> [Field] {
    let list: [Field] = &[0_Field; 2];
    if x != y {
        if x != 20_Field {
            list.push_back(y)
        } else {
            list
        }
    } else {
        list
    }
}

fn merge_lists_mutate(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    list
}

fn merge_lists_mutate_in_loop(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        for i in 0_u32..5_u32 {
            list = list.push_back(i as Field);
        }
    } else {
        list = list.push_back(x);
    };
    list
}

fn merge_lists_mutate_two_ifs(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    if x == 20_Field {
        list = list.push_back(20_Field);
    };
    list = list.push_back(15_Field);
    list = list.push_back(30_Field);
    list
}

fn merge_lists_mutate_between_ifs(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    list = list.push_back(30_Field);
    if x == 20_Field {
        list = list.push_back(20_Field);
    };
    list = list.push_back(15_Field);
    if x != 20_Field {
        list = list.push_back(50_Field);
    };
    list = list.push_back(60_Field);
    list
}

fn merge_lists_push_then_pop(x: Field, y: Field) {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    list = list.push_back(30_Field);
    if x == 20_Field {
        list = list.push_back(20_Field);
    };
    let (list, elem): ([Field], Field) = list.pop_back();
    assert(list.len() == 4_u32);
    assert(elem == 30_Field);
    let (list, elem): ([Field], Field) = list.pop_back();
    assert(list.len() == 3_u32);
    assert(elem == x);
}

fn merge_lists_push_then_insert(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    list = list.push_back(30_Field);
    if x == 20_Field {
        list = list.push_back(20_Field);
        list = list.push_back(15_Field);
    };
    list = list.insert(1_u32, 50_Field);
    list = list.insert(6_u32, 100_Field);
    list
}

fn merge_lists_remove_between_ifs(x: Field, y: Field) -> [Field] {
    let mut list: [Field] = &[0_Field; 2];
    if x != y {
        list = list.push_back(y);
        list = list.push_back(x);
    } else {
        list = list.push_back(x);
    };
    let (mut list, elem): ([Field], Field) = list.remove(2_u32);
    assert(elem == y);
    if x == 20_Field {
        list = list.push_back(20_Field);
    };
    list = list.push_back(15_Field);
    if x != 20_Field {
        list = list.push_back(50_Field);
    };
    list
}

fn regression_2370() {
    let mut list: [Field] = &[];
    list = &[1_Field, 2_Field, 3_Field];
}

fn regression_4418(x: Field) {
    let mut crash: [u8; 32] = x.to_be_bytes();
    if x != 0_Field {
        crash[0_u32] = 10_u8;
    }
}

fn regression_list_call_result(x: Field, y: Field) {
    let mut list: [Field] = merge_lists_return(x, y);
    if x != 0_Field {
        list = list.push_back(5_Field);
        list = list.push_back(10_Field);
    } else {
        list = list.push_back(5_Field);
    };
    assert(list.len() == 5_u32);
    assert(list[0_u32] == 0_Field);
    assert(list[1_u32] == 0_Field);
    assert(list[2_u32] == 10_Field);
    assert(list[3_u32] == 5_Field);
    assert(list[4_u32] == 10_Field);
}

fn regression_4506() {
    let list: [Field] = &[1_Field, 2_Field, 3_Field];
    assert(list == list);
}

struct foo {
    a: u32,
    b: u32,
    c: [Field; 3],
}

fn regression_list_to_brillig(x: u32) {
    let mut list: [foo] = &[
        foo { a: 0_u32, b: 0_u32, c: [0_Field, 0_Field, 0_Field] },
        foo { a: 1_u32, b: 1_u32, c: [0_Field, 0_Field, 0_Field] },
    ];
    let mut foo1: foo = foo { a: 10_u32, b: 10_u32, c: [0_Field, 0_Field, 0_Field] };
    foo1.c[x] = 7_Field;
    list = list.push_back(foo1);
    list = list.push_back(foo { a: 0_u32, b: 0_u32, c: [0_Field, 0_Field, 0_Field] });
    let (new_list, _): ([foo], foo) = list.pop_back();
    list = new_list;
    // Safety: comment added by `nargo expand`
    let ok: bool = unsafe { bar(list) };
    assert(ok);
}

unconstrained fn bar(list: [foo]) -> bool {
    if list.len() != 0_u32 {
        list[0_u32].a == 0_u32
    } else {
        false
    }
}
