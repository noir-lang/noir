---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        },
        "visibility": "private"
      },
      {
        "name": "nest",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/71WbW7CMAx1+sFW0ARi2gV2gpa0K9qkCWmMPztFBuIcPfqISIT7MLCNBEuV0ybxe3Ycu4r2otxjJXM6oWPxaxZOl9dJFdBWGZOnisSzF2RFp8XPfTldwH47nwZ0uADckPbnZd0Wgn8B+euC2Yxgf+btZ3Hsl3fOzmfXt0+Am8I63MP3rdiaFVtj5YH6RYDb8XM8V/3++90zpsN46sYF2IuRP5xT6Pg/CvwT5puVj456cQ6F7e0vuyi+VSN3Vo2zl4N/T04Pdk/txlIOKDjrWHdNAR4BFgH+kKLmRoX3yvPB+CQQu0zgOhHmvE9jOp+DEWNeKuCVMR9TgWsi+OHHVnL49uy0zcM3sIfnjN8SiF0i8Ilcnxt/pjkdi58bMGzOESWFd87bxued2cV1iMlzhePjeUhxXXZ7PRY4Y37yn0VFx7nva6NUp60snC6vFClPiU7fG8xDTX2eOdsT8j5NwX+OxevsiA79JevCc2nn+5hZSbtDTDAHOX4O61/d+1DwKbuC57Y11VabrWnMZlOvDcbMSsLiFBrftHq+ntXr9rvRRr9cxOc99FxP+O0d83ulf7Eb9Vr9314b4z+vvNBrpXP5a6/F3iHVyEzAmQhzvubZ3PgBUsXa7FkPAAA=",
  "debug_symbols": "pdPLjsIgFIDhd2HNAiiX0lcxxmBFQ0Jog+0kE9N3nwOn9bJwFrrpZ8X/YEi4kZM/zpdDSOfhSrrdjRxziDFcDnHo3RSGBN/eCCsP0ZJOUCJspWEIRwTSIBJRiCZdAxikRWxFMoQjAoEpEpAITFGARgzSIraiWEVDpwGJQGcAjRikRWzFMIQjAoEpZlko2U7gMGXvywE8HQkc1OiyTxPp0hwjJT8uzvVH19Gl6uQyrDJKfDqBMPAcoi+fFvqo2ftU87U19h6r15q/r61ea87kB7mQcu2Faj/p7/s37/dn3/39f3Iptl424pOeq60XzUu/hzfXh/xyQZYyKQd3jH59Pc+pf1qdfsdtZbtgYx56f5qzL5Met4zDc6caqto9JZyXF0s13y9l6z8=",
  "file_map": {
    "50": {
      "source": "fn main(x: u8, nest: bool) {\n    if nest {\n        let foo = unsafe_assert([x]);\n        assert(foo != 0);\n    }\n}\n\n#[no_predicates]\npub fn unsafe_assert<let N: u32>(msg: [u8; N]) -> u8 {\n    // Safety: testing context\n    let block = unsafe { get_block(msg) };\n    verify_block(msg, block);\n    block[0]\n}\n\nunconstrained fn get_block<let N: u32>(msg: [u8; N]) -> [u8; 2] {\n    let mut block: [u8; 2] = [0; 2];\n    block[0] = msg[0];\n    block\n}\n\nfn verify_block<let N: u32>(msg: [u8; N], block: [u8; 2]) {\n    assert_eq(block[0], msg[0]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
