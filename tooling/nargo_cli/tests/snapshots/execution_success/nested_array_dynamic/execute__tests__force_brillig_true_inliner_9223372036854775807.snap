---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
