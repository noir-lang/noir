---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
