---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
