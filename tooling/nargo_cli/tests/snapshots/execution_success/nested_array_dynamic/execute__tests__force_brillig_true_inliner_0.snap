---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dW2xk2VU9Vfbtctltu9rd7p5+TI+7O/2ehx/lR8+jx5l2T2cmD2aSQAQSijzdMxISkUKkEPFBVEHiI+QDEBICBH+8JESC4AcJ8REJkCLygZQPCHygABIIUH6QQLwEud13l1etWrXr3vgcl0vxkay6PvvcvfdZZ5+99zn31qlaeFIufOevVlxPFp/14rNW0LFY2+3ic3l/ZSUir+VUOtbGQMf6GOg4MQY6To6BjtkY6HhsDHRsjIGOU2OgY3MMdJweAx1nxkDH42Og4+wY6Dg3BjrOj4GOrTHQ8cQY6LgwBjqeHAMdT42BjotjoOPpMdDxzBjo+NQY6Hh2DHQ8NwY6nk+gYwo9LyTSs2ezKlc63xTJNx3yRX2+aM4XpfmiL19U5YuWfFGQJ915UpsnjXlSlic9eVKRB+08KOZBJ3fqudPMnVI+6fNJlRttbhTnASDeLEPwfqrx5LNZ/F8HesSNkZUmyY3Jf2t5Y60p+hdR/8f8jWd8/iuPjP9kGv2Xi2EOr3d6+QeSa3qkGaf2RuJ+PpylvgXoi8nO0sh+VCN5gTAOJH86pLSpJxvEKM/0YXzqhE8jjT7Lxn8qEX/rb1P0F/G3/s0X/x8DGvqpQbzQfqwvLXH/sYPBdSUxritVcTV9ZtLos2ZzfBr04Tl+PI3sdtk5bvKnSddUY3M89I8N4mNzfNbadPb0aRJtstPfD6NlQLPxze3u16F/SEN9vHmDtmJ6J5437cTzZvVo3nTL0bwB2pjPm83E82btezSObyXGtX3kj3qxQHmGRQhH/sjqx8QfvZN43qwfzZtuOZo3QBvzefNu4nmz8T0ax99LjOvmkT/qliN/BLTx9kcrq4nnzdbRvOmWo3kDtDGfN+uJ582d7804vrKRGNfdI3/ULUf+CGhj7o/uJJ437xzNm245mjdASz1vZkO/jU0QrQ5y3uns6fMV0O0Piuu071psdN9ZSfROz/JJoT/KykujE3pwf/wJdTZ+Np5T2J5oTaBNdnrlTBf/T4Ic5GV6ZNT+y8X/88XnMbjH7m8J+cdIfo/eoo5xaYr2TdE+z3V+q7jObdLmxr1OL7/t4nN5f6X7ntYO8E/xHtj9NPzXcozyOfagcP7e+0BlfCeORYt4oe1bzjspaInfO+q+92J5sc0BlolfpMX2eB2Ke7Duj4vPHNcPN3r7Nxl6seM6xq4m9GmK+7bjYLMWRF/ZT02S/g2Bi41Zc0D9dhx9u8/oLB5lQ/TKqP2fFZ/5/2/RWFmbuuCZF5yTHK85vzI+2F7FWMwzTL7NFVzTzYThsqegbqfT2/54RV1nRXvM0aZJV9SvG49C0txu1dMVc+vj1Le5UA2LedF+TvR3XsieJxreN0M4zafBqev/LE6j/0OZc9B/bI/Xecmo7pvFp/J/cw52JisEnVfOOdhNEXatxNidENi1HOxOAM2uETur+1aIh92U0Kcp7tuOg80K98/61hR6cL//ifRbgHtijh/yDSTL87PN0D+OKezKdEG7Qpn4vQPGya4RX6v7dvGp7ErtC2CdNyebDnY8J1ONqfXjpMBuwcHuJNDsGrGzun8P8bCbEvrw/k+Ih033GVEzOu+V9qzArkZ9OgX1o9jHMfnToX/MU+zjnCJ9GB/cx8lpi0LXlqCh3SAN5SwKOYrXZERebMNIi/lswfA6HfqL0c6A7BmiPQU0tAEuE/Q/9ikfg4/BOpnbsT5o+6ZbRrRWcWPiPVcZ92ZIf15TYN47Bfhw31jnGtVnA+7jNZm1XyyUVGsya1MXPPNyv9PbHu2lTG5/RrQ/Lfpq8Q7t/UwYLhsx3+n0tn+qoq5nRXu089OkK+p3NgyXjeN6vIRsT9dzoj3q8BTpirLPEQ3vsz41qW2qHON8wQ9zDJR5FvqP7fE6LxnVXQeb5xzjrIOdycpLKwweZ4Ud57bnE2N3QWB33sHuAtAuCOys7oWI2M0IfZrivu042LS5f9a3RaEH93uDYsfTcE/q2GGyPD/YDP3jmMKuTBe0K5RputUFTnaN+Frdy45dVc2Zzgh9FHY8J1ONqfXjYujH7mkHu4tAs2vEzup2ImI3I/ThfCnEw2a9KXSKxLv7jszF6LxX1i3vfAZ41wivJagfxXrM5E+TrpH16a7HlkgfxofXY5eEri1B41z5kpBzSchRvBYj8jK7YjuLi+/q8mzox9eKwvIM0S4DDW2Ai1qPWZ+qrscQZ9ON4+0nKaai304dU8+Q/mwXmFPPAT6D4kst9Obmi9Bndd+xAZg8Al/+1gBfXhc883K/09t+CWhl1g2XRPsl0VeLpWjvl8Jw2ejjdzq97S9X1PWKaI92vkS6on5XwnDZOK7HS8j2dH2faI86XCZdUfb7iIb3WZ+a1Db2/LF+XC34Yf6CMq9A/7E9Xuclo7ofB5vn/OWKg53Jyovyz1cc7Di3uZoYu2uhH7urDnbXgGbXiJ3VfT4idotCn6a4bzsONpvcP85rUS73+6cpdlyHe1LHDpPl+UHG7SDtCmWablXt6kuOXWE+PSHqyuRMCjuek9cSY3ddYHfNwQ5tzK4RO6v7hYjYLQp9Eq6ZttKtmZbv8FyNx3vvmcUN4F0jvG5C/SjWYyZ/mnSNrE93PXaT9GF8eD12S+jaEjTOlW8JObeEHMXrYkReZldpx3t1d1boZcVot0H2JaI9CzS0AS5qPWZ9qroeQ99lurHf+jLFVPTbqWPqJegzy+Z3xNl/ZwPuOzagn78P/pnXWNamHvR+wP1Ob3ucT2XWAt6cVLkF9udmGC4bfetOp7f9rYq63hbtcb7dIF1Rv9thuGy0SV5jPVtR1+dEe5xnt0hX1O85ouF91qcmtU2Vkzxf8MOcBGU+C/3H9nidl4zq/sTJSZ51sDNZeWmF/nF+1sHuNmH3fGLsXgj92D3vYPcC0OwasbO6r0fE7rbQpynu246DzS73z/p2SejB/f4GxYNluCd1PDBZnh9shv5xTGFXpgvaFco03eoCJzxtOaO6bzp2dQnuK7MvfVPoo7DjOZlqTK0fK6Efu2UHuxWg2TViZ3XfioidytWa4r7tONh0z4Raic/7ofFejc57ZdNyyTXgXSO82lA/ijWWyZ8mXSPr011jtUkfxofXWOtC15ag4ZxFGspZF3IUr5WIvMyumoJ3PHzXuu+7Ir5WFJY3ibYBNLQBLmqNZX2qusbCMTPdON7+D8XUNPjpmGqyysTUVHqZDZodYVxAmRwXVoGGvi2junphvKOMqauJsWsL7FYd7NAntwV2XZ8ZEbuDjakbjzj+ROTdPYtuPT7v99hfGWaI1ybUjyKmmvzp0O9bU8TUTdKH8eGYuiV0bQkazlmkoZwtIUfxakfkZXaVNoda6+ZviK8VheVtot0BGtoAFxVTrU/7iammG8fUqwW4iXNQGVPbpP8l0lG9118T96r9+Z1Ob78S+J82+5h4vNdWeZxeK8DI92VvF9fqjBX0f3mZBFrE8XyUj8eP0lkM+HskGemkvouM7XlPsiXa43d+bf+zRe1xPBQ+2QjxmXfw8fqr8Dkh2iMGNwgf/G4m5vuMz/wI8ckq4pPtA5+2g89tomFcN5n5PPzBo3nozkPzuUfz8GgeDsIn5jycJxrek/isil2vv6gPn6uBWJw4GF275+wtVNQVx2bhYHR9aLqeq6gr5pv8vbzs4DFf5n4MOsvEdKtTe8Ygo7ofcfYfMgc7k5UXNQczBzu2gdRnTijsTkTA7sciYrcg9OH/+Rya/HqTaNb2c7Q+G8V5Ix4WS1C30+nVFWPFdhQ9N9YZh4i8u+/Boa1gHpdfJ/ruaen9JJM/HfptPMV+0nnSh/Hh/aQLQteWoOHzB6ShnAtCjuLVisiLz9hB3tbvgzonRn2He0H0ux76bdP7DveXHH+n8ruWg905oQ/vXfwO7F38LOVqHG9RF5VLebm4ymcwPlwOvbJxbHnc8b7DNu4noP9Vxv2XnXE/4WBnskLQ427tDts6puf8sk5vf8+X7K/nUxD3pdCLD/qUcw4+mH8eND7zFfGZ3wc+mYNPi2joB7rn937n7+uH3Hc0hezt4nN5X2VtLV3es/e+AI455z2JzkYonfeY/OnQb1sp8h7PnvPCec/TQteWoOHzSKShnKeFHMXrREReC9Cfx/d39miH1Yd7cxb7640pxtWl0IuPymXHyYcrfDwfeH4IPuzDcQ5+tz7c26ubINp28f/y/kr396K8vUyUr+JN62B0vePFM09Xta84HwaPzWE5N9R0q4d++/PODf2mk9tOCOywjv2iyisUdmwDo14XMHZl1wXfiogdn2eM+KQ563hti9+/wKLev5gn2otAw3UNlwn6H/tU9d0MtCPTLSPat2nvL9XetNr7Q1kcN2I8N+Rz2NW8KuOnlWwVx5Ann3uOep0nmmfPoz6Hjvd/yp5D918R93/UuJWJM2l8gY+dGsuq2NUnBmMXI86kXW+N1ldan1L4yvniYhx9pVqXIE8+HxXxuFCClydbrRmRJ593inrx2Ypss3k5qPMBrxT8Bp0P2J2/1B6vQ9izK6s778z3qs8Z1LiV8ZWpz6VU2KmxrIrdlQPylXjfdhRsNjbTnd2zscVnTkXkfcd85lXgXSO8Ep0NU3ovz+RPk66R9enu5V0jfRgf3su7KXRV32vhPWd1PsFNIUfxuhKRl9lVU/A+rLkE2gAXlUtYn1LkEnfHOJe4Itojz6XiWsWdKyV4ebKrntWHenln9bG/H9ez+t504uEVBzuTlReVS1wh7LxcIo0v8LFTY1kVu4+Oby6xy+ckRuT9Dsf0iLwfcjw0zBCv24RlHNnlcwmTPx10fN6Oo083l1Dn+qi4bNg9J3RtCRrnEupMnueEHMXrakReZldNwfuw5hJoA1xULmF9SpFLfGqMc4mroj3y5DOsEI+rJXh5sr2cPb/mM6lQr2tEY5vNS+K1UDcemi0OOifzKvSfbRf9SkZ1P+HEw6sOdiYrLyqXuErYeblEonWbi50ay6rYfSFxLqGw2yDsEsWpZY5TiN1NBzuM47cFdlb3xYjY8XfhEZ80eUXcOFP1e9zWpxRx5hcPQZxJl0MvL6v3XWok97DloonGwM1F1fs9o8xF5yLy4t8ZRz3x+6TYNpV/tX6hf2WZ1h/GAX/TOKO6347oX733g7y4PpcYOxWb5sJg7MrGpt8bQVxnu0vkg5Z5/iB2t8Ng7HD+PCews7o/TGx3s+I+9t+Jzoct7b9N/nToH+cU/vu5krgads8LXVuCxr+b+7yQ87yQo3idjciLf5MUf5uK5xHKPah5pH5zsuo8+nNnHs0I7GYc7LKS2HHunGgelT5nmbEre87yNyJiN1ESO7a7UZ+zzNi9ADS7Ruys7m9GYHecN7yQGLvl0I/dCw52eFaud5bw30fEbr4kdmx3y4mxG3aWMGNX9izhfzkE/m7U520ydmXP2/y3Q+DvRn3eJmNX9rzN/05sd7Pivhphl+isvPUaybN+YB3Knw56jmzH0cc9r1nhWvW8Zn5OsZ8zlrOIvCYS6OXtY5UZdyVHxRweswx0bkCb40DvGadiEaF+56UNeng8PdyU3Vj7DdFe2dK8kL1RQjba8U5nuGxPV3V2KeqwTrqiz9giGvbR+tQUPFP4adNlckg/6tSeMcio7iLYEfvpqvOpIfRR2LUJu63E2N0R2G052OHzBbtG7KzuWkTs2kKfmtBBzRG2+RdFe+wTf7cH5b1Ygpcn+yXRHnnyd3tQr5eIhvfxOcIvAS2Fzbxc8EObeUngVKf2eJ2XjOrajs286GBnsvKi4teLDnZ3CLuXE2P3SujH7mUHu1eAZteIndW9HBG7Ow52SDsZerF7cQTYqbGsit2Og53yL3cc7E4KfZpCn4jPhd+1vOxu6C9GexVkrxNtG2ioP5cJ+h/7VPW5MNqR6cYx5O1iXJpCt9TPhU3WvJDN+c16Ir28GL0udK0aoz/h2P1JuG9C1Hn5jYcd5zd3EmOnfMYdB7uyPuOTEbFrC31qQocyOcZd0R77xN/HQ3l3S/DyZL8q2iNP/j4e6vUq0fA+jjPoy1LYjPFDm3lV4FQP/f7TrvOSUd2nHJu562BnsvKi4sxdB7tXCLvtkBa794d+7LbDYOzeDzS7Ruys7rMRsXvFwQ5pz4Re7O6OADs1llWx+0kHO+VfXnGwe0bo0xT6xMOnvWo5w2uhvxjtHsg+SbQdoKH+XFR+Y32qmt+gHZluHEN+ZkzymzR5q2/3rwhdq9r9zx2C/CbNnNjD7jWB3fsd7F4D2msCO6v7pQPKb14TvLwc455oj31aKq7V2NxLLPsyyV4SsuepLerYFDxT2IzpMjmkH/XQjxtikFHdbzo2czn0Y4d1Xn5z2cFuKfRidy8xdjsCu3sOdhh77Bqxs7ovR8RuSejTDP3YRYzRbY61WIx2H2RzjH4daFXPZrE+VY3RS0Az3TKi/dGYxOhEZ6l37X6p4Id2f07oWhfY2rXC96uHIEYvhbTYXRbYLYXB2OEcvSyws7qvHVCMVv7Hi5M7oj326XpxrcZmh3hdjyD7OrTh7/1ddmTfiCD7BrTh7/1dF7LnxX3sw28B7aBi3C2BYdUY99eOvd5wsDNZeWmF/nG74WB3nbDbSYzdfYHdjoMdxkS7Ruys7u8iYne9JHZroRe7+4mxe11gd9/BDnMGu0bsrO6fI2K3JvRpCn0i5lbd3299EPqL0T4Asi8T7Q2gVf1NdOtT1dwK7ch0y4j2H5RboW6pcyuTpeyec6tUenl2r+ysqt3/b0S7bwh91DtMnFvdGAF2aiyrYpdlg7FrhH7sGg52baGPwo7jfKrfM/awa0fAbjYidpdLYsdxPs0618fucgTsFiNid13ow/+bfMzB+ffcrO35Qrem4J/aX/OaoUGyUa9Ua/Qa6YJjr9bmdYETrmcyqrsUcewnhD5lvgPaGAF2aiyrYnfTwW5CYDfhYKe+A8rnA0TGZ9103RS6et+FRnw2SdfNNLpumK4Phui6SbqiD3xANLyPffmDNP3o2qTlp2iTKNN0q1N7vA5hzyatbtOxyczBzmTlRfnyzMHudcLuA4mxe0Ng9wEHO1yL2DViZ3WvRsTu9ZLY8fP+NOs5H7vXI2D3ICJ2zwh9mkKfiOvdXVtDvhn6i9E+CLKvE+1DQKv6vN/6VHW9i3ZkumVE+zjlT6hb6vwJZaFO+N2aU9CGvwdj99dLtjdagPanoW6n04sFxvbtKDisrLGdRuS9qmzU8Da5aKMRx7f0mRAmf5p0jaxP9zt2HyR9GB/zLWqe2r0tQWvCNdJQzoeEHMXrekRebxAv1f9noG6nM1y21/7DFdt/pGL776vY/q2K7d+u2P6jFdt/rGR7m58fD3v3x5sPa++a379U8PuVwtnmvyH36eKaY8NnIGa/NWDtl4l+YT94vf5Zh+dU6MfK+67gnGiPZ0aZ7av1+VwJXg1HtvpdH+TJ7xWjXvy7Pnif+aaD+l0f+624Qb/rMwf9x/Z4nZeM6r7g5HtzDnYmK4Q9//am0Ef9biTukT/uE9AiYid/N7LnDLJOb39PlOyvtR/227mnCR/Mrd508JkbIT6Nivg09oHPKQefKQefmYPBZ13hM+Xg4/k5hY9nbxjjW6EfuwbR8LvwJjOPGX86IGb8aomYgXp5sVP124sHw3wy7zkqn+zxqoo58uR4gHrh772z7Frx2Qz9YzWK/N3kT4ek8WmlDK554fx9Qeiq/MCzcD3IpywIOYrXxYi8FqE/j+/v7NHM/kbhv2P+bvRJBx8V3/A5RsvBZ5S/G+3576q+ROGJ88yLb15+NMr4NlcRHy8/GuZrOYahz5wiGsY3k4nxTa0d+HwddT4Sxrr7nV5eGHf4fBlvHVIrdENeM0J/pTP6Do4/KdYVNh6DzqTl55E4fmgPGdX9RcTnkVNCH4UdzpuEMa/0moyxK7sm+6uI2M0Ifbz5qc6bU1ifIF4LQ3jx8zy8f4FoC0Lng3o+b3F90PN5061O7fE6LxnV/YMzplXzkEZJ7DDOsq4psDsrsFt0sMNzZ+0asbO6f42InbK7tGfvrq9bbP3+0F+M9gMgu0G0TwAN91i4qGdS1qeqz6TQjky3jGj/Sc+kUp1drJ5JmSxl9xxDU5+pbN9lGXSmMts9fvfFrhFfq/u/iHY/JfTx8pxm6Mf1oLBTY1kVu8axwdip/espB7sZoY/CjmNVonMpXexmImA3HxG7RknsOFal/k7a+dCP3TkHu/NAs2vEzurORMROrYe83K3sWgbvxfsy0fYNolnbZ4p+Jt7vkr5/mP64Di1eY+/qWYd7tyPouLK2tcXYvF1gk39cKa7nSZ9a2Fuf8t7sNbChWM/zbjo8lV1OQh2v69U6Gm3GngV7azSPl/dMwdtrzq/5jCLU66CfJaJedm9TyN4uPpf3U9be3RrhXmRb7SX17A90erEsu1/s5Tvoc84U11X32kb5LPIgnyXxXi1i5+3VjnIvu1ERn/3MXd6rxX0cPBud8cH4khCfys8iPR+t8BnmV98KvfioPcJhzyI//13Ewo8niIWfOMBYaO9dHcXCPdoh8DftUT/74HiF/hiflTI+hzVexX4O78UrL54fxaujeJVffyT04pMqXpWNG/c7vbzUvoiHBcrmZ4tq/075Xd6fGvWzRf4NnLLPFr/o7LFU/Q2choOd91w29d6ewk6NZVXsft7BLsZz2TLxwDDLi8K6yjte+TU/W5wQvMrs1476eTHvOZZ9XvxrI9ivnSDsUu3/WT8WBHYnHOxw/b8gsLO634iI3YTQx+Pl7dcqXoHuy0TbOtGs7e/Sfi2P5Xbx//I+i9qvnSKdbG33FWcdpr5r6K3DlO9S389U+DZK8PJke2ObX79NslGvMnaSObLVvhjy5N+FUe8O1KhtKNlvJXsW2nyUZHvPIPE+9i2pn0Ha+x2DnkHOQv+xPV7nhc/D+KrjW2Yd7ExWXpRv4TFVvqIZNK7bIT12aiyrYvc1B7sJgd2Eg52KWzWhQ5l1h/puKvaJ91xQ3qkSvDzZi6I98uQ9F9RrkWheLD9FtO3i/+V9Fu7H5IB+cCwv+47VXyaO5Qo7Pn859TtWpwV2iw52p4F2WmBndX8bEbuTJbFju0v9bp/C7mQE7P4xsd2pfRw8T+Fxn4A2yn3A0yX7a+3PiPaI+zThcyb09hN5qbgwDXU7nb1+PG7T2bt/lPuGmN8xntOiT14+eNrBADFqhX6s8b1DxmeU+4YTDj4qV1e5gDcfMSf+GOGD/iojGu4Bsi1mQ/S633nyqfYWs1C+j/k17wfi/fy+PN7H78Yco/5sF/8v77NwP9D/ssy81EP/uPTsrVPddHERI1ecFPqUOftscgTYTUbAbiEiduqsMc+Gsb2dAVNmfT5sjcxzy9vT8s5rS7VHwr4dx1T5m3ro9+MYFzKqu+iMadUznJTNe36mGXTM2Q5xsTsusJt2sMMzhuwasbO6axGxawh9VMyvEXaNNNiV/u5w168GPUe24+izUsY3IK6G3XGha0vQ+Oyf40LOcSFH8boekZfR0o73yobhhTmhFaOpfNpoTwENbYDLBP2Pfar6vRPM10w3fq/3bsEv8bmaci+bcwLOLw9CL/ZH6APVs4B66B/DnjUH1e04PrBOfcK6EPrtvib0mQlp1xGbW08wyoutYewdMS6TQMf2Hyr6jTHFPif3oed7m7sr763tvre7vvvoUfvhLttYIJxiy9/dXNt6uNp+uPnO+tru2saBy3+4vvHOw/b67vK7K/m/q8Pk5zb4gNaD+EyiNuAzLxMO75bgda/z5NPmb6K4t8zrWpSVr4d+aEDege85qrUkz+NPNvZ4/nBxPR/656VhMBN0bofrjEHxWmFs9cPW3OxTcU1Y5vlY3ZHdFO3LvoeA9+J9mdCT1yjHhD7quZ9adx4jXsP2EnY6Tz7L2pXtWxzrAN/O3j15aRT/TwI/bI/PmbH9p8HmPkNxPxPy8nZfcNpVnd+Tnd66Zqe//USnv73Jnu7062i0GaBlJOd48T/ihbxMj4zaf57GZArusftbQv4Uye/RW9ShHTKvCVFn7fPx+RzFQux77PXAY5nEH+tYN7Od3Hf9Py+fsqxtVQEA",
  "debug_symbols": "nd3bjhxHkkXRf+EzH8LN3Mzc+lcaA0G3FggQkqDLAANB/z7JblZSkEdk9Nkvgm5LpHh2ZWVZJav+ePfd99/8/sNXH37810+/vvvHP/949/Gnb7/+7cNPPz7+6o8/37/75pcPHz9++OGrv/7td8enP4we/wa//vz1j5/++tffvv7lt3f/MBvv333/43ef/iwf/4F/ffj4/bt/xPHn/7x/ENOJ62TqJHSSOimdrFMy+klqI60SOw6dDJ2YTlwnUyehk9RJ6WTpRF9/6OsPff2hrz/09Ye+/tDXH/r6Q19/6OsPfX3T1zd9fdPXN31909c3fX3T17e79X1uZOmkZeKHToZOztef641EbsR1MnUSOkmdlE6WTlom89DJ0Im+/tTXn/r6U19/6utPff15vn4+38RqbKRlEodOhk5MJ66TqZPQSeqkdKKvH/r6qa+fd2/7ZRsxnbhOpk5CJ6mT0snSScukDp3o69f5+utJ2jfiOpk6CZ2kTs7XX/kk2zOlWjppmaxDJ0MnphPXydRJ6CR1oq+/9PWXvn7r67e+fuvrt75+6+u3vn7r67e+fuvrt7y+H4dOhk5MJ66TqZOb9R//sxtJnZROlk5aJue3Ph/xRsw3MnRiOnGdTJ2ETlInpZOlk5aJ6eubvr7p65u+vunrm77++a3P/fkm5msjpZOlk5bJ+a3vNRk6MZ24TqZOQif6+q6v7/r6rq8/7972vTcydGI6cZ1MnYROUielk6WTlkno65/f+jyeJI+NmE5cJ1MnoZPz9cOfZHtydX7re02WTlom57e+12ToxHTiOpk6CZ3o66e+furrp75+6euXvn7p65e+funrl75+6euXvn7p65e+/tLXX/r6S19/6euv2/W3pz0rdJI6KZ0snZyvv+yN9PZe7PzW95oMnZhOXCdTJ6GT1EnpZOlEXn8eh06GTkwnrpOpk9P1Hz/4Z/L4FzaSOimdLJ20TM5vfa/J0InpxHUydaKvP/T1h77+0NcfN2/7j27/TuzQydCJ6cR1MnUSOkmdlE6WTvT1XV/f9fVdX9/19c9vfY/A34jNjYROUielk6WTlsn5re81GToxnbhO9PWnvv7U15/6+lNff+rrh75+6OuHvn7o64e+fujrh75+6OuHvn7o66e+furr5936bhtxnUydhE5SJ+frz7fPvzzeBjeydNIyOb/1vSZDJ6YT18nUSegkdaKvX/r6pa+/9PWXvv7S1z+/9T3eWN9I1kamTkInqZPSydJJy+T81veaDJ2YTvT1W1+/9fVbX7/v3va3s+3spZNWSRyHToZOTCeuk6mT0EnqpHRyvv6XD3hXbqRlcnHre0mGTkwnrpOpk9BJ6qR0oq8/9PVNX9/09U1f3/T1z299j1o/k0ceGwmdpE5KJ0snLZPzW99rMnRiOnGd6Ou7vr7r67u+vt+87T8etTbSMpmHToZOTCeuk6mT0EnqpHSir39+64t4e3YR+fdDRJzf+qLePpcUVRsJnaROSidLJy2T1H/Fzu9jr4npxHUydaKvn/r6qa+f+vqpr1/6+qWvX/r6pa9f+vqlr1/6+ufHrjzqM8kxNtIyOT92vSZDJ6YT18nUSegkdVI60ddf+vqtr9/6+q2v3/r6ra/f+vqtr9/6+q2v3/L6eQydnE/pb79/P6dtxHUydRI6SZ2UTpZOWibnl6vXZOhEX3/o6w99/aGvP/T1h77+0Ncf+vqmr2/6+qavb/r6pq9v+vqmr29368exkaWTlokfOjldv+ztY+Tavvpcnl+uqucb6dqI62TqJHSSOimdLJ20TM4vV6/J0Im+/tTXn/r655er4fVmHn+6oySoCFoENUDnN6w7NAgygs4fo+v5ILV9DiPP72UvH6TO72WvydLJ+VtpvL3UqeLvXwEhz+9lr8nQienEdTJ1EjpJnejrp77++b3sJTm/l70m+nvo83vZa+I6mToJnehv+6WvX/r6pa+/9PWXvv7FvSzfPrWW26tw8uJe9uoxeekP4xf3spfkfMrj+bZ/bM/Oz+9lr0nL5Pxe9poMnZhOXCdTJ6GT1Im+fuvrt7x+nb847FXJdXFie0lMJ66TqZPQSeqkdLJ00jIZ+vpDX3/o6w99/aGvP+T3yHV+L6vnJ71q+zChzu9lr0nL5Pxe9poMnZhOXCdTJ6GT1Im+vunrm76+6+u7vr7r67u+vuvru76+6+u7vr7r6/vd+v33VxLXPHQydGI6cZ1MnYROUielk6UTff3zK9kab2TZ2MjQienEdTJ1EjpJnZROlk5aJqmvn/r6qa+f+vqpr5/6+qmvn/r6qa+f+vqlr1/6+nW3fhwbcZ1MnYROUielk6WTlsk6dDJ0oq9/frhb+fbZlLV9R5A6P9y9JqGT1EnpZOmkZXJ+uHtNhk5MJ/r6ra/f+vqtr9/6+q2v3/L66zh0MnRiOnGdTJ2cr99vr/Pr49hI6qR0snTSMjk/3L0mQyemE9fJ1Im+/tDXH/r6Q19/3Lzt9/a9OpYdOhk6MZ24TqZOQiepk9LJ0om+/vmtr59fsb23b1axzm99r4npxHUydRI6SZ2UTpZOWiZTX3/q6099/amvP/X1p77+1Nef+vpTX3/q64e+fujrn9/6+vkNHTu2B6XzW99rMnUSOkmdlE6WTlom57e+12ToRF8/9fVTXz/19fPubT+2jyyydLJ00jKpQydDJ6YT18nUSehEX//81tf59pKAru0J/Pmt7zVpmZzf+l6ToRPTietk6iR0kjrR11/6+ktfv/X1W1+/9fVbX7/19Vtfv/X1W1+/9fXPb33dzwel7TO8fX7re02GTkwnrpOpk9BJ6uRu/e6NLJ20TMahk6ET04nrZOokdJI60dc/v/WNI56/Z+iI2FADdH7vu0ODICPICZoEBUFJUBFEijBShJMinBThpAgnRTgpwkkRTopwUoSTIpwUMUkRkxQxSRGTFDFJEZMUMUkRkxQxSRGTFBGkiCBFBCkiSBHnN8Mxnl+S//GnY0NBUBJUBC2CGqDz++EdGgQZQU4QKSJJEUmKSFJEkiKSFFGkiCJFFCmiSBFFiihSRJEiihRRpIgiRSxSxCJFLFLEIkUsUsQiRSxSxCJFLFLEIkU0KaJJEU2KaFJEkyKaFNGkiCZFNCmiQRHjOA6kBlKGlCM1kQqkEqlCaiGF2hiojYHaGKiNgdoYqI2B2hiojYHaGKiNgdow1IahNgy1YagNQ20YasNQG4baMNSGoTYcteGoDUdtOGrDURuO2nDUxsVl00a/Kdu+z+NDLaSaqIvjpj2/rO9Dxa4GUoaUIzWRCqQSqUJqIdVEBWojUBuB2gjURqA2ArURqI1AbQRqI1AbidpI1EaiNhK1kfdteO0qkEqkCqmFVBNVB1IDKUPKkUJtFGqjUBuF2ijURqE2FmpjoTYWamOhNhZqY6E2Lk6h9vxqp48/tV0VUgupJuriHHqnBlKGlCN138b25WkfKpBKpAqphVQDNY4DqYGUIeVITaQu2sgvasWuEqlCaiHVRF3cRe/UQMqQcqQmUqiNgdoYqI2B2hioDUNt2H0b2zcXeChDypGaSAVSiVQhtZBqovxACrXhqA1HbThqw1Ebjtpw1IajNhy1MVEbE7UxURsXd1Efz+eiPmxXE6lAKpEqpBZSTdTVN0+5Ubdt+Nif6YUh5UhNpAKpRKqQWkg1UXkghdq4uIu6fVFzf25zcRe9UxOpQCqRKqQWUk3UxV30Tg2kUBuF2ijURqE2CrVRqI26byP298vVRK0DqYGUIeVITaQCqUSqkEJtLNRGozYatdGojUZtNGqjURuN2mjURqM2mrRhx30btXY1kDKkHKmJVCCVSBVSC6kmaqA2Lu6i3vam5jh2ZUg5UhOpQCqRKqQWUk3UxV30TqE2DLVhqA1DbRhqw1Ab9l+0sb9V2kKqifIDqYGUIeVITaQCqUQKteGoDUdtTNTGRG1M1MZEbUzUxkRtTNTGRG1M1MZEbQRqI1AbF3fR6f5UHrtypCZSgVQiVUgtpJqovG/Dc1cDKUPKkZpIBVKJVCG1kGqiCrVxcRedMZ4qe1eGlCM1kQqkEqlCaiHVRF3cRe8UamOhNhZqY6E2FmpjoTbWfRu136PWQqqJ6gOpgZQh5UhNpAKpRAq10aiNJm34cSA1kDKk7tvYX5nmx0QqkEqkztuI5/dKHzHmrhZSTdTFXfRODaQMKUdqIhVIJVKojYHaGKgNQ20YasNQG3bfhtmuJlKBVCJVSC2kmig/kBpIGVKoDUdtOGrDURuO2nDUhqM2JmpjojYmamOiNiZq4+IuGh5Ptf++Nr+4i96pQmoh1URd3EXv1EDKkLpvw9euJlKBVCJVSC2kmqg8kBpIGVKojYu7aM5nhxnHrs7byC+35dy+E9FD5a1K39V5G+VvX5j+8acn/18LqSbq4i56pwZShpQjNZEKpBIp1EahNgq1cXEXvXlLubiL3qnzNtZ4fj3p5ftzgIu76J06b2Ot589w/76dDxVInbZhh70pO+aJqnMV66kqd7XIj3Vxdbx5FL24Ot6pSdpo9IjdiVQhtZBqoOZxgPdE8xhIGVIXbdTzNYFZvauJVCCVSBVSC6km6uLqeKdQGwO1cXF1vFMTqUAqkSqkFlJNlKHHDUNtGGrDUBuG2jDyPmVaIlVILaTQ+xQ/kBpIGVIXd4Avj2yxbFeB1MUdIL/cN9Ze1NX98EYtpJqoq/vhX1THrgZShtTFI8Cxnm0c+/uvi/vhnQqkEqlCaiHVRF3cD+/UQMqQQm1c3Q9fd3h1P7xRiVQhtZBqohI9biR63Ej0uHF1P7xRqI1EbSRqI1Ebid6nJHqfUgdSAylDypGaSAVS6PnhxSUw+/m1uGuc/FhN1NUl8EYNpAwpR2oiFUglUoUUamOhNhq10aiNRm00aqNRG43aaNRGozb6vo39uwzMbqDiOJAaSBlSjtREKpBKpAqphRRqY6A2BmpjoDYGamOgNgZqY6A2Bmpj3Lfhvasmyg6kBlKGlCM1kQqkEqlCCrVxcausL99DuHL7rHRc3Crv1EDKkHKkJlKBVCJVSC2kUBsTtTFRGxO1MVEbE7Ux79vYX0UQM5EqpBZSTVQcSA2kDClHaiKF2gjURqA2ArURqI1EbeR9G2t/HpWG1H0bq3Y1kQqkEqmLNvr5Gbp1bB/DxsX98PXrvuLifrj6eZ3r49iVI3X+K//61WJRgVQiVUgtpJqoi6vjX9V+34iLq+OdMqQcqYlUIHXfxv57K2IVUgupJqoPpAZShpQjhdpo1EYnUoXUQqqByuNAaiBlSDlSE6lAKpEqpMj7lDzI+5QcB1IDKUPKkZpIBVLkOVte3A+X5ZfnbCc/VhN1cT98/fwwbSBlSDlSE6lAKm/VnLsqpBZSTZQfSA2k7tvYv/NauiM1kQqkEqlCaiGF2piojYnamIaUIzWRCqTQ48ZEjxsTPW5M1EagNgK1EaiNQO9TAr1PCfQ+JRKpQmoh1UQler6R6PnhxSWw5/N1sJ0nP9ZEKpBKpAqphVQTdfFaxzs1kDKkUBuF2ijURqE2CrVRqI1CbSzUxkJtLNTGum+jjl1NpAKpRKqQWkg1UX0gNZAypFAbjdpo1EajNhq10aiNJm3UcSA1kDKk/os2YlcTqfs29tfP15FIFVILqdM27Hh+xSQ75v4rf36rvFXjXL38KhB1fqu8VY7URCqQSqTqVu03hxoLqSbKLtp4+RVCygZShpQjNZEKpBKpQmoh1UQ5asNRG47acNSGozYcteGoDUdtOGrD79tY22sCax5IDaQMKUdqIhVIJVKF1EIKtRGojUBtBGojUBuB2gjURqA2ArURqI1AbSRqI1EbidpI1EaiNhK1kaiNRG0kaiPRc9E6kBpIGVKO1EQqkEqk0McphT5OKdTGQm0s1MZCbSzUxkIfwy70MSz6GpK1CqmFVBPVB1LovnF+F7VxPNUYtStHaiIVSCVShdRCqoFa53fRWzWQMqQcqYlUIJVIFVILKdTGQG0M1Ma4b8NiV47URCqQSqQKqYVUE2UHUgMp1IahNgy1YagNQ20YasNQG4bacNSGozYu7qJjHk+1v4JrXdxF79REKpBKpAqphVQTdXEXvVMDKdTGvH/cmHuHcyIVSCVShdRCqomKA6mBlCGF2gjURqA2ArURqI1AbQRqI1Ebidoo9GtY6New0K/h1SvT6vndPPuvv7f9M7p40Ufn8wN6yw0V+ZEujhvHlx/pr7897TNqgK5OG6/RxWVj1JdfiNiQEeQEzfv/p7/u9H77dx932M//6uOmtf3nSQZXLwt7jUpEfz7+4n+//uXD1998/P7XB/n0z37/8dvfPvz04+e//O3/fn77J9/88uHjxw8/fPXzLz99+/13v//y/Vcff/r20z97d3z+wz8/fcWA96NtPH46n5YYOd8/Pmn36Sf373+80t8//rA+/Y3xn7/Rj79R4/Ezefxs/h8=",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
