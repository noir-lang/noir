---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
