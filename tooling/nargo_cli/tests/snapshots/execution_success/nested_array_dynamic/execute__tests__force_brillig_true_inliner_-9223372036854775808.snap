---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
