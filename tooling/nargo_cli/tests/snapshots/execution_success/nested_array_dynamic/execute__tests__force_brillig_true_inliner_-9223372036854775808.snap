---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdzLzhzHsQTgd+Fai8mqykv5VQzDkGXaIEBQAi0d4EDQu7uzOiOSXBgQejaqT6Q6Yqb/yZ7LX6PfP/zz4z9++/ffP33518//+fCXv/7+4R9fP33+/Onff//8808//vrp5y/Xn/7+4ZX/kJgf/iI/XOuqVWu1Wr3WqHXf674OH7lKraPWWeuqVWu1Wr3WqHWfdbxetUqto9ZZ66pVa7VavdaotfKk8qTypPKk8qTypPKk8qTypPLkypvXOl61Sq2j1lnrlbdy1VqtVq81at33Ol+1Sq2j1llr5c3Km5U3K29W3qy8deVprlLrqHXWumrVWq1WrzVq3feqlaeVp5WnV57lumrVWq1WrzVq3fdqr1ql1lFr5dmV57lqrVar1xq1Xnlxrf6qVWodtc5aV61aq9XqtUatlReVF5UXlReVF5UXlReVF5UXlReVtytvV96uvF15u/J25e3Ky/nYuUat+6wz5+OsUuuVJ6/EBBaggAEOBLALOSc3BECyIFmQLEgWJAuSc15EEruQE3NDgAFMYAEKGOAAkgeSJ5InknN6ZCQmsAAFDHAggF3IKbohAJJzkGQmFqCAAQ5k8krsQs7TDQEGMIEFKGCAA0hWJBuSDcmGZEOyIdmQbEg2JBuSDcmOZEeyI9mR7Eh2JOekiSYcCGAXctpuZLIlBjCBBShggAMB7ELO3Q0kbyRvJG8kbyRvJOf4iScC2DdWTuANAQYwgQUoYIADASBZkHxmMBIDmMACFDDAgQB24czgAZIHkgeSB5IHks8M7oQDAezCmcEDAQYwgQUogOSJ5InkieSF5IXkheSF5IXkheSF5IXkheSFZEWyIlmRrEjOGRyvhAIGOBBAvti4rj8rZ/CGAAOYwAIUMMCBAJDsSHYkO5IdyY7knMExEgY4EMAu5AzeEGAAE1gAkgPJgeRAcs7guK5+67w2PBBgABNYgAIGOBBAJet5lbgSAgxgAgtQwAAHAtgFQbIgWZAsSBYkC5LPq0ZNOBDALuQM3hBgABNYgAJIHkgeSB5IzhkclhBgABNYgAIGOBDALiwk5wwOT2RyJBwIYBdyvm4IgKNyvm4sQAEDkKxIViQbkg3JhmRDsiHZkGxINiQbks9Y7YQAA5jAAhQwwIEAdiGQHEgOJAeSA8mB5EByIDmQHEjeSN5I3gjMaZqvhAIGOBDAvmE5TTcEGMAEFqCAAQ4EgGRBsiBZkCxIFiQLkgXJgmRB8nkbdl3i7LwPOxBgAJk8Epk8EwoY4EAAu5DTdEOAAUwAyRPJE8k5TXMlAtiFnKYbAgxgAgvIHE1E3Z2cr4OcrxuZY4kBTGABChjgQABINiTnfN0YAM5qztcNBQxwALfZkOxIdiQ7kh3JOV/TE1b33XEScr5uZOA1uZbzdUOAAUxgAQoY4EAASN5I3kjOp63TnoN2YwEK4DZv3OaN23wG7YKfQTsQYAATWIACBtRZ9TNf17z7ma8DAQYwgQUoYIADASB5IHkgeSB5IHkgeSB5IHkgeSB5IHki+Xzk8UoMYAILUMAABwLYhZyvG0jO+VqSmMACFDDAgQB2ISfuhgBIViQrkhXJimRFsiJZkWxINiQbkg3JOXErf+45cTcMcCCAXciJuyHAACaA5By9NRMGOBDALuTo3RBgABNYAJIDyYHkQHIgeSN5I3kjeSN5I3kjeSM5R2+tRAD7RuTo3RBgABNYgAIGOBAAkgXJOYNLEwOYwAIUMMCBAHYhZ/AGknMGlyUmsAAFDHAggF04nzoeCIDkieSJ5InkieSJ5InkieSF5IXkheSF5DODnlDAAAcC2IUzgwcCDGACSFYkK5IVyWcGI7ELZwYPBBjABBaggAEOIPnM4HWJizODBwIMYAILUMAABwJAciA5kBxIDiQHkgPJgeRAciA5kLyRnDOor8QAJrAABQxwIID8KPm6ju2cwRsCDGACC1DAAAcCQHLOoI6EAAOYwAIUMMCBAHZhIHkgeSB5IHkgeSB5IHkgeSB5IDlnUGdCgAFMYAEKGOBAALuwkLyQvJC8kLyQvJC8kLyQvJC8kKxIViQrkhXJimRFsiI5Z1BXIoBdyBlUTQgwgAksQAEDHAhgFxzJjmRHsiPZkexIdiQ7kh3JjuRAciA5kBxIzhlUSyhggAMB7ELO4A0BBjABJG8kbyRvJG8k70qW1+tFCTWoSS1KqSzwI6eC2tAZx1tCDWpS2RFHShnlVFAbOoN5S6hBTYodZzr3kVFOBbWhM6K3hBrUpBbFjsmOyY7JjsmOxY6cVnsdDWpSi1LKKKeC2lCObYkdyg5lh7JD2aHsUHYoO5Qdxg5jh7Hj/HpPjhallFFOBbWhHOVSdoyjQU1qUUoZ5VRQG8qhLrEjx9rm0aQWpZRRTgW1oRzvklDs2OzY7Njs2OzY7Mgxt3W0S5JzXhJqUJNalFJGORUUO4Qdwg5hh7BD2CHsEHYIO4Qdwo6cc9MjoQY1qUUpZZRTQW1osiPn3OxoUJNalFJGORXUhnLOS+xY7FjsWOxY7FjsOHPuR0Ft6Mz5LaEGNalFKWUUO5Qdyg5jh7HD2GHsMHYYO4wdxg5jh7HD2eHsOHMeR5NalFJGORXUhs6c7yOhBjWpRSlllFNBbWizI+fcX0eDmtSilDLKqaB26WyYKQk1qEktSimjskOOgtpQznlJqEFNalFKGcUOYYewY7BjsGOwI+fcx9GilDIqO+ZRUBvKOS8JNahJLUopo9gx2THZsdix2LHYkXPu62hRShnlVFAbyjkvCTUodig7lB3KDmWHskPZYewwdhg7jB3GjrNlR4+MciqoDeWcl4QaVHbY0aKUMsqpoDaUc14SalDsyDl3P8qOOMqOfZTbe86knA0+tzZ0NvncEmpQk1qUUkaxY7Njo+Ns/Dm36mz9KWWHHE0qO8aRUtkxj7JjHQX+7My0Hw1qouPM9C2lcF7Ovp9SUHmb8yd4tv6UhBrUpBallFHsGOw4M310ZvqWUIOa1KKU4v2Y7JjsmOxY7Fg892emb/FcLZ6rxXN1ZvqWUwHlJIcdCZVn6PwUcpJLi1Iqz9Cd4lRQ+VM4tzknuSTUoCa1KKWMcioodpxteKf3bMS7NahJLUop3g/n/XDej7Mx7yjYEewIdgQ7gucqeK7ONr1bTgW1oTPJt4Tizzfnd59pzPktGeVUULt0tg2VhBrUpBallFFOBcUOYYewQ9gh7MiZ3nKklFFOBbWhnOmSUIOaFDsGOwY7BjsGOwY7JjsmOyY7Jjtypvc4Usoop4LaUM50SahBTYodOdN7HhnlVFAbyukuCTWoSS2KHcoOZYeyQ9lh7Mjp3utoUJNalFJGORXUhnK6S+xwdjg7nB3ODmdHTvfWo6CyI696ZxtSSahBZYcfZUccRT3nnR1HO69DZ8tRSerZ72w6Kk3qbGU9w3A2/xWt6c1obvBsQTq34+xBKp0ts3I4m6upTWt6M5qbvDfnntp7e+7N0ZzN1dSmNb0Zzb5no9tGt41uG9028Grj7FgqGeVUUBvKKS8JhZ/z2bB0fWBxqE2rn/nZtVQK6tyJHIazcwmU5mjO5mqeqnVozXPK9DCamzw7CovSHM3Z7Lazv7doTW9Gs++b9X2zvm/W9836vlm3WbdZt1m3GU/keWI/Ok/st4Qa1KQWpRR//Gfn78sON3l2/xalOZqzuZratKY3uy26bXfb7rbdbbvbdrftbtvdtrvtvjycx+x9eUiePVWgNEdzNldTm9b0ZjS7TbpNuk26TbpNuk26TbpNuu2+QMThJu8LxD6U5mjOZrblNwPE7r39N/GG5GzEKgW1oXOJuCVU9uRufzn7scDV1HqPczZllZwKakN5sSgJNahJLYodix2LHYsdix3KDmWHskPZcS4P+U0DOVu3QGt6M5qbPJeHojRHcza7zbrNus26zbrNus27zbvNu827zbvNu+18UeD+0Z2vChSjuclzyShKsx8S0Q+J6IfEuWQUuy26Lbotum132+bj77ycuDWpRSnFx/jmY3zzMX4uFfkdETm7wkBpjuZsrqY2renNaHabdJt0m3SbdJt0m3SbdJt0m3Tb/dWffDT7/eWfm9IczdlcTW1a05vR7LbZbbPbZrfNbpvdNrttdtvsttlt5yVGfmVFznYzUJqjOZurqU1rejOa3XZeYuR3U+RsQgNHczZXU5vW9GY0N2nd5p3gneCdcE+qH27yntSb0hzN2VxNbXbYeZbO76TI2f6FPz3/7T60pjfzluU3NORsBLt5toKBecvySwsSL1bEPW83T1v88ccPH/Cl2b//+vXjx/zO7Dffov3r7x9++fHrxy+/fvjLl98+f/7hw//9+Pm38x/955cfv5z11x+/Xn97tX788s9rvQL/9enzx9QfP/TRr/996MivdpyDr8+7ebj++ePznNTx/t7xcz05PrdG3cfro9tv7Hd5r9/Hk+ODx+/56Hjj8eut469PgB8cP/M6ch8/ntz+Odk/473+uZ8crzzeXo+Onzxe3jz+0f3Pt0L38fvJ7V8v9F+fDL7Vf32e+KR/4OJ1fbb33vHzyfythcff9bnak+MNj5/r0673+h/9/Fef/3hy/lVw/b8+43mr//pg6Em/4v5fHzU8Od7x+L0+GHhwvOVb0nP89R73yfET1+/rvd17xz96/PnA+fNHz5+en6Lex+8n5y9/+VIB+ZuWJ2fAeQYePYJdcQW4Xqw+6TdMgD2aYH+x//XkEeB8BPuj8/fN8fvJFSQEx8eQ945/9AgOwwMoHr2Cio0J3q/3+vejV0Cbr0D2o1dAm68gt77Zr0/O3zZcQbY/OX97s//R4++b/v3kFVxuMMUV6KVPnoNE+CIi9wM+Sei3MbmX6FECn4hyD9K7CfPRtXzwUpo7f969DY+uxrm5hwmh7yY8fE4Tnocp483bMOXReZijE5a+m6D+boLHo4SNl4e5j+DthEe3Yc3JhKnv3oZpj26DChNsv5vw6HXCdwnPJkv5UkeevVv4LmE8miydyoRnV7lvb8OjzxzyFzVIePaqPX/J1AnyboI9usI4P3rJz6KfJITwmTcevfuWCN6LZ6++xmsgYbzWswTlR3AvfzTd5rxOXr9WevSY7ITrV9WPEqznIua7CfvR9cFewfPwenQebPN1lD973vw24dlruW8THn2mmL8qYcKjT3W+S3j2mPw2IeTthEdXWudbs/z1x5OEPfiY3OPRzyJ2Jzx6f/jdNerZY/LbhGfPesGPea4rrbx7rV6PnrtD+zbY693b8OzdQb9Zlv3o88LvEh693/0+Qd9NeHStHi++Crqe9V7vPm/qfPd5M55c5Ybwlw/j+uXruwmP3jUPWS8mPJqL727Ds3dq26UfD99M958P2Pwt4OvbX+P++Z/lqwO+vcb9+QDxvgX67i34X3dB8rfVf+KD0Pgu4G/Xv/z406ev3/0fqv/IoK+ffvzH54/1r//67ctP3/ztr///C/4G/4frX77+/NPHf/729WMm5d/d/5vr6x9/vZ7g/IfrMh1/++HDzH+/PlUUX9e/yflrt3H9u3n+gZw/uH7m1z/m3/7IG/hf",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
