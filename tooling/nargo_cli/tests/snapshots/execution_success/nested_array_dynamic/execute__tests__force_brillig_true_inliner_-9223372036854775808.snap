---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dXYhkSVaOzKpbVZndVZXdXd3TP9PTVT39P9O9VZ311z09MzUz1bOzqw+KoCIiVHdPgwgr8yIsrJCyC4KiiE/ik+DPgrL6sOyTPyiuD7IgDoIwL6KL7A6srCALysKCe7vvyfryyy9P3rsVkVnJVECRt27EPeeLL07EORH33ri18Dy9+MO/WnE8XfzWi99akY/Jyu4Uv6sHS2sRZa2mwlibAIz1CcA4NQEYpycAYzYBGGcmAOPsBGCcmwCMjQnA2JwAjMcmAOPxCcA4PwEYFyYA4+IEYGxNAMYTE4Dx5ARgPDUBGJcmAOPpCcB4ZgIwvjABGM9OAMZzE4Dx/ARgvJAAYwqcLybC2bNYlYPOF0XyRYd8Up9PmvNJaT7pyydV+aQlnxTkQXce1OZBYx6U5UFPHlTkTjt3irnTyQf1fNDMB6W80+edKjfa3CguAEG8WIbkXZ19/tso/q9DfsSFkbUG6Y0pf3t1s90Q9YuI/5l8kxlf/toTkz+dBv9q0czh3U6v/EB6DUeadlrfTFzPx/NUtwB1Md1ZGt1PaqQvEMeB9DdDSpt6vkCM+gwP81MnfmbT4Fk1+XOJ5Ft9G6K+yL/Vb7H4fwbycJwaJAvtx+rSEtfPjIbXtcS8rlXl1fAcS4OnbX28CXi4jx9Po3u9bB83/U3Cmqptjof+tkF+rI/PW5nOPp4G5U13+utheRnkWfvmdvdHUD/MQzxev0FbMdyJ+8164n5z96jfdNNRv4G8Ce83W4n7TfsT6se3E/O6fjQe9XKB+oyLEI7GIzs/IePRo8T9ZuOo33TTUb+BvAnvN+8n7jebn1A//jQxr1tH41E3HY1HkDfZ49Ha3cT9Zvuo33TTUb+BvAnvNxuJ+829T6YfX9tMzOve0XjUTUfjEeRN+Hh0L3G/eXTUb7rpqN9AXup+Mx/6bWyK8uqg51FnH89fALavFsdpn7XY7D6zkuiZntVTAj/qytNsJ/Tw/uwXzln7WXvOYXnKa0DedKdXT7P4fxr0oCzDkVH5Py/+Xyx+Z+Aau74l9M+Q/h7c4hzz0hDlG6J8Hut8uTjObdL6xjudXnk7xe/qwVL3Oa1dkJ/iObCHaeS3c47yPvbNIkj0ngcqM3ZiW7RIFto+P9cUsU3apisjvWhT04CfY29+3inxc1Dd+0zmf7MhuDIq/zfFb96OH8/01tnK1IXMPKFdDYsRTA6Wb4ryOPfgOQ7GOM0wXPcsnNvt9JY/VhGr8rHotxqEFfHZtYljo7seVow/j1Hd5kM1LhZE+XlR30Whe4Hy8DqOmRfS8NR9ds380DTUA3XOQ/2xPB7nKaNzHxa/ub1+h/rUvMOd6cpTK/Tb0bzDHcffi4m5awnuFh3uWpBnx8idnfsoxONuVuBpiOt24nCzxvWzus0JHFzvfyd8J+CamO13EuQG0uWNs43Q344p7MqwoF2hTsNWFzzZMfJr575V/Cq7moPrpsQ5r0/OOdxxn0zVplaPk4K7Ew53aAt2jNzZue+GeNzNCjy8RhLicdN3nyOe7LX1ecFdjep0Cs6PYy3C9DdDf5unWIs4RXiYH1yLyPOWBNaWyEO7wTzUsyT0KFnTEWWxDWNezPsOxtfp0J8s7wzo5nWUFyCPfUCg+mPCOuV1/S7M9bgc40HbN2wZ5c0VFzZC/9ia2u/xGiLPKTDunQV+uG6MuUbnswHX8Zys22YFSDUnszJ1ITNPDzu95dFeysT2Z0T506Ku5u/Q3s+E4bqR891Ob/kXKmI9K8qjnZ8mrIjvbBiuG9v1WAndHtZzojxieIGwou5zlIfXWZ0aVDZVjHG+kIcxBuo8C/XH8nicp4zOXQKb5xjjrMOd6cpTKwxuZ8Udx7bnE3N3QXB33uHuAuTZMXJn565H5K4p8DTEdTtxuFnn+lndlgQOrvcd8h0vwjWpfYfp8sbBRuhvxxR2ZVjQrlCnYasLnvB95YzOrTt2VTVmOiPwKO64T6ZqU6vHxdDP3YsOdxchz46ROzv3ICJ3TYGH46UQj5uNhsAUSXb3OY+L0WXvx8gvgewa8XUJzo9jPmb6m4Q1Mp7ufOwS4WF+eD62LLC2RB7HystCz7LQo2QtRZRldsV2FpfftafzoZ9fS4rLM5S3AnloA5zUfMzqVHU+hjwvF8fsb3+GfCqO26l96hnCz3aBMXX3WYYw2L/UQm9svgR1VtdlAzj5eRjLPx4wlteFzDw97PSWV/0R24rnDcui/CVRV/OlaO/LYbhuHON3O73lVypivSzKo51fIqzLkHc5DNeN7XqshG4P68uiPGJYIayo+2XKw+uWi+MGlY3df6weVwp5GL+gzstQfyyPx3nK6NznwOY5frnscGe68qTG58sOdxzbXEnM3dXQz90Vh7urkGfHyJ2d+5WI3C0JPA1x3U4cbra4fhzXol6u96+S77gG16T2HabLGweZt1HaFeo0bFXt6ouOXWE8PSXOlYmZFHfcJ68m5u6a4O6qwx3amB0jd3buNyNytyTwJJwzbaebM63e474aT/bapsWd10F2jfi6AefHMR8z/U3CGhlPdz52g/AwPzwfuymwtkQex8o3hZ6bQo+SdTGiLLOrtO199968wGXJ8m6B7mXKewXy0AY4qfmY1anqfAzHLsPG49afkE9dhmtS+9RlqDPrrhMOHr+zAddlA+r5pzA+8xzLytSDXg942Oktj/2pzFzA65MqtliGvBthuG4cW3c7veVvVsR6S5TH/nadsCK+W2G4brRJnmO9UhHrq6I89rObhBXxvUp5eJ3VqUFlU8Uktwt5GJOgzleg/lgej/OU0bm/cmKSVxzuTFeeWqG/nV9xuLtF3N1OzN2d0M/dbYe7O5Bnx8idnft6RO5uCTwNcd1OHG72uH5Wt2WBg+v9DfIHn4JrUvsD0+WNg43Q344p7MqwoF2hTsNWFzzZMfJr5z507GoZriuzLn1D4FHccZ9M1aZWj9XQz92nwmDuViFvVXBn5z6KyJ2K1Rriup0QhZvuvkar8WU/Ntlr0WWvbVkseRdk14ivNpwfxxzL9DcJa2Q83TlWm/AwPzzHWhdYWyJvGY4xD/WsCz1K1mpEWWZXDSE7Hr/t7ru3yK8lxeUNytuAPLQBTmqOZXWqOsdahjzDxv72e+RT0/CnfarpKuNTU+EyGzQ7Qr+AOg1bncrz2JbRue8fAp+6lpi7tuBuLQzmDsfktuDOztXr8bgbrU/dfML+J6Ls7n5q6/FlP+XxyjhDvjbh/Dh8qulvhv6xNYVP3SQ8zA/71C2BtSXyluEY81DPltCjZLUjyjK7ShtDtbtr5MivJcXlLcrbhjy0AU7Kp1qdDuJTDRv71IsFuYljUOlT24R/mTDiOhW/V6JiR1zT2+301ivB+LPOY0w82e273E73CzLy5n+5OFb7hOD4l6dpyIvYnk9yW1yc3ceRy8f3jTPChO/hTonyvCbZEuXxvVVb/2xReWwPxc/CGPmpVeSndgB+rjv8YLzP/HxS7Kft8HOL8tCvm868H/7kUT90+6GNuUf98KgfDuInZj9cDL3c4TWJ96rY8+pbE7gXBRet0WDt7hV3oiJWbJsTo8H62DCdq4gV36fn9/Jqo+d8lesxaC8Tw1an8sxBRuf2nPWHWhjMnekKQffBmsMd20DqPScUd60I3P1iRO5OCDz8P+9Dkx9vUp6V/WWan41jvxGPC3xWfbfTixV9xU4UnJsbzENE2d05PtoK+uH8ONG7p6XXk0x/M/TbeIr1pPOEh/nh9aQLAmtL5OH9B8xDPReEHiVrMaIs3mMHZVu9R7VPjHqH+4Sodz3026b3DvcXnfFOxXeLDnfnBB5eu/hDWLv4dYrV0Pcxv+PeG2sB6sy+xtsb67ccftWebCp+VvxyjMOxCuo5UVKP18/R1lZIN3Jh1x62eV7PPlOd8vVV/KgxBfsbv4OJY8o5hx+MoUbNz0JFfhYOwE/N4adFeYPmeV+nWAjx7IQYPLXb6WKXdncfKhw7OL5I5FNKxxemvxn6+3mK+EKNU8gPxxfnBdaWyMP7foPs+bzQo2QtRJRldnUYxnD0dUdjuD+Gtxx+DusYrtaiqtqPml97dl12DC+zVjdFeTvF/6sHS91vHnlrvahf9dXF0WC957Wlh1WtKy6GwW1zWPYNNWz10D9+efuGfujE3FOCOzzH47UakxV3bAPjng8yd2Xngx9F5I7nbMhPmvlce4ufv8Cknr9YoLx7kIfzLU5T9D/WqeqzGWhHhi2jvG8NiHdj25da++OYR81bsV7sS7z7RLXQvw+76ldlxmmlW/kxlMn7niOu85Tn2fO496Hj9Z+y+9D9T8T1H9VuZfxM6rUdxZ1qy6rcfT+xn0m7F914x0qrU4qxcrY4mMSxUs1LUCbvj4p8XCghy9P9oiiPMnm/U8TFeyuyzeZpVPsDXi7kDdof8ALUH8vjcZ4yOneqqIjq71XvM6h2KzNWpt6XUnGn2rIqdxcc7mKOlXjdThRuNrfS7d2zuc17TkWU3d1fAfeMqhFfifaGKb3GaPqbhDUynu4a41XCw/zwGuMNgVW918LrdWp/ghtCj5J1OaIss6uGkH1YYwm0AU4qlrA6pYglNic4lrgsyqNM3tsP+bhcQpan+2VRHmWukG7E9TLlsc3micfNVP4w1V59bzv+8LLDnenKk4olLhN3XiyRZizwuVNtWZW7z05uLLHH+yRGlP2IfXpE2Y/ZHxpnyNct4jKO7vKxhOlvBu2fd+Lg6cYSal8f5ZeNu1cF1pbI41hC7cnzqtCjZF2JKMvsqiFkH9ZYAm2Ak4olrE4pYon3JziWuCLKo0zewwr5uFJClqfbi9nz45ukG3FdpTy22Twlngt1/aHZ4qB9Mq9A/dl2cVzJ6NwHjj+84nBnuvKkYokrxJ0XS6Te91dxp9qyKnefTxxLKO42iLtEfmqV/RRyd8PhDv34LcGdnfu1iNzxu/DIT5q4Iq6fqfoet9UphZ/57UPgZ9LF0Kur6nmXGuk9bLFoojZwY1H1fM84Y9H5iLL4O+OMM0/8jdJU46vVC8dX1mn1YR6wz2d07g8ijq81gWdeXMfczafhrnQ/Mv3N0N/OKfrRfEle1f7E88Q55vH3S1V/vSX0KFlnI8rqfr+S/rf8PCW2hY0f1RYSfXfUtYWm4NW4OyuwtkQez8Wqfu+P2z+WrKkEuIwb5LI24Nf08DnWg3bI37QybnEv6xkocwzysfzfwlj78YD3dOpDZHq8Kbvx+q+yl0Wh+1YJ3RgH7HaG6/awKp+txiY1F+f9obGOVqfE8dsq12N6SD3qVJ45yOjcPzk+u2p/mhF4FHccc497b23mruze2v8akbsFgacmMHixspW/I8pjnfj5RdR3p4QsT/enRHmUyc8vIi7e+xmv4+/E4l7CKWxmtZA3aP/iO1B/LI/HeeL9i//TsZk7DnemK0/Kf91xuLtN3I17j0/mruwen/8VkbvbDneYd5K4uzMG7lRbVuXuew53any57XB3UuBJuwdq9bWvs5SHa1+8DhSo/piwTlXXvtCOeO2rm1dMtBoCW+q1Lzu3KHRzfHM2ES7PR58VWKv66NmCX2X3J+G6KXHOi2887ji+uZ2YOzVm3Ha4KztmLEbkbkHgqQkMZWIMtX8m1omfOUZ97RKyPN1qD3WUyc8cI651ysPr2M/gHiMpbMbW/9Fm1B71dSqPx3nK6NxFx2baDnemK0/Kz7Qd7nhv+kT7FHe52xLcbTjc4d66W4I7O3c1IndrDneY9xJxl2oPXY871ZZVubvtcKfGlzWHu5cEnobAEzG+2eYYBpMXw1jefcir+q1vq1PV+AbtyLCxD7k/IfFN6r37ld2vCaxV7X7nEMQ3afrEPnfbgrsthzucB2wL7uzceyOKb7aFLC/GuCfKY534OWjUdy+x7hXSfUnoXqSyiLEhZKawGcMyPaQe9dDPG3KQ0bmfdmxmJfRzh+e8+GbF4e4ScXcvMXf3BXf3HO7Q99gxcmfnfiEid5cEnkbo5y6ij95jX4vJ8l4D3eyjH0Be1fdPrU5VfTTyZNgyyvulCfHRifaL7Nq98YF2f05grQtucS9R5veDQ+CjLyXmbkVwd8nhDvvoiuDOzn1+RD5ajT+en7wvymOdrhXHqm3uk6xrEXTjN3X52eYVR/f1CLrxO8b8bPM1oXtRXMdjOH5veFQ+Tn3juKqP+w3HXq873JmuPLVCf7tdd7jj75/fT8zda4K7+w536BPtGLmzc78bkbtrJbm7G3q5ey0xdw8Ed6853GHMYMfInZ37/Yjc3RV4GgJPxNjqicUrr4f+ZHlvgO4VynsT8qp+99HqVDW2QjsybBnlfZliq0TfJZWxlelSds+xVSpcnt0rO6tq91+JaPczAo96holjq+tj4E61ZVXuvuZwNxP6uZtxuFsQeBR3K6GXu9TfrFDcLUTg7q8jcrdSkjv28ytj4G4lAnf/EJG7awIP/2/6cYzkb1ZY2W/QeI3yU4/XPGeYId2IK9UcvUZYsO3V3LwueML5TEbnPozY9lMCT5n3K2bGwJ1qy6rcfeRwNyW4m3K4qwk8ifeD3TC96juvCo+aQ24S1kTfyN00TK8PwbpJWHEMfJ3yVF9vUNlUNmnxKdok6jRsdSqPx3nK6Ny3HZushcHcma48qbG85nD3gLh7IzF3bwru3giDucO5iB0jd3buvyNy9yCU447v96eZz/ncPYjA3f9G5O4lgach8MTjZ737TuhO6E+W9xbovkZ5b0Ne1fv9Vqeq8120I8PG3/yazp7/NgS21PETt2MNMJodnIIy/B6MXV8vWd7yApQ/Ded2O71coG/ficLDWpvtNKLsu8pGuX+gjUZs39LvW5r+JmGNjKf7jt1bhIf5sbFF9VO7tiXy5uAY81DP20KPknUtoqw3SZaq/0twbrczXLdX/p2K5Xcrln9Ysfy7Fct/umL59yqW/0zJ8vwds3eLcTkf7i8Vx2qeuVMcj+pddFuLGfQuOs8zce2m5/shdO5qUccY88wdgYf93k3QN+h9TNTnvbM4bP/5t4pj1X5l9p+fcXQP++axt6ey950ZXG/O0zTkRbQr+Z0Z5CDrlK+v4sf75hP6f/VN1Z2wj4v5we9xjJqfmYr8zByAn1MOP7hfDfPTHA0/G+P+pvjbxA9yN0N5+F45fqfog6wXP6+L5inx+F46fjP9zdA/lqWI32YJzyB75rbHa9U9j1fgeNCY730rE2VdjChrqThmf/VTjr9SHHkxieoDnn8b1gd4rxzlYzxZXv8bNj6xf0Ncdu1h+85cz/dcO+Xrq/hRz1ThGM3+Td0TUPzgt+pHzY/n31Tfqurf0D49/7bo8PNJ8W88hh7Ev6n4l/fsago82L4PO72y0B8O2qtFycqPC1hdWU2BX2E2naO6J27tUfaeOLZfTyxN574Qcc6l5oCKO+w3jDUFd8O+u83clf3u9pcictcUeLz+yftShaC5Zt97YogsvjeG1/O36k8IzKO6120x0qB73YatTuXxOE8Znfsdp00Vd+r7r+rZJI879LOMNQV3ZwV3Sw53+E7/WcGdnfu9iNwpu0u7r8F6912Rz4b+ZHk/BrpnKO/HIW8Hjjmp+ztWp6r3d9CODBt/q/SP6f5Oqn0h1P0d3lMK8bIPTb1fhb0XMmi/CrZ7fI/EjpFfO/dnEe1+VuDx4pxRfQtWcafasip3X3W4U3PaWYe7psCjuGNflWiPR5e7ZgTu/jIidzMluWNflfr9LvUN4nMOd2W/Qfz3EblrCTxe7FZ2LoPX4nWZKPsm5XWfjaSxH7GmHvuH4cd5KO9dW4eyxtuZ0M9bg64Pkeq01t7eZi5/APfj/rnEfJbX7/7FWb8bNuflObt3fyo/tnumyq7KfKdj1tE97F4X7+WDuMrc6/J0x7jXxfb3b6JdGlQmTzvF7+pBUvv97TGuJa2P+16b9WG11obr+MwPxooJ+ZFrkXWHH9Vv6w4/w+byvFaL3HlrkfUx8jNbkZ+qYwvyw2u12Pe9e5Ejupe9kdp+ho3774Zefrx7Ybjuanpynm4WZFXxbVZoFL7tndCL78i3DfZtx0S7HDb/4/UPxWHV8RU5ZP+D46vFkIfN/zQr8nOQ+7ie//H884jsp7J/VnM5z368Pjup/iemfx42Nu8SPzhG8bwZ/Y/pVP4HMfC9wmHt+7DTK0utc5Txxfkx3ytU63HKL/B607jvFRq2qvcK18GXfKeEj1fjkFpvYu68+6yp1+oUd6otq3L3wOEuxn3WsuOXd6+wSvySH/O9wikhq8z667jv//IaYtn7v+85bZpq/XWKuEu1nmf1OCG4aznc4Xz+hODOzv1ERO6mBB5Plrf+qmQFui4TZacpz8r+LK0npXo2X62/zhImy/s5Z642Jfjy4iU1diEv9gyieq9xpoQsT7fXtvnxp0m3atvFAVjyNKr3KVQf896nKNvHnkb0OardVJvy+JTo2WCXO9WWVbn7nMNdLfRzV3O4mxJ4agID9x+UZeXLPuup2uZkCVmebvXuJMrk9QnEdYryFCejenbIsAx6dmgK6o/lmYOMzn3BsRk1riquvb0eFHf8bMypxNyp565OhcHclX3u6ksRueNnIVCW6m+ej1kS5VG+vQuo2maphCyvv50W5VEmf5dLjQNqLQLH6DxNU95OcX71YEmu1RjmPGWd4fwcPwA/Vr8Wlef+hf+jrAac2+3s1+NZmc7+9YZxHHyi/TCfDVEnz96WHA6Qo1bo59p7z2JE96bk2letIj/Kj9v540P4+Uzo5ed46K0n5vE6Fh5PDcH1sPP8V62P8Xjn1TH/5TUtvJ6/OYjXYZuinFR+p2s7UI+M6hrCvt9piHqEsO937NxXIsZ5bC+DuOMYuT4G7uoRuPvaiGJkbxzLj22PD8U1j1/HHFl54r7VcPR4MSzuO5KiTW1swTZlnXmqh/6xqMcH07m/G0MM2yDujifmbl5wd9zhDsfqecGdnfvHiNw1BB7l89nuGmm4K/1usOlvhv52johnrczYgLzyN8LxWuWTeW8X9Z32eaFHyboWUZatMzYEznj8rq0bXxgTWrI8FU9b3hnCFUKv7WD9MWGdqr4Lgc+QGraM8v6D1mN5jNop/l89YFLrsXZ8LKSNhbe2n491z/jt7PPAXKP+jMp/u+AJ730F4HLnR8T5dGtv7Wl77+next6TJ+uP99R3XbvPriTQ/3hj89Hj9Y291ffX8n/vjlr/3lZ7+/Hd9cdbjzbae+3NofXP+8A3oQ+gLTMuljPlyG4JWe90nv+aj1bx9ajWdW39e9C6bgb1wfJ4HEL/s/L/5/joLPRyx+e8+CYjflLNhzgGQF15dX4woE74HL2KdzMqX5/dl2nkqfja7OdY0HbDz/WrezbKPu38nChf9n72XAlZ3tqfii3mHN2IC6/F6zKBk+9Zzgg8mZDFfZjlDrJpbP/dzvPfsnZl981nOiC3s39NnmaL/6dBHpa3emVU/hTY3GlYx3lWVujLy11xylUdG6c7vecanf7yU53+8qa72enHaHnHIC8jPceL/5EvlGU4Miq/Av0yT3NwjV3fEvrnSH8PbnEO7ZBlTYlz+Czx+QKj+VGse+z5wDOdJB/PMTaznXzs+n/PIT9H9UYBAA==",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
