---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dXYhcR3au7pk7M93SzLSkkawfy5qRJevHljyjnj/Jsj22R17vJg8JgSSEEBhJFoTABr8EFjbQYRf2IeTnLXkMZJPAhiSQJU/5ISGbh2AIMYGAX0KyhF3Dhg2EhYSFheyV7un5+uuvT9+7U9U9jadAzFVV3XO++upUnVN1b9ethWfp+R/+qxXX08XfevG3VpRjsro7xd/Vg6W1iLJWU2GsTQDG+gRgnJoAjNMTgDGbAIwzE4BxdgIwzk0AxsYEYGxOAMZjE4Dx+ARgnJ8AjAsTgHFxAjC2JgDjiQnAeHICMJ6aAIxLE4Dx9ARgPDMBGJ+bAIxnJwDjuQnAeH4CMF5IgDEFzucT4ezZrMpB55si+aZDvqjPF835ojRf9OWLqnzRki8K8qA7D2rzoDEPyvKgJw8qcqedO8Xc6eSTej5p5pNSPujzQZUbbW4UF4Ag3ixD8q7OPvvbKP5fh/KIGyNrDdIbU/726ma7IdoXEf9T+SYzvvy1xyZ/Og3+1aKbw7udXvmB9BqONP20vpm4nY/mqW0B2mK6szS6H9dIXyCOA+lvhpQ29WyDGPUZHuanTvzMpsGzavLnEsm39jZEe5F/a99i8f8ZKMN5apAstB9rS0vcPzMaXtcS87pWlVfDcywNnraN8Sbg4TF+PI3u9bJj3PQ3CWuqvjke+vsG+bExPm91Ovt4GlQ23elvh5VlUGb9m9vdV6F9WIZ4vHGDtmK4E4+b9cTj5s7RuOmmo3EDZRM+brYSj5v2p9SPbyfmdf1oPurlAvUZFyEczUeWPyHz0cPE42bjaNx009G4gbIJHzfvJx43m59SP/4kMa9bR/NRNx3NR1A22fPR2p3E42b7aNx009G4gbIJHzcbicfN3U+nH1/bTMzr3tF81E1H8xGUTfh8dDfxuHl4NG666WjcQFnqcTMf+m1sisrqoOdhZx/PnwG2rxfXad+12Oy+s5LonZ7VUwI/6srTbCf08P70L+RZ/1l/zmF9KmtA2XSnV0+z+P806EFZhiOj+n9a/H+x+DsD99j9LaF/hvT34BZ5zEtD1G+I+nms80fFdW6TNjbe6fTK2yn+rh4sdd/T2gX5Kd4De5BGfjvnKB9j3yyCRO99oDJzJ/ZFi2Sh7fN7TRH7pG26MtKLNjUN+Dn25vedEr8H1X3OZP43G4Iro/p/U/zN+/GTmd42W526kJkntKthMYLJwfpNUR/XHrzGwRinGYbrnoW83U5v/WMVsSofi36rQVgRn92bODa642HF+PMYtW0+VONiQdSfF+1dFLoXqAzv45h5IQ1P3XfXzA9NQztQ5zy0H+vjdZ4yyvuo+Jvb63doTM073JmuPLVCvx3NO9xx/L2YmLuW4G7R4a4FZXaN3FnexyEed7MCT0PctxOHmzVun7VtTuDgdv874TsB98Tsv5MgN5Aub55thP5+TGFXhgXtCnUatrrgya6RX8v7VvFX2dUc3Dcl8rwxOedwx2MyVZ9aO04K7k443KEt2DVyZ3nfDfG4mxV4eI8kxOOm7zlHPNlr6/OCuxq16RTkj2MvwvQ3Q3+fp9iLOEV4mB/ci8jLlgTWlihDu8Ey1LMk9ChZ0xFlsQ1jWcznDsbX6dCfrOwM6OZ9lOegjH1AoPZjwjblbf0urPW4HuNB2zdsGZXNFTc2Qv/cmtrv8R4irykw7p0FfrhtjLlG+dmA+3hN1u2zAqRak1mdupCZpwed3vpoL2Vi+zOi/mnRVvN3aO9nwnDdyPlup7f+cxWxnhX10c5PE1bEdzYM1439eqyEbg/rOVEfMTxHWFH3OSrD+6xNDaqbKsY4X8jDGAN1noX2Y328zlNGeZfA5jnGOOtwZ7ry1AqD+1lxx7Ht+cTcXRDcnXe4uwBldo3cWd61iNw1BZ6GuG8nDjfr3D5r25LAwe2+Tb7jebgnte8wXd482Aj9/ZjCrgwL2hXqNGx1wRP+XjmjvHXHrqrGTGcEHsUdj8lUfWrtuBj6uXve4e4ilNk1cmd59yNy1xR4OF4K8bjZaAhMkWR33/O4GF32foz8AsiuEV+XIH8c6zHT3ySskfF012OXCA/zw+uxZYG1Jco4Vl4WepaFHiVrKaIssyu2s7j8rj2ZD/38WlJcnqGyFShDG+Ck1mPWpqrrMeR5ubhmf/sz5FNx3k7tU88QfrYLjKm77zKEwf6lFnpj8yVos7ovG8DJz8Nc/smAubwuZObpQae3vhqP2Fe8blgW9S+JtpovRXtfDsN14xy/2+mtv1IR62VRH+38EmFdhrLLYbhu7NdjJXR7WF8U9RHDCmFF3S9SGd63XFw3qG7s8WPtuFLIw/gFdV6G9mN9vM5TRnmfB5vn+OWyw53pypOany873HFscyUxd1dDP3dXHO6uQpldI3eW9ysRuVsSeBrivp043Gxx+ziuRb3c7l8l3/ES3JPad5gubx5k3kZpV6jTsFW1qy85doXx9JTIKxMzKe54TF5NzN1LgrurDndoY3aN3Fner0fkbkngSbhm2k63Zlq9y2M1nuy1TYs7r4HsGvF1HfLHsR4z/U3CGhlPdz12nfAwP7weuyGwtkQZx8o3hJ4bQo+SdTGiLLOrtP195+68wGXJym6C7mUqexnK0AY4qfWYtanqegznLsPG89Yfkk9dhntS+9RlaDPrrhMOnr+zAfdlA9r5NZifeY1ldepB7wc86PTWx/FUZi3gjUkVWyxD2fUwXDfOrbud3vo3KmK9KerjeLtGWBHfzTBcN9okr7Feroj1FVEfx9kNwor4XqEyvM/a1KC6qWKSW4U8jElQ58vQfqyP13nKKO+vnJjkZYc705WnVujv55cd7m4Sd7cSc3c79HN3y+HuNpTZNXJned+IyN1Ngach7tuJw80et8/atixwcLs/JH/wKtyT2h+YLm8ebIT+fkxhV4YF7Qp1Gra64MmukV/L+8ixq2W4r8y+9HWBR3HHYzJVn1o7VkM/d6+GwdytQtmq4M7yPo7InYrVGuK+nRCFm+65RqvxZT8y2WvRZa9tWSx5B2TXiK825I9jjWX6m4Q1Mp7uGqtNeJgfXmOtC6wtUbYM11iGetaFHiVrNaIss6uGkB2P33b3t7fIryXF5XUq24AytAFOao1lbaq6xlqGMsPG/vZ75FPT8Kd9qukq41NT4TIbNDtCv4A6DVud6vPcllHe9w+BT11LzF1bcLcWBnOHc3JbcGd59Xo87kbrUzcfs/+JKLt7ntp6fNlPeL4yzpCvTcgfh081/c3QP7em8KmbhIf5YZ+6JbC2RNkyXGMZ6tkSepSsdkRZZldpY6h2d48c+bWkuLxJZdtQhjbASflUa9NBfKphY596sSA3cQwqfWqb8C8TRtyn4t+VqNgR9/R2O73tSjD/rPMcE092+w73072CjLz7Xyyu1TkhOP/laRrKIvbn49wWF2f3ceTy8ffGGWHC3+FOifq8J9kS9fF3q7b/2aL62B+Kn4Ux8lOryE/tAPxcc/jBeJ/5+bTYT9vh5yaVoV83nfk4/MmjceiOQ5tzj8bh0TgcxE/McbgYernDexKfVbHntbcmcC8KLlqjwdo9K+5ERazYNydGg/WRYTpXESv+np5/l1cbPeer3I5BZ5kYtjrVZw4yyttz9h9qYTB3pisEPQZrDndsA6nPnFDctSJw94sRuTsh8PD/+Rya/HqTyqzuL9P6bBznjXhc4Lvqu51erOgrdqLg3NxgHiLK7q7x0VbQD+fXiX57Wno/yfQ3Q7+Np9hPOk94mB/eT7ogsLZEGT5/wDLUc0HoUbIWI8riM3ZQtrV7VOfEqN9wnxDtrod+2/R+w/0lZ75T8d2iw905gYf3Ln4f9i6+QrEa+j7md9xnYy1Am9nXeGdj/YbDrzqTTcXPil+OcThWQT0nSurxxjna2grpRi7s3sO2zus5Z6pTvr2KHzWn4Hjj32DinHLO4QdjqFHzs1CRn4UD8FNz+GlR2aB13jcoFkI8OyEGT+12util3T2HCucOji8S+ZTS8YXpb4b+cZ4ivlDzFPLD8cV5gbUlyvC53yB7Pi/0KFkLEWWZXR2GORx93dEc7s/hLYefwzqHq72oqvaj1teeXZedw8vs1U1R2U7x/9WDpe43j7y9XtSvxuriaLDe9frSw6r2FRfD4L45LOeGGrZ66J+/vHNDP3Ji7inBHebxfK3mZMUd28C414PMXdn14McRueM1G/KTZj3X3uL3LzCp9y8WqOwulOF6i9MU/R/bVPXdDLQjw5ZR2bcGxLux7Uvt/XHMo9at2C72Jd5zolroP4ddjasy87TSrfwYyuRzzxHXeSrz7Hnc59Dx/k/Zc+j+J+L+j+q3Mn4m9d6O4k71ZVXuvp/Yz6Q9i268c6W1KcVcOVtcTOJcqdYlKJPPR0U+LpSQ5el+XtRHmXzeKeLisxXZZvM0qvMBLxfyBp0PeAHaj/XxOk8Z5Z0qGqLGe9XnDKrfysyVqc+lVNypvqzK3QWHu5hzJd63E4Wbza10Z/dsbvOZUxFld89XwDOjasRXorNhSu8xmv4mYY2Mp7vHeJXwMD+8x3hdYFW/a+H9OnU+wXWhR8m6HFGW2VVDyD6ssQTaACcVS1ibUsQSmxMcS1wW9VEmn+2HfFwuIcvT/aKojzJXSDfiepHK2GbzxPNmKn+Y6qy+tx1/eNnhznTlScUSl4k7L5ZIMxf43Km+rMrd5yY3ltjjcxIjyn7IPj2i7EfsD40z5OsmcRlHd/lYwvQ3g/bPO3HwdGMJda6P8svG3SsCa0uUcSyhzuR5RehRsq5ElGV21RCyD2ssgTbAScUS1qYUscT7ExxLXBH1USafYYV8XCkhy9Ptxez59Q3SjbiuUhnbbJ4Sr4W6/tBscdA5mVeg/Wy7OK9klPeB4w+vONyZrjypWOIKcefFEqnP/VXcqb6syt0XEscSirsN4i6Rn1plP4XcXXe4Qz9+U3Bneb8WkTv+LTzykyauiOtnqv6O29qUws/85iHwM+li6NVV9b5LjfQetlg0UR+4sah6v2ecseh8RFn8nXHGmSf+Rmmq+dXahfMr67T2MA845jPK+72I82tN4JkX9zF382m4Kz2OTH8z9PdzinE0X5JXdT7xPHGOZfz9UjVebwo9StbZiLK636+k/1t5nhLbwsaPaguJvjvq2kJT8GrcnRVYW6KM12JVv/fH/R9L1lQCXMYNclkb8Nf0cB7rQTvkb1oZt3iW9QzUOQblWP9vYa79ZMDvdOpDZHq8Kbvxxq+yl0Wh+2YJ3RgH7HaG6/awKp+t5ia1FufzobGN1qbE8dsqt2N6SDvqVJ85yCjvnxyfXXU8zQg8ijuOucd9tjZzV/Zs7X+NyN2CwFMTGLxY2erfFvWxTfz+Iuq7XUKWp/tVUR9l8vuLiIvPfsb7+DuxeJZwCptZLeQNOr/4NrQf6+N1nvj84v90bOa2w53pypPyX7cd7m4Rd+M+45O5K3vG539F5O6Wwx2WnSTubo+BO9WXVbn7nsOdml9uOdydFHjSnoFafe/rLJXh3hfvAwVqPyZsU9W9L7Qj3vvqlhULrYbAlnrvy/IWhW6Ob84mwuX56LMCa1UfPVvwq+z+JNw3JfK8+MbjjuObW4m5U3PGLYe7snPGYkTuFgSemsBQJsZQ52dim/idY9TXLiHL063OUEeZ/M4x4lqnMryP/QyeMZLCZmz/H21GnVFfp/p4naeM8i46NtN2uDNdeVJ+pu1wx2fTJzqnuMvdluBuw+EOz9bdEtxZ3tWI3K053GHZC8RdqjN0Pe5UX1bl7pbDnZpf1hzuXhB4GgJPxPhmm2MYTF4MY2X3oKzqt76tTVXjG7Qjw8Y+5N6ExDepz+5Xdr8msFa1+51DEN+kGRP73G0L7rYc7nAdsC24s7z3RhTfbAtZXoxxV9THNvF70KjvbmLdK6T7ktC9SHURY0PITGEzhmV6SDvqoZ835CCjvJ92bGYl9HOHeV58s+Jwd4m4u5uYu3uCu7sOd+h77Bq5s7xfiMjdJYGnEfq5i+ij99jXYrKy10A3++j7UFb196fWpqo+GnkybBmV/dKE+OhE50V27d74QLs/J7DWBbd4lijz+8Eh8NGXEnO3Iri75HCHY3RFcGd5XxiRj1bzj+cn74n62CZ+vxj13SNZ1yLoxm8J8/vFK0L3oriPfTR+83dUfkZ9Z7iqn/mKYzPXHO5MV56Uj77mcLdC3N1LzN1rgrt7Dnfol+waubO834rI3UpJ7u6EXu5eS8zdfcHdaw536LftGrmzvN+JyN0dgach8ESMbx5bzPB66E9W9gbo5vjmTSir+u1Fa1PV+AbtyLBlVPZVim8SfRtUxjemS9k9xzepcHl2r+ysqt1/LaLdzwg86j0ijm+ujYE71ZdVuftzh7uZ0M/djMPdgsBTExjKxBivi/rYppeKa9U3r1OZirsaJGeU/YY6+Zzssv32106/VT0nW8XtiruV0MtdqnWax93JCNz9Q0TuVgQe/r/pRxvlb1ZY3Q/JV6D81L7CdKkxZT5zVN96MSyDvvXC892KaAfya3kfRZzvpgSeMr+vmBkDd6ovq3L3scPdlOBuyuGuJvAkPg92w/Sq77wqPGr9uklYE30jd9PzgzWBx7DiHMh+UI31BtVNZZMWG6NNok7DVqf6eJ2njPK+7dhkLQzmznTlSc3lNYe7+8TdG4m5e1Nw90YYzB2ug+waubO8/47I3f1Qjjt+3p9mLelzdz8Cd/8bkbsXBJ6GwBOPn/Xub0J3Qn+ysrdA9wqVvQ1lVZ/3W5uqrrXRjgwbf/NrOnv2tyGwpY6fuB9rgNHs4BTU4d/B2P31kvWtLED905C32+nlYgXKdqLwsNZmO40o+46yUR4faKMR+7f07y1Nf5OwRsbT/Y3dW4SH+bG5RY1Tu7clyubgGstQz9tCj5K1ElHWmyRLtf8FyNvtDNft1X+nYv3divUfVKz/bsX6n6lY/72K9T9bsj5/x+zdYl7Op/tLxbVaZ+4U16P6LbqtKQf9Fp3XmbgG7fl+COVdLdoYY525I/Cw37sB+j4psafh/WZx2PnzbxXXqv/KnD8/4+ge9s1j70xl7zszuNedp2koi2hX8jszyEHWKd9exY/3zSf0/+qbqjthHxfzg9/jGDU/MxX5mTkAP6ccfvC8GuanORp+Nsb9TfG3iR/kbobK8Hfl+J2iD7Je/NhfNl8lnt9Lx2+mvxn657IU8dss4Rlkz9z3eK963vIyXA+a8719bJR1MaKspeKa/dVPOf5KceTFJGoMeP5t2Bjgs3KUj/FkeeNv2PzE/g1x2b2H7TtzPd9z7ZRvr+JHvVOFczT7N/W+nuIHv1U/an48/6bGVlX/hvbp+bdFh59Pi3/jOfQg/k3Fv3xmV1Pgwf590OmVhf5w0FktSlZ+XcDqymoK/Aqz6RzVsz3rj7LP9rD/emJpyvtixDWXWgMq7nDcMNYU3A377jZzV/a721+OyF1T4PHGJ59LFYLmmn3viSGy+NkY3s/fqj8hMI/qPQeLkQa952DY6lQfr/OUUd5vO32quFPff1XvRXncoZ9lrCm4Oyu4W3K4w9/0nxXcWd7vRuRO2V3acw3Wu78V+VzoT1b2Y6B7hsp+HMp24JqTer5jbar6fAftyLDxt0r/gJ7vpDoXQj3f4TOlEC/70NTnVdjvQgadV8F2j78jsWvk1/L+OKLdzwo8Xpwzqm/BKu5UX1bl7usOd2pNO+tw1xR4FHfsqxKd8ehy14zA3V9G5G6mJHfsq1L/vkt9g/icw13ZbxD/fUTuWgKPF7uVXcvgvXhfJuq+SWVW90Oa+xFr6rl/GH5ch/LZtXWoa7ydCf28Nej+EKlNa+3tbebyB/A87p9LrGd5/+5fnP27YWteXrN7z6fya3tmquyqzHc6Zh3dw5518Vk+iKvMsy5Pd4xnXWx//yb6pUF18rRT/F09SGq/vz3GvaT1cT9rszGs9tpwH5/5wVgxIT9yL7Lu8KPGbd3hZ9hanvdqkTtvL7I+Rn5mK/JTdW5BfnivFse+9yxyRM+yN1Lbz7B5/93Qy4/3LAz3XU1PztONgqwqvs0qjcK3vRN68R35tsG+7Zjol8Pmf7zxoTisOr8ih+x/cH61GPKw+Z9mRX4O8hzX8z+efx6R/VT2z2ot59mPN2Yn1f/E9M/D5uZd4gfnKF43o/8xncr/IAZ+Vjisfx90emWpfY4yvji/5meFaj9O+QXebxr3s0LDVvVZ4Tr4ku+U8PFqHlL7Tcyd95w19V6d4k71ZVXu7jvcxXjOWnb+8p4VVolf8mt+VjglZJXZfx3381/eQyz7/Pc9p09T7b9OEXep9vOsHScEdy2HO1zPnxDcWd5PRORuSuDxZHn7r0pWoPsyUXeayqzuz9J+Uqp389X+6yxhsrKfc9ZqU4IvL15ScxfyYu8gqt81zpSQ5en2+ja//gzpVn27OABLnkb1ewo1xrzfU5QdY08i+hzVb6pPeX5K9G6wy53qy6rcfd7hrhb6uas53E0JPDWBgccPyrL6Zd/1VH1zsoQsT7f67STK5P0JxHWKyhQno3p3yLAMendoCtqP9ZmDjPK+6NiMmlcV195ZD4o7fjfmVGLu1HtXp8Jg7sq+d/XliNzxuxAoS403z8csifoo334LqPpmqYQsb7ydFvVRJn+XS80Dai8C5+g8TVPZTpG/erAk92oMc56yznB+jh+AH2tfi+rz+ML/o6wG5O129tvxtE5n/37DOA4+0X6Yz4Zok2dvSw4HyFEr9HPt/c5iRM+m5N5XrSI/yo9b/vEh/Hw29PJzPPS2E8t4Hwuvp4bgetB59lftj/F857Ux/8t7Wng/f3MQ78M+RTmp/E7XdqAdGbU1hH2/0xDtCGHf71jen0SM89heBnHHMXJ9DNzVI3D3FyOKkb15LL+2Mz4U1zx/HXNk5YnHVsPR48WweO5Iij61uQX7lHXmqR7656IeH0x5fzeGGLZB3B1PzN284O64wx3O1fOCO8v7x4jcNQQe5fPZ7hppuCv922DT3wz9/RwRz1qZuQF55W+E473KJ/PZLuo77fNCj5K1ElGW7TM2BM54/K6tG18YE1qyMhVPW9kZwhVCr+1g+zFhm6r+FgLfITVsGZX9B+3H8hy1U/x/9YBJ7cfa9bGQNhbe2n421z3lt7PPA3ON+jOq/+2CJ3z2FYDLnR8R55OtvbUn7b0next7jx+vP9pT33XtvruSQP+jjc2Hj9Y39lbfX8v/e2fU+ve22tuP7qw/2nq40d5rbw5tfz4GvgljAG2ZcbGcKUd2S8h6p/Psr/loFV+Pal/X9r8H7etm0B6sj9ch9L8r/3+Oj85CL3ec58U3GfGTaj3EMQDqypvzgwFtwvfoVbybUf367L5MI0/F12Y/x4K2G36vXz2zUfZp+XOiftnn2XMlZHl7fyq2mHN0Iy68F+9T51rzM8sZgScTsngMs9xBNo39v9t59resXdlz85kOyO3s35On2eL/0yAP61u7Mqp/CmzuNOzjPK0r9OX1rjj1qs6N053evEanv/5Up7++6W52+jFa2TEoy0jP8eL/yBfKMhwZ1V+BcZmnObjH7m8J/XOkvwe3yEM7ZFlTIg/fJT5fYDQ/im2PvR54qpPkYx5jM9vJ567/B249x531RgEA",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
