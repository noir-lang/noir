---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dXYhkSVaOzKqbVZnVVZXdXd3TP9PTVT39P9O9WZ311z09M7Uz1bOzqw/6oiIi1HTPgCjKgAgLCqkrCCuI+iQ+Cf4sKKsPyz75g+L6IAviIAjzIrrI7sLICrKgLCy4tztP1pdffnny3qmIzEqmApq6HRH3nC++OBHnRNybcSvhWXr+B/8q3evZ7t9q92+lW47J6u52/7YOl9YjymqlwliZAozVKcA4MwUYZ6cAYzYFGGtTgHFuCjDOTwHG+hRgbEwBxoUpwHhiCjAuTgHGpSnAuDwFGJtTgPHkFGA8NQUYT08BxpUpwHhmCjCenQKMz00BxnNTgPH8FGC8MAUYLybAmALn84lw9m1W5aDzTZF80yFf1OeL5nxRmi/68kVVvmjJFwV50J0HtXnQmAdledCTBxW5086dYu508kk9nzTzSSkf9Pmgyo02N4qLQBBvliF51+ae/a13/1+F8ogbI+t10htT/k5rq10X7YuI/6l8kxlf/voTkz+bBn+r283hrU6//EB6DUeaftrYStzOx4vUtgBtMd1ZGt1PKqQvEMeB9DdCSpt6tkGM+gwP81MlfubS4GmZ/PlE8q29ddFe5N/at9z9fw3KcJ4aJgvtx9rSFPfXxsPremJe18vyangW0uBp2xhvAB4e4yfS6N4oOsZNf4OwpuqbE2Gwb5AfG+OLVqdzgKdOZbOdwXZYWQZl1r+53f0RtA/LEI83btBWDHficbOReNzcOx43vXQ8bqBsysfNduJx0/6E+vGdxLxuHM9H/VygPuMihOP5yPKnZD56J/G42TweN710PG6gbMrHzbuJx83WJ9SPv5eY1+3j+aiXjucjKJvu+Wj9XuJxs3M8bnrpeNxA2ZSPm83E4+b+J9OPr28l5nX/eD7qpeP5CMqmfD66n3jcvHM8bnrpeNxAWepxsxgGbWyGyqqg553OAZ6/AGxf6V6nfddiq/fOSqJ3elqnBX7Ulae5Tujj/elfyLP+s/6cx/pUVoey2U6/nkb3/7OgB2UZjozq/3n3/8vdvzW4x+5vCv010t+HW+QxL3VRvy7q57HOl7rXuU3a2Hiz0y9vt/u3dbjUe09rD+SneA/sURr57ZyjfIx9oxskeu8DFZk7sS+aJAttn99ritgnbdOVkV60qVnAz7E3v++U+D2o3nMm87/ZCFwZ1f+b7t+8H79d62+z1akKmXlCuxoVI5gcrN8Q9XHtwWscjHEaYbTuOcjb6/TXXyiJVflY9Ft1wor47N7EsdE9DyvGnwvUtsVQjoslUX9RtHdZ6F6iMryPY+alNDz13l0zPzQL7UCdi9B+rI/Xecoo74Pu39xeP6IxtehwZ7ry1AyDdrTocMfx93Ji7pqCu2WHuyaU2TVyZ3kfhnjczQk8dXHfbhxu1rl91rZ5gYPb/e+E7yTcE7P/ToHcQLq8ebYeBvsxhV0ZFrQr1GnYqoInu0Z+Le+b3b/KrubhvhmR543JeYc7HpOp+tTacUpwd9LhDm3BrpE7y/tOiMfdnMDDeyQhHjcDzzniyV7fWBTcVahNpyF/EnsRpr8RBvs8xV7EacLD/OBeRF62IrA2RRnaDZahnhWhR8majSiLbRjLYj53ML7OhMFkZWdBN++jPAdl7AMCtR8Ttilv63dgrcf1GA/avmHLqGy+e2M9DM6tqf0e7yHymgLj3jngh9vGmCuUnw25j9dkvT7rglRrMqtTFTLz9KjTXx/tpUhsf1bUPyPaav4O7f1sGK0bOd/r9Nd/riTWc6I+2vkZwor4zoXRurFfFwro9rCeF/URw3OEFXWfpzK8z9pUp7qpYowLXXkYY6DOc9B+rI/Xecoo7zLYPMcY5xzuTFeemmF4PyvuOLa9kJi7i4K7Cw53F6HMrpE7y7sRkbuGwFMX9+3G4WaD22dtWxE4uN13yXc8D/ek9h2my5sH62GwH1PYlWFBu0Kdhq0qeMLfK2eUt+HYVdmY6azAo7jjMZmqT60dl8Igd8873F2CMrtG7izvYUTuGgIPx0shHjebdYEpkuzeex6Xoss+iJFfANkV4usy5E9iPWb6G4Q1Mp7eeuwy4WF+eD22KrA2RRnHyqtCz6rQo2StRJRldsV2Fpff9fcWwyC/lhSXZ6lsDcrQBjip9Zi1qex6DHle7V6zv/1x8qk4b6f2qWcJP9sFxtS9dxnCcP9SCf2x+Qq0Wd2XDeHkp2Au//aQubwqZObpUae/vhqP2Fe8blgV9S+LtpovRXtfDaN14xy/1+mvv1YS6xVRH+38MmFdhbIrYbRu7NeFAro9rC+K+ohhjbCi7hepDO9b7V7XqW7s8WPtuNqVh/EL6rwC7cf6eJ2njPJ+Hmye45crDnemK09qfr7icMexzdXE3F0Lg9xddbi7BmV2jdxZ3i9F5G5F4KmL+3bjcLPN7eO4FvVyu3+FfMd1uCe17zBd3jzIvI3TrlCnYStrV19w7Arj6RmRVyRmUtzxmLyWmLvrgrtrDndoY3aN3Fneb0bkbkXgSbhm2km3Zmrd57EaT/b6lsWdN0B2hfi6CfmTWI+Z/gZhjYyntx67SXiYH16P3RJYm6KMY+VbQs8toUfJuhRRltlV2v6+d39R4LJkZbdB9yqVvQRlaAOc1HrM2lR2PYZzl2HjeetPyKeuwj2pfeoqtJl1VwkHz9/ZkPuyIe38U5ifeY1ldapB7wc86vTXx/FUZC3gjUkVW6xC2c0wWjfOrXud/vq3SmK9LerjeLtBWBHf7TBaN9okr7FeKon1ZVEfx9ktwor4XqYyvM/aVKe6qWKSO115GJOgzpeg/Vgfr/OUUd5fOTHJSw53pitPzTDYzy853N0m7u4k5u5uGOTujsPdXSiza+TO8r4WkbvbAk9d3Lcbh5t9bp+1bVXg4HZ/nfzBp+Ce1P7AdHnzYD0M9mMKuzIsaFeo07BVBU92jfxa3geOXa3CfUX2pW8KPIo7HpOp+tTa0QqD3H0qDOeuBWUtwZ3lfRiROxWr1cV9uyEKN71zjVrxZT822evRZa9vWyx5D2RXiK825E9ijWX6G4Q1Mp7eGqtNeJgfXmNtCKxNUbYK11iGejaEHiWrFVGW2VVdyI7Hb7v321vk15Li8iaVbUIZ2gAntcayNpVdY61CmWFjf/td8qlp+NM+1XQV8ampcJkNmh2hX0Cdhq1K9Xluyyjve0fAp64n5q4tuFsPw7nDObktuLO8ajUed+P1qVtP2P9ElN07T20jvuz3eL4yzpCvLcifhE81/Y0wOLem8KlbhIf5YZ+6LbA2RdkqXGMZ6tkWepSsdkRZZldpY6h2b48c+bWkuLxNZTtQhjbASflUa9NhfKphY596qUtu4hhU+tQ24V8ljLhPxb8rUbEj7untdfrblWD+2eA5Jp7s9j3upwddMvLuf7F7rc4JwfkvT7NQFrE/n+S2uDx3gCOXj783zggT/g53RtTnPcmmqI+/W7X9zybVx/5Q/CxNkJ9KSX4qh+DnhsMPxvvMzyfFftoOP7epDP266czH4Y8ej0N3HNqcezwOj8fhMH5ijsPl0M8d3pP4rIp9r70VgXtZcNEcD9beWXEnS2LFvjk5HqyPDdP5kljx9/T8u7zK+DlvcTuGnWVi2KpUnznIKG/f2X+ohOHcma4Q9BisONyxDaQ+c0Jx14zA3c9E5O6kwMP/53No8ustKrO6v0Drs0mcN+Jxge+q73X6saKv2I2Cc2uTeYgou7fGR1tBP5xfJ/rtaeH9JNPfCIM2nmI/6QLhYX54P+miwNoUZfj8ActQz0WhR8lajiiLz9hB2dbucZ0To37DfVK0uxoGbdP7DfcXnPlOxXfLDnfnBR7eu/hD2Lv4DYrV2N8iFhVLebGmimfQP6yFft3Yt9zveN9R6/cmtL9Mv/+O0+9NhzvTFYLud6t31NZ5feeXdfrbe6Fge705BXnn32DinHLe4Qfjz3Hzs1SSn6VD8FNx+FmmsmHrvK8d8bmjLnTvdv+2DpXa7XRxT7t3Phb2Occ9ic5GKBz3mP5GGLStFHGPZ8954rjneYG1KcrweSSWoZ7nhR4lqxlR1kloz9P7OwdlR3UO98YsttfrU/Sr3hx+weHnqM7hih9vDrwwgh+ew3EMftw5HMc479XNUNlu9/+tw6XeN4+8vV7Ur/zN8niw3vf8mYdV7Ssuh+F9c1TODTVs1TBof965oR84se2M4A7zeF5UcYXijm1g0usC5q7ouuDDiNzxecbIT5qzjtvb/P4FJvX+xRKV3YcyXNdwmqH/Y5vKvpuBdmTYMir7Ju39pdqbVnt/vCetzhLHdrEv8Z4TVcLgOexqXBWZp5Vu5cdQJp97jrguUJlnz5M+h473f4qeQ/c/Efd/VL8V8TNp5gKfO9WXZbn7XmI/k3a9Ndm50tqUYq6c615M41yp1iUok89HRT4uFpDl6VZrRpTJ550iLj5bkW02T+M6H/BKV96w8wEvQvuxPl7nKaO8092GqPFe9jmD6rcic2XqcykVd6ovy3J30eEu5lyJ9+1G4WZrO93ZPVs7fOZURNm98xXwzKgK8ZXobJjCe3mmv0FYI+Pp7eVdIzzMD+/l3RRY1e9aeM9ZnU9wU+hRsq5ElGV2VReyj2osgTbAScUS1qYUscTWFMcSV0R9lMln+yEfVwrI8nS/KOqjzDXSjbhepDK22TzxvJnKH6Y6q+8Nxx9ecbgzXXlSscQV4s6LJdLMBT53qi/Lcve56Y0l9vmcxIiy32GfHlH2Y/aHxhnydZu4jKO7eCxh+htB++fdOHh6sYQ610f5ZePuZYG1Kco4llBn8rws9ChZVyPKMruqC9lHNZZAG+CkYglrU4pY4t0pjiWuivook8+wQj6uFpDl6fZi9vz6FulGXNeojG02T4nXQj1/aLY47JzMq9B+tl2cVzLKe9/xh1cd7kxXnlQscZW482KJ1Of+Ku5UX5bl7vOJYwnF3SZxl8hPtdhPIXc3He7Qj98W3Fner0bkjn8Lj/ykiSvi+pmyv+O2NqXwM791BPxMuhi61VLvu1RI71GLRRP1gRuLqvd7JhmLLkaUxd8ZZ5x54m+UpppfrV04v7JOaw/zgGM+o7w/iDi/VgSeRXEfc7eYhrvC48j0N8JgP6cYR4sFeVXnEy8S51jG3y9V4/W20KNknYsoq/f9Svq/lecpsS1sflxbSPTdUdcWGoJX4+6cwNoUZbwWK/u9P+7/WLJmEuAybpDLypC/pofzWA/aIX/TyrjFs6xrUGcByrH+38Jcy2dZLwEOT6bHm7Ibb/wqe1kWum8X0I1xwF5ntG4Pq/LZam5Sa3E+HxrbaG1KHL+1uB2zI9pRpfrMQUZ5/+T47LLjqSbwKO445p702drMXdGztf81IndLAk9FYPBiZat/V9THNvH7i6jvbgFZnu5Pifook99fRFx89jPex9+JnfT5xXeh/Vgfr/PE5xf/p2Mzdx3uTFeelP+663B3h7hrJeZu1BmfzF3RMz7/KyJ3dxzusOwUcXd3AtypvizL3Xcd7tT8csfh7pTAk/YM1PJ7X+eoDPe+eB8oUPsxYZvK7n2hHfHeV6+su9CqC2yp974sb1no5vjmXCJcno8+J7CW9dFzXX6V3Z+C+2ZEnhffeNxxfHMnMXdqzrjjcFd0zliOyN2SwFMRGIrEGOr8TGwTv3OM+toFZHm61RnqKJPfOUZcG1SG97GfwTNGUtiM7f+jzagz6qtUH6/zlFHeJcdm2g53pitPys+0He74bPpE5xT3uNsW3G063OHZutuCO8u7FpG7dYc7LHuBuEt1hq7HnerLstzdcbhT88u6w90LAk9d4IkY3+xwDIPJi2Gs7AGUlf3Wt7WpbHyDdmTY2Ic8mJL4JvXZ/cru1wXWsna/ewTimzRj4oC7HcHdtsMdrgN2BHeW9/aY4psdIcuLMe6L+tgmfg8a9d1PrHuNdF8WupepLmKsC5kpbMawzI5oRzUM8oYcZJT3Y47NrIVB7jDPi2/WHO4uE3f3E3P3QHB33+EOfY9dI3eW99MRubss8NTDIHcRffQ++1pMVvYK6GYf/RDKyv7+1NpU1kcjT4Yto7KfnRIfnei8yJ7dGx9o9+cF1qrgFs8SZX7fPwI++nJi7tYEd5cd7nCMrgnuLO/zY/LRav7x/OQDUR/bdL17rfrmAcm6HkE3flOX321ec3TfiKAbv2PM7zZfF7qXxX08h+P3hsfl49Q3jsv6uC869nrD4c505akZBvvthsMdf//8QWLuXhHcPXC4Q59o18id5f1uRO6uF+TuXujn7pXE3D0U3L3icIcxg10jd5b3+xG5uyfw1AWeiLHVE4tXXg2DycpeA91rVPY6lJX97qO1qWxshXZk2DIq+xLFVom+SypjK9Ol7J5jq1S4PLtXdlbW7r8c0e5rAo96h4ljqxsT4E71ZVnuvupwVwuD3NUc7pYEHsXdWujnLvU3KxR3SxG4++uI3K0V5I79/NoEuFuLwN0/ROTuusDD/zf9OEfyNyus7tdpvkb5qedrXjPUSDfiSrVGrxAW7Hu1Nq8KnnA9k1HeBxH7fkbgKfL7itoEuFN9WZa7Dx3uZgR3Mw53FYEn8Xmwm6ZXfedV4VFryC3CmugbuVuG6dURWLcIK86Br1KZGut1qpvKJi0+RZtEnYatSvXxOk8Z5X3LsclKGM6d6cqTmssrDncPibvXEnP3uuDutTCcO1yL2DVyZ3n/HZG7h6EYd/y8P816zufuYQTu/jcidy8IPHWBJx4/G73fhO6GwWRlnwbd16nsDSgr+7zf2lR2vYt2ZNj4m1+z2bO/dYEtdfzE/VgBjGYHp6EO/w7G7q8WrG9lAeqfgby9Tj8X6Nt3o/Cw3mY7jSj7nrJRHh9ooxH7t/DvLU1/g7BGxtP7jd2nCQ/zY3OLGqd2b1OUzcM1lqGeN4QeJet6RFmvkyzV/hcgb68zWrdX/82S9fdK1n9Usv5bJet/pmT9t0vW/2zB+vwds7e683I+3V/O+uvYeFrr5qvfFM4Jvd7v7tR5Pfgbc7Mjb3/Nk1VzdI86v53f0UVcfA443rfbvR7XOeD2bYlh54Dj7zyxPl7nKaO8O9DPHw357ajiznSFcDBX7Ao86jszuN/8tE1QFpG70t+Zif2trTPED37jYjcc4GJ+JvmdolpJfmqH4Oe0w8+cw09jPPxsKn7mHH68eU7x49kb+kv1PeMaleHvyk1nXuf9IfP72878rvbePD+k2u35g1FzMu/fqTnZk1WWc5TpnROP34dk3cZr4u8PFY6FTX8jJPVP60V4zRPHwuo7oGoeeAmuh80pmFd1ZF2KKGule63mJ7O/af/O3CmHH+XfcB2+7PAzye/MefN32blE8YnjzPNvXnw0Sf+2VJIfLz4aNdeyD8M5c47K0L/hd/jMv6m1A5/Z1RB40Nc96vTLQr8z7KwWJSu/7sLqyWoI/Aozzh3sf1KsK6w/ij4Tx/5De8go75eddUXZZ3tzAo/iDsdNQp9XeE3G3BVdk/16RO4aAo83PvlcqhA01/zN1pMjZPGzMbyfv1l+UmAe17Nu8+vDnnUbtirVx+s8ZZT3206flo1DagW5Qz/LWFNwd05wt+Jwh7/pPye4s7zfi8idsru05xps9H4r8rkwmKzsh0B3jcp+GMp24ZqTer5jbSr7fAftyLDxt0r/mJ7vpDoXQj3f4TOl1N7BuM6rsN+FDDuvgu0ef0di18iv5f1ZRLufE3i8OGdc34JV3Km+LMvdVxzu1P71nMNdQ+BR3LGvSnTGo8tdIwJ3fxmRu1pB7thXpf59l/oG8XmHu6LfIP77iNyp9ZAXuxVdy+C9eF8m6r5OZb13I2nuT7TfJef+UfhxHcpn11ahrvF2NgzyVqf7Q6Q2rbd3dpjL78PzuH8usJ7lvdx/cfZyR615izyrwznFnpkquyryrM7bTxm1L8xn+SCuo7AvzPb3b6Jf6lQnT7vdv63DpPa7OxPcS9pQe0l9+wOgdxTfIZR/lmRjWO214d4z8zPJvdqqw48at1WHn1Fred6rRe68vdrqBPmZK8lP2bkF+eG9WvVsfYLPsjdT28+oef+t0M8Pzn/eXq3pyXm61SWrjG+zSuPwbW+GfnzHvm24b1sQ/XLU/I83PhSHZedX5JD9D86vFkMeNf/TKMlP4xD8eP7H889jsp/S/lmt5Tz78cbstPqfmP551Ny8R/zgHMXr5mHvwrD/QQz8rHBU/z7q9MtS+xxFfHF+zc8K1X6c8gu83zTpZ4WGreyzwg3wJR8V8PFqHlL7Tcyd95w19V6d4k71ZVnuHjrcxXjOWnT+8p4Vlolf8mt+VjgjZBXZf53081/eQyz6/Pdtp09T7b/OEHep9vOsHScFd02HO1zPnxTcWd6PRORuRuDxZHn7r0pWoPsyUXeWyqzuT9B+Evflbvf/rUMmtf86R5is7CedtdqM4MuLl9TchbzY+6jqd421ArI83V7f5tefId1l7WTG0a32uVAmfzNFvQtQobooq1pS9wmo8zbp9p4pniDZeRrXM0Wz2WHPFE9A+7E+XueJz4r4OWduOeFwZ7rypH5zz32qxlo9DPI6Lu5UX5bl7hcd7iphkLuKwx2PMbxW76x66w71u01sE+/LoL7TBWR5uldEfZTJ+zKIa4XKFCd1IXNc70yhTvblRd+Z+rWIvlyNKcUdn02c+p2pM4K7FYe7M1B2RnBneV+MyN0pgUftRWAM+bRNVLbbzW8dLpV+VlB2Tjgj6iMHdeLnDN2P1xUhqw55e52Ddjyt0zm4f5J7gxijMJ910SYvpjnlcIAcKXvDd+GYnzE9m5J7XxWHHxVvKn/mjUeM6z4b+vlR6za198W2ODMC16POs79qf2wmFG9j/pf3tPB+focb78M+RTmp5l/DgvNvRm0N4WD+rYl2hDC4PvtyxHiH7WUYd7yGr06Au2oE7r4akTu2W7wetca0Mz6KrDFHrfN4bHn7Mgpz6nU+z+1FvweP8zj6hYzy/s7p05kR3HmxHO87qnmmLrCm4G5BcFcPw7nDM2TsGrmzvH+MyF1N4FE+n+2uloa7wr9nNf2NMNjPEfGsF5kbkFfjbkFgbYoyPttlQehZEHqUrOsRZdk+Y9r+Xt80vjDGtmRlZ6ldWPYc4Qqh33aw/ZiwTWV/C4HvkBq2jMr+g/ZjeY7a7f6/dcik9mPteiGkjYW3d57NdU/57RzwwFyj/ozqf6vLEz77CsDl7sfE+d72/vp77f339jf3nzzZeLyvvuvae3clgf7Hm1vvPN7Y3G+9u57/99649e9vt3ce39t4vP3OZnu/vTWy/fkY+AaMAbRlxsVyZhzZTSHrzc6zv+ajVXw9rvNYLZYZdh5rBu3B+ngdwuC78v/n+Ogs9HPHeV58kxE/qdZDHAOgrrw53x/SJnyPXsW7GdWvzh3INPJUfG32sxC03fB7/Sr+VvZp+fOiftHn2fMFZHnPWdT+ybyjG3HhvXhfJnDynnBN4MmELB7DLHeYTWP/73We/S1qV/bcvNYBuZ2De/I01/3/LMjD+taujOqfBps7A/s4T+sKfXm9q069snPjbKc/r94ZrD/TGaxvuhudQYxWtgBlGek50f0/8oWyDEdG9ddgXOZpHu6x+5tC/zzp78Mt8tAOWdaMyMN3iS90MZofxbbHXg881UnyMY+xme3kc9f/A+y61+L1RgEA",
  "debug_symbols": "nd3bjhtHloXhd9G1L3JHxD5Ev0pjYPjUhgBBMmR7gIHhdx/KEFmGIzKz138j6ODPVcW1Mpm1yCL/ePfjT9///vO37z/+59Ov7/717z/effj0w3e/vf/08fGnP/785t33n99/+PD+52///tfvji+/WPW/wK+/fPfxy59//e27z7+9+1dr9s27nz7++OV38fgf/Of9h5/e/cuPP//nmwcZOnGdhE5SJ6WTKZN5bInNF8mFmE6aTrpOhk5cJ6GT1EnpZKqkHYdOTCdNJ10nQyeuk9BJ6qR0oqdvevqmp296+qanb3r6pqdvevqmp296+naXfh//JO3Qiemk6aTrZJ/+qCfxWIjrJHSSOimdTJn0Qyemk6aTrhM9/a6n3/X0u55+19Pvevpjn368DrG0hZhOmk66ToZOXCehk9RJ6WTKxPX0XU/f9fT97tjPtpChE9dJ6CR1UjqZMolDJ6aTphM9/dinXy8y+0JcJ6GT1EnpZJ9+xYssV0p56MR00nTSdTJ04joJnaROSid6+qWnX3r6padfevqlp196+qWnX3r6padfevpTT3/q6U89/amnP/X0p57+1NOfN+n3Y7nsmaWTqZJ+HDoxnWzT7+ZP0vpCuk6GTlwnoZPUSelkymS/9V0T04mevunpm56+6embnr7p6e+3vt5fh1ivhUyZ7Le+a2I6aTrpOhk6cZ2ETlInevpNT7/r6Xc9/X537Pe5kK6ToRPXSegkdVI6mTIZh05MJ3r6+62v+4vEsZChE9dJ6CR1sk/f+4ssF1f7re+S7Le+a2I6aTrpOhk6cZ2ETlInevqupx96+qGnH3r6oacfevqhpx96+qGnH3r6oaefevqpp596+qmnn3r6qaeft+kvlz2ZOimdTJnUoZN9+tWeZC73Yvut75p0nQyduE5CJ6mT0smUyX7ruyZ6+lNPf+rpTz39qac/9fT3W984nofYOHwhpZOpkrHf+q6J6aTppOtk6MR1EjpJnZRO9PRNT99ujv3H7bOQppOuk6ET10noJHVSOpkyaYdO9PSbnn7T0296+k1Pf7/1PW7IJ2ljIamT0smUyX7ruyamk6aTrpOhE9eJnn7X0+96+l1Pf+jpDz39oac/9PSHnv7Q0x96+kNPf+jpDz1919N3PX3X03c9fb9Lv7eFuE5CJ6mT0sk+/fF8/OWR9T/Jfuu7JqaTppOuk6ET10noJHVSOtHTTz391NNPPf3U0089/f3W9yjFk0QuJHSSOimdTJnst75rYjppOuk6GTrR0y89/dLTLz39ujv2l9l2zEMnppOmk66ToRPXSegkdVI6kdP3k63v7RveioWYTppOuk6GTlwnoZPUSelkysT09E1P3/T0TU/f9PRNT3+/9T1ula/k8WksJHVSOpky2W9918R00nTSdTJ04jrR0296+k1Pv+np95tj/3F0LMR00nTSdTJ04joJnaROSidTJkNPf7/1uT+vLjzaQvbHfj4fS/LMhaROSidTJvt97JqYTvRbbL+PXZOhE9dJ6ERP3/X0XU8/9PRDTz/09ENPP/T0Q08/9PRDTz/09PdjVxz5lYTZQkwnTSddJ0MnrpPQSeqkdDJlUnr6padfevqlp196+qWnX3r6padfevqlpz/19Kee/tSj3C9X0Z8/vx9jubjaL1fXJHSSOimdTJXEfrm6JqaTppOuk6ET10noJHVSOtHTNz1909M3PX3T0zc9fdPTNz1909M3PX27S9//+YBdtEMnppOmk2362Z7fI+fy6nOxX65yjieZuRDXSegkdVI6mTLZL1fXxHTSdNJ1oqff9fS7nv5+ubKeT/P47YqKoAnQfr+6Q0ZQI6gTNAjan6PzdZJaHsOI/V52eZLa72WXZL+XXZP9UerPpzql94U0nXSdDJ24TkInqZPSiZ5+6Onv97Jr0nSi30Pv97Jr4joJnaRO9GM/9PRTTz/19FNPP/X0T/ayeD60FsuzcOJkL7s6J6d+Gj/Zyy7JPsrjdewfy9X5fi+7JqaTppOuk6ET10noJHVSOtHTn3r6U09//+SwyyafTGyXZOjEdaIf+1M/9qd+7J9MbBckTya2S2I6aTrpOhk6cZ2ETuR75NzvZfl60CuXbxNyv5ddE9NJ00nXydCJ6yR0kjopnejpNz39pqff9PSbnn7T0296+k1Pv+npNz39pqff9fT7XfqzFtJ00nUydOI6CZ2kTkonUybj0Ime/n4lK3uSaraQrpOhE9dJ6CR1UjqZMtmvcNfEdKKn73r6rqfvevqup+96+q6n73r6oacfevqhpx96+nGXvh8LcZ2ETlInpZMpkzx0YjppOuk60dPfD3cVz0dTanlHkNwPd9ckdVI6mTLZD3fXxHTSdNJ1MnSip196+qWnX3r6pac/9fSnnv7U0596+lNPf+rpTz39/XBX8/k8v3ksJ6X9cHdNpkpqP9xdE9NJ00nXydCJ6yR0kjopnejpm56+3Rz7c3mvjrKmk66ToRPXSegkdVI6mTJph0709Pdb33y9Yvtc3qyi9lvfNRk6cZ2ETlInpZMpk/3Wd01MJ3r6XU+/6+l3Pf2up9/19LueftfTH3r6Q09/6OkPPf391jdfb+g4fTkp7be+axI6SZ2UTqZM9lvfNTGdNJ10nejpu56+6+m7nr7fHfveFjJlEodOTCdNJ10nQyeuk9BJ6kRPf7/1zXg+JWDmcgG/3/quiemk6aTrZOjEdRI6SZ2UTvT0S0+/9PRLT7/09EtPv/T0S0+/9PRLT7/09Kee/n7rm/N1Uloe4a391ndNuk6GTlwnoZPUSenkLv35zzdCm8ehE9NJ00nXydCJ6yR0kjopnejp77c+O/z1M0OH+4KMoEZQJ2gQ5AQFQUlQETQBaqQRjTSikUY00ohGGtFIIxppRCONaKQRjTRivwmavV5C/PFbW5AR1AjqBA2CnKAgKAkqgiZAgzRikEYM0ohBGjFIIwZpxCCNGKQRgzRikEY4aYSTRjhphJNGOGmEk0Y4acR+SXz8h/OJ2vLOFnO/Jd6hCdB+T3x8SfmGlrua/aJ4hxpBnaBBkBMUBCVBRdAEKEkjkjQiSSOSNCJJI5I0IkkjkjQiSSOSNKJII4o0okgjijSi7hvRc0FOUBCUBBVBE6B5EGQENYI6QaQRkzRikkZM0ohJGjFBI+w4DqQMqYZUR2og5UidFOP1qi2P37ZVJVKF1CTqZL68U4ZUQ6ojdd+N5WV2HsqRCqQSqUJqEtUOpAyphlRHCnXjZM1s8abKVxVIJVKF1CTqZNK8U4ZUQ6ojNZBC3eioGx11o6NudNSNgbox7rsx1/vl0ZDqSA2kHKlAKpEqpCZRfiCFuuGoG4664agbjrrhqBuOuuGoG466EagbgboRqBsnm2e317Vot/Va9GT0vFOOVCCVSBVSk6iT6fNO3Xaj23qllw2pjtRAypEKpBKpQmoSVQdSqBsnM2hvb2qs1zYnO+idGkg5UoFUIlVITaJO5tA7ZUihbkzUjYm6MVE3JurGRN2Y993w9X55TqDsOJAypBpSHamBlCMVSCVShRTqhqFuGOqGoW4Y6oahbhjqhqFuGOqGoW4Y6ka770bWqgyphlRHaiDlSAVSiVQhNYnqqBsnu2ifz3eDtWHHqhpSHamBlCMVSCVShdQk6uwtU24U6sZA3RioGwN1Y6BuDNSN8V90Yz0qRyE1ifIDKUOqIdWRGkg5UoEU6oajbjjqRqBuBOpGoG4E6kagbgTqRqBuBOpGoG4E6kaibiTqxskuOnp/qe6r6kgNpBypQCqRKqQmUXXfjR6rMqQaUh2pgZQjFUglUoXUJGqibpzsosPtpWKuqiHVkRpIOVKBVCJVSE2g2skueqcMqYZUR2og5UgFUvfdWN4q4qEKqUmUHUgZUg2pjtRAypEKpFA3DHXDUDca6kZD3WioG+2+G+sz01obSDlSgdS+G/56z7fHUjBWVUhNok520TtlSDWkOlIDKUcqkELd6KgbHXVjoG4M1I2BujHuu9HaqgZSjlQglUgVUpMoP5AypBpSqBuOuuGoG4664agbjrrhqBuBuhGoG4G6Eagbgbpxsot695daf66tneyidyqRKqQmUSe76J0ypBpS993otaqBlCMVSCVShdQkqg6kDKmGFOrGyS4a49XD8GNV+27E27YcyysqP1Tcquir2ncj+/MF9h6/3XxdhdQk6mQXvVOGVEOqIzWQcqQCKdSNiboxSTf6yS56faT0k130Tu27UfZ6nbnqbVUdqX03ql6f4fr+Iw/lSG278ZiBn+qx0m5U7pXXS2WsqsjHOtkqr8+i/WSrvFOddONkq7xTjhQ5z/eTrfJOFVL7Yzny9Yy7yGVp7ydb5Z0ypBpSHamBlCMVSKFuNNSNk63yRvUDKUOqIdWRGkg5Uui80VE3OupGR90YqBsDXQOMhhS6TxnoPmWg+5QRSCVSRdTZ6vh2ZvNar6POVscbdfIdYrytB7U26mx1vFEDKUcqbtX0VSVShdTJGeCoVzeO9f7rZHW8U4ZUQ6ojNZBypAKpRKqQQt04Wx2ve3i2Ot6ohlRHaiDlSKHzRqLzRqLzxtnqeK0KdaNQNwp1o1A3Ct2nFLpPqUAqkSqkJlHzQMqQQteHJ/thzNcrWKdtPpYjFUglUoXUBGqc7Yc3ypBqSHWkBlKOVCCVSBVSqBuGumGoG4a6Yagbdt+N5YX5H8qRCqQSqUJqEtUOpAyphlRHCnWjoW401I2GutFQNxrqRkfd6KgbHXWjo270+270uSpHKpBKpAqpSdQ4kDKkGlIdKdSNk60y3965K6NWFUglUoXUJOpk4bxThlRDqiM1kELdcNQNR91w1A1H3QjUjbjvxvoY/YiGVEdqIOVIBVKJVCE1icoDKdSNRN1I1I1E3UjUjUTdyPtu1HodlYXUfTdqeUbrqAMpQ6ohddKN+XqEro71e9iThXO2184223q9cbIfXj8Xa5zshzXfPtaxPI9onOyHd2p/y18/g2ucPGvxTnWkxq3abA7TkQqkEqlCagLlJ6vjdXv9ZHW8U/fdWH9ywY+O1EDKkQqkEqlCahJ1sjreNMoMqYZUR2og5UgFUolUIYXOGw11o6FuNNSNhrrRBrgn8uZIBVKJVCE1ieoHUoYUuWbzk/2wWrxdfW0+liMV4ErPT/bDO1VIzVs1lp969pP98E4ZUg2pjtRA6qQb/taNOFYVSN13Y32HMh+F1CTKD6QMqYZURwp142Q/vFOBVCJVSKHzRqDzRqDzRqDzRqDzRqBuBOpGoG4E6kag+5SYROWBlCHVkOpIDaQcKXR9eLIEzvF6RuuMzceaRJ0sgXfKkGpIdaQGUo5UIJVIoW4U6sZE3ZioGxN1Y6JuTNSNiboxUTcm6sa870auV7BzAhXHgZQh1ZDqSA2kHKlAKpEqpFA3DHXDUDcMdcNQNwx1w1A3DHXDUDfsv+iGr2oS1e67sT4TPpoh1ZDqSG270Y7XKwu1Y6y3/H6rvFXklRmiJVKF1CRqv1XeKkOq3ap1c4j9wnmrBlIn3bh8JY3ogVQiVUhNosaBlCHVkOpIDaRQNwbqxkDdGKgbA3XDUTccdcNRNxx1w++7UbUqRyqQSqQKqUlUHEgZUg2pjhTqRqBuBOpGoG4E6kagbiTqRqJuJOpGom4k6kaibuT9tejm2iYTqUJqElUHUoYUuhYtdC1a6Fq0HCnUjULdKNSNQt2YqBsTfZ8yG1IdqYGUI4W+h53oe9iJvofd76LNjpcyW563nPtd9FYZUg2pjtRAypEKpBKpQgp1w1A3DHXDUDcMdcNQNwx1w1A3DHXDUDfsvhtt2UWzHUgZUg2pjtRAypEKpBKpQgp1o6NudNSNjrrRUTc66kZH3eioGx11o6NunOyiNo6XWp8RlCe76J0ypBpSHamBlCMVSCVShRTqht+fN8baQzekGlIdqYGUIxVIJVKF1CQqUDcS3YaJbsNEt+HZc+fy9a588+8/RfsVTYDOnjl3jYygRlAnaBDkBJGb/OxJYjNe38i3WBD5ms5GjePtI/39B5a+oiAoCTpZNCzfbghf0NRRnewZN8juv6a/5/TN8t9mPo/yrFj+96AGdfZ0sGs0RPTn4w//+93n9999/+GnXx/ky7/9/vGH395/+vj1j7/93y/Pf/n+8/sPH97//O0vnz/98NOPv3/+6dsPn3748m/vjq+//PvxKeQ3Vq0en86XL+DxEOk3j8uBL5/cX/+c0R5/jvzyF/bXXzxq/filPz6Tx2fz/w==",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
