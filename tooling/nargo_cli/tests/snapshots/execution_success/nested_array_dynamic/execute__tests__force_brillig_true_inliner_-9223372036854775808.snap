---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "pdzBzhvHsQXgd9HaC1ZXV3V1XiUIAsdRAgGCbCj2BS4Mv3umeuqckhYBjOHG/cnynEPyZw2HZP/+/cM/P/7jt3///dOXf/38nw9/+evvH/7x9dPnz5/+/ffPP//046+ffv5y/dvfP7zyHxL64S/yw7XOWq1Wr3XVGrXue93X4SNXqXXUqrXOWq1Wr3XVGrXus47Xq1apddSqtc5arVavddUatVaeVJ5UnlSeVJ5UnlSeVJ5UnlSeXHl6reNVq9Q6atVar7yZq9Xqta5ao9Z9r/qqVWodtWqtlaeVp5WnlaeVp5U3rzzLVWodtWqts1ar1WtdtUat+16t8qzyrPLsyvNcZ61Wq9e6ao1a9736q1apddRaeX7lrVytVq911Rq1XnlxretVq9Q6atVaZ61Wq9e6ao1aKy8qLyovKi8qLyovKi8qLyovKi8qb1ferrxdebvyduXtytuVl/Oxc41a91k15+OsUuuVJ6+EAhMwwIEFBLALOSc3BECyIFmQLEgWJAuSc15EEruQE3NDgAEoMAEDHFgAkgeSFcmK5JweGQkFJmCAAwsIYBdyim4IgOQcJNHEBAxwYAGZPBO7kPN0Q4ABKDABAxxYAJINyY5kR7Ij2ZHsSHYkO5IdyY5kR/JC8kLyQvJC8kLyQnJOmlhiAQHsQk7bjUz2xAAUmIABDiwggF3IubuB5I3kjeSN5I3kjeQcP1mJAPaNmRN4Q4ABKDABAxxYQABIFiSfGYzEABSYgAEOLCCAXTgzeIDkgeSB5IHkgeQzgzuxgAB24czggQADUGACBiBZkaxIViRPJE8kTyRPJE8kTyRPJE8kTyRPJBuSDcmGZENyzuB4JQxwYAEB5MXGdf6ZOYM3BBiAAhMwwIEFBIDkheSF5IXkheSF5JzBMRIOLCCAXcgZvCHAABSYAJIDyYHkQHLO4LjOfvNcGx4IMAAFJmCAAwsIoJLtXCXOhAADUGACBjiwgAB2QZAsSBYkC5IFyYLkc9VoiQUEsAs5gzcEGIACEzAAyQPJA8kDyTmDwxMCDECBCRjgwAIC2IWJ5JzBsRKZHIkFBLALOV83BMBROV83JmCAA0g2JBuSHcmOZEeyI9mR7Eh2JDuSHclnrHZCgAEoMAEDHFhAALsQSA4kB5IDyYHkQHIgOZAcSA4kbyRvJG8E5jTpK2GAAwsIYN/wnKYbAgxAgQkY4MACAkCyIFmQLEgWJAuSBcmCZEGyIPm8DbtOcX7ehx0IMIBMHolM1oQBDiwggF3IabohwAAUQLIiWZGc06QzEcAu5DTdEGAACkwgcywRwC7kfN0QYAAKTMAAr4cl5+tGALuQ83VDgAHgUc35umEAkh3JjmRH8kLyQvJC8kJyzpd6woEFBLALOV83BBiAAhNAciA5kBxIzvnS6xTnOV83BBiAAhMwwIEFBFDJ6/UCBBiAAhMwwIF6VNeZr+v0tc58HQgwAAUmYIADCwgAyQPJA8kDyQPJA8kDyQPJA8kDyQPJiuQzXzsxAAUmYIADCwhgF858HSA552u+EgpMwAAHFhDALuTE3RAAyYZkQ7Ih2ZBsSDYkG5IdyY5kR7IjOSduSsIABxYQwC7kxN0QYAAKIDlHb+ZTK0fvxgIC2IUcvRsCDECBCSA5kBxIDiQHkjeSN5I3kjeSN5I3kjeSc/SmJgLYNyJH74YAA1BgAgY4sIAAkCxIzhmcMzEABSZggAMLCGAXcgZvIDlncFpCgQkY4MACAtiF86njgQBIViQrkhXJimRFsiJZkTyRPJE8kTyRfGbQEwY4sIAAduHM4IEAA1AAyYZkQ7Ih+czgSuzCmcEDAQagwAQMcGABSD4zeJ3i4szggQADUGACBjiwgACQHEgOJAeSA8mB5EByIDmQHEgOJG8knxnciQEoMAEDHFhAAPlR8nUe2zmDNwQYgAITMMCBBQSA5JxBk4QAA1BgAgY4sIAAdmEgeSB5IHkgeSB5IHkgeSB5IHkgOWfQRkKAASgwAQMcWEAAuzCRPJE8kTyRPJE8kTyRPJE8kTyRbEg2JBuSDcmGZEOyITln0DQRwC7kDNpMCDAABSZggAMLCGAXFpIXkheSF5IXkheSF5IXkheSF5IDyYHkQHIgOWfQLGGAAwsIYBdyBm8IMAAFkLyRvJG8kbyRvCtZXq8XJdSglJqUUVngR4sKakNnHG8JNSilsmMdGeXUooLa0BnMW0INSil2nOmMI6cWFdSGzojeEmpQSk2KHcoOZYeyQ9kx2XGmdR8NSqlJGeXUooLa0BnbW+wwdhg7jB3GDmOHscPYYexwdjg7nB3n673X0aSMcmpRQW0oR7mUXx/K0aCUmpRRTi0qqA3lUJfYkWPt40ipSRnl1KKC2lCOd0kodmx2bHZsdmx2bHbkmLse7ZLknJeEGpRSkzLKqUUFxQ5hh7BD2CHsEHYIO4Qdwg5hh7Aj59znkVCDUmpSRjm1qKA2pOzIOXc7GpRSkzLKqUUFtaGc8xI7JjsmOyY7JjsmO3LO3Y+C2lDOeUmoQSk1KaOcYoexw9jh7HB2ODucHc4OZ4ezw9nh7HB2LHYsdpw5X0dKTcoopxYV1IbOnMeRUINSalJGObWooDa02XHmfB8NSqlJGeXUooLapbNhpiTUoJSalFFO5faK11FQG8o5Lwk1KKUmZZRT7BB2CDsGOwY7BjtyzpccTcoop7JjHAW1oZzzklCDUmpSRjnFDmWHsmOyY7JjsiPnfOnRpIxyalFBbSjnvCTUoNhh7DB2GDuMHcYOY4ezw9nh7HB2ODvOlp155NSigtpQznlJqEFlhx1NyiinFhXUhnLOS0INih0558uPsmMdZUccZceZlJzz0oZyzktCDUqpSRnlFDs2OzY6zsafc6vO1p9SbiZ6HSmVG4rkyKjcVDSOcpuSHgWUMx3zaFBKTcoopxYV1K5H8mz9KfE2n5m+pdSsx/ns/yk5taigNnRm+pZQg1KKHcoOZYeyQ9mh7JjsmLwfk/dj8n6cmb5llFOLCignOexIqEEpNSmjnFpUUBtyduQkx/l55CSXsuPclpzkklFOZcd5DHKSSxs62/BuCTUopSZllFPsWOxY7Ah2BDuCHcGO4P0I3o/g/Tgb9W4FtaGzXe+WUPz5ns16ZxrPdr1bTi0qqF0624ZKQg1KqUkZ5dSigmKHsEPYIewQduRM79eRUU4tKqgN5UyXhBqUUuwY7BjsGOwY7BjsUHYoO5Qdyo6c6S1HRjm1qKA2lDNdEmpQSrEjZ3qPI6cWFdSGcrpLQg1KqUmxw9hh7DB2GDucHTndW48GpdSkjHJqUUFtKKe7xI7FjsWOxY7FjsWOnO49j4LKjjw3nW1IJaEGlR1+lB3rKFPiKFPOMzvntyT16nc2HZWUOltZz5PobP4renM1o7nBswXp3I6zB6l0tszKoTZn05reXM1obvLenHtq7+25N0dTm7NpTW+uZjT7no1uG902um1028DVxtmxVHJqUUFtKKe8JNSJHofnjuihNb0udM62pVJQ517kM+tsXQKlOZranM1TZYfePI+ZH0Zzk2dLYVGao6nNbjsbfIveXM1o9n3zvm/e9837vnnfN+827zbvNu825wN5XtmPziv7LaEGpdSkjOLP/2z9fZ0hOZt/b57tv0VpjqY2Z9Oa3lzNbotu2922u2132+623W2723a37W67zw9xuMGzqQqU5mhqczat6c3VjGa3SbdJt0m3SbdJt0m3SbdJt91niH24yXtL/+tQmqOpzWzLzfni9+b+m3hHcnZilYLa0DlH3BJqUEpNyih2KDuUHcqOyY7JjsmOyY7JjsmOyY7JjnOGkJubPGeIojRHU5uzaU1vrma3Wbd5t3m3ebd5t3m3ebd5t3m3ebd5t51zhB4JNahTdXM2renN1YzmJs8poyjN0ey26Lbotui26Lbotui23W2b92zznp3riVuTMsqpRQV1WvK0e7aFgdIcTW3OpjW9uZrR7DbpNuk26TbpNuk26TbpNuk26bb7d3/ylXPdp4qb0hxNbc6mNb25mtHsNu027TbtNu027TbtNu027TbttnOJkb8jIme/GSjN0dTmbFrTm6sZzW67TyDrUJqjqc3ZtKY3VzOam/RuW52wOmF1wj2pcbjJe1JvSnM0tTmb1uyw8yqdv5ghZ/8X/m3+t/kbGHL2gIGrmbcsfyVCzk6wm2cvGJi3LH+lQOLFirjn7eZp23/88cMH/Nbs33/9+vFj/tLsN79G+9ffP/zy49ePX3798Jcvv33+/MOH//vx82/nP/rPLz9+OeuvP369/va6WR+//PNar8B/ffr8MfXHD330638fOvImn4OvD7x5uP354/Me1fHrveN1Pjk+dxXdx9uj2+/sX/Je/xpPjg8ev/XR8c7j51vHXx8BPzhe8wR2Hz+e3H5V9mu816/7yfHG4/316Hjl8fLm8Y/uf14e3sfvJ7d/vtB/fTT4Vv/1geKT/oGT1/Xh3nvH65P5mxPPv+uDtSfHO54/18dd7/U/+vnPfvzjyeNvgvP/9SHPW/3XJ0NP+g33//qo4cnxC8/f64OBB8d7vt0+x1/vcZ8crzh/X2/v3jv+0fNvDTx+69Hr58qPTO/j95PHL799qYD8quXJLTBM8HWx+eT4F49/PfoJLP4EHk3Q4jNwPbv/ffx+cgYIwfEx5L3jHz0Dw/EEiEdXQLExgfv1Xv9+dAWzeQWxH13BbF4Bbnuz3548fttxBtjryeO3N/sfPf++6d9PrsByhyjOIC978hoiwouA3ND3JKHfhuRmoEcJfCHJTUTvJuijc/HgqTS37rx7Gx6djXN3DhPC3k14+JokfBxUxpu3QeXR46CjE6a9m2Dr3YQVjxI2Lu9yI8DbCY9uw1Rlgtq7t0H90W0wYYLvdxMeXSd8l/BssoyXSvLsav+7hPFoskyNCc/Oct/ehkefGeR3LUh4dtWd3xJ1gryb4I/OMIsfneRnyU8SQvjKG4/ePUsE78Wzq6/xMn4A9lqPPsF7DWXCfPazWDxPXl8LPUp4BRNejxKsb8P1ZfWjBO/JCn03YT86w/jmddR69rr5bcKza7lvEx59JphfdTDh0acy3yU8elZ/lxDydsKjM+3iW7P8+uJJwhaeo/azn+Ye1gmPfpqxO+HRO8zvznLPntXfJjx73Qx+UCbhz+7F6ASVd18v5qPrh5j9jHr2DuXb2/DsHUq/YZf96DPH7xIevef+PsHeTXh0tr9ebl/9ymvvvnZHvPva/einOYRfYIzrm+N3Ex69cx8y+UjKo7n47jY8e7e4l/Tz4Zvp/vMBm98kvr79KvjP/yxfHfDtWfLPB8jqW2Dv3oL/dRck/3+Cf+LD2Pgu4G/XH3786dPX7/43139k0NdPP/7j88f6479++/LTN3/76///gr/B/yb7l68///Txn799/ZhJ+Xf3/yv7+sdfrxfZ9cN1mo6//fBB88/XJ5uy5vUnOX+9fFx/9pX/Qs6/uH7m1z/0b3/kDfwv",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
