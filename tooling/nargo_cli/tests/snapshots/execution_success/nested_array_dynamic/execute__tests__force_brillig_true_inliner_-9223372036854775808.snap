---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
