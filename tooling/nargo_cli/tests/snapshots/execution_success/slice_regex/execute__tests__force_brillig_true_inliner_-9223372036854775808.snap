---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
