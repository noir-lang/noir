---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
