---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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CDKCjCAjyAgygoxGRiOjkdHIaGQ0MhoZjYxGRiOjk9HJ6GR0MjoZnYxORiejk9HJSDKSjCQjyUgykowkI8lIMpKMQcYgY5AxyBhkDDIGGYOMQcYgY5IxyZhkTDImGZOMScYkY5IxyVhkLDIWGYuMRcYiY5GxyFhk0HOj50bPjZ4bPTd6bvTc6LnRc6PnRs+Nnhs9N3pu9NzoudFzo+dGz42eGz03em703Oi50XOj50bPjZ4bPTd6bvTc6LnRc6PnRs+Nnhs9N3pu9NzoudFzo+dGz42eGz03em703Oi50XOj50bPjZ4bPTd6bvTc6LnRc6PnRs+Nnhs9N3pu9NzoudFzo+dGz42eGz03em703Oi50XOj50bPjZ4bPTd6bvTc6LnRc6PnRs+Nnhs9N3pu9NzoudFzo+dGz42eGz03em703Oi50XOj50bPjZ4bPXd67vTc6bnTc6fnTs+dnjs9d3ru9NzpudNzp+dOz52eOz13eu703Om503On507PnZ47PXd67vTc6bnTc6fnTs+dnjs9d3ru9NzpudNzp+dOz52eOz13eu703Om503On507PnZ47PXd67vTc6bnTc6fnTs+dnjs9d3ru9NzpudNzp+dOz52eOz13eu703Om503On507PnZ47PXd67vTc6bnTc6fnTs+dnjs9d3ru9NzpudNzp+dOz52eOz13eu703Om503On507PnZ47PXd67vTc6bnT86DnQc+Dngc9D3oe9DzoedDzoOdBz4OeBz0Peh70POh50POg50HPg54HPQ96HvQ86HnQ86DnQc+Dngc9D3oe9DzoedDzoOdBz4OeBz0Peh70POh50POg50HPg54HPQ96HvQ86HnQ86DnQc+Dngc9D3oe9DzoedDzoOdBz4OeBz0Peh70POh50POg50HPg54HPQ96HvQ86PlZKrNvN9lZK1MUUIM6lNBeUXpt2p1OO7RXlfqhvR41DiU0oAkt0W5tkUEOBdQgMhYZi4xFxlLGWRVTVDe27KyLKQqoQR1KaEATWiK7IDKMDOdV51X/8ipb4GyBswXOFjhb4HUfzM5il4figgxyKKAGdSihAZERZDQyWt1us7POpahDCQ1oQkt0bqA+VLfd7CxhKZrQEu0jMc8S7f2JUzShJTpH50MGORRQgzpExiTjHKfPku/9s+ddOMfkQx3KorPqI5/F4R1KaEAT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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
