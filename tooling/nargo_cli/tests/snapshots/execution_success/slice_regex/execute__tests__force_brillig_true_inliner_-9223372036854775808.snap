---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "zd3bjhzHlUDRf+GzHvKcuPtXBgNDljUGAUEyJHmAgeF/n6KtLlmszE7kMhPQC8EmeweKjF152ZEd9fcPf/72T3/7yx8/fv8/P/z04Q//9fcP3/3wzdc/f/zh+8dXf//HVx/+9OPH7777+Jc//vsff9g+/bLin9//01+//v7Tlz/9/PWPP3/4Q82+ffXh2+///Om3sz9G+J+P33374Q9t+8d/f/VhJTAFmApMA6YDM4CZwKzrTGybQCFQClQEqgI1gbpAQ6ApkBgRYkQcGFHGE2rrBUqBikBVoCZQF2gINAVaAOUmkBiRYkSKESlGpBiRYkSKESlGpBhRxIgiRhQxoogR5cCI1d6gEtu/Q1+9fPNc8cv3rizPb8381/jt5vH7zeOPm8efN4+/7h2/bjePHzePnzePX24ef//9W0Y8xx/5+Zu+NoG6QEOgKdACqG0ChUApUBFIjGhiRDswIvsTmi8nnDYEmgItgPomUAiUAhWBqkBNIDGiixFdjOhixBAjhhgxxIixb0QdT6htL+/cUQVqAnWBhkBToAXQ3AQKgVIgMWKKEVOMmGLEFCOmGDHFiCVGLDFiiREHbbm28gbV0V6gKlATqAs0BJoCretQHhTmEygESoGKQFWgJlAXaAg0BRIjQowIMSLEiBAjQowIMeKgMLd43qC0/E2fv3YfnQcx+suNP28ef907/kEN/3Ljx83j583jl5vHrzeP324e/+D9O59xus35+Zv+YD3gBJoCLYAO1gNOoBAoBSoCHXhW8w3q28vB+SDyn0BdoCHQFGgBdFDDT6AQKAUqAokRVYyoYkQVI6oYUcWIJkY0MaKJEU2MaGJEEyOaGNHEiCZGNDGiixFdjOhiRBcjuhjRxYguRnQxoosRXYwYYsQQI4YYMcSIIUYMMWKIEUOMGGLEECOmGDHFiClGTDFiihFTjJhixBQjphgxxYglRiwxYokRS4xYYsQSI5YYscSIJUYsMKJsm0Ah0L4RozzbwGjzBSoCVYGaQF2gIdAUaAF0UJhPoBBIjAgxIsSIECNCjAgxIsSIECNSjEgxIsWIFCMOSujYnllrlO0FagJ1gYZAU6AF0EGzPIFCoBSoCCRGFDGiiBFFjChiRBEjqhhRxYgqRlQxoooRVYyoYsRBsxz9V2j+5iGOa4st5SBvfrnx173jH0TTLzd+3Dx+3jx+uXn8evP47ebx+83j779/Z30+wTBr/fxNf1CYT6AF0EFhPoFCoBSoCFQFOvBszSfU4wXqAg2BpkALoIPCfAKFQClQEagKJEYMMWKIEUOMGGLEFCOmGHFQmNf2fGJ1lZd37kFhPoGqQE2gLtAQaAq0ADoozCdQCCRGLDFiiRFLjFhixBIjlhixwIi6bQKFQClQEagK1ATaN2LOZ2pfL6m9HhTmE2gKtAA6KMwnUAiUAhWBqkBNIDEixIgQI0KMSDEixYgUI1KMSDEixYgUI1KMSDHioDCvX2+61m/7/LX76HoQo7/c+HHz+Hnz+OXm8evN47ebx+83jz9uHn/ePP7u+7dtsX5h2pafx+m6vx5wBoVAKVARqArUBOoCHXg26hMq4wWaAi2ADnL8CRQCpUBFoCpQE6gLJEY0MaKJEV2M6GJEFyO6GLFfmFv++s7Nl8Jc9wvzGdQFGgJNgRZA+4X5DAqBUqAikBgxxIghRgwxYogRQ4yYYsQUI6YYsV+YW8z5hGK+QFWgJlAXaAg0BVoA7RfmMygESoHEiCVGLDFiiRFLjFhixAIj2rYJFAIdHCOemw607P/BrVbbys3j15vHbzeP328ef9w8/rx5/HXv+LHdPH7cPP7++7fk8xxfXp6za/vrAWdQFagJ1AUaAk2BFkB54Nl83nqVOl6gECgFKgJVgZpAXaAh0BRoAVTEiCJGFDGiiBFFjChiRBEjihhRxIgiRlQxoooRVYyoYkQVI6oYUcWIKkZUMaKKEU2MaGLEfmF+/FPfPufj8VraC1QEqgI1gbpAQ6Ap0AJovzC3XzeJeyi9XqAQKAUqAlWBmkBdoCHQFGgBNMSIIUYMMWKIEUOMGGLEECOGGDHEiCFGHBTmxx3c88CSv4Eu3nMexOgvN37ePH65efx68/jt5vH7zeOPm8efN4+/7h3/YD3g8efP8dfnP07QDtYDTqAUqAhUBWoCdYGGQAee1bfPsHlcrb0E94P1gHehfrAecAKFQClQEagK1ATqAg2BpkBiRIgRIUaEGBFiRIgRIUaEGBFiRIgRIUakGJFiRIoRB4V5lGc1H72+QFWgJlAXaAg0BVoAHRTmE2jfiBHPO45RXib3oDCfQEWgKlATqAs0BJoCLYAOCvMJJEZUMaKKEVWMqGJEFSOqGFHFiCpGNDHioDCP8Ss0/4NF7X4Qo7/c+OXm8evN47ebx+83jz9uHn/ePP66d/yDyP/lxt9//876vDCY7fMnGPrBesAJVASqAjWBukBDoCnQvmdze4am2T9fyesH6wEnUAiUAhWBqkBNoC7QEGgKJEZMMWKKEVOMmGLEFCOmGDHFiClGTDFiihFLjFhixBIjlhhxUJjXcxOeR9ssL1ATqAs0BJoCrevQOCjMJ1AItG/EGm8/cf/gxwtUBKoCNYG6QEOgKdAC6KAwn0AhkBgRYkSIESFGhBgRYkSIESFGpBiRYsR+YX6sM+XzwPLbR9iu3QCN/Rj9BcevN4/fbh6/3zz+uHn8efP4697x98v9Fxw/bh5///0b2/PCILbPH1sa++sBZ1AVqAnUBRoCTYEWQPXAs16e0G8/3fSfUAiUAhWBqkBNoC7QEGgKtABqYkQTI5oY0cSIJkY0MaKJEU2MaGJEEyO6GNHFiC5GdDGiixH7hblnfzsRPpb2X65k9wvzGTQEmgItgPYL8xkUAqVARaAqkBgxxIghRgwxYogRU4yYYsQUI6YYMcWIeWBEeR5Ysm8vUBdoCDQFWgCtTaAQKAUqAlWBxIglRiwxYokRC4yY2yZQCJQCFYGqQAdGrLdds3uJ3zxrfu3me2795vHHzePPm8df944f283jx83j583jl5vHrzePv//+Lc+i/fjt56tec3894AwaAk2BFkD76wFnUAiUAu17VnI8ofVycD4o9ydQE6gLNASaAi2ADrr1CRQCpUBiRBEjihhRxIgiRhQxoogR+2kw2nPL2Xj9wbq5nwbPoCJQFagJ1AUaAk2BFkD7afAMEiO6GNHFiC5GdDGiixFdjOhiRBcjhhixH+wyngeWx2/nC1QFagJ1gYZAU6AF0H6wO4P2he3Pah59vpwA9jvVGTQFWgDtd6ozKARKgYpAVaAmkBixxIglRiwwYm2bQCFQClQEqgI1gbpAYMTazyy55dtPIT9+21+gECgFKgJVgZpAXaAB0P5teDzuq94md75sYbT2b8PPoCZQF2gINAVaAO3fhp9BIVAKJEYUMWL/7vO9urf27z3fR8p1pF5H2nWkX0fGdWReR9ZlZP9e833k+uz367Pfr89+vz77/frs9+uz36/Pfr8++/367I/rsz+uz/64Pvvj+uyP67M/rs/+uD774/rsj+uzP67P/rw++/P67M/rsz+vz/68Pvvz+uzP67M/r8/+vD778/rsr+uzv67P/ro+++v67K/rs7+uz/66Pvvr+uyv67O/Ls9+bNsGTACTwBRgKjANmA7MAGYCAx4EeBDgQYAHAR4EeBDgQYAHAR4EeBDgQYIHCR4keJDgQYIHCR4keJDgQYIHCR4U8KCABwU8KOBBAQ8KeFDAgwIeFPCggAcVPKjgQQUPKnhQwYMKHlTwoIIHFTyo4EEDDxp40MCDBh408KCBBw08aOBBAw8aeNDBgw4edPCggwcdPOjgQQcPOnjQwYMOHgzwYIAHAzwY4MEADwZ4MMCDAR4M8GCABxM8mODBBA8meDDBgwkeTPBgggcTPJjgwQIPFniwwIMFHizwYIEHCzxY4MECD6AnBvTEgJ4Y0BMDeuLjYhmYBkwHZgAzgQEPoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSAnhjQEwN6YkBPDOiJAT0xoCcG9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPTOiJCT0xoScm9MSEnpjQExN6YkJPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2xQE8s0BML9MQCPbFATyzQEwv0xAI9sUBPLNATC/TEAj2x7PfEUd8+RWH827blT2YCs64z+z3xhAlgEpj9Lcv722fVP4LWk/nXVs4PZnd+Htnnjak7zP6G5X08mfycqRt8Ps2DSqIKUZWoRlQnahA1iVpCxUYUuRHkRpAbQW4EuRHkRpAbQW4EuZHkRsKnGD2oSlQjqhM1iJpELaHKRhR8UsmDGkRNopZQdSMqiEqiClGVqEYUuVHJjUpuVHKjkRuN3GjkRiM3GrnRyI1GbuyXnfc/Oidq34gKopKoQlQlqhHVhRrwwTYPqhBViWpEdaIGUZOoJdTciAqiyI0pbrT9p0HyUUXe7H3cRL5SQVQSVYiqRDWiOlGDqEnUEirIjSA3gtwIciPIjSA3gtwIciPIjSA39p/myPrrWa++nvXawX1lb2+RLfuar1QnahA1hdp/1uDsf2P/Xu+UmkQtofbv9c7+N/bv9U6pJKoQVYkieyvZW8neSvbu3+udUY3caORGo1ludBRtdBRtdBTtdIbtdIbtdIbtdIbtdIYd9O8a9O8a9O8a9u+iK4dBVw6DnB/k/CDnJzk/yY1JbkxyY5Ibk9yY5MYkNya5McmNRW7srypnXc8+/7g0fqWSqEJUJaoR1YkaRE2iFlD9oFScUUFUEiVXKX2rRDWiOlGDqEmUXIv22IgKopIociPIjSA3gtwIciPIjZQzbM9GVCdqEDWJkjNsLxtRQVQSVYgiNwq5UciNQm4UcqOQG5XcqORGJTcquVHl6qvXRlQnahA1iaKrr0ZXX42uvhpdfbVCFLnRyI1GZ9hGZ9hGZ9hGV1+drr46XX11uvrqdPXV6eqr09VXJzc6udFlBaEf1LkzKokqRNF7edB7edBxftBxftBxftBxftJxftJxftJxftJxfpIbk9yY5MYkNya5McmNRW5QnetU5zrVub7oOL/oOL/oOL/oOL/oGmDJNcDYNqKCqCSqEFWJakR1ogZRkyhygzrboM42qLMN6myDntIZ9JTOoKd0Rm5EBVFJVCGqEtWI6kSRG1QCB5XAQSVwUAkcVAIHlcBBJXBQCRxUAgc9izXo+ahBz0cNej5q0PNR46gsvf+/0QpRlahGlNwFjDaImkTJXcDoG1FBVBJViKpENaLIjU5udHKjkxuD3BjkxiA3BrlBZWlQWRqD7gIG3QUMugsYdBcw6Q5x0r3DpHPlpHPlpHPlpHPlJDcmuTHJjUluLHJjkRuLZnm/wJSI51YfUV6vAfYLzCm1gJr7BeaUCqKSqEJUJaoR1YkaRE2iyI0gN4LcCHIjyI2DPX9n/gLN1V6ZBkwHZgAzgVnXmYM9f99nApjd+VnxdqhduV6Z/Z8F3p5XTRE71H7N+LRL1RtVXvdUmfs145RKogpRlahGVCdqCHWwR0c+t0P7tBH6K1WJakR1ogZRk6gl1MEeHWdUEJVC7d/1v3/U2L/nP2Hg6LR/v3/C7Jq0njvYrf56Ztu//36f2b/7PmH253WLt63yYts57x7sXnFGFaIqUY2oTtQgahK1hDrYveKMIjcmuTHJjUluTHJjkhuT3JjkxiQ39u+9I6K+d721Qq7SVhJViepArU325lu0p+eiPT0X7em59u+iT6lGVCdqEDWJkn0bF+3puWhPz0V7ei7a03PRnp6L9vRctKfnoj09F+3puWhPz0V7ei7a03PRnp6L9vRctKfnoj09F+3puWhPz0V7ei7a03PRnp6L9vRctKfnoj09F+3puWhPz0V7ei7a03PRnp6L9vRctKfnoj09F+3puWhPz0V7ei7a03PRnp6L9vRctKfnOng+4/09Ihft6bloT89Fe3ou2tNz0Z6ei/b0XLSn5xqyb+OiPT0X7em5aE/PRXt6LtrTc9Genov29Fy0p+eiPT0X7em5ZE/P3GSd9UEVoipRjahO1CBqErWEknXWBxVEkRtBbgS5EeRGkBtBbgS5cX3F9XGS2YAJYBKYAkwFpgHTgVlX12hyK1AmHxSssz6oTtQgahK1hKobUUFUEgXrrA9qCSXrrA8qiEqiClGVqEZUJ2oItf909ftHjf1nq08YODodrOy+z+ya9N5q8IOpwDRgYC3tQQ2iJlFLKFlnfVBBVBJViKpENaLIjUluTHJjkhuL3FjkxiI3FrmxyI39n55/f9X5QcGa7oMaRC2gYguiYC3tQXWiBlGTqCWUrLM+qCAqiSpEVaLIjSA3gtwIciPIjSQ3ktxIciPJjSQ3ZJ310x8RtYSSddYHFUQlUYWoKpSssz6oICqJKkRVohpRnahB1CRqCdXIjUZuNHKjkRuN3GjkRiM3GrnRyI1Gbsg664MqRFWiGlGdqEHUJGoJJeusD6oTNYiaRC2hZJ31QQVRSVQhqhJFbkxxI2XPswdViWpEdaIGUZOoJZR8IsGDCqKSKHIjyI0gN4LcCHIjyI0gN2AtOGEtOGEtOGEtOGEtOGEtOGEtOHMAc31VJ2HNOcvln9d7MNJos1SiGlGdqEHUJEr6fdaNqCAqiSI3KrlRyY1KblRyo5Ibldxo5MbBvfv7ayDZ5EmVPLgLP6M6UfL0SPaNqCAqiSpEVaIaUfJkUQ55eiRHIaoS1YjqRA2iJlHyZFHOjSh5sqjsXzmUbXvrVWXLfKUaUZ2oQdQkagm1f+VwSgVRSVQhityo5EYlNyq5UcmNSm40cqORG43caORGk6e4SxtETaLkCf/SN6KCqCSqEFWJakSRG53cONid8/112jIbUZ2oQdQkStbwy9qICqL2nS/bepvlx8HvlSpEVaIaUZ2oQdQkagFVD3YdPaOCqCRK3Kgh5+UaQVQSVYiqRDWiOlGDqEmUXLPVJDeS3EhyI8mNJDeS3EhyI8mNJDeS3CjkRrl6ffjVyzf3/tZ4+m8Xgl+/NcYz3435+lryd/Rayu/otdTf0Wtpv6PX0n9Hr2X8jl7L/B29FjqWUbeq1K0qdatK3apSt6rUrSp1q0rdqlK3qte71T8eX/3v1z9+/PpP333704P59Jd/+/6bnz/+8P0vX/78f399+5s//fjxu+8+/uWPf/3xh2++/fPffvz2j9/98M2nv/uwffrl07Q/FhPbV4/1uu3xej79d+WnJv2Irfn4+p/X4bPGV7P2T19+kivWml/ltm2PV/J4Nf8P",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
