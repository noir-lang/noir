---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "7Z3dziO3kYbvZY590PyrYuVWFovASbzBAIYdOM4Ci8D3vhr1SHFWra79OM3W002dGN94VF89xSFfVv+81D8//eWHP/3jr3/8/NN//fz3T3/4j39++vHnP3//6+eff7r86Z+/fffpT798/vHHz3/94+//96fpy39Cun7+73/7/qcvf/z7r9//8uunP+Qo03effvjpL19+rHL5Df/1+ccfPv2hTL/953efQm6IKQ0x0hCjDTG1IcY+HhOnhpjQEBMbYhrmQWyYB7FhHsSGeRAb5kFsmAexYR6khnmQGuZBapgHqWEepIZ5kBrmQWqYB+nJPEh6jyn2+5jvHj4ciuavHw7FwvqHUwi335xCeqCpKBoj0eQJRRNQNBFFk1A0GUVTUDSCokFpcUZpcUZpcUFpcdlZi8MU6u3D0yNNRNEkFE1G0RQUjaBoFEVTUTRGopEJRYPSYkFpsaC0WFBaLCgtFpQWC0qLBaXFgtJiRWmxorRYUVqsKC1WlBYrSosVpcWK0mJFabGitLjursV2+80hRPu/NAFFg1pTFbWmKmpNVdSaMlR/Y6j+xlD9jaH6G8soGlR/YygtNpQWG0qLDaXFYUKJ8eVvWTgoOb78LxYOSpDDhFLkMKEkOUwoTQ4TSpQvFzoonMBS5cBS5RBJl8EhZBaOoHDi3nMn2e1NzcuP4QEnsnASCyezcAoLR1g4ysKpKJy091SOFu44U33AKSwcYeEoC6eycAyFs/c79B5OYOFEFk5i4XSdyl8y9H2r+JohdM8Qu2dI3TPk7hlK9wzSO8MGbzrGSyP49cOXHx9W3AZvL3oZUvcMuXuG0j2DdM+g3TPU3hm2eIdJJN1WnNRpw70tTdPtN6cpRqdQKXIrVOyx0DJKoTJKoTpKoXWUQm2QQrd4y+0YhYZRCo2jFJpGKTSPUugonVEdpTOqo3RGdZTOqI7SGdkonZGdpjOyfEM2eTxQ7TS7qPOOjJ1mF/UKPc0u6hV6ml3UK/Q0u6hX6Gl20fVC43SaXdQr9DS7qFfoae4veIWe5v6CV2gepdBBOqM4DdIZxWmQzihOg3RGcRqlMwqjdEZhlM4onKczCuH+mx+NHTGcqDNac7DEcKKGYb3QE+2jq4XG86juqgkixvOorlPoeVTXKfQ8qusUmkcp9Dzbi1Poea5HnULPs4+uF5rOI0artpWYziNGTqHnESOn0POIkVPoecTIKfQ8N8ecQs9zc2y90HyeyzSn0PNcpjmFnucyzSn0oGJ0ZT+ovnxhLweVjCv7QVXgyn7QhX1lP+hVzJU9H5j9oNcaV3a0vj//orPHD6+/FxwLejPYsFBB7xxbForeZrYsFL0nbVkoegPbslD0brdloeitcctC0bfhtiwUfRtuy0JH6YxklM5IR+mMdJTOSEfpjHSUzoh9btKWhZ5mH3XeI2WfsrNloafZR51C2afsbFnoafZRr9DT7KNeoafZR71CT7OPeoWe5g6DV+hp7jB4hY7SGbFP2dmy0FE6I/YpO1sWOkpnZKN0RjZKZ8Q+OWnLQs/TGa0bONknJ33sX3TV7sc+UGi7QhP7nJ0tCz2P6q46bNJ0HtV1Cj2P6jqFnkd1nULPcz3qFHqe7cUp9DzXo+uFsk9l2bLQ84jRqh8jsY+22LLQ84iRU+h5xGi9UPZhJVsWep6bY06h57k55hR6nss0p9A8SqHnuUxbLxRkyb3icCTjisNZ2FcczvK74nAWyRWH0+RfcTit+BWH0zB/wdnbBLz+fZxpb1+vh5NYOJmFU1g4wsJRFk5F4exurfsQ++o74Wl3t9yW7HJgdj0wez0wux2XfXcz2Zbs4cDs8cDs6cDsB95X9cD7qh54X9UD76t64H1VD7yv1gPvq5W8r659nWiqZHVff881VbK6e+xkdffYyerusZPV3WMnq7vDbmR199jJ6u6xk6+aPHbyVZPHfuB91Q68r9qB91U78L5qB95X7bj7ap6Ou6/m6bj7ap7Q++qqbS5P7H11zTeVJ/betM7O1vdV9oDWmVWPQA5onXHY0TrjsKN1xmHPB2ZHa6TDju7fHXa0vq+zR/RaXX3TOUf0WnXY0WvVYUevVYcdvVYddvS1tsOOvtZeZ0/oHthhR/fADju6B3bYOWv1isNZfl9wMmdFXXE4i+SKw5n3VxxOi3jFySwcTiN3xdn75fwplq8fvvz4cLt0729kdHD2/pJFDyewcCILJ7FwMgunoHB2/262mu6POqo+3Lbe/RvUHJzEwsksnMLCERaOsnAqC8dQOLubhBwcliorS5X7fjfENUPunqF0zyDdM2j3DLV7Buudoe+btNcM374enC5xg7cjvQylewbpnkG7Z6jdM1jnDGWDN+C8DBso3+oOVLZ4M8jJULtnsN4ZtngHyckQumeI3TOk7hly9wyle4buazp0X9Mffg58DbKGoA8/+bwGhZag2BKUWoJyS1BpCXoy1+y26VyezjpXMPX+kNFiun80xo989IqiHJTKQTEMyrMnoq9ACRyUyEFJHJTMQSkcFI7aZo7aZo7aZo7aFo7aFo7aFo7aFo7aFo7aFo7aFo7aFo7aFo7aFo7aCkdthaO2wlFb4aitcNRWOGorHLUVjtoKR22Fo7bKUVvlqK1y1FY5aqsctVWO2ipHbZWjtspRW+WobeWobeWobeWobeWobeWobeWobeWobeWobeWobeWorXHU1jhqaxy1NY7aGkdtjaO2xlFb46itcdTWMGorE0ZtZcKorUwYtZUJo7YyYdRWJozayoRRW5kwaisTRm1l4qht4Kht4Kht4Kht4Kht4Kht4Kht4Kht4Kht4Kht4Kht5Kht5Kht5Kht5Kht5Kht5Kht5Kht5Kht5Kht5Kht4qht4qht4qht4qht4qht4qgtx0smHC+ZcLxkwvGSCcdLJhwvmXC8ZMLxkgnHSyYcL5lwvGTC8ZIJx0smHC+ZcLxkwvGSCcdLJhwvmXC8ZMLxkgnHSyYcL5lwvGTC8ZIJx0smHC+ZcLxkwvGSCcdLJhwvmXC8ZMLxkgnHSyYcL5lwvGTC8ZIJx0smHC+ZcLxkwvGSCcdLJhwvmXC8ZMLxkgnHSyYcL5lwvGTC8ZIJx0smHC+ZcLxkwvGSCcdLJhwvmXC8ZMLxkgnHSyYcL5lwvGTC8ZIJx0smHC+ZcLxkwvGSKcdLphwvmXK8ZMrxkumEUVvleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl0w5XjLleMmU4yVTjpdMOV4y5XjJlOMlU46XTDleMuV4yZTjJVOOl6xyvGSV4yWrHC9Z5XjJ6oRR28rxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLVjlessrxklWOl6xyvGSV4yWrHC9Z5XjJKsdLZhwvmXG8ZMbxkhnHS2YTRm2N4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLjeMmM4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLjeMmM4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLjeMmM4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLjeMmM4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLjeMmM4yUzjpfMOF4y43jJjOMlM46XzDheMuN4yYzjJTOOl8w4XjLb10umWb9+VOv0gKIclMpBMQzKvl6ydZTAQVlW2xTljlLt9yjXoNQSlFuCSkuQtARpS1BtCVpeE1nvQWWK/zfoiTfHCQotQbElKLUE5Zag0hIkLUHaElRbghpmRJimqSkqNEXFpqjUFJWbokpTlDRFaVNUbYp6MjdKukVlLet7RSiav344FAvrH04h3LaLFJI88Dx5kfp1PAHGE2E8CcaTYTwFxiMwHoXxVBgPTJ8jTJ8jTJ8jTJ/jzvr8ZQXdPjwt8WQYT4HxCIxHYTwVxmMsnjTBeAKMJ8J4YPqcYPqcYPqcYPqcYPqcYPqcYPqcYfqcYfqcYfqcYfqcYfqcYfqcYfqcYfqcYfqcYfpcYPpcdtdnu91PCCHaIw9MfwpMfwpMfwpMfwpMfwpMfwSmPwLrDwXWHwqsPxSYPgtMnwWmzwLTZ4Hps8D0WWH6rDB9Vpg+K0yfFabPCtNnhemzwvRZYfqsMH2uE+t6uUYYT4bx7L2+kk23D6d///DMU2E8xuKxCcYTYDwRxpNgPBnFE6a953O8O2tCmuojT4DxRBhPgvFkGE+B8QiMR2E8FcZjLJ6+78/PKaR/Cu2fovZPYd1T9H29fE4R+qeI/VN8+7qIId4uzS4/Pi69DV5FdlNo/xS1fwrrnmKD13rdFKF/itg/xQYyKHL7cJDfWdq/fbNL03T7zWmK0alUys25GcUWKrVRKt3incmDVBqGqTQOU2kaptI8TKVlmEplmEp1mEqH6ZHyMD1SGaZHKsP0SGWYHqkM0yNt8f78QSo9TY9k9xPuTOSxztPsps67NaGcZjf1KpXT7KZupafZTd1KT7ObupWeZjd1Kz3NbupWeprd1K30NHcc3EpPc8fBrXSYHkmG6ZF0mB5Jh+mRdJgeSYfpkbZwHB2k0mF6JD1Pj3S5SX/7zQv+kKAn6pFWnTBBT9Q5rFdaT7SfOpWeR3sdH0U9j/Z6lZ5He71Kz6O9XqXnuT71Kj3PLuNUaue5PvUqPc9+6lV6HkVyfC92HkXyKj2PIq1XGqfzKJJX6XkUyav0PHfMvErPc8fMqzQPU+l5rtq8Ss9z1eZUGg6qSDP8QUVmhj+obszwB5WCGf6gq3uGP+hFzQx/0OuUGf6glx5X+IjW+edfS/b4YedN4hjRm8KmlaJ3kE0rRW83m1aK3ps2rRS9kW1aKXrX27RS9Ba5ZaUJfXdu00rRd+c2rXSYHikN0yNt8Q2FB6l0mB4pDdMjpWF6JPZJTFtWyj615yOVOu+dRvapPZtWepr91K30NPupW+lp9lO30tPsp26lp9lP3UpPs5+6lZ7mnoNXKfvUnk0rHaZHYp/as2mlw/RI7FN7Nq10mB6pDNMjlWF6JPZZTJtWep4ead0BGtlnMX3s33TVLRjZJxRtWumJ9lOn0vNo77o3J7LPeNm00vNor1Mp+4yXTSs9z/WpV+l5dhmv0vNcn3qVnmc/dSqt51Ekx8fBPiVj00rPo0hepedRJK/S8yiSV+l57ph5lZ7njplX6Xmu2rxKz3PV5lV6nqu29UoTyNU783B0Y+bhrO6Zh7MGZx7OSrnyBE7PP/NwOvOZh9M/zzw764/znaBpb3ewy6MwngrjMRZPnGA8AcYTYTx776cfgl9/mTztbrjbEn53D92m8OHI8PHI8OnI8PnI8OXI8HJkeD0y/JF32HTkHTYfeYfNR95h85F32HzkHXZ3h9qm8OQddvWbTVMmq7zzgmzKZJX34AtZ5V14ssq78GSVd+HJKu/Ck1XehServAtPvo5y4cnXUS78kXfYcuQdVo68w8qRd1g58g4rR95hd3fdbAp/5B1W0DvsugEvCXuHXfVfJWFvUuvwytZ5Bx6tNus2g6RotfHg0WrjwaPVxoNH9/MePFoqHfiK7uc9eLTOe/DoBeu8Kl3RC9aDRy9YB97QC9aDRy9YDx59Ae7Boy/APfh8ZHh0S+zBo1vidfg8cRbszMNZgzMPZ1nNPJyVMvNwJv/Mw+kYZx5OEzjzcPq6K8/e/qI4xfL1w5cf5ZEnwXgyjKfAeATGozCeCuMxFs/u3xVX0/2BSFV75BEYj8J4KozHWDy7u6Q8ngDjiTCeBOPJMB6YPieYPvf9joo5Re2fwrqn6Pva85wi9E8R+6dI/VPk/im+fV14reMGL1i6Kax7ig1eVnRThP4pYv8UqX+K3D3FFqfuOlvSFm8WeSli/xSpf4rcP0Xpn0L6p9D+KWr/FNY9Re2/umv/1f3hh8hzVGqKyk1RpSlKmqK0Kao2RVlDVJmWZ10JtyePl7bVOXaw3p9SWkz3j8b4kY/OLAHEEkEsCcSSQSwFxCIgFgWx1D1Z9O5b199dV95ZjMMSJhBLALFEEEsCsTzR3RxvLDI97u5Pnvh6UdIUpU1RtSnKWqKenNfoRYWmqNgUlZqimuZGbJobsWluxKa5EZvmRmyaG6lpbqSmuZGa5kZqmhtPnglpumuYlvoYVZqipClKm6JqU5S1RD05W8uLCk1RsSkqNUU1zY3cNDdy09zITXMjN82N3DQ3StPcKE1zozTNjdI0N0rT3ChNc+PJOSM66T0qeY9aN/pShZlHYTwVxmMsniePwV7HE2A8EcaTYDwZxlNgPDB9Fpg+C0yfBabPCtNnhemzwvRZYfqsO+uPBbnftLNHmp1Xl3OeSqk7zx7H919qgvFkGE+B8QiMR2E8FcZjLB7bez6vu6KLCYxHYTwVxmMoHpkmGE+A8UQYT4LxZBZP6Dqf5xShf4rYP0XqnyL3T1H6p5D+KbR7ivjt68L5wkGJoX+K2D9F6p8i909R+qeQ/im0e4q0gQx+yCX5oVtFabLbraJUvA9P0w0jTV/euVodlvXv65GU38OyNCzlPSxLwyLvYVkaFn0Py9Kw1PewLA2LvYdlYVjy9B6WpWEJ72FZGpb4HpalYXl3uYvDkt/DsjQs7y53cVjeXe7isLy73MVheXe5i8Py7nKXhqWM2eWufvOylDG7Fudr1KSM2bW4wzJm1+IOy5hdizssY3Yt7rCM2bW4wzJm1+INi4zZtbjDMua9OXdYxrw35w7Lu8tdHJb8HpalYXl3uYvD8u5yF4fl3eUuDsu7y10clneXuzQs+u5yF4dl0C43hDvGgkFRdNQud9W3KTpqO+cMy6h9izMsg+5E6+ZDqYPuRN6wDLoTecMy6E7kDcug91u8YRl0g/aGZdD7Ld6wDNq3OMNig0quY8q1QSXXG5ZBJdcblkEl1xuWQSXXG5ZBb3F7wzLoLW5vWAa9sbA+LDoNemPBG5ZBbyx4wzKC5M6VjqCic6UjCOO10jCC1s2VjiBfc6UjXHfPlY5wKT1Xmoep9DxXds/PNn78sMjtXpr8+1erLhDr/XGhPvYj4Tz9yGvG7zxdzmvG7zy900vGL56nI3vN+J2nz3vN+J2ne3zN+J2nJ33J+KVhrtPSMNdpQ5wrOVeah6mU82By5uFcN848nOuwmYdzXTPzcK4Trjygo/VmHs4+OPNwdquZZ2f9cc5O1r0PxHJ5FMZTYTzG4tn70COXJ8B4Ioxn7/30Q/DrJ2zp7kd4bAm/+0Ebm8KHI8PHI8OnI8PnI8OXI8PLkeH1yPBH3mHlyDusHnmH1SPvsHrkHVaPvMPu7snfFJ68w66ea6tKVnnn2A9Vssp78JWs8i48WeVdeLLKu/BklXfhySrvwpNV3oUnX0e58OTrKBf+yDtsPfIOa0feYe3IO6wdeYe1I++wu/v4N4U/8g5r6B12/aRANfYOu3pCmxp7k1qFrxNb5x14tNqsH5BTJ7TaePBotfHg0WrjwaP7eQ8eLZUOfED38x48Wuc9ePSCXT8iogb0gvXg0QvWgY/oBevBoxesB4++APfg0RfgHnw+Mjy6Jfbg0S2xA584C3bm4azBmYezrGYezkqZeTiTf+bhdIwzD6cJnHk4fd2VZ29/UZxi+frhy4/yyJNgPBnGU2A8AuNRGE+F8RiLZ/dvzL50FLcPV328s737V1V7PArjqTAeY/Hs7pLyeAKMJ8J4Eownw3hg+iwwfdau+jynqP1TWPcUfV97nlOE/ili/xSpf4rcP8W3rwuvddzgBUs3hXVPscHLim6K0D9F7J8i9U+Re6ewLb7lYH1Lsi3eLPJSxP4pUv8UuX+K0j+F9E+h/VPU/imse4rQf3WH/qv7ww+R56jUFJWbokpTlDRFaVNUbYqylqj0ZNbJv6Kq83Ur9f6U8vLveP/ol/MH//8fnVkCiCWCWBKIJYNYCohFQCwKYql7sujdt66/u668sxiHJU8glgBiiSCWBGJ5ort28xfly+36h9392RNfJ0qaorQpqjZFWUvUs/Manajl1XG5drpFXTbFx6jYFJWaonJTVGmKkqYobYqqTVHWEvXk2ZsX1TQ3pGluSNPckKa5IU1zQ5rmhjTNDWmaG9I0N7RpbmjT3NCmuaFNc0Ob5saTg4sujzfuUVNZ3xU/dgT+8++0mHkExqMwngrjMRbPk4eLr+MJMJ4I40kwngzjgelzhelzhelzhelzhemzwfTZYPpsMH22nfXHgtxvsTw+j7KdV9f66RdxmnaePesu7QtPhPEkGE+G8RQYj8B4FMZTWTxh7/m86mG98BQYj8B4FMZTYTzG4okTjCfAeCKMJ8F4us7na4o09U8R+qeI/VOk/ily/xSlfwrpn+Lb18X618PFKU/9U4T+KWL/FKl/itw/RemfQrqnKBvI4Ic8ba/49uqFYVn9dpXLsKT3sCwNS34Py9KwlPewLA2LvIdlaVj0PSxLw1Lfw7I0LPYeloVhkek9LEvDEt7DsjQs7y53cVjeXe7isOT3sCwNy7vLXRyWd5e7OCzvLndxWN5d7uKwjNnlrn1Pbpx0zK5l/UuvLsMyZtfiDkt+D8vSsIzZtbjDMmbX4g7LmF2LOyxjdi3usIzZtXjDUse8N+cOy5j35txheXe5i8Py7nIXhyW/h2VpWN5d7uKwvLvcxWF5d7mLw/LucheH5d3lLg2LDdrlrn6r+2VYRu1y132bNmo75wzLqH2LMyyD7kSO+dAG3YnWhyVMg+5E3rAMuhN5wzLo/RZvWAbdoL1hye9hWRqWQfsWZ1jCoJK7bsq9tHjvYVkalkEl1xuWQSXXG5ZBJdcblkFvcXvDMugtbm9YBr2x4A3LoDcWnGGJg95Y8IZlBMmdKx1BRedKRxDGudIRtO5aaRpBvuZKR7junisd4VJ6rnSEq+O50vNc2T0/2/jxwyK3e2ny71+EuUCs98eF+tiPpPP0I68Zv/N0Oa8Zv/P0Tq8Zv/N0ZC8Zv3yePu8143ee7vE143eenvQl41eGuU4rw1ynDXGu5FzpMNdpoNMfZx7OdePMw7kOm3k41zUzD+c6Yebh9N1XHtCZdjMPZ7eaeXbWH+fs5LD3gVguj8B4FMZTYTzG4tEJxhNgPHvvpx+CXz9hK+x+hMem8HZg+N2Pw9gUPhwZPh4ZPh0ZPh8ZvhwZXo4Mf+Qdth55h61H3mHtyDusHXmHtSPvsHbkHdbIO+zqubbByCrvHPsRjKzyLjxZ5R34OJFV3oUnq7wLT1Z5F56s8i48WeVdePJ1lAtPvo5y4Q+8w8bpwDtsnI68w4Yj77DhyDtsOPIOG468w+7utt8UHr3Drp8UGAN7h109oS0G9ia1Dh/ZOu/Ao9Vm/YCcGNFq48Gj1caDR6uNB4/u5z14tFR68Oh+3oFPaJ334NELdv2IiJjQC9aDRy9YDx69YB34jF6wHjz6AtyDR1+Ae/DoltiDz0eGR7fEDnzhLNiZh7MGZx7Ospp5OCtl5uFM/pmH0zHOPJwmcObh9HVXnr39RZfn2OXrhy8/Pt5NlQjjSTCeDOMpMB6B8SiMp7J4dv/G7JruD0SqPt7Z3v2rqj0egfEojKfCeIzFs7vxyeMJMJ4I40kwHpg+V5g+W1d9nlNo/xS1fwrrnSL1fTl5ThH6p4j9U6T+Kb59XTitY9rgBUs3Re2fwrqn2OCVQjdF6J8i9k+R+qfYQAbXt6S0xZtFXorQP0XsnyL1T5H7pyj9U0j/FNo/Re2fov/qTv1X94cfIs9RsSkqNUXlpqjSFCVNUdoUVZuilmed5XSPKnV9StT7U0qL6f7RL+cP/v8/emV5co7oa1gCiCWCWBKIJYNYCohFQCy6J4vefev6u+vKO0sFsRiHRSYQSwCxRBDLE929n7hZpqQPu/uTJ75eVGmKkqYobYqqTVHWErV8qmKJ4XYwc4k5P0aFpqjYFJWaonJTVGmKkqYobYqqTVHWElWb5kZtmhu1aW7UprlRm+ZGbZobtWlu1Ka5UZvmxvLZWiXUeo8KD29npuVDrdyo0BQVm6JSU1RuiipNUdIU9WRulHSPkr36X6sgFsOw5GkCsQQQSwSxJBBLBrGUPVlWrwvyJCAWBbFUEItxWMIEYlnW3fwvlvz4hCEvP8t1o1JTVG6KKk1R0hSlTVG1KWp5Hpf7MSGlRNtJg5cfVL+IJYBYIoglgVgyiKWAWATEonuyrO9Nyw/8X8RiHJY0gVgCiCWCWJZ1V8N9d9fk9Hgx3w9xiiV4H14/6jqnDOMpMB6B8SiMp8J4jMWzfOrIC3nCvjzOKYt5+e2yF/IkGE+G8RQYj8B4FMZTYTzG4ikTjAemzwWmzwWmzwWmzwWmzwWmz+Wj+jxH1aYoa4mSqSkqNEXFpqjUFJWbop7MZ/1XVN3r2aIIiEVBLBXEYhyWJ28nvoYlgFgiiCXtybJ+b/DJW5+vYSkgFgGxKIilgliWddf05nArZur0eanebsh/eb/poRV48kLvpilC/xSxf4rUP0Xun6L0TyH9U2j/FLV/iv6r2/qvbuu/uq3/6rb+q9v6r27rv7qt/+q2/qvbuq/uMm2wLvK/jkfJj8ejlGmDGbX+ZKtMpX8K6Z9C+6f46Iyao6wlKkxNUaEpKjZFpaao3BRVmqIWZ51M6RYlU9Z9LpfL8iutL2KpIBbjsCy/fvsilgBiiSCWBGLJe7Ks3kYoy6/fvohFQCwKYqkgFuOwpCe6ez9QU8JCZ5xCU1RsikpNUbkpqjRFSVPU8uqIcvuXlVgf+6rlVxfdKGuJWn4N0I0KTVGxKSo1ReWmqNIUJU1RTXMjN82N3DQ3StPcKE1zozTNjdI0N0rT3ChNc6M0zY3yZG6ku9pEmX77pnsrpfZPYd1TyNQ/ReifIvZPkfqnyP1TlP4ppH+K/qtb+q9u6b+6tf/q1v6rW/uvbu2/urX/6tb+q1v7r27dYF04Dy3qBjPKuRdfU/8UuX+K0j/FR2fUHKVNUbUpylqibGqKCk1RsSkqNUU9mXV2+1eWFMJv+9zgtAJiERCLglgqiMUwLDJNIJYAYol7sqze+JUpgVgyiKWAWATEoiCWZd1NUe8s9rC7y/LLIF7U8ssgblRoiopNUakpKjdFbXCNtH4BI6H7NZLEqX+KDe4dbHiEgsQI40kwngzjKTAegfEojKfCeIzFkyYYD0yfE0yfE0yfE0yfE0yfE0yfE0yf0876bPcLGJPH7jDvrD7OAROSI4wnwXgyjKfAeATGozCeCuMxFk+ZYDwwfS4wfS4wfS4wfS4wfS4wfS4wfS4wfS5763O4HysdQnz4ogaR3fX5/uFlngjjyTCevdfX5VnBjSdZeOSpMB5j8egE4wkwngjjSTCezOKpe8/neH+0HNL0ePenBhhPhPEkGE+G8RQYj8B4FMZTYTzG4rGu83lOIf1TaP8UtX8K651Cp6l/itA/ReyfIvVPscHWtv6sS6fSP4X0T6H9U9T+Kax7ijD1TxH6p4j9U6T+Kfqv7tB/dYf+qzv0X92h/+oO/Vd37L/0nnyV6YZHKWrU/ilq/xQbnCi74UstmiYYT4DxRBhPgvFkGE+B8QiMR2E8FcYD0+cM0+cM0+cM0+cM0+cM0+cM0+e8sz6vvtSreWf1cV4i0TLBeAKMJ8J4Eownw3gKjEdgPArjqTAemD4LTJ8Fps8C02eB6bPA9Flg+iwwfZa99Xn9pV6V3fV59aVV1QnGE2E8e6+v9Zf8VAXGozCeCuMxFk+dYDwBxhNhPHvP5/WX2LQai8cmGE+A8UQYT4LxZBhPgfEIjEdRPHXqOp/nFLl/itI/hfRPof1T1P4prHuKMPVPEfqn2GBrW3/WVUPqnyL3T1H6p5D+KbR/ito/hXVPEaf+KUL/FP1Xd+y/umP/1R37r+7Yf3XH/qs79l96y+8+5lpvKbJNxWk4i95vIBdzDne2cMOxx3uXdfnNx5fRZBRNQdHIzjRr79TU5Tf6XkWz/D7fy2jCvjTO862aI4wnwXgyjKfAeATGozCeCuMxFk+ZYDwwfS4wfS4wfS4wfS4wfS4wfS4wfS4wfS4wfZa99Xn9/acqu+vz6vs9VSKMJ8N4BMazvL50ukVlTdNu1+3Lb8+9jCagaCKKJu1Ms3oXYfktvpfRKIqm7kvj7aBqLJ46wXgCjCfCeBKMJ8N4CoxHYDwK44Hpc4Xps8H02WD6bDB9Npg+G0yfDabPBtNn21ufnTsstrs+r1+xm6F4bAownsTh+e3yp//+/pfP3//pxx/+fon58pf/+OnPv37++aevf/z1f/52+5s//fL5xx8///WPf/vl5z//8Jd//PLDH3/8+c9f/u7T9OU/X2Q+Wq7fRdN0qVSufw7l8uecL3++voR6KV8u/yOEL/8jzBHXT+iF5cLzvw==",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
