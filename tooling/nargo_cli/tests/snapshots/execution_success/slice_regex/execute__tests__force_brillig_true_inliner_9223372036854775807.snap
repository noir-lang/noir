---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
