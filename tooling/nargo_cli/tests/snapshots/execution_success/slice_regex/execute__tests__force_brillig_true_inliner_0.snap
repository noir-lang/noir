---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
