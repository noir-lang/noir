---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "points",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "struct",
            "path": "Point",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": [
    "func 0",
    "current witness index : _5",
    "private parameters indices : [_0, _1, _2, _3, _4, _5]",
    "public parameters indices : []",
    "return value indices : []",
    "BRILLIG CALL func 0: inputs: [[EXPR [ (1, _0) 0 ], EXPR [ (1, _1) 0 ], EXPR [ (1, _2) 0 ], EXPR [ (1, _3) 0 ], EXPR [ (1, _4) 0 ], EXPR [ (1, _5) 0 ]]], outputs: []",
    "unconstrained func 0",
    "[Const { destination: Direct(2), bit_size: Integer(U32), value: 1 }, Const { destination: Direct(1), bit_size: Integer(U32), value: 32845 }, Const { destination: Direct(0), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(2), bit_size: Integer(U32), value: 6 }, Const { destination: Relative(3), bit_size: Integer(U32), value: 0 }, CalldataCopy { destination_address: Direct(32839), size_address: Relative(2), offset_address: Relative(3) }, Const { destination: Relative(1), bit_size: Integer(U32), value: 32839 }, Const { destination: Relative(3), bit_size: Integer(U32), value: 6 }, Mov { destination: Relative(2), source: Direct(1) }, Const { destination: Relative(4), bit_size: Integer(U32), value: 7 }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(4) }, IndirectConst { destination_pointer: Relative(2), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(4), op: Add, bit_size: U32, lhs: Relative(2), rhs: Direct(2) }, Mov { destination: Direct(32771), source: Relative(1) }, Mov { destination: Direct(32772), source: Relative(4) }, Mov { destination: Direct(32773), source: Relative(3) }, Call { location: 23 }, Mov { destination: Relative(1), source: Relative(2) }, Call { location: 34 }, Call { location: 39 }, Const { destination: Relative(1), bit_size: Integer(U32), value: 32845 }, Const { destination: Relative(2), bit_size: Integer(U32), value: 0 }, Stop { return_data: HeapVector { pointer: Relative(1), size: Relative(2) } }, BinaryIntOp { destination: Direct(32775), op: Add, bit_size: U32, lhs: Direct(32771), rhs: Direct(32773) }, Mov { destination: Direct(32776), source: Direct(32771) }, Mov { destination: Direct(32777), source: Direct(32772) }, BinaryIntOp { destination: Direct(32778), op: Equals, bit_size: U32, lhs: Direct(32776), rhs: Direct(32775) }, JumpIf { condition: Direct(32778), location: 33 }, Load { destination: Direct(32774), source_pointer: Direct(32776) }, Store { destination_pointer: Direct(32777), source: Direct(32774) }, BinaryIntOp { destination: Direct(32776), op: Add, bit_size: U32, lhs: Direct(32776), rhs: Direct(2) }, BinaryIntOp { destination: Direct(32777), op: Add, bit_size: U32, lhs: Direct(32777), rhs: Direct(2) }, Jump { location: 26 }, Return, Const { destination: Direct(32835), bit_size: Integer(U32), value: 0 }, Const { destination: Direct(32836), bit_size: Field, value: 0 }, Const { destination: Direct(32837), bit_size: Integer(U1), value: 1 }, Const { destination: Direct(32838), bit_size: Integer(U32), value: 1 }, Return, Call { location: 175 }, Const { destination: Relative(4), bit_size: Integer(U32), value: 0 }, Const { destination: Relative(6), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(5), op: Add, bit_size: U32, lhs: Relative(4), rhs: Relative(6) }, Mov { destination: Relative(3), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(5) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(5), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, Store { destination_pointer: Relative(5), source: Relative(4) }, BinaryIntOp { destination: Relative(5), op: Add, bit_size: U32, lhs: Relative(5), rhs: Direct(2) }, Store { destination_pointer: Relative(5), source: Relative(4) }, Const { destination: Relative(5), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(4), op: Add, bit_size: U32, lhs: Relative(3), rhs: Relative(5) }, Mov { destination: Relative(4), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(2) }, Store { destination_pointer: Relative(4), source: Direct(32835) }, Mov { destination: Relative(5), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(2) }, Store { destination_pointer: Relative(5), source: Relative(3) }, Const { destination: Relative(3), bit_size: Integer(U32), value: 3 }, Const { destination: Relative(6), bit_size: Integer(U32), value: 2 }, Mov { destination: Relative(2), source: Direct(32835) }, Jump { location: 62 }, BinaryIntOp { destination: Relative(7), op: LessThan, bit_size: U32, lhs: Relative(2), rhs: Relative(3) }, JumpIf { condition: Relative(7), location: 125 }, Jump { location: 65 }, Load { destination: Relative(1), source_pointer: Relative(4) }, Const { destination: Relative(2), bit_size: Integer(U32), value: 5 }, BinaryIntOp { destination: Relative(3), op: LessThan, bit_size: U32, lhs: Relative(2), rhs: Relative(1) }, JumpIf { condition: Relative(3), location: 70 }, Jump { location: 109 }, Load { destination: Relative(2), source_pointer: Relative(5) }, Load { destination: Relative(3), source_pointer: Relative(2) }, Const { destination: Relative(7), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(8), op: Equals, bit_size: U32, lhs: Relative(7), rhs: Relative(3) }, Not { destination: Relative(8), source: Relative(8), bit_size: U1 }, JumpIf { condition: Relative(8), location: 77 }, Call { location: 181 }, BinaryIntOp { destination: Relative(3), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, Store { destination_pointer: Relative(2), source: Relative(3) }, Const { destination: Relative(8), bit_size: Integer(U32), value: 2 }, Const { destination: Relative(10), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(8), rhs: Relative(10) }, Mov { destination: Relative(3), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(9) }, IndirectConst { destination_pointer: Relative(3), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(2) }, Store { destination_pointer: Relative(9), source: Relative(8) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Store { destination_pointer: Relative(9), source: Relative(8) }, Const { destination: Relative(9), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(8), op: Add, bit_size: U32, lhs: Relative(3), rhs: Relative(9) }, Mov { destination: Relative(9), source: Relative(8) }, Store { destination_pointer: Relative(9), source: Direct(32836) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Store { destination_pointer: Relative(9), source: Direct(32836) }, Const { destination: Relative(10), bit_size: Integer(U32), value: 11 }, Mov { destination: Relative(11), source: Direct(0) }, Mov { destination: Relative(12), source: Relative(1) }, Mov { destination: Relative(13), source: Relative(2) }, Mov { destination: Relative(14), source: Relative(6) }, Mov { destination: Relative(15), source: Relative(3) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(10) }, Call { location: 184 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(8), source: Relative(12) }, Mov { destination: Relative(9), source: Relative(13) }, Store { destination_pointer: Relative(4), source: Relative(8) }, Store { destination_pointer: Relative(5), source: Relative(9) }, Jump { location: 109 }, Load { destination: Relative(1), source_pointer: Relative(4) }, Load { destination: Relative(2), source_pointer: Relative(5) }, Const { destination: Relative(4), bit_size: Integer(U32), value: 5 }, Mov { destination: Relative(5), source: Direct(0) }, Mov { destination: Relative(6), source: Relative(1) }, Mov { destination: Relative(7), source: Relative(2) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(4) }, Call { location: 230 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(3), source: Relative(6) }, Const { destination: Relative(1), bit_size: Field, value: 21 }, BinaryFieldOp { destination: Relative(2), op: Equals, lhs: Relative(3), rhs: Relative(1) }, JumpIf { condition: Relative(2), location: 124 }, Const { destination: Relative(4), bit_size: Integer(U32), value: 0 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Relative(4) } }, Return, BinaryIntOp { destination: Relative(7), op: Mul, bit_size: U32, lhs: Relative(2), rhs: Relative(6) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(1), rhs: Direct(2) }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(9), rhs: Relative(7) }, Load { destination: Relative(8), source_pointer: Relative(10) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(32838) }, BinaryIntOp { destination: Relative(10), op: Add, bit_size: U32, lhs: Relative(1), rhs: Direct(2) }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(10), rhs: Relative(9) }, Load { destination: Relative(7), source_pointer: Relative(11) }, Load { destination: Relative(9), source_pointer: Relative(4) }, Load { destination: Relative(10), source_pointer: Relative(5) }, Load { destination: Relative(11), source_pointer: Relative(10) }, Const { destination: Relative(12), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(13), op: Equals, bit_size: U32, lhs: Relative(12), rhs: Relative(11) }, Not { destination: Relative(13), source: Relative(13), bit_size: U1 }, JumpIf { condition: Relative(13), location: 141 }, Call { location: 181 }, BinaryIntOp { destination: Relative(11), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, Store { destination_pointer: Relative(10), source: Relative(11) }, Const { destination: Relative(13), bit_size: Integer(U32), value: 2 }, Const { destination: Relative(15), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(13), rhs: Relative(15) }, Mov { destination: Relative(11), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Relative(14) }, IndirectConst { destination_pointer: Relative(11), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(11), rhs: Direct(2) }, Store { destination_pointer: Relative(14), source: Relative(13) }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Store { destination_pointer: Relative(14), source: Relative(13) }, Const { destination: Relative(14), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(13), op: Add, bit_size: U32, lhs: Relative(11), rhs: Relative(14) }, Mov { destination: Relative(14), source: Relative(13) }, Store { destination_pointer: Relative(14), source: Relative(8) }, BinaryIntOp { destination: Relative(14), op: Add, bit_size: U32, lhs: Relative(14), rhs: Direct(2) }, Store { destination_pointer: Relative(14), source: Relative(7) }, Const { destination: Relative(13), bit_size: Integer(U32), value: 14 }, Mov { destination: Relative(14), source: Direct(0) }, Mov { destination: Relative(15), source: Relative(9) }, Mov { destination: Relative(16), source: Relative(10) }, Mov { destination: Relative(17), source: Relative(6) }, Mov { destination: Relative(18), source: Relative(11) }, BinaryIntOp { destination: Direct(0), op: Add, bit_size: U32, lhs: Direct(0), rhs: Relative(13) }, Call { location: 184 }, Mov { destination: Direct(0), source: Relative(0) }, Mov { destination: Relative(7), source: Relative(15) }, Mov { destination: Relative(8), source: Relative(16) }, Store { destination_pointer: Relative(4), source: Relative(7) }, Store { destination_pointer: Relative(5), source: Relative(8) }, BinaryIntOp { destination: Relative(7), op: Add, bit_size: U32, lhs: Relative(2), rhs: Direct(32838) }, Mov { destination: Relative(2), source: Relative(7) }, Jump { location: 62 }, Const { destination: Direct(32772), bit_size: Integer(U32), value: 30720 }, BinaryIntOp { destination: Direct(32771), op: LessThan, bit_size: U32, lhs: Direct(0), rhs: Direct(32772) }, JumpIf { condition: Direct(32771), location: 180 }, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 17843811134343075018 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 12049594436772143978 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return, Call { location: 175 }, Mov { destination: Relative(6), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(2) }, Store { destination_pointer: Relative(6), source: Relative(1) }, Mov { destination: Relative(1), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(2) }, Store { destination_pointer: Relative(1), source: Relative(2) }, Mov { destination: Relative(5), source: Direct(32835) }, Jump { location: 193 }, BinaryIntOp { destination: Relative(2), op: LessThan, bit_size: U32, lhs: Relative(5), rhs: Relative(3) }, JumpIf { condition: Relative(2), location: 201 }, Jump { location: 196 }, Load { destination: Relative(2), source_pointer: Relative(6) }, Load { destination: Relative(3), source_pointer: Relative(1) }, Mov { destination: Relative(1), source: Relative(2) }, Mov { destination: Relative(2), source: Relative(3) }, Return, JumpIf { condition: Relative(2), location: 203 }, Call { location: 253 }, Const { destination: Relative(8), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(7), op: Add, bit_size: U32, lhs: Relative(4), rhs: Relative(8) }, BinaryIntOp { destination: Relative(8), op: Add, bit_size: U32, lhs: Relative(7), rhs: Relative(5) }, Load { destination: Relative(2), source_pointer: Relative(8) }, Load { destination: Relative(7), source_pointer: Relative(6) }, Load { destination: Relative(8), source_pointer: Relative(1) }, Load { destination: Relative(9), source_pointer: Relative(8) }, Const { destination: Relative(10), bit_size: Integer(U32), value: 0 }, BinaryIntOp { destination: Relative(11), op: Equals, bit_size: U32, lhs: Relative(10), rhs: Relative(9) }, Not { destination: Relative(11), source: Relative(11), bit_size: U1 }, JumpIf { condition: Relative(11), location: 215 }, Call { location: 181 }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(9), rhs: Direct(2) }, Store { destination_pointer: Relative(8), source: Relative(9) }, BinaryIntOp { destination: Relative(9), op: Add, bit_size: U32, lhs: Relative(7), rhs: Direct(2) }, Mov { destination: Direct(32771), source: Relative(7) }, Mov { destination: Direct(32772), source: Relative(8) }, Const { destination: Direct(32773), bit_size: Integer(U32), value: 1 }, Call { location: 256 }, Mov { destination: Relative(11), source: Direct(32774) }, Mov { destination: Relative(12), source: Direct(32775) }, Store { destination_pointer: Relative(12), source: Relative(2) }, Store { destination_pointer: Relative(6), source: Relative(9) }, Store { destination_pointer: Relative(1), source: Relative(11) }, BinaryIntOp { destination: Relative(2), op: Add, bit_size: U32, lhs: Relative(5), rhs: Direct(32838) }, Mov { destination: Relative(5), source: Relative(2) }, Jump { location: 193 }, Call { location: 175 }, Mov { destination: Relative(4), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(2) }, Store { destination_pointer: Relative(4), source: Direct(32836) }, Mov { destination: Relative(3), source: Direct(32835) }, Jump { location: 236 }, BinaryIntOp { destination: Relative(5), op: LessThan, bit_size: U32, lhs: Relative(3), rhs: Relative(1) }, JumpIf { condition: Relative(5), location: 241 }, Jump { location: 239 }, Load { destination: Relative(1), source_pointer: Relative(4) }, Return, JumpIf { condition: Relative(5), location: 243 }, Call { location: 253 }, Const { destination: Relative(7), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Relative(6), op: Add, bit_size: U32, lhs: Relative(2), rhs: Relative(7) }, BinaryIntOp { destination: Relative(7), op: Add, bit_size: U32, lhs: Relative(6), rhs: Relative(3) }, Load { destination: Relative(5), source_pointer: Relative(7) }, Load { destination: Relative(6), source_pointer: Relative(4) }, BinaryFieldOp { destination: Relative(7), op: Add, lhs: Relative(6), rhs: Relative(5) }, Store { destination_pointer: Relative(4), source: Relative(7) }, BinaryIntOp { destination: Relative(5), op: Add, bit_size: U32, lhs: Relative(3), rhs: Direct(32838) }, Mov { destination: Relative(3), source: Relative(5) }, Jump { location: 236 }, IndirectConst { destination_pointer: Direct(1), bit_size: Integer(U64), value: 14225679739041873922 }, Trap { revert_data: HeapVector { pointer: Direct(1), size: Direct(2) } }, Return, Load { destination: Direct(32776), source_pointer: Direct(32772) }, BinaryIntOp { destination: Direct(32780), op: Add, bit_size: U32, lhs: Direct(32772), rhs: Direct(2) }, BinaryIntOp { destination: Direct(32777), op: Mul, bit_size: U32, lhs: Direct(32771), rhs: Direct(32773) }, BinaryIntOp { destination: Direct(32780), op: Add, bit_size: U32, lhs: Direct(32780), rhs: Direct(2) }, Load { destination: Direct(32778), source_pointer: Direct(32780) }, BinaryIntOp { destination: Direct(32779), op: Add, bit_size: U32, lhs: Direct(32780), rhs: Direct(2) }, BinaryIntOp { destination: Direct(32780), op: Add, bit_size: U32, lhs: Direct(32777), rhs: Direct(32773) }, BinaryIntOp { destination: Direct(32781), op: LessThanEquals, bit_size: U32, lhs: Direct(32780), rhs: Direct(32778) }, BinaryIntOp { destination: Direct(32782), op: Equals, bit_size: U32, lhs: Direct(32776), rhs: Direct(2) }, JumpIf { condition: Direct(32781), location: 267 }, Jump { location: 284 }, JumpIf { condition: Direct(32782), location: 269 }, Jump { location: 273 }, Mov { destination: Direct(32774), source: Direct(32772) }, BinaryIntOp { destination: Direct(32783), op: Add, bit_size: U32, lhs: Direct(32774), rhs: Direct(2) }, Store { destination_pointer: Direct(32783), source: Direct(32780) }, Jump { location: 283 }, Const { destination: Direct(32784), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Direct(32783), op: Add, bit_size: U32, lhs: Direct(32778), rhs: Direct(32784) }, Mov { destination: Direct(32774), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(32783) }, IndirectConst { destination_pointer: Direct(32774), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Direct(32783), op: Add, bit_size: U32, lhs: Direct(32774), rhs: Direct(2) }, Store { destination_pointer: Direct(32783), source: Direct(32780) }, BinaryIntOp { destination: Direct(32783), op: Add, bit_size: U32, lhs: Direct(32783), rhs: Direct(2) }, Store { destination_pointer: Direct(32783), source: Direct(32778) }, Jump { location: 283 }, Jump { location: 296 }, Const { destination: Direct(32784), bit_size: Integer(U32), value: 2 }, BinaryIntOp { destination: Direct(32783), op: Mul, bit_size: U32, lhs: Direct(32780), rhs: Direct(32784) }, Const { destination: Direct(32785), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Direct(32784), op: Add, bit_size: U32, lhs: Direct(32783), rhs: Direct(32785) }, Mov { destination: Direct(32774), source: Direct(1) }, BinaryIntOp { destination: Direct(1), op: Add, bit_size: U32, lhs: Direct(1), rhs: Direct(32784) }, IndirectConst { destination_pointer: Direct(32774), bit_size: Integer(U32), value: 1 }, BinaryIntOp { destination: Direct(32784), op: Add, bit_size: U32, lhs: Direct(32774), rhs: Direct(2) }, Store { destination_pointer: Direct(32784), source: Direct(32780) }, BinaryIntOp { destination: Direct(32784), op: Add, bit_size: U32, lhs: Direct(32784), rhs: Direct(2) }, Store { destination_pointer: Direct(32784), source: Direct(32783) }, Jump { location: 296 }, Const { destination: Direct(32782), bit_size: Integer(U32), value: 3 }, BinaryIntOp { destination: Direct(32781), op: Add, bit_size: U32, lhs: Direct(32774), rhs: Direct(32782) }, BinaryIntOp { destination: Direct(32782), op: Equals, bit_size: U32, lhs: Direct(32772), rhs: Direct(32774) }, JumpIf { condition: Direct(32782), location: 310 }, BinaryIntOp { destination: Direct(32784), op: Add, bit_size: U32, lhs: Direct(32779), rhs: Direct(32777) }, Mov { destination: Direct(32785), source: Direct(32779) }, Mov { destination: Direct(32786), source: Direct(32781) }, BinaryIntOp { destination: Direct(32787), op: Equals, bit_size: U32, lhs: Direct(32785), rhs: Direct(32784) }, JumpIf { condition: Direct(32787), location: 310 }, Load { destination: Direct(32783), source_pointer: Direct(32785) }, Store { destination_pointer: Direct(32786), source: Direct(32783) }, BinaryIntOp { destination: Direct(32785), op: Add, bit_size: U32, lhs: Direct(32785), rhs: Direct(2) }, BinaryIntOp { destination: Direct(32786), op: Add, bit_size: U32, lhs: Direct(32786), rhs: Direct(2) }, Jump { location: 303 }, BinaryIntOp { destination: Direct(32775), op: Add, bit_size: U32, lhs: Direct(32781), rhs: Direct(32777) }, Return]"
  ],
  "debug_symbols": "pZbdauMwEIXfxde+0Ega/eRVllDc1C0G4wQ3WVhK3n01njNpe7FQvDf5jmOfj1ieCH90L+Pz7e1pWl7P793h10f3vE7zPL09zefTcJ3OS/v2o3PykXx3oL5L3B18Q+oOoSFvyO2K2EAKrwiKqGBFUmRFUdTuwH1XnIIUXhEUUcGKpMiKolBLVUtVS1VLVUtVS22W1JAUWVEUdQM5BxLowQBGkMEEZhAegoeaJws9GMAIMpjADBaw+UqjdyCBHgwgb4+JfAIzWMCqDA4k0IMBjCB8Ab4AX4AvwBfhi/BF+GLzVWEEGUxgBgtYlexAAj0IH8PH8DF8DB/Dx3WbV0oOJNCDAYwggwnMYAHhy/Bl+DJ8MqHkJCQL2UKxUBFkVjXIqstyyUySeGQqJXgZQDnlZQI1BAvRAltIFrKFYqEiyERqMDOZmcxMZiYzk5nJfphMpoaKILOpgSx4C8FCtMAWkgUzbzMZJHgLwYJcHCVgDf02cPLNNnFbCBaiBbZgdRk7DcU8JuTtodzvfWeb4NN1HUfZA7/sim2vvAzruFy7w3Kb5777Pcy37aL3y7BsvA5rO9uU4/LS2ISv0zxKuvefbffvaoge5RDLo84/7+eKfnRhR599QJ/Z7enXZP2ad/QTR/RTSXv63u4/8Z77L47RLz7/Xz/Qjn50dv8x7Fl/7wv67e+yo982S1vAtl/GhyGmnxtiehiS22Motoa0awb84xm0/e5b/9iOhtO0fnvXuYtpnYbnecTh6205fTl7/XOxM/audFnPp/Hlto5i+nxharvQr/YHCuHYd1Eypz4QHeXloB1S5p6Kk0OSw0LtMBzv8sP+Ag==",
  "file_map": {
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds, array has size 2, but index was 2\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed constraint\")]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "struct Point {\n    x: Field,\n    y: Field,\n}\n\nimpl Point {\n    fn serialize(self) -> [Field; 2] {\n        [self.x, self.y]\n    }\n}\n\nfn sum(values: [Field]) -> Field {\n    let mut sum = 0;\n    for value in values {\n        sum = sum + value;\n    }\n    sum\n}\n\nfn main(points: [Point; 3]) {\n    let mut serialized_points = &[];\n    for point in points {\n        serialized_points = serialized_points.append(point.serialize().as_slice());\n    }\n    // Do a compile-time check that needs the previous loop to be unrolled\n    if serialized_points.len() > 5 {\n        let empty_point = Point { x: 0, y: 0 };\n        serialized_points = serialized_points.append(empty_point.serialize().as_slice());\n    }\n    // Do a sum that needs both the previous loop and the previous if to have been simplified\n    assert_eq(sum(serialized_points), 21);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
