---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "points",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "struct",
            "path": "Point",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "ndrfTioxEMfxd9lrLvpn2k59lRNjUNGQEDSIJzkxvvvpGkBDK+Q7N4QSPmF3foXdKf2YHlf378936+3Ty9t08+dj2rw8LPfrl20bfXwupvvderNZP9/9fHly80PSr/e/vS638/Btv9ztp5soYTGtto/zM23+ab1ZTTfJfd4uplSpyA4Lj0XAImIhWCQqCq5VGZ5HCvEgkrhzIVgkLDIWBQvFolKhDguPRcDiWuapE4LFMI8c6kFkyedCsahUVIeFxyJgEbEQLBIWGYtx5kmOQjuhWFQqvHOceE4CJ5ET4SRxkjkpnCgnPH3P0/c8fc/T99e+9Sl2RDhJnGROCifKScUkOE48J4ETnn7g6QeefhhGqe5INHQzOSgndUzSiZRzEh0nnpPASeREOEmcZE7KFRJ9R5STiok4TjwnuKvzIpwkTjInhRPlBPfzPjlOxh19Of7CxNr9wqTASeREOEmcZE4KJ8pJxeSX5ZyLZJi+uOPNlUTXkcBJ5EQ4SZxkTgonyknFZLxAdZnw9AtPv/D0C0+/8PQLT79c+e6L6+76inJSMVHHieckcBI5EU4SJ5kTnr7y9JWnX3H6YbxC0praA2ktYUeEk8RJ5qRwopwMc2mX0GOV26VRTqgt4c1ovEZyDXkLChYULUgsKFlQtiBLTuGX6mk+oeo6FC2oWA5PLchSiGiZsNEyYaNlwsZfSi7fJU9dyaNYULKgbEHFgtSCqgGJsyBvQcGCrs+I3COxoGRB2YKKBakFVQNKzoK8BQULGpdcT9f27h+DMO7pLxPlZFjscFo2axf+czLu6S8Tz0ngJHIinCROMic8l3Ef3Cb5kSTpCD/9wk+/8NMfN7WXiXLCizxuatvN0JHEnvhrpLuvHze1l0lk5LON/i536+X9ZnXY+fX0vn34sRFs/+91dbYn7HX38rB6fN+t5t1h3xvD5o8OcRFjO5B5RgWtiyhyO/+H24a+xoWvOg/917AugvPtCNpR/Ac=",
  "file_map": {
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "struct Point {\n    x: Field,\n    y: Field,\n}\n\nimpl Point {\n    fn serialize(self) -> [Field; 2] {\n        [self.x, self.y]\n    }\n}\n\nfn sum(values: [Field]) -> Field {\n    let mut sum = 0;\n    for value in values {\n        sum = sum + value;\n    }\n    sum\n}\n\nfn main(points: [Point; 3]) {\n    let mut serialized_points = &[];\n    for point in points {\n        serialized_points = serialized_points.append(point.serialize().as_slice());\n    }\n    // Do a compile-time check that needs the previous loop to be unrolled\n    if serialized_points.len() > 5 {\n        let empty_point = Point { x: 0, y: 0 };\n        serialized_points = serialized_points.append(empty_point.serialize().as_slice());\n    }\n    // Do a sum that needs both the previous loop and the previous if to have been simplified\n    assert_eq(sum(serialized_points), 21);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
