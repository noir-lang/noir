---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_invert",
    "directive_integer_quotient",
    "directive_to_radix"
  ]
}
