---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
