---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
