---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_invert",
    "directive_integer_quotient",
    "directive_to_radix"
  ]
}
