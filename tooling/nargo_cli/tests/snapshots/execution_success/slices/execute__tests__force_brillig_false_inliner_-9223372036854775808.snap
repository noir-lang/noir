---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "50": {
      "source": "use std::slice;\n\nfn main(x: Field, y: pub Field) {\n    let mut slice = &[0; 2];\n    assert(slice[0] == 0);\n    assert(slice[0] != 1);\n    slice[0] = x;\n    assert(slice[0] == x);\n\n    let slice_plus_10 = slice.push_back(y);\n    assert(slice_plus_10[2] == 10);\n    assert(slice_plus_10[2] != 8);\n    assert(slice_plus_10.len() == 3);\n\n    let mut new_slice = &[];\n    for i in 0..5 {\n        new_slice = new_slice.push_back(i);\n    }\n    assert(new_slice.len() == 5);\n\n    new_slice = new_slice.push_front(20);\n    assert(new_slice[0] == 20);\n    assert(new_slice.len() == 6);\n\n    let (popped_slice, last_elem) = new_slice.pop_back();\n    assert(last_elem == 4);\n    assert(popped_slice.len() == 5);\n\n    let (first_elem, rest_of_slice) = popped_slice.pop_front();\n    assert(first_elem == 20);\n    assert(rest_of_slice.len() == 4);\n\n    new_slice = rest_of_slice.insert(2, 100);\n    assert(new_slice[2] == 100);\n    assert(new_slice[4] == 3);\n    assert(new_slice.len() == 5);\n\n    let (remove_slice, removed_elem) = new_slice.remove(3);\n    assert(removed_elem == 2);\n    assert(remove_slice[3] == 3);\n    assert(remove_slice.len() == 4);\n\n    let append = &[1, 2].append(&[3, 4, 5]);\n    assert(append.len() == 5);\n    assert(append[0] == 1);\n    assert(append[4] == 5);\n\n    let mapped = &[1, 2].map(|x| x + 1);\n    assert_eq(mapped, &[2, 3]);\n\n    assert_eq(&[1, 2, 3].fold(0, |acc, x| acc + x), 6);\n    assert_eq(&[1, 2, 3].reduce(|acc, x| acc + x), 6);\n    assert(&[2, 4, 6].all(|x| x > 0));\n    assert(&[2, 4, 6].any(|x| x > 5));\n\n    regression_2083();\n    // The parameters to this function must come from witness values (inputs to main)\n    regression_merge_slices(x, y);\n    regression_2370();\n\n    regression_4418(x);\n    regression_slice_call_result(x, y);\n    regression_4506();\n}\n\n// Ensure that slices of struct/tuple values work.\nfn regression_2083() {\n    let y = &[(1, 2)];\n    let y = y.push_back((3, 4)); // [(1, 2), (3, 4)]\n    let y = y.push_back((5, 6)); // [(1, 2), (3, 4), (5, 6)]\n    assert(y[2].1 == 6);\n\n    let y = y.push_front((10, 11)); // [(10, 11), (1, 2), (3, 4), (5, 6)]\n    let y = y.push_front((12, 13)); // [(12, 13), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[1].0 == 10);\n\n    let y = y.insert(1, (55, 56)); // [(12, 13), (55, 56), (10, 11), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].1 == 13);\n    assert(y[1].1 == 56);\n    assert(y[2].0 == 10);\n\n    let (y, x) = y.remove(2); // [(12, 13), (55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[2].0 == 1);\n    assert(x.0 == 10);\n    assert(x.1 == 11);\n\n    let (x, y) = y.pop_front(); // [(55, 56), (1, 2), (3, 4), (5, 6)]\n    assert(y[0].0 == 55);\n    assert(x.0 == 12);\n    assert(x.1 == 13);\n\n    let (y, x) = y.pop_back(); // [(55, 56), (1, 2), (3, 4)]\n    assert(y.len() == 3);\n    assert(x.0 == 5);\n    assert(x.1 == 6);\n}\n\n// The parameters to this function must come from witness values (inputs to main)\nfn regression_merge_slices(x: Field, y: Field) {\n    merge_slices_if(x, y);\n    merge_slices_else(x);\n}\n\nfn merge_slices_if(x: Field, y: Field) {\n    let slice = merge_slices_return(x, y);\n    assert(slice.len() == 3);\n    assert(slice[2] == 10);\n\n    let slice = merge_slices_mutate(x, y);\n    assert(slice.len() == 4);\n    assert(slice[3] == 5);\n\n    let slice = merge_slices_mutate_in_loop(x, y);\n    assert(slice.len() == 7);\n    assert(slice[6] == 4);\n\n    let slice = merge_slices_mutate_two_ifs(x, y);\n    assert(slice.len() == 6);\n    assert(slice[3] == 5);\n    assert(slice[4] == 15);\n    assert(slice[5] == 30);\n\n    let slice = merge_slices_mutate_between_ifs(x, y);\n    assert(slice.len() == 8);\n    assert(slice[3] == 5);\n    assert(slice[4] == 30);\n    assert(slice[5] == 15);\n    assert(slice[6] == 50);\n    assert(slice[7] == 60);\n\n    merge_slices_push_then_pop(x, y);\n\n    let slice = merge_slices_push_then_insert(x, y);\n    assert(slice.len() == 7);\n    assert(slice[1] == 50);\n    assert(slice[2] == 0);\n    assert(slice[5] == 30);\n    assert(slice[6] == 100);\n\n    let slice = merge_slices_remove_between_ifs(x, y);\n    assert(slice.len() == 5);\n}\n\nfn merge_slices_else(x: Field) {\n    let slice = merge_slices_return(x, 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice.len() == 2);\n\n    let slice = merge_slices_mutate(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n\n    let slice = merge_slices_mutate_in_loop(x, 5);\n    assert(slice[2] == 5);\n    assert(slice.len() == 3);\n}\n\n// Test returning a merged slice without a mutation\nfn merge_slices_return(x: Field, y: Field) -> [Field] {\n    let slice = &[0; 2];\n    if x != y {\n        if x != 20 {\n            slice.push_back(y)\n        } else {\n            slice\n        }\n    } else {\n        slice\n    }\n}\n\n// Test mutating a slice inside of an if statement\nfn merge_slices_mutate(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\n// Test mutating a slice inside of a loop in an if statement\nfn merge_slices_mutate_in_loop(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        for i in 0..5 {\n            slice = slice.push_back(i as Field);\n        }\n    } else {\n        slice = slice.push_back(x);\n    }\n    slice\n}\n\nfn merge_slices_mutate_two_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n    slice = slice.push_back(30);\n\n    slice\n}\n\nfn merge_slices_mutate_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n\n    slice\n}\n\nfn merge_slices_push_then_pop(x: Field, y: Field) {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 4);\n    assert(elem == 30);\n\n    let (slice, elem) = slice.pop_back();\n    assert(slice.len() == 3);\n    assert(elem == x);\n}\n\nfn merge_slices_push_then_insert(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n        slice = slice.push_back(15);\n    }\n\n    slice = slice.insert(1, 50);\n    // Test that we can use slice insert the same as slice push back\n    slice = slice.insert(6, 100);\n\n    slice\n}\n\nfn merge_slices_remove_between_ifs(x: Field, y: Field) -> [Field] {\n    let mut slice = &[0; 2];\n    if x != y {\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    let (mut slice, elem) = slice.remove(2);\n    assert(elem == y);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice\n}\n// Previously, we'd get a type error when trying to assign an array of a different size to\n// an existing array variable. Now, we infer the variable must be a slice.\nfn regression_2370() {\n    let mut slice = &[];\n    slice = &[1, 2, 3];\n}\n\nfn regression_4418(x: Field) {\n    let mut crash: [u8; 32] = x.to_be_bytes();\n\n    if x != 0 {\n        crash[0] = 10;\n    }\n}\n\nfn regression_slice_call_result(x: Field, y: Field) {\n    let mut slice = merge_slices_return(x, y);\n    if x != 0 {\n        slice = slice.push_back(5);\n        slice = slice.push_back(10);\n    } else {\n        slice = slice.push_back(5);\n    }\n    assert(slice.len() == 5);\n    assert(slice[0] == 0);\n    assert(slice[1] == 0);\n    assert(slice[2] == 10);\n    assert(slice[3] == 5);\n    assert(slice[4] == 10);\n}\n\nfn regression_4506() {\n    let slice: [Field] = &[1, 2, 3];\n    assert(slice == slice);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_invert",
    "directive_integer_quotient",
    "directive_to_radix"
  ]
}
