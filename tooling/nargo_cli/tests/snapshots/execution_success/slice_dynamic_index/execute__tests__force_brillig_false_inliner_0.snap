---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
