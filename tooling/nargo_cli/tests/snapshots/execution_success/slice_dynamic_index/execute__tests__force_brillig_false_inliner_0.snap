---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
