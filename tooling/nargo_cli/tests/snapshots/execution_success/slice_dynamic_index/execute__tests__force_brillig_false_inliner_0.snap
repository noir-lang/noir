---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+2dB3QdxdXHZ1cCG9sYY2zAmCK66W/13pNkCGBRbHoNPRhsWYLQwWDAEJtAQjE9DQIESKE4Cb0XUxxSIPnSSSWEkN4baQSSz/d512/f00rnwP6uvr2fZs7RkVU8+s/9/++dO3dmZwO3vF3Z4tyTLcv/3Rp/L3T9WxB/nhZ/LuVrEdFX3/I2KwNu3r6j5B9hhg3C5IuW+LN8o60JQIuiwcqljkqlt7O9NypHs0rtU2d3VUuV6uyOrqgrqnZV57R3lcu9XZWuzqmzp3aWpkaVcm/UV53a3hf3FeTvq9yXMpAGkc2Cy4sz4LgoaeJsMYKzFda2Fs6VOJztmjhX5nCWNXGO4HBWkhi5UvxZvm6NvxZ7jHD9W9g0nlK+RsTVFbYZ6di4mtWgcZcG0kcpX4tGGsC4igJGdaBvV1C9yyfXOUazu84MuCrZ3aj48+jEIEl2J99oawJQ5OxulOOi0GglIulZaZTT8egizzZjHBccrM42YwxgXNU5G7PNqs6nLy0GMI4lMVolqtUAxtU8UaVoJQMYx3miStHKBjCu7okqRSMMYBxPYkxWYkmdSCZAia3itqKI8fH3w9RAFAiNtIxlIYtFEyNlooZ1cWsNBYzqQIn1q0VBWchiJzgjgiKBDmW1FIgqKyqaGXBVqqUT489rJgZJ5mj5wY+bvie/1NYEiq6gAnsvKyqoE/P3taIQsqYSuc2Vybw4yTGvlTHmt9tnWkdrxdpqjb/Oivh0ZXkiPJakra0JeG03cOn67fa/tuOcdRI4Xi0bTnIDR/q32/8kx06l9LjXjMc9kHbeakv6JfleB7RhOrhIvxu6oT0FB0wOyfZaRwZclZl/cvx53cQgiQEnu3pUTr4nv9TWBIqe+dNGzDvzT3acUNeFyaWdfWTMGeXscYvIUzDrcbhKVteIpA20MK5PY6TFLkJfnxd7ZbKSEfMWRDRsaCFgbOB8wCBtoIWxjcRolSgLhw029ETZKNNu5ImycdhgY0+UjcMGm3iibBw22JTEKJOykJUcNpAJUGKruK0oYtMUeVqrFLhE0l60VUoy3q+EuvXQUr5WKwe1OX6zZTMQY9qGOVeNfaHLrntSWN0AflPK10yseDajMWot7zV3Zkv5Glqf3RzsS9lx1ES5uQGMU0iMVomyUCrYwhNlo1SwpSfKRqlgK0+UjVLB1p4oG6WCbUiMMinLR1IqkAlQYqu4rShimxR5GkvTKY5fmm4LYqSXpi2uf6OwavFkIcPeVgFjrVHijEXQSy7/tuMGXVYWpxrx2xnAWHLDUJwRLE6LOw+RAYztzoY455DiLHODrliNnGUDGCtuGIqzCovTYuSsGsDYQWPUeCpvsuO3WTrBgVsVKGkDLYxdJEarRFnYdpjqibKx7bC9J8rGtsMOnigb2w7v8ETZ2HbYkcSYviZbmkyAElvFbUURO6bI0zihKJlRCBuoC8S4E2js0NWfCE43atxagrOQYZM8NZADi7NM1id2dmbEqUY8aQMtjNPcEImTiMhUX92OjWwaYwX3g2qb6O2On81K4Jh3URIiPOYKqcNdnQ+SpA20MO5GY9Q4JdPh+DT46yE7cI00XbZ/6LP8FRDj7iAumg96QkiCI9WfTNS7uHrLy0lyykrLB3dT0Pi3lH2wlK/VONpdod/0uPPy/VYuuyrQTYizMuBSfTdcdjU9/jwjMUhysdV01/+yK/mltiZQLYpGzHvZ1XQQ1wyYXI2H22S8dGAn767Zg8NldmeYtIEWxj1pjLTYReh78mKvTFcyYlEvuyp6wNjL+YBB2kAL494kRqtEWThKso8nysZRkn09UTaOkuznibJxlGR/T5SNoyQHkBiTp1eToyQyAUpsFbcVRRyQIk9rlUJfdlW0VUoy3hcLXq8Uu0mmGsI8HwhifBGsfYYp3acbhdUN4DelfM3EiudAGqPW8r7Il12R9dmDwL6UHUdNlAcZwHiwU3acUr5WE6WApGeJdzo/Sww3sb9TAWOtUeJMCsxkJD6EG3TFaiQ+xADGQ90wFOdhsDgtFgEOM4DxcFfwNCHJr+m8/Qhw4FYFStpAC+ORTlmgRPVJQIaKA8+L8ShnRuxqeawFsZM8NZADi7NCpgrvcj4SkzbQwni0GyJxEhGZ6mumYyObxljBBUatKnO442ezQ8ExHwMLkR6r2BB0lkg0eIyrN3LsA/lgKV+rdIN8H+vYCSJ0/RttUzr4HmsA4ywSY6urn4tvbjTwMaBY03hnawKWzunZZDaIsQfEpWXDHsevB3sc66k0vu543PSsR0b8Oco2LOVrtaLUHAVuep2f6UgbaGHsIzFaJcrCOezjPFE2zmEf74mycQ773Z4oG+ewT/BE2TiHfSKJUSZlUWdymEMmQImt4raiiBNT5NErAHmhbzpzJ1YBkmmxRyujdnB10ZAJ5h3vSRyuWva/suvfqHE7JWewkP2TPDWQQxdhSWc82ZkRpxrxpA20MJ7ihkicZI0nb1+nOjayadzgM0vBhqeBGMmbr4ayeE/cgxCfgOxJ4z1dE/DpDj++2XM6iPEMUKRaNjzDcQXYxIZnODZ6agQSjU2LuU5n1tBYYlBjPpPTjcp1d6LFuQpcn+WKrXHh5SxH+3bvbO1x5+Ul4Zv2mbkgxnkF147MC/MUuDkbHLfVWhppAy2M59AYaSGJOAUk/LjwLNAxG4yYd7znOjOOo1bTsuA4JE9+R1sR43xPlI0d7fM8UTZ2tM/3RNnY0X6PJ8rGjvYCBYyZQPNmpws5oH2SPAg5ycaWTNQyB0h4EeWKURa6/o0e0wXcmKphPKbmBvWvlnFf4IrvJAudkpPQm0zzwL7eC4uH3kORV4zMAfvrjvtrZcVTnQz21Q32RW7qXqjkIHB9tUL6x0XgmJWDt1pgJG2ghfF9NEa66C+OCB4FieSExWmOz1be70w4eZV08oudd3LSBloYLyExZr0gi3Ymya4udPTOad9sYHMheSdTxfFizXzh1qXx58sSQycv17rU9X/hlvxSmzIp1Au8skjJ+wKvS8HxXgaLReOoSyIOQHwrmvRBz+LCMZhqRKLF9yvYdBFsRzqSC+eLHB4YO+cWfNxJ7IF12UFmQ5cX3IYy1ksUfOYKcNxDkVxImeBy3od6gFLGkCcXV8afr0oMnSQS8o02ZQLgRKIHeN/6ikTiSnC8VykJg+blSlfsACa6WaTQL/j64E6tcV/O91sF/GVFEq817itcvUFY29/KK55L+VrDjUylt9nio9k9GXBVJoWr48/XJAZJJgX5RlsTAPp1IcAVViuC+NWOC47XKBFJB/GrHRvEk0avCMmryq4FcWUFBXDcajW+aw1g/IDT0aYqUOJ1KRYFZeEM6QdJjFaJsnCG9EOeKBtnSD/sibJxhvQjnigbZ0ivIzHKpCyPBia3IskEKLFV3FYUcV38/TD+PSVC1c47Wshi0cRImSg1I4w0gPF6BYzqQPO++8yqoCwkRx91RgRFA9WIHt2OL37dAI7bqiORNtDCeCON0YpAb/ICjUgbaGH8mPM5nokK4M2eKBsVwFs8UTaS3Fs9UTYqgB/3RNmoAH6CxCiT8iquXgGUCVBi663LPkQRn0iRF8IDkYw4nboTBwEl04IPAvaBD4I2ZIJ5x/tJDlct+1/F9W/UuJ2SM1jI/kmeGsiBHRJ9OeWnnBlxqhFP2kAL421uGIrzdseK02KqQ9pAC+MdJMahvHz9WlCsabx3agKWzpu9Ni/4O0GMi0FcWjZc7Pgq72LHeqrGwXqNcX+64OOWqP9phXF/xvnUibSBFsbPkhitEmWhqn+XJ8pGVf9uT5SNqv49nigbVf17PVE2qvr3kRhlUh7l6lV9mQAltorbiiLuS5EXwgORin46cydWAZJp0W87BVcXDZlg3vHez+GqZf+jXP9GjdspOYOF7J/kqYEcunBKOuMDzow41YgnbaCF8UE3ROIkazx5+3rIsZGNnhnlggywol2ru93m+PrTw6B4jL7xdE4a7yOagB9x+G3dcx4BMT4KCkvLho+CTpDY8FHHRlCNW68WO51DORTGx5RtWMrXatp+TIGbxws+bvGZxxXG/QQ4bqu1BtIGWhifpDFqOJCAhG+DqoKO2WDEvONd4sw4jtqa34LjkDw1kEOv+R8HxfmU81GdtIEWxqfdEImTTI/y9vWMYyMbnU5LfQMsxkRS43jY8TPus7B4aDuKZkCBR88s6+NZBTsuhe1IBwlZ7ix1+HK5p+hLPVnyTFbg+3OOnRwtniQmbaCF8TkaIy0kEaeApAPncyDGzzszYldbplgQO8lTAzn0MoW4MjwR5xecj8SkDbQwfpHGqLFNB4KsVdSXuv4iyptyaZCjdVHNlxzrnFmN6t8pCZ+0gRbG551ymlTK12rO9DzfbwV8ecUcjXFrOeYLzjsmaQMtjF8mMVolysKzJl/xRNl41uR/PFE2njX5qifKxrMmX/NE2XjW5OskRpmUR7v6syYyAUpsFbcVRXw9RR69VE9WA0l/xKE6ybSKfIPUl8HxfgMUQhjroLlR43ZKzmAh+yd5aiCHLuiSp0e/6cyIU4140gZaGL9FY7Sy9/ttWKDOoEBJG2hhfNEVXKAizhedDukaBdhvuUIXYPskfZMXgiYpqXzdGn8tC6kRKVtbKdR+x7HBZozr36j+tWxL2kAL43ddwYONiPO7zu+g5MWaOOb3nHdM0gZaGL9PYrRKlIUdlB94omzsoPzQE2VjB+UlT5SNHZQfeaJs7KC8TGKUSXlVV1+uygQosVXcVhTxcoq8EB5IshpI+iN2UCTTKvIOyvfB8f4YFEIY66C5UeN2Ss5gIfsneVIBqLU8fcWOQNXIf8UAxp/QGOmZQuo7YHFrxcwTQoLPminyOs+rMCnUWNOzLSicGievKmjnJ+CYf+r8jPuKK35AI3lSAai1LfwzWKAW13CkDbQw/twVXKAizp87nnSraZyFwsAvFDCqA82bcmngk+g80/HR+ZeOdaSsRvWvxT1pAy2Mv3IFj84izl85HdI1nGm6453p1847E2kDLYy/cQV3JhHnb0CBJgdJprvh6Zi/dd4xSRtoYfwdidEqURYOpfzeE2XjUMofPFE2DqX80RNl41DKnzxRNmpPfyYxyqQ81tUPpcgEKLFV3FYU8ecUefR2UbIaSPrLmw1Lf5Jp0YdSwNVFQyaYd7x/AYUQxjpobtS4nZIzWMj+SZ4ayIEdsjIdFOdfnRlxqhFP2kAL42s0Ro2a0Wt8v5WZjpshRKAWnzu3sCT/G4nRKlEWluR/90TZWJL/wxNlY0n+T0+UjSX5vxQwZgLNm5W/zgGdJcnDam75VQvSZKKWOUDCiyhXjPJ6/LMw/l0l8aktLy9wxRff6zRGK888/BscuLJA1cgnbaCF8Q2nLFDifL2AhN9DOYt8mu0NcLxvOjOOoxbZLTgOyVMDOSELtEo+jPMfcNBCSEtMjPTb5pwZO/zX+dmNtIEWRukQxahxE5R0Ch+66wRnN7VDdxppZxB4xwyC4mMMtR2TSDsFJJt2RhUy7UwbMe94W+w4jlraacFxSJ5qF3JKC13/phHx8/YV7+jNcry4ouQfaVu0xkZYKYgNkuSrrfGUnf6e/FJbEyh40dpgxLfp8e2xx0etYPRYKWDJ1YjmCZkgH6ZSo5V9ahStbCDCj7CQGo3gU6NeMjUaAQa3kT41MuE4JE/OaoSzcGpoFU+UjVNDozxRNk4NjfZE2Tg1NMYTZePU0KqeKBsnbMYqZKaZQPMuI1bjgM6WLG+cq79FR/qWrEombJkLJMyIgsfGgwjj37cmQAvZ7DgLe4zjAnyPsQNcrzd4XsiOH934Xx2uBVh0ytWD4mMcb8Epx+NO2VsmndLPGnoY16DzS4tEWaiBTPBE2aiBTPRE2aiBrOmJslEDWcsTZaMGsraVGsgkDmiHVUFNMrB8WseKoCZzQHtk2bD6so+RcX/St6TpkgFKciHzloRE8bZ1UoW11Z09EVpYIq1rYQ2/Ll9YqxoprHWQhbX14MKaRadcz8DMsL4Fp1y/4IU1l2r0jLgBR1CnVUfawIAjtdGLK5+G6GDc0BNlo1K7kSfKRqV2Y0+UjUrtJp4oG5XaTT1RNiq1m3mibFRAN/dE2VhHTSExynpkvKuXgCX3l7RSMhaZDCXOiguLOqYEdSI1ihhtfGURvRYkjG1lTdQW1pxb0KJew9UPC/9fCXoLA6Vy/KyDW/4wd8iOu48svW8Jik3sl1yIIP22ucYGb0F0knbYSskOW8V2GMrbNtYE+oql1pkBN2/fmbdtbB0bYZvANd6ssXXQ/7aNbQL92zbWzC+uFbdtbB1wQt0mYMmltyC6U2SCfJSE3wmuPpG1DPIh7a04XN4x53C4qOnr9gy4VN8NDrdtbITtmp1r2wyH2y4lOpciQMuIb7GvUlNf0bagw20XcOQaFWWUAZfqu0GUpdgIUbMASxmijIyJsgSKMuJEGQkBaziM4H4t6W84ruXa6SIKDVAipQgzhB2HjMBlzoi1SEaNNT4dMiexISmackCvl6IKyUkFFLaMc4Lr30jONXzHQgAiebKaU5cdJ65B05dqbISO5lSlmpG+dBhLX6pg9Ojg0peyX+gNLsrO2AhdzQLszBBllzFRdoKi7Ap0yKVTK9IRp4Jpi9V1xNSg+Bi3L/o6QkTZGRRb7DsUfB2R2JAUzQ4K6wiSk3f4dYSJ87UkT1bXERXHiWvQlG3H2Ag7NadnO2akbDsZS9l2BKPHTlzKVvGL28FFuXNshGnNAtw5Q5TTjIlyZ1CU0wIdcunUinTEbm56aLe6jugOio9xl6KvI0SUOwfFFvuuBV9HJDYkRbOrwjqC5GQ3v44w8fgXyZPVdUTVceIaNGXbPTbC9Ob0bPeMlG26sZRtdzB6TOdStqpf3A4uyhmxEfZoFuCMDFHuYUyUM0BR7hHokEunVqQj7slND2Wr64g9g+Jj3Kvo6wgR5Yyg2GLfu+DriMSGpGj2VlhHkJzs49cRJm4nIHmyuo7ocJy4Bk3Z9o2NsF9zerZvRsq2n7GUbV8weuzHpWwdfnE7uCj3j41wQLMA988Q5QHGRLk/KMoDAh1y6dSKdMQDuemhYnUdcWBQfIwHFX0dIaLcPyi22A8u+DoisSEpmoMV1hEkJ+/06wgTl2eRPFldR5AP+Q+ash0SG+HQ5vTskIyU7VBjKdshYPQ4lEvZOv3idnBRHhYb4fBmAR6WIcrDjYnyMFCUhwc65NKpFemIR3DTQ9XqOuKIoPgYjyz6OkJEeVhQbLEfVfB1RGJDUjRHKawjSE7e5dcRJu52JXmyuo7ocpy4Bk3Zjo6NMLM5PTs6I2WbaSxlOxqMHjO5lK3LL24HF+UxsRGObRbgMRmiPNaYKI8BRXlsoEMunVqRjjiLmx46rK4jZgXFxzi76OsIEeUxQbHF3lPwdURiQ1I0PQrrCJKTOX4dYeLVA3MUMLosJyrla+3djhNnrx1xqhHfa0CcfUWfHUWUfQG3HklmjG6n45WwU6IvZT3OO2V0nAGnPN6CUx7POyX+UlZ63PTrH9I3rFN9vRsUT7q+If22ObOvPSArmSvwJf9I2+KE2AgnNheITsgoGp0YGzXdivzagxPA9cuJAUsuXbHsTpEJ8mF25rRwN+5J5MxplSgLl4+d7ImycbvDKZ4oG4/PneqJsnE++TRPlI0DIKd7omxU2M9QwFhrIQwUWIqtWJ7MBZdiVsU514A4zyQxyhpsoqu/Mk/WO5JKS5YmCYDMLRK2zgjqAvZLGB2MZ5HEDuVRrBxe0++4lOPENehRrHmxEc5urqDNy6iqnZ0aYNLoo1g5wm+/o1jzwFB+NkwuXeqWiDUvYL1wXsBP1SeBnJwD77tNdP0bNe6kv+FYPSR58kUpRYzn+ql36N7gOj82wnnN0+z8jKn3PGNT73wwzJ8Hk0tPvbJQmB+wXjhfYeo9GeTkfD/1mlhMne+nXhvbDO/xU+/QvehxQWyEhc3T7IKMqXehsal3ARjmF8Lk0lOv1OcWBKwXLlCYek8BObnAT70mFlMX+KnXxsbxe/3UO3TvRrswNsJFzdPshRlT70XGpt4LwTB/EUwuPfXKttiFAeuFFypMvaeCnLzPT70mFlPv81OvjaNA7/dT79C9Tuji2AiXNE+zF2dMvZcYm3ovBsP8JTC59NQrp1EuDlgvvFhh6j0N5ORSP/WaWExd6qdeG4c7L/NT79C9gWNRbITLm6fZRRlT7+XGpt5FYJi/HCaXnnrlEOiigPXCRQpT7+kgJ1f4qdfEYuoKhVnHZTlRKV+rdjtOnFfaEaca8VcaSDeuojHSAEWUZwY6j7uTA6edcbJbfvcG1F/tYp1unp+OyQAny+9D6ZutpZ+rArrfqMKNu7esMe6Ry/qY6Xi/uRoO7FmN6j/pj7bt1QYC+zX0gt8iURZO4V/ribJxZvMDnigbJ3w+6ImysR/8IU+Ujd2DD5NEyaQsNwOsFHcoE6DEVnFbUcSHgzp5dPYqGbFkRvClc+0zQWNfA9YIPwJn62u6/o0at5Z4LWTrH6EjoSJRwzpbv84TVYpmGsB4vZGqe8PUkTfcf9ROuFcj/qMGwv0NRsRZJsV5oxdndKMBcd5kRJwVUpwf8+KMPmZAnDfT+ddYZ48oC4nyLZ4oG2XtWz1RNsraH/dE2Shrf8ITZaOs/Um6rL3Wso+V4w5lApTYKm4ripA/9nr8szD+XSVSh/Vxy9cd7H2KRA3rDPFTgScqmm4A421FPyMqhYDrFU7rp8nJW2C4XamqQpejyTHfARdVLDr4HUHxMd5pwcFvCIot9sU2HLxMjvnT3sGjTxtw8M9YcPCbgmKL/bM2HLxCjvku7+DRXQYc/G4LDn5zUGyx32PDwavkmO/1Dh7da8DB76MxaogSPBdWnemyn18r5WsdhPNoPq8o+O5LOuWwdra6+o0WzU3j2UMGd++cNN77A0XA9wfctRQJ+Ps5r40eAI+Fa9lQMFJH9hMbPmBjVu4k+XkQHLPwkVxhI/226Yy/FrjAkn4tY7wO1FNi24dgPWnY8TbYjrcr2PFhA3a8E7bjYgU7PmLAjp+B7fhZBTs+asCOd8N2vEfBjo+BdhzKpJOcf9N4Hw8UAT8e8HehPQ6K7ImCJ51iwycUnOAJE0lnVCFFvwQcsyScay/7GBn3J0mXJAwy2Umgfiw+DCV/c6Hr3+jgS9rpKc5OHWFsp+ZGjTvpj/a7pxT8g8a40IEYlYka1lfePq0UbFVTjFLOJn3QUU5mrSUBOws+HegSnrOu2fBuOvhWB6SOmdhyDNjXM0ZTdBJ3Gu+zgSLgZxUcYGnB02oZ99KMTYhSzpaFNe/4xUmX8jvLqPN/Dt5lzWokRxqa+pyBTOQ5EqNVoiw8O/B5T5SNp0u/4Imy8XTpFz1RNp4u/ZInysbTpc+TRMmkPMnVL02UCVBiq7itKOL5VLausVp5Dj8d09NHroJewIxdbg9jWys5hVpR1kKG/QIdvRSJGtYZ9pc9UTYy7K94omxk2P/jibKRYX/VE2Ujw/4anWGv4+r3t8gEKLFV3FYUIX9sTPyzMP5dJVKH9f0tYxzsfYpEDesM8euBJ8pEhvgNT5SNDPGbnigbGeK3PFE2MsRve6JsZH0v0qm8vJ9zRNyhZCoyCUp8FdcVVcgfTE4nh/HvKxGrls5bONw50sEeqEjUsE7nv6MgploLm4Dm3eoht42+yw06sirO7xqIIt8rujjj48jonub3uUG3WxXn9w2I8wdGxNlLivOH3KDLVsX5QwPifMmIOOeQ4vwRN+iKVXH+yIA4XzYizh5SnD/mBl21Ks4fGxDnK0bEOZsU50+4QXdYFedPDIjzVRqjRt1HhBlAYk8E+lP/KFX0UwMC/dlwFejPvUCjnxsQ6C/8cxQ2CtO/9ETZOGfyK0+UjXMmv/ZE2Thn8htPlI1zJr+ljy+s6+rP+skEKLFV3FYU8dugTl4ID0Qy4p+B9QTpTzKt5qt5yH22Ur7WkAnmHe/v4Ox/Xde/UePWcgYL2f/v6MiqSNSwzv5/74mykf3/wRNlI/v/oyfKRvb/J0+Ujez/z3T2v56rP4coE6DEVnFbUcSfmw4ur+fUSB3WzyHiB5cViRrWGeJfAk9UtNTAmuuvChhrLWwCWqQT5q8FbDgOFMb6vYC/O5ks0HwP5ONvSiKEC3HtpAb/DhelLAbIvxsIkP/QPjNBBIsf8MGinQwWPwAd5582gkWZDBb/8sEi+peBYPG6hWDxEh8symSweAl0nH/bCBYVMli84YNF9IaBYPGmhWDxMh8sKmSweBl0nP/YCBZVMlj81weL6L8GgoWICMUIA6wtF7Je+VKk52MD0IhD+Y4mEncabxgqApbO8dJ3yIlBa9wtYd3AUL+ZL6YjZnfwfpFacfEvAX/67TtgAFgp1OWklK/VbAhW5CMpdEtxlc4MVzZgx3/Advyngh1HGLDj67Ad/61gx5EG7PgmbMf/KNhxlbD4c9Yr8JwlIGm+XwHnrFEwJxpVglcV5v1XQRuOpldPcaNtOQbDGfVK1WZ9Vz+XJLmPzNsy50i8FF8XbYltxoQDj6mUr5lYGK7K6aMzjO3e3KD+1c5/rargIzTGMSRGZaKG9fmvsZ4oG08IrOaJsvGEwDhPlI0nBFb3RNl4QmC8J8rGqf81PFE27pWf4IkqRRsYIGoivdbTKhpQBZasokEpZ3OpFrLjn/oAWNxYEyRb+GiJ+ZZ+23TGX9voTW/W5bWB9DdWodA7FsS4VsE3MVriAiLJyWoKnKwGYlzbACcjYE7GKXAyDsQ4yQAnI2FOVlfgZHUQ4zoGOFkF5mS8AifjQYyTDXAyCuZkDQVO1gAxrmuAk9EwJxMUOJkAYlwP5oTeFBYbyoKNPYa/bIOYG3fDgjLveNcH+RjKU7rkmi2Nd4NQEfAGIX9KZwNQWG2gsLRsKBhpp2+Dg1LS6EBMin5DbsxT04WKDeNChXy9wbKPUfHfkAW3LPBkQSEJrCRMMkHLhCBBaMmy/7zQ9W9FtuFGnA27wthezY0ad9If7ZMbKfgOjXGhAzEqEzWsT7JsHHqiTJxk2cQTZeMky6aeKBsnWTbzRNk4ybK5J8rGSZYpnigbJ1m28ETZOMmypcJaLxNo3oX5VnYW5mpkbRUWH+PWVgS1DVgtsyqobQwIalsS41DuZ2wIlN7jc3edabzbhYqAtwvxJw07twP3M0oF388QG5bA/YzEhiXYU+loKjV4GXuLQr9FcsgEVwRqOr3XEoV6h0Jlv4bcD5S+Ng55nBuDGNthv6HHurYCJ5socLIJiLFccE4mKXCyqQInm4IYKwXnZB0FTjZT4GQzEGO14JxMVuBkcwVONgcxdhSck3UVOJmiwMkUEGNnwTlZT4GTLRQ42QLE2FVwTtZX4GRLBU62BDFOLTgnSwKek60VONkaxLh9wdf1YsNtQ/wO8742cP28LcjHDjAfSaN5eQeGs9wu3LYt+xgd9ydrZlmjyZpAclDJeWSOlZguMUQ0K3Z6R6g3vqSeRPsuWQPaEdRK6Op1n3Sj+h+Ip1K+FpE20MK4E41R4xD8TiFdeO/pIw9G7wwGHGWxqx2MtiD2nUmMVqOShYPR05QyDSyKZG3B5O2rG0z7rIqz20AU2aXo4oz3RdEpbldu0O1WxbmrAXHuZkScvaQ4d+cGXbYqzt0NiHO6EXHOIcU5gxt0xao4ZxgQ5x5GxNlDinNPbtBVq+Lc04A49zIiztmkOPfmBt1hVZx7GxDnPkbEOYsU577coDutinNfA+Lcz4g40WtZ9+cG3WVVnPsbEOcBRsTZRYrzQG7QU62K80AD4jzIiDg7SXEezA16llVxHmxAnO8sujg1dogO4QYdZY21lK/VHkBLP1SSd7y1B7tCHuc0EOOhsBA1OCnDnOyiwMkuIMbDDHBSgTnZTYGT3UCMhxvgpApzMl2Bk+kgxiMMcNIBc7KHAid7gBiPNMBJJ8zJXgqc7AViPMoAJ10wJ/socLIPiPFdBjiZCnOynwIn+4EYjzbAyfYwJwcocHIAiHGmAU52gDk5SIGTg0CMx8Cc0A+YiA2lwMI+2FRuBy9qaSgA5R3vsTAfSRsuF77MAvpKirlDeQvVLJD3NN7ZoSJg6ZzutwcUg9a4e8K6gaF+VSY0cVLwZp1Iir6HhnyQ7y14YiB2LMN2PEzBjn0G7FiB7Xi4gh2PM2DHKmzHIxTseLwBO3bAdjxSwY7vNmDHTtiORynY8QQDduyC7fguBTueaMCOU2E7Hq1gx5MM2HF72I4zFex4sgE77gDb8RgFO56iXAwq5Wu1cR+rMO5T4XEnjcZ5Goaz3CMFoQ2XfYyJ+5M1mKwfJPeVvE1yDpkvJdZLnBIfE32IrU4LXb82XApMp4N+HMYcNDeq/4F0WMrXotMV/IXGeBqJUZmoYX3BxhmeKBtvHpzribLx5sEzPVE23jx4lifKxpsH53mibLx58GxPlI03D57jibLx5sFzPVE23ug33xNl401553miStHrBjCe74kqRasZmKPeo+D1tRY2Af3/VtRO7lRobRpvutFkjQT6im8VrWbAzdt3lPwjbYsF8RcLw9ggyXsA5RttTQDgdzA0GOxtEt0eCzBaAO6ELAx1iKR3zRbA0SGE+ZXTpL0gL9KfFNVpnGeAGC8wwEkfzMlcBU7mghjfa4CT42BOzlTg5EwQ44UGODke5uQsBU7OAjFeZICTd8OczFPgZB6I8X0GODkB5uRsBU7OBjG+3wAnJ8KcnKPAyTkgxosNcHISzMm5CpycC2K8xAAnJ8OczFfgZD6I8VIDnJwCc3KeAifngRgvM8DJqTAn5ytwcj6IcRHMCV37ERtKdRi+PqCnhxt3Q/U673gvB/kQm23k6ifEpWYjNQJZk8oaSHJuyfEkp5A5TGKm+Kho4vJYtGHcR3OjMCb9FbFIrY3xipDHqA4077syNXFeguHsLWvivBTD2deuifMyI7wv4nBWNfBJMHot4CfHK8EAErrsRvWvxT1pAy2MV9EYaSGJOK/Cs6xS9bVAx4h5x3u1HcdRewbMguOQPDmrEc7CM2DXeKJsPAN2rSfKxjNgH/BE2XgG7IOeKBvPgH2IJEom5Y2XfawcdygToMRWcVtRhPyxpO4Wxr+rRKpahniBKz6pYxzsfYpEDesM8cOhJ8pEhvgRT5SNDPE6T5SNDPF6T5SNDPGjnigbWd8NdCq/ybKPEXGHkqnIJCjxVVxXVCF/cGT88zD+fSVi1dJ5C7cKoNv2ykQN6+sfbgw9USbWXTd5omysuz7mibKx7rrZE2Vj3XWLJ8rGuutWT5SNddfHPVE20vNPhDDGsAlg3hNYyZFIasDS142hjohocgSrZHsh3O/SgOPnk2HxbXgzb8N20oafMmDDW3gblkkb3mbAhrfyNqyQNry92Dasylg1jsdf0VLocXe8pjTuK1v4BEVaKzx+UuN3cBqPQN1EaS5yPuozeyhfZwvas+F1tneGioClc7rfxSEnUq1xLw7rBob6VZssbwr5gPcZA0nCJwue8H/WgA0/VfCE/y4DNryt4An/3QZseHvBE/57YBvScUuKP0vh4s/HFeaVe0E7yl7xZq5+ykTmLIm5EjNE88KZ/L0xqbk8aUVOvO8zkHiXcrYw5q65UViT/uhYdR8cBzQwjqG3FBSJGtYHSe73RNk4SPKAJ8rGQZIHPVE2DpI85ImycZDkYU+UjYMkj3iibBwkeVRhCVFr8FVDHWQ9oagbQGn7haz9uh4AawKPgaIJXP1lPdJvm874a/s86X2EvDaQ/u5XqPnfD2J8vOB1wsVxjYzk5AEFTh4AMT5hgJO7YE4eVODkQRDjkwY4uRvm5CEFTh4CMS4xwMk9MCcPK3DyMIjxKQOc3Atz8ogCJ4+AGJ+GOaH32MSGsshg1wNR72Ju3A2LoLzjfabgPiLrADAvjA4Jl/dH6+ZZA3Z8ArbjEwp2XGrAjk/CdnxSwY6fM2DHJbAdlyjY8TkDdnwKtuNTCnb8vAE7Pg3b8WkFO37BgB2fge34jIIdvwjaUXLFzV39Rh7JBWQekxgs8UO0L7zJ31yScVoerj13gW+F7zwEzDW/BPYVxjZvbtC41TYwvhQWH+PzJEYR95QczqE5OPKlPHQgJZ3lBdjxpvSnqfCifsGA431ZAWOmOPOKALzmGB20ENLaRE5WG5/6d8sKG40be+RzJ34+/XvjBvnZ44P8bOkgP3t+kJ8dFYPe9c2XZtz7gYsb/Oy4YOD/d/0g/++G+GcTf9Y96fQX7tg9/bNbBukzDAfuc0Q48P87JRz47/10kJ/9aZCftbYM/LMjWgbGctsA/y/xh2RSWiX+PCr+nOzyTou/LuVr7Un/o3X6L41w/duo1L9HN/0sGX9rxv8LBvg6bPo82O8O9kjoqhk/S/pcI/6cxpuMY5WmzxNT/YK2jJL+J+j0n8nVxNS/JzSNM23vaRCGpL8k9q3k+rew6WfJ7zb7TMDji5qxtGT8raQlmpmQ+l5iz/8FFQCzuHiaBAA=",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
