---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
