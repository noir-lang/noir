---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
