---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
