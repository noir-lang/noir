---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1dfYxkWVW/9fH6q7qnq3u+dmZnZ2pmdlkJSLqnZmcXgqYNmLAKxoBCYnYls7NM/MYYDSYgWzEmIBo0LobIGkAJSFSMChhNSAgBMeEjiIQ/SIioBLPrN/CHayIKb3in+1e/+r1T93W/W/Vmpl/Sqap3z73n855z7rn3vW6FvatVfHbpdxAwO8Xn1sGu7RrH2pKEepfB/M/Stz+Xi99taO/UyOwy4a1z/Ae2Lt+3LPirkf7hcjFmSvnYmAnG31osxnnhaG985iW/1orfaEPWJzeV1bD3fa34vkx9Uug2oey3jgr6DVev4PXNi+O8dkA+NdGxbbjRCSm5Ih1Z/XRcNlwLDh0Z0bGYSDc2/nKa8YfG1xLIsSN4MvxqfrRKPm0sbjNcKyHdvPnWte3xhjSarfcJnmVQNtZSxbGWRVsKnS6Gcr4R/5qAr6JT5Dsxb1v9MKkX5mO5Bj76YXLetYjHRHa76+9X0oy/bXJqCxnmPu+ZxHOv+J2FPTtqC7lkBP+axb0xn13cWxf9F6mtB20sf4u/3UhaDP5S8WmyXYM+ddrnJowbCBfLneHwMwTfPteJP5Rbah5NzkeK8VAXiHMVaEZ4/J5fGd17XvGZ2+RbFvf64JgBcK4K+fTDpC2tlvTjnAN95RGgUfVjn7AObfm1U3xuHezaZhl9D8jorZSbbRAvNdGwG1f6IUzoAOW8QfLZEPB9gDF5rodJO8G+2C8TsBm1GeyDYSbykXN/g/hGeheIjpbgUfVrlfD5kuJT2cRmGp6Hno7RJjaJ/k0Bj3oxftfDpL1gX+yXCdgOtRnsD4eZyEfaxCbhxvlUF17zw53RHl7TR24fbyvsYy1M6q87GqfvaBrZDGNtAfHjb4RHOZvt9EX/PrVh7mA4je9jifk+OoXvY8T3MQGPvLEf3RRjBeqXCVj2owZ7fTbykXPmGOFONF8ve7JG3WySrI8KWvl3FsrtMSPYnyZ+j6fhV8r6OPGNeuY8qTOFfzUG+5PEfuZqi/jKptBl9JwAPmqi5VJGtLy++MxzgV8ovivfbbanfPca0NkdjfNwR0gi010fdhJwqzUA4sffCH8SYMyH9UV/z3cbzlyOj4c9+dzAM9qDO5TjuF2zX1NzvAwH59GcC2Yl/VrQjvBvKj4xf1U6XAO4KnnMKaJ3p/i9dbBr6OkEZXSKZHBKwKOeTGZ90f8Etak8BufCepi0Ka7ZJdpfuBJr41zb2BCy4N+ZgD1BbQb7BPGbaE7LmHoH4U60Br3fs0WU9QbJ+qSgNVC/TMCyrA3298P8Za1snmtkJxPRxXrAGtlJIdu2kBPqIaN77y0+VY2M6354z3Dll6qRrZHssI3rtIiH94fYhtRnCHE1zlOCPtPf6TDO607xe+uAl8nyzmI81B/iPAU0Izx+z6+M7n2g+FT6U3HhlJBPP0zqoSzGlNUve0Sfwf8V0Me1pDPQP0UcvVPwjzyeIR7PCHjUA6+LT4mxAvXLBCyviw32I2Em8pG+jmWh9I21wzJ9f6z4vBX0zbXD/eqba4cG+6kwE/m4+q6aF6P/6I5mQr+rX6WTqvrti/68RsR4ajiN77sS831mCt93Ed93CXjkjf3YnWKsQP0yAct+zGC/OBv5SLtmWeC8NFngfnivhL8vFZ/ox2L1wTU9lBn7DU++XNMz2K8Un02Vr6rhMX9fLT7zteWTxXfli0yuyhfhWq47GpdJal90GnCrfDzGF2H+x3WWWF9kOHM5LrT25HMDz2gP7lCOk/UqznG9etXpkn5Yr1I5E/Yry5m+UXxOq1edBLgqcflmi08ms77oz/UqFZdxLnh1iRb9Rr2h72O9GfxKgUPFiGl1Va6b9AR9gfplApZjxG6tr6CtCXUTVRdoSt3EaKtaNzkBuud1d494wnuGK7/UurvnyG7WdRPlW/Y7ltGM/pBtIdX6h/0O2oLyO+0w6XfQZ2V0727HFlR8Oy3ko2wBZYW/Y2swBv9M4adM5mehf4rYoHw98niWeDwr4FEPvHY5LcYK1C8TsLx2Mdjt1kzkI/0my0Lp26vBGPzlW0jfXIPZr765BmOwz2+AvqvWYNB/dEczod/Vr9JJVf32RX9v3dOjNsw3jZ6bVSbeOdZpNu+dYzXYlzTIx6lz0V59xuB/UPi4WH1wfQZlxvUvT76cexvsyxsg32WiN9SH9z5eV9Y49lWWWY1jX7exz9U+9vYVPo91vVBKvhZ9qPiu/LzZZdW6zCDsjTGrNT2umxA//kZ4VXPui/779fNY+3rfoYxdGXt1kxgZ22/MSfPf/OwBthns62Au/JyjJ6++5eU8A6Jhp/i9dbDL1RPGE8R/UD2do7aqOQ/OBW4zvWCd8wi1Gezvgs4eO9SZqzOub6rzaar+4/kqq+d0R0nktJ3r6wOkL5RZNhpvG0DbwqhcFha3Vf3qDPDG+khR7zG6ys7ccO0P+bDvN2RB9x4v5oNX+wshrvZ3RtDj7fOouc97JD3BN8aVNvFl8E8UfM3zPELub37PGog+o/cEtJ0r4eWdxEuqOrPi5aTgxavzqz0K3ptStSBvj8Lg3wO2+taI2mTsHgX2xX5qj4LXUAb7x6SjVP5A6UjFy3np6M8dHU3LEVlHKMNpZw0QlnVksH9JOhpAn9Q6QlxIL/o11FW7hL8PNcCvLQt6a8T9QKy98P7Sfu3lLLUZ7EcbYC/sT0JteLcve3Juwz0vxzsJdOZXd5RERjLHGwCN2Wi87Ty0cY5nbShX5RMHwBv3S5HjXTAZhj09IE6jrU3w+P2GLOjeZ8Enc46n8nu8xzneQNCjcrwz1IbxBcfAccr2MvlZdoP/As3PeT67kigne26L5BdARgPAafjXhSx4z/sUyRNheX1tsP/QgLijeON990TPs22xr0RbRZxGW1vIaWxNSvf+2ZmjbNd4z3Dll9p395774TMYiIffF8XxVNXKlF9ulXyGEHfG4oLgxXR9kWjYKX5vHfAyud9djIe6RpwXgGaEx+/5ldG9rzu6vkDy4Xus6zsEPTxW2RkLfobN4J8G+njP/R7on6LWdbfgH3m8h3i8R8CjHnj/8YIYK1C/TMDy/uMune2ZyEf6xXuIb6SX/XNL8Kj6rZXw2S34VDbxjDQ8Dz0do00gfvyN8KgX43c9TNoL9sV+mYDl5zwNdrU9E/lImzBcKlc3man6Ns677mgm9A9j5/B+9dsX/Xl/bgBthvNm5dvzddPs2vN1BnumAXa9LOitEfellpBPjJ80+IHwk57+UN/G73qY1C3r7xkl+NHGM4J9Bunv3pBEhlJ/9xKfSr7Yj+VrZxEuFTzceCdn8V35OpNr1XeapH5GRK3jqj7XieuNKs/aDKAN3w3zUAI5ngdc85Aj4sffCO/JEfvzeYMBtKEMcExe35kcsM1gXwY2/V1tfzzc785KxtuB8R50dLvfZ2PPEU87xe+tg13Rz+AgfvyN8N5+N/bnM5sDaMNncEyOah1tfdgXv9iJBYpH710k3vPa7CtPCf74XSQvpVgwr/3RhxLY5/k0vETbZ4zv8ewT+/MZmgG0oX0+tA/7fGWD7fNVDbBPJUuuQc273sjvyomtN/4k6P6g78pR9dj91hvV+Z1WyWcIfg1R5URcDz0n2lLv97FfQN0iznPAD/sF+55fGd37RUe3Klaec2R3h6CHx4qtL1oO/0bIT36pPQ5jYz7m1JsGgCOFf1cyQjkMSA4DAY+y8t61g31ZpgzL6zqDfUN7JvJx96lzXT5Ross3HepyApZzd4P9rQbosmrt0MvFBmnod/Xr7TUPBLzSb8y5c4wrmIs9QblYzHt9YusgBv+Oirkb0sC5m6o/MF+ZgOX6t8G++zB3G6Ol7tztjxLnbsui3049shl6z/QntpcrLcIXwmT+iPhXhIzqPNPkzVe1v2+yOydoVbUN/J8PZb7Sy/24zlPXWCdqHGutxrEsJqv6Zqvk0/DwvSpnMtT6JHGtzX2uQNlX1ecKPu74KGXvZxzZqXNlvKb4O1hTfKI9HZ+aX54Nee+cU7XJMnq9fN5gP0vxM5UNqPhpuHI5/tNNIkfOpQ32Cw2Qo5dLJz4zeyWfe//m5OoZ4C3Tr3rHblX9ejHAe18v2qD33uMY+g0Gx6o7733qMO8do6XuvPc/D2uWE/PoVqlZ/m9Da5b2js9ThdJyn9TqjMPYmJ3OHg+HdS4dmw2215mJfKKerUmEu1G6aQlYi2N11vvOw/gpZDkIk7Kpuvc6AJgqe69l9b67S/zBnYf+YAK2bA/jYgP8AeoyZe32O4RdtKh/CNVrt/w/QDcJv5fDGuxzSA+pckWlh1MOb5znpPrfpOwnMc9Rum0LOY2tsejeZdB9E3PYOt6Pqp75WyM8h7ny/nPlFzo2NI9cmWN/fu0Un1sHurZfNfEuMsjDv68k7r7YibtLQH+KuNsJk/JHGS+RjJcEPNo8x92WGCtQv0zActw12B/qzEQ+0t+zLFpCFsr/zbGmJp9DR51no/E21NFC0dYX/PNz6KwH4y3/vRKS8LbFcQj9FuI02tphMtagvjjvuOr4LTUP8B77rY6gR8WdFrWp89i5L3ldd5xm8yU/5viS1OegzeehTGL8NcLj/0j2/hc219vx/wIzLK/pDfZnOzORz77r7WotizlzdzQT+l39Kp1U1W/MnqvCHetrjcZ5+FqUAfvaAbSxrx0A//Z+IJUrnwPeWB+z2n/11hnIh32/IQu69ysR64wQ4tYZ3n47rnFVjsh+xOB/VfhVZWuGu+rzRxeBhlnVoVA2F0lOFwX8AGB47mJ/ficj+yX2AysEPyh+LwQdz1lHBv8W0FF7SY+Jej8XMeZbnXh6N/G1U/zeOtg19HSAOuNnMdW7CFAvxu96mNQn9kXYLJT7I8493kHxNJFNy3jK9ms0oZ9Cm2uX8PCuBtT1qj5bhLGxO5oJ/cPYGI/4y/xQ7HnW0458jjvyWWuYfNYSyed8GOcN7WKnHr4e8fhqwz0vH8M6TH51oa3ufCxb2qNjIgcZjbehv+V8DP2LydV7dq0p7/zhfCz2nT8frjEfGwh6eCyMy1hL4Dhk8B9z4jLXpXeK31sHu9z3YAwEj+p9LfwOH+99LZyTGOwnKUbN470WLaKx7DwmvwvP4D9DPCTKpSQPnDcpXzYAGH5vJ8Y3rkOcK+EX/TPnHJ9vgCwSxoxrnpw34J4XMwZAZ351R0lkJGPGmJ8cjbfhfOaYge844ZgxgDbWQap3cpkebA7jnEWcRls7TM55fK8Lv6/ly07MGEC/jrjHMeNuQQ+PFRszDP5JZx97ECbpQxrYpy8J+hg2E7Bl9YX/aMC6o0X0lvn0Xgl/XyMeEsVhyUNZXhGC1ie/f3RJjMW/lT7PU5vBPt2A2nJL0GuyiP2fGOib8qs7SsLHDb/7fPK7Y3szo/G2AbSZ31V76Aan/C7vB6eKu57fVX6uqt/Nir2gOvyuWsvwb85f8u9cEzLYXkFbE3JVVRPCubFRwt868TCYIQ8D4kHNZZVDJX5n2pBtOgRd3zD8am56736cZY3gakSNIGatn8q2WyRLtF/EyWt91P29yBPdu8vxH3Ws9fm38h9ledFFmnvzfAegOmeA87FdwsO9xMPxGfJwnHhQ/uMY3LtQwjPuxSDMsRKenwU2xXsx02o+GyVjPgfGnNHZhm2OHe2gc+KlErmFUL0+OqC2LrThfu8NGY3S8J3z8xj5RawNWM5lbehfFou2fpicR965oePAW0KdRj9LzOeGBtBm3/OLc57vdvxp1XNDxwU9PFbsO18N/gViHrFMkD72IfkVsw5uleBHO+Czfw82KNdC+nkOK/ka/Isd+Sr9o3x5XYr08fnJpRL8+ed5ajPYlzZQvjj/ML/aKOHv5cRDE86AlsVTPttg/cvONnA8NfgfceKp8gMtR44G/7ATTxPVbrY5PmI85RqO4hHl7K17LqShfxjrJzmPUvADgOH6ItqQwXn73ipX4DVUNkoikxu5wscoVzCbzi+uz6BuV4DGhHa3G/PVfpWyu3aY1CnmP7y/82on5regX0fc45jPPgPb8KwwnyPGs8Iof45lbF8dajPY15CfTXWOW/lZloGKFd7ay+BfSzx0ZsiD4cLz2moO8HNkSCM/w6dq8y1HDgb/yw3S5bRnSHi/VcXfEHzbzT/PU5vBvrEB+YPijZ/3SmWrni0hTvaFS4IPlK/de3OEL2yFOF94h6BHyY6fGURa+ZlB9o3qM4RxWZTRp3y12r84KB6MUWxDm6LNbIj9/E7xe+uAlxdPEecm8IPw+D2/OJ6+3bEh9czxpiO7JUEPj1V2Hpzjpr1f45MFfblvfxc9i2NjvtvJrxPpZejJCOVwjHg8JuBRVvwsTkeMFcKkTBmWn8Ux2Pd1ZyIf6ZMN1+2km5aA9d6vYfSp87UdwNEt+iSudQ892SBPXLtSzxGhvPl87XFHdkqPLbjn1XiNxnk8k4Qyy0bjbarGq2TBzyR58yl1HqNikJfHxMagj9e4puM5jW2YQ2xSG8Z9GyOPOV8qiTmfPow5E7D8LLnBfr4BMadOXzsP/SqdVNWvmiP8vkWvJsI1o/zCOeLVnZRtcT3IaI5dcxv8VxpgX7G689bc097Tg7B3lcjiXxski1aYlEXs3uw84zbqgeM2zjWO28g/77+iDeBz0il15MVtVZesGrefduI2+s+OuMdxm5+nxrZYn1SWc5f5E96v6SCjoRk1PCVH7OftY2Jf/K38yekSWSw0QBZefXJWua/REpv7rgg+UL52b7WQbx01PN4zLZPdYQ1P21Cq82LGr9VYy56V5hoe1mTxfeoZ3Tvj2FATangPFvTlueL5bBzGxrwIPPB6KtG7NnbzbVu3oIxi5IDw+D81vPUU53hl799qhckansE+K5uJfKRP5tylnwb3rm5MBijrJSE/T5cZwHi6wb7cj2FT1PDmYefKNqvaucrhWHZKjy2419S1AMosG423oXx4LYCy8Gp4feCN9ZEiBqk1tpfHIB9j6yK698KIPCaEuDyG5zS2YQ6RURvGfRsjjzkPl8Sc759jzJnm12LmYqxf45jDccWr4RnsyxoQc+r0tfOIW0rOVeOWmiN11PBsjhy0hmc0x9bwDP4a2Vci/Uj7Yl1gjapqDQ/7Kn4Rlmt4BvvjJItUMcE7SxWIXqOxC21lZ8t/CvL9EdkVnuvej12FcHPVEuvIH7iWiDJsWv5gtFXNH17r5A9qPirdK9/o1SBi84dDG9679mvDZ8O4nG5FG/6NxDbMYyH9mCtwXdvgf7sBOZw3F5BnrmujDLAv/s4E7FlqM9gnGiQLZRux7+vBuZNf3VESPqRfQD3UFdvQBjLgLaWOTA+2J1b2zl2jrU3w+D2EybP/73X8gsr78R77hUzQo2KbVxPn2oza28A5xO+hMfg/pTk0z/fQ4D6F8olHi+9eDGf5KH/COa/B/kWD9smQXt7jyBLR5dkS4uTYGrtP9qGI2NoKcbFVPc+iZNeEfbI24ZnVPllftDXlvAL74djzCp+q0Q+rPQj+rdbMC2EcL76PQ+2pGV6T/UnAtVN8bh3oGl7i/aVvwPr9c1Q7NXo/L2qnN9NeyLT63H7rryrHOUlj3azrwDrORZn9K3/Le4up14Eq3/PWgbH53lM1rgM3BT3eWJkYS9kRyjq/utCW2o7qOBdvPnU9TM5FPhefet2g4pXaC618vs6xI+VDlO7VHOS6V+y6Ac/F37Wgaf7/23xPrSVgU5wVuJXOoMecFbhd4iP7tVsxPt5R+I5U8bFqrd/GQL92u9b667Dh82FcTreiDT+7oTbMNJTVYbimZ/CXC77m+fwI7ydfKWjKP160oPkMwGfsO5fnmQNjbOd5hr6D5xnqkGvnXNsz3lAmqeaZ2lNDnJwDx+6pvcCZZ1Vz4I6gp2oOjGdmXnSbxwqcZ2zDdewL94C3WcSKVPvCr6gxVvQEPVVjBft+87OvBj/7cISfja01oB7zqwtt8/SzsTbKe9G3op/9iQb72Vcf0M/y3ld+7RSfWwe6hrv/c6cnZHS75Psm11s5339sDvl+j9pUvr8cJmVeo1x3/w+h2tdVsYj3bd9I64kmnBGYttfGPPwa6H7W/wNP+ZVNh0f1PnTUE9c0V8RYIeg8AWFPUpvBPt4gfU+T3VFHFr0KsjhfIovfuYlk0a4gi7YjCz5vZ7DvIFmkypOULHgdkchXXpu1rE+WyPo9t76sH521rMvOhL2vAbK+lc99vT8i72qFtOe+FqGNz30tAb5WyWcI4zloFfrWCG8deJYBhnldEW2zWtvuvls96NxlBfjhGIe5S0b3PurYkDo3uuLIblHQw+enNgqgHO3fUB2lA31iclCD/4TIQdVa0uirup+c6Lxq9HkrfmZx2nle3k/G/kdorJu1vjrmF0fjbRi7eG2Oc8Y7b8X/EyD12tzoil2bIx9jtWa69/c1rs1VfcobK7YGirLOry60zbNOvwptbEfol7zzVpzzpTr73iK60I5UrtYWfCC/Gd379xproKomy2OVPW/Bz28Z/Ncp10S+Uuea/J4flXvFPrM0y/0A/l+33jNLmEPYXFgX/PP/kFG6ntX/WbFYV/Z/Voy2dpiMjfY9hD1b271X2L+aC2rNpfbc1Z71tLqK8jns7xeoBoc8pZ4HhmudaFS6T50vKz/YE/Kr6gdXHd13oV9H3PN036U2td5RaxQbI3d/FyPeMxmb2+H6Jr+60JY6Jnt+SP1PJ5WfeGcF2RbRTme1/kec+13/n3VssWpup+oRyhY71DbNFr36i9qXxPHK5tTNsD6pw4bPh3E5eTacen0y7R2f+7XhS3OwYfa1yoaZhrK5W/Y+gedRHJ7HM698huX5UHv5gYj3kMXmrGiLN2Q1SsKrnGdoDzzPMP7xPEPb9d5H3QbeZhEr1PqHcYawN8/QXsd8Dt170JlnKk/AezyXeH2Dbeo9u2qe2Rhoi967jJUP5FjBPpDt2rNh1HN+dUfjY+0U97cOdsl1F8Y4tmGsofO6K3PkhDLsAm9Kfzv18Ob+TzeuF4WwZ8Ox/9PtYceGlf9Suu+HyTmFcPib5xDGZPat18jfz+P/+bEscB6o+azmAdpKfnVHSfioXH/APR6eB+rdA0hzCJO2lH9foDaD/RnSZSqfr3TJ6xb0abznlDoWmXxiY9GCkC3K1+79fEQsmma7as/J4HpB1594Pw/X/GY3qk6EOYbRifUhr86j5pjhnUe+tA408hzDdzVwvoTvvPBqfOvAG8t4VvuiiJNrfLH7om+osca3LuhR9nuE2jC/wTHKaFD7V2uibbdW+K2/ZxbfU9ri/Q98W183aC3Gtz1evrrQjvCPF4LCdZR9dg9A5/X7r25fH169fvW+q48+evnaVfbJAWTXS4D/6v3DB65dunzt/kfuG14dXpk5/mv3XXnk2uX7rm69ajv/eWkafrND8x35hb4tv8x32JxkeNzHR/i3w/r0nbSP3xX4crj3Q6zOryWgpUZ/c8l4W0Q6iB7Evy7g7XtiWocerYuCViXjVsknjoX3Fkfj95ZHk/Aop0XCvYLw1NaDti7hWS1+o63hWEZHRvB/BmvO/FqCPta/L/CjzhiXwo9+l8fqiHu4Lv5D8nldwF1nnoDzCOf4mP0A7jI+OoIPJd9exFg9Z6xlZ6yVyLE83Ehrl8Y3+1koGX+Z4NeK32ifi4Iets8Pgy/828VxGBvzIwDz1+QvPf98BNsEPOYvDG+85jg/Q753HfCk8GeKbrQFw69kUNWfGa4VGqvuuVenTryxjkSOZfJE/ebfvzgbXV9iHtpBzzPDb/T009Cza3vrI1+mhr8O2zNcs7I9xZtnewjPtqfGWo8cy+Sp7G0tjQyG7NdDiQwQP/5Gv47xz/qyz/6XxfFxlLwwhnGO1oe2FWrbgLZVondzNEkvjrVO9G4SvRZ7lc33Bf4jhB9xKfwclzcE/IaAz23lyyTTBdEX9WsyxVxnrM9ofDyL1yi7BUFLRvD/Bf7zaxHxOYdrLZXDVfUj3dH4vWk5ucFXzcnRP+XXfnPy/7sJcvL/ppw8tW9eoPHxHtNmtpOiTnDpgQeuPPfSI1uX73/02vVHLw9j6wSHa4j5rSH6S3t4zi+Nw9iYmwBzwvE9qdYQgwLn4Rpi31ej1xADsK/vnI2uD9cQ4XANoeytqWsIhMcxugR/hOjPL4wzHJeUHBFnTI6+4sDbb9zLUeuTjOCfV+jFYjHm9bymQB42Suhthbg1xbqAV3aV286QYiHmXKajXphcI4QQl8uofQEbi/cFGL47Gh9rLK+nsUwHmDssC7psjqwS7p3i/tbBrmFszmf4M6L/eyGOPFghT5k2J9mXqHVijvOVDfAlONcNfx2xwnDNKlbUoRNvrNWKYzU1PqgcTK17d89jQFuP2tAvcm3I/Cr6CBVTM4L/UfLjGFusf1/gZz5j433VWlI+b18BfsPmsFcnUvKNrROpdWNsDFiJGGvFGWvJGWs5cqyW6O/Fn3nGDKTf8NfhCw3XrHyh4s3zhQjPeo6tgXhjzVOnyDf7KOU70a67BK9856rgV/lOtif0LbxW2a/vfP1N4DtfA/VE5Wdici3P/6H+YvS96oy14ozVixwr1tbQJ+SX6WQh+LbGtok2o9ZxXKt7E8SyJ6ieZ2P+OsD8prOGYd0pO1J1ZrUuw3rm2yhPnkdNBW2BayrI00FrKgtpeNuuUyd11FRMnqjf/PsfzEbXl5gHrOfhPDP8Rs9GGnqGni9V9Yo6bM9wzcr2FG+e7Xnri9iYo8YyeSp7O5JGBkP266FEBmX1sLIzAdaXffYHaV2i5KXOQKp9f173bUIb5w5HR5P0qlpcRvAfpNxF2Xxf4Mf6G+NS+Dkubwr4TQGf28qfkEyV//POlap63poDr3SGY3DOwL4pv7x8dlPAe7I6KuhBGnG8/Dom4NcdePuNtV8co+w8yUfJdo5DH+vfFzwcL6G3VYK/TB4If1TA57bzIch751HfNVu5neq7n4a84nMV8tZpPppjC8I3of6HtOI64qkGxDpckxj+OnIZwzWrXKYOG/HGWqs4VtPszauZeHnHrOvNT94ENZN/BD/2FOUgyna8HGSarXFOMa3mxeOr/dDFivDrDj0qv1M683JVa8NYzXm3xX20JxzL6MgI/mmyJ5UfqVwE17mMy8tLvdysLBf5KuQi3wTtj3u0aW0BAA==",
  "debug_symbols": "zd3fjuPGlYDxd5lrX1Sd/5VXCRaB7TjBAIYd2M4CiyDvvpqxRRlTDXOzah59N0a3R13zc1v8RFI81L8+/PW7b/759798/OFvP/784U9//teH73/89utfPv74w+27f/37qw/f/PTx++8//v0vv//XH8anf0z7/Pif//H1D5++/fmXr3/65cOfps+vPnz3w18/fRW3n//bx++/+/AnH//+r68+TP+PfyLe/om6/0Tolz+R//FP1Js/IeP4Cfv9T3z1f3/op8XXhYvLuHLxeeXicuXieuXiduXifuXiceXieeXiV26hcuUWqlduoXrlFqpXbqF65RaqV26heuUWqlduofbss0UifnuoRH65+LO/c6n74jrml4v7lYs/+ztXlfviVl8unlcuXlcuvi5c3J+tovrxP3T5ySaR89j1S/3y/75PjEQwEsVIDCNxjCQwksRICiNZFElgGhuYxgamsYFpbGAaG52NHVPvyw7ZJIGRJEZSGMl6leTLs5M5MJKJkQhGohiJYSSOkQRG0tpYO5Yd23FxFkayKJIaGMl8kcS/fMeqBCNRjMQwktbGxkMS2zM2MJLESAojWRTJGhjJxEgEI1GMpLWx5YdkfdnY5RhJYCSJkdSrJNszdlEkcwwOZXIonZmd8/6e5O2rsVGUQzEOxV9F8Y0SHEpyKMWhdNZ26tGVads1nXNwKJNDkVdRtvBP5VA6N2aJdV9WMjdKcSgLQ5HBoUwORTgU5VCMQ2ndX1nHsnPfzZbkUIpDWRiKDg5lcijCobQmTh5d0W2kSFsTp8clO2LbeJY6hxIcSnIorTuUoo+n7XZ0qAtDscGhTA5FOBTlUIxDcQ6Fc8xsnYnTcSyrY9tJsIWhtM7YnFDmiyhzOwHWOmVzQlEOxTiUzsSp5EHZE9c6aXNCSQ6lXkSx7a2p1mGbP6a0TtucUCaHIhyKcijGoTiHEhxKciic2ganttfN3XxefV66+rNNtHG/XZKZ/PFDPcb9wMlDtwOnpwdk3pFiHIpzKMGhJIdSHMrCUJ6ek3lHyuRQOLUtTm2LU9tqrO3trPJxp0HTtVGCQ0kOpTiU9SKKbW/BrsGhTA5FOBTlUIxDcQ6ltbaP279abO+Rr+RQikNZFIqM8SJKzo0yORThUJRDaa1tPii1P22dQwkOJTmU4lAWhjIHhzI5lM7a+jiuvfG5JW4qh2IcinMo8SrK/rRNDqU4lIWhSGdtXeOgbOfiRCaHIhxKa211PCi1UYxD8RdRtqFWkeBQkkMpDqW1tv6o7X4mQTu7EnVcxBDbhQCiyqEYh+IcSnAoyaEUh7IwFOvcdYrx+DCzfYfShENRDsU4FOdQgkNJDqU1cfboistGaU3ccd3ijPjyDTvxwaFMDkU4lNba2nw8bbc9fjcOxTmU4FCSQykOZWEoMTgUzjFzdCYuxe7LpuwU41CcQ+lM3O8/TWj7VAeJ5FDqRZTtM5YkFoaSg0OZHIpwKMqhGIfiHEpwKMmhcGqbnNpeNx/0efV56epPN9HuvxofJw8NOUZPQ7bRU3l+iuf9KMahOIcSHEpyKMWhLAzl+Sme96NMDoVT28Wp7eLUdnFquzi1XY21tdI7xcq2syCrOJRFoegYHMp8EcXHRhEORTkU41CcQwkOJTmU1tqGHZSUjbIwlDk4lMmhyKsouVGUQzEOxTmU1trWg7L2p21yKMWhLAxFBocyORThUJRDMQ6ls7bruBGUrbnVVoJDSQ6lOJT1IopsT1sdHMrkUIRD6aztMjko2/CZqnEozqG01vaYr71RbKMkh1KvoqyNsjAUGxzK5FAanytu874X57bX1haG4oNDmRyKcCjKoRiH4hxKcCitL4elR23X3CgLQ4nBoUwORTgU5VCMQ3EOJTiUxoMPH/O4E/rYRmc0O3edho3HY2ujTA5FOBTlUIxDcQ4lOJTkUApDqdbEreOxc2ynejqv43c57oR++3I7k9B5Hf8ZxTmU4FCSQykOZWEondfxu+SROKltL67zOv4zinAoyqEYh+IcSnAoyaEUh7IoFBuY2trA1NYGprY2MLW1gamtDUxtbWBqa53X8bs+3m5QHRulOJSFoXRex39G6UzczDwO37fzttZ58fwZxTgU51A4XZmcrszWrqQclPzyCjCTwaFMDqUzcbc3wh4U2yjKodiLKLVtQZ1XrJ9RgkNJDgVzMZop5mI009aL0fw4WWq+U4RDUQ6lM3Fm/qBsr0HqHEq8irI2SnIoxaEsDMVaa5t6UGqnTA5FOBTlUDpr+/j8Pfftsisz51CCQ8kXUbYbV1rroMUJZWEorYMWJ5TO2vrxcSnuse3FtQ5anFCUQzEOxTmU4FCSQykOZWEoMTgUTm2DU9vg1DY4tQ1ObYNT2+DUNji1jdba5jEJ49un/FjrJMwJZXIowqF01jaOO4147AcfrZMwJxTnUOJVlNwoyaEUh7IwlNahnBPK5FCEQ1EOxTgU51A4tS1Oba8bVfq8+rpy9acHim472MevZvvNPD0j5PO4pDfqjx8q47iLkYztLkb29IzQO1KUQzEOxTmU4FCSQykOZVEo/vSM0DtSMLX1gamtD0xtby+/fRTP46Oub1/uFOdQgkNJDqVeRHHbKAtDmYNDmRyKcCjKoRiH4hxKa23jOPTMjI2SHEpxKAtDkfEiSs2NMjkU4VCUQ2mtbT0oa3/aOocSHEpyKMWhLAxFB4cyOZTO2tY8Lv8t2RKnyqEYh+IcSryKsj9tk0MpDmVhKNZZ27JjkLgsN8rkUIRDUQ6ltbaPG8vWdmNZN+dQ4kWUbXrXLTmU4lAWhuKNtY3p9+nd25db+F07KevelZDt4gt341CcQwkOJTmU4lAWhhKDQ2nddapjwqG2q9Y9lEMxDsU5lOBQkkMpDmVhKNl5oLqOj5KIsScuO3edxnHXxRi17VBm607CkGOHco6NkhxKcSgLQ6nBoUwORTgU5VCcQwnMMXMlh9KaOFsPynZasBaGssaLKNt4ta/JoQiHohxKZ+IenwQZQ/anbXAoyaEUh7IolOgctDijTA5FOBSjnIuLzumGENWDojslOJTOxInkg+IbpTiU9SKKfbnHH53TDWeUyaEIh6IcinEozqEEh5IcSnEonNoKp7bXTTd8Xl0uXf3pJqYde5Xxxw8Viftjb7/QbQ/0+RmE96M4hxIcSnIoxaEsDOX5GYT3o0wORTgUTm21sbZz+bHs8u01SJNDKQ6lsyvjuHO+jPnlZEbY4FAmhyIcir6KEhvFOBTnUIJD6UxcLT8SN7bE2cJQfHSGX+Kg7Cd6fXIowqEoh2KvoqyN4hxKcCjJoXB2KH1hKDE4lMmhCIeiHIpxKM6hJGaHMjrPxQ2Tg2K6URaGkoNDaT1m/v09NLddpxQORV9F2XYS0jgU51CCQ0kOpTiUhaHU4FAmhyIcCqe2xant0/MqcXw6RLyxely6el66el26+rpy9afHOf549Xnp6nLp6nrp6nbp6pduq+vSbXVduq2uS7fVdeW2mmNcuvrT2+o8Zgz95KHidbzf7ys3inAoyqEYh+IcSnAoyaEUh7IwlKenHt6Rwqnt7OyK6P0jA25fbq9B0zmU4FDyRZTtRGTO4lAWhiKDQ+ncdZp+dGWf/k5RDsU4FH8VZQu/BIeSHEpxKJ2Jm1kHpb584zR1cCiTQxEORTkU41CcQwkOhbMXp617cb+fMtlemW1wKPNVlO01yIRDUQ7FOBTnUIJDSQ6lOJSFofjgUDi1dU5t/bLafl7dLl396SbG/aG3d2r/+KEmcb9swmTtlOBQkkMpDmVhKE+PGrwjZXIowqEoh2IcCqe20VhbsePaOrHaXj9jYSg5OJTGrojP4yyIb5/LlykcinIoxqH4iyg6N0pwKMmhFIfSWVv3Y8bMY6PU4FAmhyIcir6K4hultbaPyTv/9IgvKM6hBIeSHEpxKAtDWYNDmRxKZ+LMjsTZ9jEquYxD8VcdB23v8K3gUJJDKQ4Fc/heA3P4XmNyKMKhYPbiarTuxa1xUNbcKMGhJIfSuhf3+wv/ZaMsDGWOV1G2jXlODkU4FOVQjENxDiU4lORQikNZGIpwaiuc2spltf28ul66+rNNzHG/SjdV//ihlsct1iy3M/H19IDLO1KCQ0kOpTiUhaE8PeDyjpTJoQiHohwKp7bKqa1yaquc2mpnbefxHrnN7V7gZcKhKIfSuTHP8IOSulGcQwkOJTmUehWlNsrCUHxwKJNDaa3tun/oo8nczq66cijGoTiHEhxKcijFoSwMJQaHMjkUTm2DU9vg1DY4tQ1ObYNT2+DUNhsTJxHHdeVR2+F7Tg5FOilr3Sk5trdKUjkU41CcQ4kXUd7YmJNDKQ5lYSjVWduU4wLdN06W1uRQhENRDsU4FOdQgkPprG0eJ8Aka2yU4lAWhrIGhzI5FOFQlEMxDsU5lOBQOLVdnNouTG3XwNR2DUxt1+is7cqDsra7jK2hHIpxKJ21XY/bwK3tVqRrBIeSHEpxKAtDmYNDmRxKY211jPuyOqZvFOVQjENxDiU4lORQikNpre2yB+XLuxksGRzK5FCEQ9EXUWR7DeqcDzqjOIcSHEprbe2RON+ftsWhLAylcz7ojDI7Kcc1CTpypwiHohyKcSjOoQSHkhxKa23XPChrbZSFodjgUCaHIhyKcijGoXTWduqxQzl9O8ffOcB1RkkOpTiUhaF0DnCdUSaHIhyKcijGoXBq65zaOqe2zqmtc2obnNpGa20zD8o2LrtCOBTlUFprm/NB2fZtwzmU4FDyRZTa3pqK4lAWhpKDQ+msrRx3pVGZ29O2c5bsjKIcinEonbUVPV6DxPanbXAo+SKKz41SHMrCUDpnyc4orbV9hF+2+8OvEg5FORTjUJxDCQ4lOZTiUBaGsgaHwqnt4tR2cWq7OLVdnNouTm07Z8lU53FaUPeLXDtnyc4oi0KZo3OYTHXUwxK7ZYIs8iLLdhnlzaIgi4EsDrJ0Rlcfl1Kqv/HcTZClQJbFsczW7ubjNaD25+6cIIu8ylK7RUEWA1kcZOnsrun9YwrV7I1tOkGWAlkWx9I5YHZqmSCLgCwKshjI4iALqLsC6q6Auiug7iqou62zZnbctUZtu2vNzSIgi4IsBrK0dncd5xlc5m4JkCVBlgJZOrvrcVww4LU2S+vQ2ZllgiwCsijIYiCLgywBsiTIUiALqLsO6q6Duuug7jqouw7qbusMWjzeVwux3RIgS4IsBbJ0djfsOLaP2I/tWwfRziwTZBGQpbO7OY7W5dxb1zqMdmZxkCVAltbuVhyW8cZzt0CWxbG0jqSdWSbIIiCLgiwGsjjIEiALqLsJ6m6Culug7haouwXqboG6W6DuFqi7BepugbrbOqSW9jgOsP1av9YptRNL65jamWW2WubDsh+rtQ6qnVn0RRbf52xaR9XOLA6yBMjS2d3MdVjeuOakdVztzLIwltk6r5apD8vcLRNkkVdZcrcoyGIgi4Msnd2tcVxfV/LGczdBlgJZFsfSOq9Wdbx/VMt2ywRZBGRRkKWzuxXHPkO98drYOq92ZgmQJUGWAlkWx9I6r3ZmmSCLgCwKsoC6K6DuCqi7AuqugLoroO4qqLsK6q6Cuqug7iqouwrqroK6q6DuKqi7nfNqdns3/LfH2u1k7mbpnFc7tUyQRUCWxu7a7cjwsOh+nqFzXu3U4iBLgCzVaVn398pNpuyWxbF0zoiZaBwWf8MyQRYBWRRk6WydxMOy33drds6InVriRZY3znt3zoidWgpkWRxLDJBlgiwCsijIYiCLgyyg7gaou9fNiP26/Lp0+ecnufR+tiHz5DcZJXdK1H4F53x+kusdLQKyKMhiIIuDLAGyJMhSIMviWArU3QJ1t0DdLVB3q7G7ZnK/2stM9zPClSBLgSyr0xJ2WHI/e7QGyDJBFgFZ9FWW/QrxZSCLgywBsrR2d90faz7esBTIsjAWGQNkmS+yzLlbWrtbxzuUtmK3KMhiIIuDLAGyJMhSIEtnd10efbHtLKzMAbJMkEVAFgVZDGRxkCVAlgRZCmQBdVdA3RVQdwXUXQF1V0DdFVB3pbN1etwR3HS/64ZIgSydrdP12N/d744lOkCWCbIIyKIvsrxxzkMNZHGQJUAWzntZopz3skQXx2IDZJkgi4AsCrIYyOIgC+h42kDH09Z6PP3Y3/XarscUHyDLBFkEZGk9nn5MlcX+aRniBrL4iyziuyVAlgRZCmTp7G4cd4O18P24MQbIMkEWAVkUZDGQxUGWAFkSZCmQBdTdBHU3Qd1NUHcT1N0EdTdB3c3W7h53m7bYP1FWMkGWAlkWx9I5f2Q5Dku+cRzQOX90apEXWXR/b6Jz/ujUYiCLgywBsiTIUiDL4ljWAFkmyALq7gJ197q5rF+X92uXf7qOx+cD1YyTh/pxtXrG3PeQn5+eekdLgSwLY9Hnp6fe0TJBFgFZFGQxkMVBFk53dXC6q4PTXR2g7s7G7obmcacLzbVbFGQxkKWxL7eTjfe90rD988F0BsiSIEuBLOtVlr0vMkCWCbIIyNLZXbM6LP6GxUAWB1kCZMkXWWLsltbuah4W892yOBYdIMsEWQRkUZDFQJbW7uajL0t3S4AsCbIUyLI4FhsgywRZBGRRkMVAFlB3DdRdA3XXQN01UHcd1F0Hdddbz6nOOM5jyn4e0w1k6WzdrSCHxff9XQ+QJUGWAlnWiyxvnPOIAbJMkEVAFtB7WWEgi4MsAbIkyFIgy+JYEvReeU6QBXQ8nQaydLbO5/F65PqGJUCWBFkKZOlsnT/2Xzz2bboGyDJfZMn9OKAEZFGQxUCW1u7WcZ7B33gNqAJZFseyOvsS8353rAjJ3TJBFgFZFGQxkMVBlgBZEmQpkGVhLDY43bXB6a4NTndtcLprg9NdG5zu2uB01wandTZArWudbQl/WOINywRZBGRRkMVAFgdZAmRJkKVAlsWxCKi7AuqugLoroO4KqLutMz9RfrfkmLslQJYEWQpk6exuzodF9+du68zPmWW+yGK6WwRkUZDFQJbO7qavw5K2WwJkSZClQJbFsbTO/JxZJsgiIIuCLAaygLproO4aqLsG6q6Buuug7jqou97a3XVcG1pjPw5onT86sxjI4iBLZ3dLHpY3jgNa54/OLPUqy9oti2NpnT86s0yQRUAWBVkMZHGQJUCWBFlA3Q1Qd6+bP/p1+Xnt8s/WsY7PuK2ze6uX1P0K8ZL1hkVBFgNZHGQJkCVBlgJZFsfy9MTSe1omyALqboG6W6DuFqi71djdWHZMCS2X3ZKdlrTDkvvvZU2QRUAW7bSEPiz71RjLQBYHWQJkSZClQJaFsfgYnZZ170uOsXbLBFkEZFGQxUAWB1kCZEmQpUCWxbFMUHcnqLsT1N0J6u4EdXc2djeHjsOy30HeZ4AsCbIUyLI4FhkgywRZBGRRkMVAFlB3BdRdAXVXQN0VUHcV1F0FdVdBrVNQ67S1dSWHZY3dEiBLgiwFsqxXWWyzWGvrjjv23r7cj9VsgiwCsijIYiCLgywBsnR2dx53O8q53+3IrUCWxbH4AFkmyCIgi4IsBrI4yBIgC6i7Duqug7oboO4GqLsB6m6Auhug1gWoddHaOj/2d2fEbimQZXEsOUCWCbIIyKIgi4EsDrIEyALqboK6m6DuFqi7BepugbpboO5Wa3dLD8vazx2WgywBsiTHsjr7InqfhUrx/Zr8zvmjU4uALAqyGMjiIEuALAmyFMiyMJYYnO7G4HQ3Bqe7MTjdjcHpbgxOd2NwuhuD07oYoNbN1tblw7LesEyQRUAWBVkMZHGQJUCWBFkKZFkci4C6K6DuCqi7AuqugLoroO4KqLutsy2qx7lmte1cc7TOtpxZJsgiIIuCLAayOMgSIEuCLAWygLproO4aqLsG6q6Bumug7hqouwZqnYFa1zrboo/5I63d0jrbcmaZIIuALAqyGMjiIEuALAmyFMgC6m6Auhug7gaouwHqboC6G6DuBqi7rXM2No7rDk3GbimQZXEsrXM2Z5YJsgjIoiCLgSyd3TU97tVpJrslQJYEWQpkWa+y1GZpnbM5s0yQRUCW1u7GMbNsZbvFQBZ/kWW/H1m0ztmcWRJkKZCls7s+jm3aZT8maZ0/OrPMF1l0f21snT86syjIYiBLZ3f9+Byx9NhfG1vnj84sCbLUiyy5v063zh/9sSVb54/OLBNkae1u1d0Sc+wWBVkMZPFXWWK3BMiSIEuBLItjaZ2FOrNMkEVAFgVZDGQBdXeCunvdLNSvy9e1yz9dx1y/PXSJ/z8f+lny/LzSu0kmRiIYiWIkhpE4RhIYSWIkhZFgGquYxiqmsYpprDb2JPNx14bU3C0BsiTIUp0W8Ydl33fTxbHYAFkmyCIgi4IsBrK0dtcfltzPblqALAmyFMiyOBYfIMsEWQRkUZDFQBZQdx3UXQd110HddVB3o7W765jsqLGfgY4JsgjIoiCLgSwOsgTIkiBLgSyLY0lQdxPU3QR1N0HdTVB3s7O7Jcd5zNqnbzIDZEmQpUCWzu5WPZ67a39vogbIMkEWAVkUZDGQxUGWAFkSZCmQBdTdBeruAnV3gbq7QN1dnd1ddlwZuXx/r3w5yBIgS4IsBbIsjKXGAFkmyCIgi4IsnO7W4HS3Bqe7NTjdrdF5TeiY98fetplt6rHmAFkmyCIgi4IsBrI4yBIgS4IsBbKAuiug7gqouwLqroC6K6DuCqi7AmqdgFrXOnc0vA7LPmdarZNHZ5YJsgjIoiCLgSwOsgTIkiBLgSyg7hqouwbqroG6a6DuGqi7BuqutXZ33Ze9nZuL3ZIgS4Esi2PpnD+6nZDTw+K1WxRkMZDFQZYAWRJkKZBlcSyd80enlgmygLoboO4GqLsB6m6Auhug7gaouwlqXYJal62tW/d52Nv7Vmu3KMhiIIuDLAGyJMhSIMviWGqALBNkAXW3QN0tUHcL1N0Cdbdz5qdE7LC88f5058zPqWVxLJ0zP6eWzu7K4xy8pOwWAVkUZDGQxUGWAFkSZGntbuVhWfv7JGthLGsMkGWCLAKyKMhiIIuDLAGyJMjC6e4aoO4+PfMjcb+PikTuy8u1yz9bJB33D2jRKfvyz0ZG6q7XMffl/drl49rl89rl69rl16XLPz1ecrL8vHZ5uXZ5vXb5a7dauXarlWu3Wrl2q5Vrt1q5dqvVa7davW6r/fftu//++qePX3/z/Xc/337i0x/+84dvf/n44w+/ffvL//zj/iff/PTx++8//v0v//jpx2+/++s/f/ruL9//+O2nP/swfvvHn2VIfSXD1g3+KQZzWXw1V87b9/b5+5Tbn0vevvfPj3f9Sub49P2nJ7BM89v3abfv8/P347betE/f1+fv8/bnYnr7/tP/09uXdvt+xadf1Pj8F6jd/kL9BPi8j3L7G8btb3S5/bfe/nv/Fw==",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
