---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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QLkboNxNUO4e7bOxNtc1m7TVIiCLgiwGsjjIEiBLgiwFspzMXdO5F7DZep/kaJ/NlaWDLAKy6KsstVoMZHGQJUCWBFkKZBkcy2ggSwdZBGQB5e4A5e7R/iMLmZay1RIgS77Isu7XnEf7j64sA2Opo/1HV5YOsgjIoiCLgSwOsgTIwsndapzcraO9UN7mmMFlmVOto71QV5b+IovKahGQRUEWA1kcZAmQJUGWAlkGxyINZAHlroBy9+izmNxmX5ZHrRYDWRxkiRdZ0lZLgiwFsgyO5WiPmFfdLdHX64CjPWJXFgFZ9FWW9ZrkaI/YlcVBlgBZtuXuz+Vrb/mn0zHHv986xP+fb/0ieb6P690kHSMRjEQxEsNI8pwk87FLTGqulgJZBsfi7aRF/GFZs9Y7yCIgi4IsBrI4yBIgS4IsBbIMjiVAuRug3A1Q7gYodwOUu3E0d/1hyXU2IgJkSZClQJbBsWQDWTrIIiCLgiwGsoByN0G5m6DcTVDuJih362jujtmpWm2dka4OsgjIoiCLgSwOsgTIkiBLgSyDYxmg3B2g3B2g3B2g3B2g3B0nc7dk3ieptZu4RoAsCbIUyDIwltEayNJBFgFZFGQxkIWTu6Nxcne0o7lbj+/G4aulQJbBsfQGsnSQRUAWBVkMZHGQJUAWUO52UO52UO4KKHcFlLsCyl0B5a6AcldAuSug3BVQ7goodwWUu3oyd4fNTo/huVo6yCIgi4IsBrI4yJIgS4Esg2MxUNYZKOsMlHUGyjoDZZ0dzLpq/f7eamqrJUCWBFkKZBkcy8kesUtLB1kEZFGQBZR1Dso6B2Wdg7LOQVkXoKwLUNYFKOsClHUn+7IuLUdz12ta1n0zRgTIkiBLgSyDY8kGsnSQRUAWBVkMZAHlboJyN0G5m6DcTVDuFih3C5S7dTR3x71s9XUd/CgFWQxkcZDlZL70ntMi63XAyf6jK8vJ/qNLSwdZBGRRkMVAFgdZTo7ruum0eK2WBFkKZBkUi7TWQJYOsgjIoiCLgSyYrLtZMFl3sxzNunHfz6OkjdUyOJbeQJYOsgjIoiCLgSwOsgTIkiALKHc7KHcFlLsCyl0B5e7Jnp8SsWlZ7k/fLAayOMgSIMvJ3JXHHLykrJYCWQbHcrLn59LSQRYBWRRkOZq7NecxZcRqcZAlQJYEWZ7NOon7PioSuZR/uo3nonzfW172lte95W1ved9bPvaWz73la2/5Z89abfcHoWlfv0SebgKRuuu19bV831te9pbXveVtb3nfWz72ls+95Wtv+bGt/L9ur/77mx8/ffPH7779++0Tn3/5j+//9NOnH77/98uf/udv99/88cdP33336a9/+NuPP/zp2z//48dv//DdD3/6/LsP7d//+b10j4/SMz/DP79uaR9vcw7j9tq+/L612+/db6/9y+vqH0X08+vPh4BI6ke5pcztdX55rbd6twHr7fXnf+Tbrz7/Pvvt9fjyOuWjmNjt9Zcpfmlx+x8tPgO+zLPfMHX7E6vd/q63v+//Ag==",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
