---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
