---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
