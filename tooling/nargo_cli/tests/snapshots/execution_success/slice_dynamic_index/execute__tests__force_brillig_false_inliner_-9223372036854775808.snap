---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
