---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
