---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "zd3bjhvHtYDhd9G1L2rVOvtVNjYC2ZYDAYJkyHKAwMi7hwnMYjxliLA5KP53GqlFfSBH//ShVvevb354990vf//b+48/fvr5zbf/9+ubD5++f/vl/aePl69+fTP++1s///T243+++vnL289f3nwrc3zz5t3HHy6/CvvXN29+fP/h3Ztvffzrm21T9fhtU23/+qaSUteXTZX/3fj/v3kjFMikQJQCsYOQIXp92TFfQpwCCQokKZCiQJoCkYGRCEYynyWJlxLFSAwjcYwkMJKjhbX1ssPqpaQwkn6SxPXlvtrRxsZNEi/fkykYycRIFCMxjMQxksBIjja2fEl660k9S7K9JycbKzKvL3v5F14eho5nSfyl5GRjRdenI/by+0QnRqIYiWEkjpEERpIYSWEkTZHYwEgwjbWnNfblz2JTjMQwEsdIjjY2YknSXkoSI6lnSfql5Ghje72sbHvUPjASwUgmRqIYiWEkjpEERpIYSWEkmMbGycZOXdesp708bx+CkUyMRDESw0hONnbOdaVp6suzWxEYSWIkhZE0RZIDIxGMZGIkipEYRoJpbGIam5jGJqaxiWlsYRpbmMYWprF1tLHRS5L5UmIYiWMkgZEkRlIYSVMkPTASwUgmRoJpbGMa25jGNqaxjWlsYxrbmMbKwERWxsnK6lgvq6Ib5WRmdeai2NgoyqE8Glob8tumZvMOxX3t4Htsi+6HcyjBoSSHUicpZYvSc6M0hvLwyNdfpmy1fXjm689QYqwrLCHb98rDQ1+vSFEOxTgU51CCQ0kOpTiUxlDm4FA4tZ1Ha7t2PiXCNsrR2pqsl93mBGUah+IcSnAoyaEUh9IYig4O5Whtax0zR/tGmRyKcijGoTiHEhxKcijFoZys7ddvhvXwQJjZ9eV93Nu063qqx7p3inAo8xzFh/TadhtFlodnwl6RYhyKn6SsO4P4H9yj5OGxsFekJIdSHEpjKD44FOFQJoeiHIpxKJzaOqe2zqmtc2rrnNrG0dr22lbGdoYyhEOZHIpyKCdrK5mLsh98hHMowaGcrO3U6/H15Ze9UYpDaQwlB4ciHMrJ2s5cPw5nbcfMqRyKcSjOoQSHkhxKcSiNodTgUIRD4dS2OLUtTm2LU9vi1LY4ta2TtdW83oT18svt6ns1htKDQxEOZXIoJ2ur6z50rjU2inEoJ2trcl0m7ja3FevNqW2frK35Ojo039+V4lCaQpljcCgna2vmN0pvlJO1tdRFqZ1ysrY+FsX3Z6iNR2t7ORl8ffnfPy/gDzbNtVrQ022jOIcSHEpyKHWSEutbPDM2SmMoD8+S/VVKbf+ZH54l+1OUulF6f1cmh6IcinEozqEEh5Icysna1nq0mtfcu9LPomzvyjxZ27otjyjbH98lT6LsT1ebJ2tbt4UAPfYPSDmUk7WttWL9ovKN4hxKcCjJoRSH0hiKDg5FOJTJoSiHwqmtcmqrnNoqp7Z6sra9dhJibAsXpzaGYoNDOVjbuI0qxZi5USaHohyKcSjOoQSHkhxKcSiNofjgUDi1dU5tnVNb59TWObX1o7Vd0w0xajsB5smhFIfSGEqcrK2M61qnEBkbRTiUyaEoh2IcinMowaEkh1Icysnaiq2fzBLbsqscHMrR2vZ1OWfM/aRGTg5FORTjUJxDCQ7lZG3nuvN8zO3O8/PhWTJPWzuJ8fVNpee6Z2nr/q40hvLwLNlfpmwrSx+eJftTFF8v274tj3h4luwVKcqhGIfiHEpwKMmhFIfSGEoPDoVT2+bUtg/Wdo413TCHbAsX2zgUfxZlWxfXcZKisSi27a88PEsWsg7J/c6mU/zKnn9woPrwLNkrUppC0Ydnyf4yJTeKnKRkLUrFRpkcinIoxqE4hxIcSnIoxaE0hiKDQ+HUVji1FU5thVNb4dRWTtb2duu6ud+6TiU5lHoSxWyjnKzt5VLyouS2bzvHsyjbvu3Ds2QR102j71FsHb5Nq/1dmRyKPouyf0B2kOLrkSPTtxFIfXiW7BUp8STKdiMLfXiW7E9RbC6Kj41SHEpjKA/Pkr0iRTiUyaEoh2IcinMowaFwaquc2urR2q7His/9seL68CxZrkekpeodSsb1xlszt7vo6cOzZK9ImRyKcijGoTiHEhxKcih1kNK5KL0fMz88S/Z6FB8cinAok0M5Wdu+nerp/ayTG4fiHEpwKAdre7m+fn3Zy/Vt3yjFoRytbduNsp11isGhyJMo2x2iNebJ75V1H8rLReX9XVEOxTgU51DiJKVlUXq7NBXJoRSH0hhKHqzt5fr6Spzs51dSOJTJoSiHYhyKcyjBoSSHcrK2kitxknvi+kmU7eEaWidrO/U67He5vr1ThEOZT6L4dp25TtZ23r5X5r4moYxDcQ4lOJTkUIpDaQylB4ciHMrkUE7WVsc6Ztb9VE/bkyj7qZ4+WVtd6+Iul9p3SnAo+SxKbZSTtTW9rkm4XMndv22bQrExOBThUCaHohyKcSjOoQSHkhwKprY2jtZ2rdRQ21ZqmJysrcc6ZvbteYcmwqGcrG3c9uJi2kY5Wdsc611J2d8V41BO1jYqFmV7fpBJcCjJoRSH0hjKHByKcCiTQ1EOxTgUTm0np7aTU9vJqe3k1FY5tVVObZVTW+XUVjm1VU5tlVNb5dRWObVVTm2NU1vj1NY4tTVObY1TW+PU1ji1NU5tjVNb49TWObV1Tm2dU1vn1NY5tXVObZ1TW+fU1jm1dU5tg1Pb4NQ2OLUNTm2DU9vg1DY4tQ1ObYNT2+DUNjm1TU5tk1Pb5NQ2ObVNTm2TU9vk1DY5tU1ObYtT2+LUtji1LU5ti1Pb4tS2OLUtTm2LU9vi1LY5tW1ObZtT2+bUtjm1bU5tm1Pb5tS2ObVtTG19YGrrA1NbH5ja+sDU1gemtj4wtfWBqa0PTG19YGrrg1Nb4dRWOLUVTm3PzpLZumVDbo909bOzZF+n+JMo7hvlZG0zdVFKNkpyKPUsSm6Uk7WtWkPE1S8HQ/3oLNkdysnaVvSi7N8rR2fJ7lCUQzEOxTmU4FCSQykOpTGUo7Nkdyic2iqntsqprXJqq5zaKqe2yqmtcmqrnNoap7bGqa1xamuc2hqntsaprXFqa5zaGqe2xqmtc2rrnNo6p7bOqa1zauuc2jqnts6prXNq65zaBqe2waltcGobnNoGp7bBqW1wahuc2gantsGpbXJqm5zaJqe2yaltcmqbnNomp7bJqW1yapuc2p6cJbNR15UaJmNslIO1tanXZVc2fW6UeZISN8q+UuPxWTK9fv6Z9yg2r4tGzHT/gIxDcQ4lOJTkUIpDaQzl8Vmy16MIhzI5FE5tm1Pb5tS2ObVtTm2bU9vG1DYGprYxTtbW53Vbu1xr3yiTQ1EOxTgU51CCQ0kOpTiUxlBkcCic2gqntsKprXBqK5zaCqe2wqmtcGornNpOTm0np7bzaG3XAyntcpZ2oxytbS9KTN8oD9c2r5T6/fPT903D1zxzXM6mbBTnUIJDyYMUy+vDS8P+gFIcSh+kXHbUrpTLx/GS8vgs2etRhEOZHIpyKCdrG36jxE5xDiU4lORQikNpDMUGhyIcytHa1vUR9JFDNsrJ2qbcKLbtJDw8S1brvH3d282OtrUX19uikXh4luwVKcGhJIdSJymhi5L7/6DGUB6eJXtFinAok0NRDsU4FOdQgkNJDuVobduuJ8vG6I3SGEoMDkU4lMmhKIdiHMrB2ubQsSi2nc2O4FCSQykOpTGUHByKcCiTQ1EOxTgUTm2TU9vk1DY5tU1ObYtT2+LUtji1LU5ti1Pb4tS2jtZ23SE6R4+NkhzK0drmmtwcuR0HVWMoPTgU4VAmh6IcinEozqEEh5IcysnaylpKk7IvpemmUHIMDkU4lMmhKIdiHIpzKMGhJIeCqW0OTm2FU1vh1FY4tRVObYVTW+HUVji1FU5thVNb4dR2Hq2tr4MPidgowqFMDkU5FONQnEMJDiU5lOJQGkNRTm2VU1vl1FY5tVVObZVTW+XUVjm1VU5tlVNb49TWOLU1Tm3taG3XDYgvx1+9UQxzSGacMwknZ8nydlvmy+69bJTkUIpDaQzl5CzZPYpwKJNDUQ7lZG1n3ii9U5xDCQ6FU1vn1NYb8wHF4FCEQ5kcinIonNoGp7bBqe3RWbI7lOJQOLVNTm2TU9vk1DY5tT06S6Z6e9aQbedXjs6S3aEEh8LZt03Ovu3RWbKvf0BHZ8nuUIRDmRyKciic2hantsWp7dFZsjuU4lA4tW1ObZtT2+bUtjm1bU5tm1Pb5tS2ObVtTm0bU9samNrWwNS2Bqa2NTC1rYGpbQ1MbWtgalsDU9samNrW4NRWOLUVTm2FU1vh1FY4tRVObYVTW+HUVji1FU5tJ6e2k1Pbyant5NR2cmo7ObWdnNpOTm2PzpLp7QY5WjulMZSjs2R3KMKhTA5FORTjUJxDCQ4lORRObZVTW+PU1ji1NU5tjVNb49TWOLU1Tm2NU1vj1NY4tXVObZ1TW+fU1jm1dU5tnVNb59TWObV1Tm2PzpLZWLPvNsdLytFZsjsU4VAmh6Icysnamq7nkpnNjeIcSnAoyaEUh9IYytFZsjsU4VAmh6IcCqe2yaltcmqbnNrm02pbG+VobWMuyvb8oDo6S+ZjvSuu2wd0dJbMbQ37edpGOVlbr7pSQrbjoMdnybJ/27Sn36Hk9Cvlcs15oxiH4hxKcCh5kuI3Su5dKQ6lMZTHZ8lejyIcyuRQlEM5Wtte5+JqbD+D2jmU4FCSQykOpSmUHoNDEQ7lZG0vO/WL0r5RlEMxDsU5lOBQkkMpDqUxFDlZ27Z1zNyeG0U4lMmhKIdiHMrB2tbwK6VG6kYJDiU5lOJQGkOZg0MRDmVyKMqhGIfCqe3k1HZyajs5tZ2c2iqntsqprXJqq5zaKqe2yqmtcmqrR2vb15ct2c/F6dHaSq93RW2jNIZiJ2srpusD8toowqFMDkU5FONQnEMJDuVkbaWvV1Rrjt4oxaE0huKDQxEOZXIoyqEYh+IcSnAonNr6ydrOaYuy71D6ydrO28HHzJeLXDsGh3KytrNyUfr3x0GXL777/P7Dh/d//9uHT9+//fL+08efL3/18tv/ePv5/dvvPrz77csff/n4/f/86Zd//nT9k+vf/+nzp+/f/fDL53f/eaX//tnl5f8N",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
