---
source: tooling/nargo_cli/tests/execute.rs
assertion_line: 309
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
