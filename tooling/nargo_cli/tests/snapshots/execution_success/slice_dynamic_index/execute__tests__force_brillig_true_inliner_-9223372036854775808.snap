---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
