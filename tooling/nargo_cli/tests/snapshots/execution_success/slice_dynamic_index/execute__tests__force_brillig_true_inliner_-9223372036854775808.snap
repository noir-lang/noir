---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
