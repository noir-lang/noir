---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
