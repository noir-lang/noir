---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
