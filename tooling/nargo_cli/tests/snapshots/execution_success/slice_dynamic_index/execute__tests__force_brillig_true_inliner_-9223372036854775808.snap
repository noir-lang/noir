---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "13819803046210490551",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
