---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "nd3bjiS3lYXhd+lrXQS5T6RfZTAwZFtjNCBIhiwPMDD87hOt6Yz09OYuiv+NUKXWp+pKroyMWEEy/vnpLz/86R9//ePnn/7r579/+sN//PPTjz//+ftfP//80/3dP//13ac//fL5xx8///WP//6vP11f/iH+23//9799/9OXb//+6/e//PrpD83ad59++OkvX77y2//X5x9/+PQHu/71n999kliL8RIu34qxFP16hH4r5qnQ61i0Y9GPhRwLPRV2/DPs/GfYsfBjEcfiOFd2nCs/zpUf58qPc+XHY+7HY+7HY+7HY+7HY+7HY+7HYx7HYx7L8ejuX0X3+FYsX6s+XkKu9q2IY7F8rUT6S+j4VsxTMa5j0Y7F8v0h9vzm074Vciz0WNix8GMRx2Ici3kq5nUslmOu1+ssQ7V/K/qxkGOhx8KOhR+LOBbjWMxT0a7loKu+Tvvs0kTaOennRM6JnhM7J35O4pyMc7IcffPXEdjSp1Vry9G3dj1kJNLOST8nck70nNg58XMS52Sck/Xoh34lfn17xXef+ZyTdk76OZFzoufEzomfk+Xo+/NGdp2JjHMyj4lc56Sdk35O5JzoObFz4ufkfPTlfPTlfPT1fPT1fPT1fPTX3Yq316eYW/rgW5crHxM7J35O4pyMczKPia1H31+fLz4zaeeknxM5J3pO7Jz4OYlzshz9eE7gQySReUzW5dfHpJ2Tfk7knOg5sXOyHP2Q+SKRSZyTcU7mMVnXYB+Tdk76OZFzsh79eJHR0vlY2DnxcxLnZJyTeUzWxd7HpJ2T5eiP/vpIGnko193ex0TPiZ0TPydxTsY5mcdkXfF9TJajP57Rn90S6edEzomeEzsnfk7inIxzMk9JXxd3H93O6Ovi7mOyLumv50ZA64no6T2Qvi7uPiZ+TuKcjHMyj8m6uPuYtHPSz4mck/PRb+ej385Hv52Pfjsf/XY++v189Pv56K/7sftk8JkSEpKRExQEDYImQOumbIcaQZ0gIUgJIokQkgghiRCSiGJO0tXkha6eUDEtaYMaQZ0g2SNPSAkygpygIGgQNAGyi6AiEfpMSbnSrIlunSAhSAmyLTJJyAkKggZBRSL8jdINuV5MMdugRlAnSAhSgowgJ6hIxLAHzTS4xdSzDZoAFRPQNqjtUXohohMkBClB60S09wf1fTs7IScoCBoF6g/qV0IToHUb9/9Ruoxf93E71AkSgtaJuG+4PkhTyocR5ATFHqXAzmLqqL/alvs2fypCZiOoEyQEKUFGkBMUBBVvwvl8arR0NJLrIqgR1AkSgpQgI6gY3P4eJ0nrQK5icOU5LN8XCQkVc8S7vH+SJTQBahdBjaBOkBCkBBlB4J0r6+Ks3fF6oTs0CU2A1uXZDrUCXW+U3hrrmW87JFvU0kqs9ey3HTKCnKB1IkSeGEk+RhT93gZNgIp+7/5rv1FKedHvbVDfIr0SEoKUICPICQqCBkETIL0IagSRRChJxLp1M79eh2VzSce9deu2Q4OgCdC6dduhRlAnSAhSgowgkggjiTCSCCOJKFo3lWfls8pMqBHUCRKCdIs0fagVrdsGOUFB0CBoAhQXQY2gIhHvNfTqedm9EKQEGUG+RdESCoIGQROgonXTeKORXoiiddugTpAQpAQZQU5QELROhF3Pyby1PLgToKLf26BGUN+j9EIU/d4GKUFGULHZiDxX1JY/qIt+b4MGQUUi5Hqjby/DtSgFN6htUSqktSgFN0gIUoKKRNg7Ed4ScoKCoLFH3wZWi6rOx3P95GmtuxZV3QYJQUqQEeQEBUEDoKKq8+u9KVE6GmlR1W1QJ0gIUoKMICeoGFx9j5P1hIrBfbaOaL7YdWkWP6m9f1I6GhVV3QY1gjpBQpASZAQ5QeSdW7Ru0V8rpe8vEypatw1qBO3nWabZWqpCkG5RmpOoagQ5QUHQIAjMvFW7CGoEdYKEIJIII4lYt27en5rYe6qJdd26bdC6dduhRlAnSAhSgowgJygIIolwkoggiQiSiCCJCJKIdeumQ15Ih6aPmnXrtkNOUBA0tsjyCzEBWrduO9QI6gQJQUqQEVQkwvVBkc7LRxA0CJoAzWuPIqFGUCdICCoSMd5o5hfCCHKCgqBB0DxHVuxGt0GNoE7QOhHzuSN5pzMSUoKMICcotqjnF2IQNAFaT8XboXUipvYHpaLT1v3eDglBRSKeFvtGaYvjZgT5Hs2EgqBB0ASoF4mwdyLSonTrjaBOkGxR+iS0Yl+5uwn+ikxzytdV3Q4NgiZA66puhxpBnSAhSAkq3oRDnkTMllAQNAiaAOlFUCOoEyQEKUHriVdXeyYpXal+tGKC3HsRouWFlVZMkPsYFRPkNqgR1AkSgpQgI8gJKgZ3Plv3tis/VmH9kvdnvtH9ZfokXHdhOyQEKUFGkBMUBK3HqcczuH2kd+66C9ugdRe2Q42gTpAQpAQZQU5QEEQSESQRgyRikEQMkohBEjFIItZd2H0a+JxQiVwJOUFB0ABoFpuqRzwfAPk8YjaCOkFCEBmnScZpFuMUzzb2kjapszkImufI1w3VfY7vb5QfNtQI6ls0roSEICXICAKXrH4NgopL1ucJaPeXCRWPQ9igRlBxyar2Ril7xUMRNkj3aCZkBDlBQVCRiJAHjYwmQMUjEjaoEbROxHvm7X2FZQkJQbpFaS6BFw9L2CAnKAhaJ8KeaWv3tVx6Exa11seoqLU2qBHUCRKClCAjyAkKgkgihCRCSSKUJEJJIpQkQkkiii7Mnj1pzdJMQS+WpW5QEDQI+h2LENPR6PcsS80ILEt1sizVybJUJ8tSnSxLdbIs1cmyVCfLUp0sS3W/CCKJcJKIdVXXr+dGXL/SjThfV3U7FAQNgiZA66puhxpBnSAhSAkiiQiSiCCJCJKIqB6R9lypRUbjIqgR1AmSLbL8sF0lyAhygoKgQdAEaF4EFYnw565QhCfUCRKClCDbopFOc4pScIOCoEFQkYjxRvPbFyKKUnCDGkGdICFICTKCnKB1Isaz3/J95yM9OLtoEjdoAlQ0iRvU9ii9EEWTuEFCkBK0TsTQpyYemh6iXjSJGxQEFYl43+Ef+WnqRZP4MSqaxH9HqbyNokncoE6QEFQkwt+JSLtvRNEkbpATFHuUAls8fLXZq5C+v0yoeDBqm6/s3UWyJtQJEoKUICPICQqCBkBFVTeetaw2UgUURVW3QZ0gIUgJMoKcoCBofViezxyq+z5sGtziCaXXc2P7vpOYDmHF00Pb87iq+/7elZAR5AQFQYOgCVCx7nODGkFCkIJjebGEc4OKwdX5Runko1jCuUFji1IzH8USzo9RsYRzgxpB68F9T6L1q6cXYl1r7ZAR5AQFQYOgCdC61tohcsYyiqW2z5a8njcIj3VDtUP7xddpS94YThBYfB1jEAQWX8e8CGoEdYKEICXICHKCSCImSMQonuLZn2WpPW+vPorneG6QEKQEGUFOUBA0CJoAFc/13CCSiGI7s/tk/Ctq85KEhCAlyPZoJLTeAmfas8HdtIwCoGJnsg1qBBX3CZ/pUP1Ku0yOLgQpQUaQ75EnFAQNgiZAxSZjHwdWOkFC0PpNOPuzRdtMJ1Sj2GRsg5ygIGjs0UxoAlTsTLZBjaAOjhHFzmQbpAQZQeSwrOSwXOxMtkETIGvgGGHFsfzZLeD+Mn0SmhCkBP2OOR/pTWhOEJjzMWwQBGYBDb8IagR1goQgJcgIcoJIIsi8sFHM1rJn55duM50tF7O1NkgIUoKMICcoCBoETYDWtdYOkUSsu7Denkej9Zbm+I51F7ZDSpDtUfp8WndhvT279Pc2MgqA1g3VDjWCiubjWRve89rwMYUgJci2KH98TicoCBrnaF7XefZmUWttUCeoeBPa83bPtyhmUWttkBHkexQJBUGDoAlQA2/32RpBnSAhSAkygpygIGiCt3v/HZ1lSnlvBIEWe3YhSAkygpygIGgQBFrsKRdBjSCSCCGJKHbx6s96d+0zvTWKXbw2aBA0ASp28dqgRlAnSAhSgowgkoh1rXUfVZ8zFrWW0CBoArReufj/UfrUKLowjef9pCO9n4oubIOKK+pnG/ye14bPoqHa/KQgaGz/ej2/ehOgoqHaoEZQBy+5k3EqGqoNMoKcoCCoSMTzeKqen2k1i5WLH6Ni5eIGNYL6HllCRSLehbTZlZASZAQ5QUHQIGgCVHVhH6MOPgCKWmuDlCDbH5bTZcNwgoKgQdAEHzVFgbZB5IN6kg/qSd65RRdm83r3sOloVHRhGxQE/Y4WOw3unOeoXReosW/VkOpICVKKlCHlSAVSA6lJVEPZaCgbxU718dzl1vzYqVsZUo5UIDWQmkQV+9XvVEOqIyVIoWx0lI2OstFRNoqazJ9l493TqsFbTaKKomyn2laN/HutqzJtz/WLtjTF6laClCMVSK3fy83tUWkbz1tNoorCbKcaUn2vRlaClCJlSBXZmM/jr+77d1kFUgOpSZRdSDWkOlKClCJlSKFsGMqGoWwYyoajbDjKhqNsFOXb5jOlaN92ypFan5n7fK1Y63HlM9iigNupSVRRwe1U26rFeBUl3E4JUorUOhvxnpuxOvsqiridCqQGUpOooozbqYbUOhvxfC73SFtz30qQUqQMKUcqkBpITaKKLm+nGlIoGxNlY6JsTJSNibJR9IDzPRMgP6ztVgOpCVQrmsCdakh1pASpZTbkbj6/KrlrpKwMKUcqkBpITaLWTeBWFdmY+laeVUdKkFKkbKt6zmExt26nAqmBVJENfY+y5VejX0g1pDpSslbPVYBcsVCKlCHlSAVSA6lJlFxINaQ6UkU2ZnvUnFkpUoaUIxVIDaQmUeuGU+7X9qWaXVk1pDpSgpQiZUg5UoHUQGoSZSgbhrJhKBuGsmEoG4ayYUU2nk3qZNGZNwukBlJFNqK9VT5u+IVU26qRz2C9IyVIKVLrbPTnzqP0tng1HKlAaiC1zkaXJ1Fd86ux7kW3qm1Vmr98q46UIKVIFdl4J6qn+VS3cqQCqYHUJGpcSDWkOlKClCKFsjFQNgbKxkDZGCgbE2Vj3YvK+6mj95f5aLPuRbdKkFpnQ67xVvmaaN2LbpVv1aJzWPeiWzWQmkD1dS8q8u4cJHcO/WpIdaQEqSIb8U7UWLwahpTv1cgqkBpITaKKXlTlNflYVPMrv+5Ft6ojJUgpUoaUIxVIDaQmUR1lo6NsdJSNjrLRUTaKXlSfu2ai+a5ZL3rRnQqkBlJFNp7948XS41fuQvpCqiHVkVpnw/y54rD0ZOFbKVKGlCMVSA2kJlFFL7pTDamOFMqGomwoyoaibCjKhqJsFL2ov89FvacZyL3oRXeqIdWRWmfDn+VY4p4/HYpedKcMKUdqnY24nlGO3GL1ohfdqUlU0YvuVJGN4Y+68qtR9KI7JUgpUoaUIxVIDaQmUUUvulMoG4GyESgbgbIRKBuBshEoG4GyESgbA2VjoGwUvWjo+xil+Sq76EV3SpGyQrW3ykfRohfdqdgqs6wGUpOoohfdqXU2IuajFldSRS+6U4JUkY2Qt8rXREUvulO+V5FVIDWQmkBJ0YuO67lezg8evVVDqiMlSK2zMcZzfjjSZku3MqQcqUBqnY3hzztljMWrMYkqetGdakh1pAQpRcqQcqQCKZSNhrLRUTY6ykZH2egoGx1lo6NsdJSNjrLRUTY6yoagbAjKhqBsFKvUr/Gs9G/XlZUiZUg5UmRFvFQr4jdqElWtiN8oskZVVJBaj3KX9zaNtlCGlCMVSO23Cc33RkUnUQY2Cr1VQ6ojJUgpUoaUIxVIDaQmUY6y4SgbxQN97wuGr8pHvqKX4om+O+VIBVIDqUlU8VjfnWpIdaQEKZSNQNkIlI1A2Vi3jirPnSy9f4msJlHr1nGr2lbltkfWraNqf10vq8pCCVLr47w+a1RVI3cp6yZw+7MGUnP/N8znAOsmcKsaUh0pIa/8ROO1bgK3ypEKpAZSRTae/TfU8r4iel1INaQ6UrJV6dmhtyqyMZ4rDp2elSHlSAVSA6lJVLuQWmfD+nu80tNBbtWREqQUKUPKkQqkBlKTqGK/yp1C2egoGx1lo6NsdJSNjrLRUTb6/kwvn32pXEg1pNajLPN9tMl3pbXo9HZKkTKkfKsWn19Fp7dTA6lJVNHpfXwGq8UulzvVkRKkFClDypEKpMgVhxo6zhs6zhed3ns2ptqQrAQpRcqQKo7z70ba8+w+LTq9nRpb1S2rSVTR6e1UQ2qdDX9ms6jndVK6nrW4VYqUIeVIBVIDqUnUuj/cqoYUykagbATKRqBsBMpGoGwEykbRH/oz++jOXD5GFf3hTjWkOlL7ve4Xx6iiP9wpste9DkcqkBpIkecg6LyQakh1pAQpRQplY6JsrPvDsKftCc8rx23dH25VQ6ojJUgpUoaUIxVIDaRQNhrKRkPZaCgb6/7Qpb3uL7vkdVK27g+3ypDyvZpZre8hyrMnxv3lQg2k1veX7272pbTnV37d6e1+VhekdP83bFkZUo5UIDXQK4/Ga90EblVDqiMlSBXZ0PEoWyhDypEKpMZW+ZVVkY1nr6r7f5DOYE0vpBpSHSlBSpEypIpsxHu8pmQVSA2kJlF2IdWQ6kgJUoqUIYWyYSgbhrJhKBuOsuEoG46y4b/jTC+fb7ghhc70ipmE8qyUdMmr/KyYSbhTk6hiJuFOta1afH4VMwl3SpBSpIycwRYzCXcKXQUEugqISdS4kGpIoSuOga44BjrOD3ScX3d6fl8DvtR9apzVQGoSte70tmo9yvZ+f90HpKw6UrJVeUarrTu9rTKkHKkiG89Kf7ecKL8upBpS6/Hy9ror7d4jK0FKkTKkHKlAaiA1iVp3elvVkELZaCgbDWWjoWw0lI2GstFQNjoa5Y5GuWgC3d7KF0qQUqQMKUcqkBpITaKKJnCnGlIoG4KyISgbgrIhKBtFE+jjtSeGx9WyGkhNooomcKfW2Yj2VpJfjaIJ3CnZKs1nKUUTuFOGlCO1zkbYfFRoVgOpSVTRBO5UQ6ojJUgpUoaUI4WyYSgbhrLhKBuOsuEoG46yUfSHMd9rOfOKJy/6w51ypAKp37ESOR+jfs9K5KzQSmRHK5EdrUR2tBLZ0UpkRyuRHa1EdrQS2WMgRVap+0DZGCgb69l9o49XAzN6Xg3n6yZwqxypQGogNYlaN4Fb1ZDqSAlSKBsTZWOibEyUjfVK5PvXfTq9mfec8fVMwvuvoI/KT/OMotObLm/VslKkDClHKpAaSE2iik7v/cThuK6ZVUOqIyVIKVKGlCMVSA2kJlEdZaOjbHSUjY6y0VE21k3gfei6HpXn9sS6CdyqQGogNYlaN4Fb1ZDqSAlSihTKhqBsCMqGoGwIyoaibCjKhqJRVjTKikZZi1F+dv29P7mvrAKpgdQkyq690qyKUX7mVNxf5mOvdaQEKUXKkHKkAql1Ntpzh+4+P4usJlHrTm+rGlIdKUFKkTKkHKlACmXDUTYCZSNQNgJlI1A2AmUj0CgHGuUoRtme40bLT1CKmESNC6mGVEdKkFKkDClHKpBC2RgoGxNlY6JsTJSNibIxUTZmkY1n3+/76j1/mk9HKpAaSK2z0dtzttxbOkaNYp3ve6fr+zq8ZSVIKVKGlCMVSA2kJlHFOt+dakihbDSUjYay0VA2GspGQ9loKBsdjXJHo9yLUY63mgslSClShpQjFUgNpCZRRRO4Uw0plA1B2RCUDUHZEJQNQdkQlI2inRN5zm0kPz18rOfpbZUgpUgZUo5UIDWQmkQVnd5OoWwYyoahbBjKhqFsGMqGoWwYGmVHo1y0c+/VcPc9hoXqSAlSipQh5UgFUgOpSVTRzu0UykagbATKRqBsBMpGoGwEykagbBSdnj67hIX2dMdnFJ3eTjWkOlKClCJlSDlS62yoPDMWVHtWA6lJVNHp7VTbq5FVR0qQUqSKbPjTz+vQrByp2Kp893YUnd5OTaBmsU/gThV7wV3PK295T6dZ7RO4UbJV0rNSpAwpR6rYJ/CZw3nfgR5ZDaQmUdU+gf+m8tqKWe0TuFEdKUGqyMa/70mYM98MKUeK7CE520CK7CE5+4VUQ6ojJUgpUoaUI4Wy0VE21k3gfYr6Fc28b/Jc94AbI8AoMAaMAxPADGDmuVnPANwYkAMFOVCQAwU5KJrFuJ53Q7T8uVG0ffG+Z7JY2TyLtu++v/JWaXXdLNq+nWpIdaQEKUXKkFofX8PeKvJnb9H27dRAahJVdIQ71ZDqSAlSipQhhbLhKBuOsuEoG4GyUXSE79XGMfITtGbREe6UIKVIGVKOVCA1kJpEFR3hTqFsDJSNgbIxUDYGykbREY7+nAOM3KXNoiPcqYHUJKroCO+G+FEzn0cVHeFOdaQEKUXKkHKkAqmB1DxX/boupBpSHSlBSpFaZ2M+O7jHfQqZlSMVSA2kJlFFR7hTDamOlCClSKFsNJSNhrLRUDbWbd+42usie1yiWTWkOlKClCJlSDlSgdRAahIlKBuCsiEoG4KyISgbgrIhKBuCRlnQKBet4WXjUSFZNaQ6UoKUImVIOVKB1EBqEmUoG4ayYSgbhrJhKBuGsmEoG1ZkY77W8YyWrmFvNZCaRPmF1Dob7dmZfrSej1Hr/nA0lUfZyMqQcqQCqYHUJGrdH25VQ6ojJUihbATKRqBsBMpGoGwEysZA2RholAca5WIvwPtGy0v1tHvQrQwpRyqQGkhNooq9AHeqIdWREqRQNibKxkTZmCgbE2VjFvtEdn1Uvgpo14VUQ6ojVewT+T6P6tGzUqQMKUcqkBpITaIa2EP0Vg2pjpQgpUgZUo5UIDWQmkR1lI1+nI1/3d/99/e/fP7+Tz/+8PfbfPnDf/z0518///zT129//Z+/vf7kT798/vHHz3/9499++fnPP/zlH7/88Mcff/7zlz/7dH39x3/0+xf+rnfpX/4+X75vw+7v23V/r7993+W73mLc39tv/734/efzy59/Gcpbju/ufzfv7+O3P7/vLt7/Mu7vx29/Htd3XeWL//LC3l/O+/vZ7u9/ez+pf2e/fdP+7/8uX/42dv+e9+/6vw==",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
