---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
