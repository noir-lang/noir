---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
