---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
