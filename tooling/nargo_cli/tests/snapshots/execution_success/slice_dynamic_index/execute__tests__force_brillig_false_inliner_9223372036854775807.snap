---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
