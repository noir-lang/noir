---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
