---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
