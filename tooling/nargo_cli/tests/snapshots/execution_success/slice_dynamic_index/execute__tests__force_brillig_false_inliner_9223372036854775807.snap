---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+2dB5wdVfXH78xuSG+kQGjZBJDQ39v3toQSEkJCM0BoKpGSsiuKEBT/8Acx9GJDQRT+gArSERGlSG8C0kERkSYgTaUJSBFE/jkvM9l5s5NVmO9Z57j3fj7hZQs3v3N+v3PvuefeuRO4JW1kg3OtDUv+3hh9L3TdWxB9To0+S/lameirc0mbmwE3b9/l+C9hhg/C+IuG6FO+0ZQC0KDosEqptVrtaGvuKFfKc0vNk+e1t5SqLfNa28vt5Zb2lgXN7ZVKR3u1vW3yvMltpcnlaqWj3Nkyubkz6ivI31elM+EgDSLTgsuLM+C4KGnibDCCsxHWthbOfhzOZk2cy3E4K5o4+3M4q/EY2S/6lK8bo6/FH/1d9xam7Cnla8S4utQ3Axw7rmY1yO7SsvRRytfKAwxgHKiAUR3oRxVUx5LJdYHR7K4tA65Kdjco+hwcOyTO7uQbTSkARc7uBjluFBqsRCQ9Kw1yOhFd5NlmiOMGB6uzzRADGIc6Z2O2GQqKMx48/1VqFybsUBBeuS8LD11KKhPVp/PRYc7ICJEESkw5FgXVaADjcGdEUCTQ3lzgAKPK0kVIBlyVBc6I6HNk7JB4jpYfPJn6nvxSUwoUvegByiVLFz0jHJe7jFQiN72YyIuTtHn5DJs/ap9JHS0faasx+jprxKcXgyNgW+I2ShPwKLfs1eZH7X+U44J1NGivlg9Hu2WP9B+1/9GOnUppu0dGdlOVirhfku8xoA+Tg4v0O8H17sY1MDnEFbHWDLgqM//Y6HOF2CGxA8e6rlE5/p78UlMKFD3zJ52Yd+Yf6zihrgCTSwf7gIgzuixJblytyOEqWV0jkj7QwjiOxkiLXYQ+jhd7daySE/MWRDR8aGHAWMn5AYP0gRbGlUmMVolqMIBxFU+UjTLtqp6oUrmfAYyreaJK5eUMYBzviSqV+xvA2ERilElZyIoPG8gEKGOrhK0ooilBntYqBS6RNBdtlRLbu3OoWw8t5Wu1ctDKjt9smQBiTPow56qxM3TZdU8Kq1tG3JTyNRMrngkkRmPb073+dNXE6HP12CFxQXqi616kll9qSoEq8vb0RMeNRKvD5GqMwBMdP9NOdLozD1Vr09RhKV9DN0vWAPtSnsXUZog1DGBck8RolSgLdbuPeaJs1O3W8kTZqNtN8kTZqNut7YmyUbdbh8Qok7L8iet2MgHK2CphK4pYJ0GexiplTcfXidYFMdJ1ogbXvVFYtXiykGGvq4Cx1ihxRiLoIJd/63FGV5TFqUb8egYwru/6oDg3gMVpcRtwAwMYN3Q2xLmAFGeJM7pqdeQsGcBYdn1QnM2wOC2OnM0GMFZojBp7kGMdv81SBQ23KlDSB1oYW0iMVomysO3Q6omyse3Q5omyse3Q7omyse0w2RNlY9thIxJj8i4yaTIBytgqYSuK2ChBnsZxYcmMQthBLSDGjUFnh67r8fxko+zWEpyFDJvkqY4cWJwVsj6xiTMjTjXiSR9oYdzU9ZI4iRGZ6muKY0c2DVvB/aDaJvqGjp/N1gdt3kxJiLDNVVKHU50fJEkfaGGcRmPUOCVTcXwa/MmQNVwjTZcRmD7LXwYxbg7iovmgJwThA8woyjJRb+a6Wl5O4lNWWjE4TUHjc5RjsJSv1TjaXKHfpN15+f4wD/UV6FrSuRlwqb7rHuqbHn1uETskfoBPvtGUAtCg6LC8D/BNB3FtAROp8SCb2EsP4uSlUTM4XGZ3gUkfaGGcSWOkxS5Cn8mLvTpdyYlFvWWu6APGls4PGKQPtDBuRWK0SpSFYyNbe6JsHBvZxhNl49jItp4oG8dGPu6JsnFsZBaJMX5SNT42IhOgjK0StqKIWQnytFYp9C1zRVulxPbuXvDapPhNMtUQ5nk7EOPuYJ0zTOg+2SisbhlxU8rXTKx4tqMx0gAnuiXL+754oZfYXeQLvci69PZgX8oDhlowbm8A4w6u4AOGiFJA0rPjbOdnx74m9tkKGGuNEmdcWCdH4h05o6tWR+IdDWDcyfVBce4Mi9Ni8WNnAxh3cQVPE+L8ms7bdwUNtypQ0gdaGD/hlAVKVN0EZKhoeO6TtM6M2NXyWAtiJ3mqIwcWZ5VMFT7l/EhM+kAL426ul8RJjMhUX3McO7Jp2AouMGpVmV0cP5vtBNr8aViItK3iQzBYyqLBT7uuRtq+rBgs5WvVKSDfuzt2gghd90b7lB58SR9oYdyDxNjoul7ok2408CGgWJN499QELJ3Ts8meIMa9QFxaPtzL8evBvRwbqTS+KZHd9KxHjvhzlX1YytdqRam5CtzMc36mI32ghXE+idEqURbOny/wRNk4f97hibJx/rzTE2Xj/PlnPFE2zp/vTWKUSVnUGR/mkAlQxlYJW1HE3gny6BWAvEE8mbkTqwDJtNijleVmcHVRlwnmtfezHK5a9r+c694ou51SMFjI/kme6sihi7BkMH7OmRGnGvGkD7Qw7uN6SZxkjSdvX5937MimcUvRHgo+3BfESN7u1ZvFe+L+h+gE5Pwk3v00Ae/n8OOb8/cDMS4ERarlw4WOK8DGPlzo2NFTYyDZy/GF5/2dzqyhscSgbP4CpxuVK/1Ei/srcP1FV2yNCy9fdHRsd8zTtjsvLzHfdMzsD2I8oODakXnhAAVuvgTabbWWRvpAC+P/0BhpIYk4BST8uPBcMDDrnJjX3gOdmcBRq2lZCBySJ7+jrYjxIE+UjR3t//VE2djRPtgTZWNH+xBPlI0d7S8rYMwEmjc7PZQD2pnESdf5DwD7+gpINGlrXIKVN1nMBfubEvXXyIq8ZSzYF/hKsBZyX22RYwOZLm2JreCGZ1n2EWVPjR5nDgP9mPU2ERqvjBGLHL69Mg+oUsQvtai6jAb1Xfd2ksOjzyNiR8dvJzncdW1yxt+TX2pSJoV6A0oWKXnfgHI4aO8RsFg09swOd5j4ljbpgx4ohWMwKyuLFg9T8OmRsB/pzFY4P9LhA2Pb/gW3Ox57YF22kontUc7WJCtJ31G8luYDiWmvT7JHR5/HxI6OJ1T5RpMyAfCEOh94SevSCfVo0N5jlIRB83K0K/ZgKLo5UqFf8J2DbVp2H8X320K81DhOZhXs7hS7D3BdDcLa/GHeC1nK1+quOCh9xBaddZqfAVdlUjg2+jwudkg8Kcg3mlIA6Pu3gTshlg7ixzpucDxOiUh6ED/WsYN43OiVEXn3x/EgrqxBAbRbrfZ/vAGMX3U62lQFmveIqgyQcjwufjJQvm6Mvpbdv/7R98Po95SEp3bKxoLw0AMmykSpOWGAAYxfc0ZGiCTQvPd/WxWUhUMmX3dGBEUD1Rg9pjg+X/0GaLfVQCJ9oIXxmzRGKwI9wQu0TPpAC+O3nM/xTJyk/rYnysZJ6hM9UTaS3JM8UTZOUn/HE2XjJPXJJEaZlAe6rgqgTIAytkrYiiJOTpAXwoZIRpxM3Ym9e8m04L37TvAkbl0mmNfe74JCCCMdpBtlt1MKBgvZP8lTHTlwQKIvaPieMyNONeJJH2hhPMX1QXGe6lhxWkx1SB9oYfw/EmNvXkB2PCjWJN7TNAFL5+mozQv+NBDj6SAuLR+e7vgq7+mOjVSNM4Aadp9RcLtl1D9Dwe7vO586kT7QwvgDEqNVoixU9X/oibJR1T/TE2Wjqn+WJ8pGVf9HnigbVf2zSYwyKQ9yXVV9mQDPXPxHwlYUcXaCvBA2RCr6ycydWAVIpkW/8QNcXdRlgnntPYfDVcv+B7nujbLbKQWDheyf5KmOHLpwSgbjuc6MONWIJ32ghfE810viJGs8efs637EjGz0zyjOtYEW7Vnc7xfH1pwtA8Rh968eCJN4LNQFf6PDr0hZcCGK8CBSWlg8vAoMg9uFFjh1BNS6qON0V+5XdP1b2YSlfq2n7xwrcXFxwuyVmLlaw+yeg3VZrDaQPtDBeQmPUCCABCV/g0AIGZp0T89r7U2cmcNTW/BYCh+Spjhx6zX8xKM5LnR/VSR9oYfyZ6yVxkulR3r5+7tiRjU6npb4BFmPKUuO4wPEz7mWweGg/imZAgZdFN5cp+PFy2I/0ICHLncsdvlyeX/Slnix5xirwfYVjJ0eLJ4lJH2hhvJLGSAtJxCkg6YHzShDjL5wZsastUyyIneSpjhx6mULc8hmL8yrnR2LSB1oYr6YxamzTgSBrFfXLXXcR5U25NMjRuqjmGscGZ1aj+ndKwid9oIXxWqecJpXytVowXcv3WwXvm16gYbdWYF7nfGCSPtDCeD2JUbZVBrt/fe2rNI395WtBAUt/17tiX/pwPWjvDY4N2MGue6PsdkrBYCFgSZ7qyKHXYOSBjxudGXGqEU/6QAvjTa7gaZ5WufZmWKDOoEBJH2hhvMUVXKAizlucDukaa6abXKHXTLU3EchrN/6dlNTK2uqXjh1shrjujepfy7ekD7Qw3uoKPtiIOG91vuiRF2scmLc5H5ikD7Qw3k5ilBllqPvPFT1uBQUs/d3uil30uB2091eODdihrnuj7HZKwWAhYEmenDJRffq2gTtcwVMerQLAnc5P/aQPtDDe5QouUBHnXU6HdI31wx2u2AUADbtlEJnj+EHkbscOIlmN6j/uj/Yt6QMtjPe4gg8iIs57nA7pGsE03fHBdK/zwUT6QAvjfa7gwSTivA8UaFzZmu76ZmDe73xgkj7QwvgAiVEqSsPcf6ZKFgfwVEjA0t8Djq+SgQNCHXl57f21YwN2mOveKLudUjBYCFiSpzpy4ICsTgfF+RtnRpxqxJM+0ML4oDOQ5j3I91ud47gZQgRq8eyahcvcf0titEqUhcvcH/JE2bjM/XeeKBuXuT/sibKxvfp7BYyZQPNm5Y9wQOdK8jDcLSkTSJOJWuYAGV5EueKUR6KfNUafoeveNOpjefuK8rq5GXDz9l2O/5L0xaPR52OxQxqiz0dd13268ffkl5pSoOCb84i7dZsj0ZUfdZyAH4PJ1bim9VGHiWVpy8JaytfUjls+DtotQTLcdW+kXzV8S/pAC+MTNEaNYBKQ8OA2lzz2+ARo7x+cmcBRK+haCBySpzpy4IJuC/ms55Og0clsRvptcs6MH55yfnZ7ygDGp53y7FbK12qn9J52+PmFNnB2M5V2/tH5wCR9oIXxGaccmETaKSDhN9BVybTzGdDeZ52ZwFFLOy0EDsmTCkCtkf05OwJVI5/0gRbG552BkV1AwiN7BzmyPw/a+4LzI7uFwCF5clZHOAuHUf7kibJxGOXPnigbh1H+4omycRjlRU+UjcMoLylgzASaNzt9mQPaYlVQLxvA+IozIqhXOaDzNBwpy8SXHF3x76jQFX8tfv7K4Zwvq4WRruu1HdK38C8ZuiR/kle8GPn7lR5sKuVrfZ7T1zicbWHEabrRfqA18JoBjK+TGCX4lnfFCL7XHR187BZqGPkq3TAylHxroRzzhoNFPcp1PfL8nxL0G7ygW4p+JkBGfcEYsnZ3kgd//gb6MHkASvptcvUtZP3bRvrhTSU/vBn5oTefFRgJ9BVJrS0Dbt6+M58VeCv6fDt2SOzAt1z3ZwXedvrPCiSdmPdZgbccJ9S3YXI1diPfcphYljbhd7Trmsgaevgj7cMEXF6bcwRcOfV1cwZcqu+6gHsn+vx77JA4uN5x3QPu7wkQLkGAlhM/ZF+lVF/ld0BcfwfJNSrKcgZcFVG+G32+FzskFuC7rrso33O2RPkuiOs9kFwhYJTDCO7W4v764lruHzRGGqCMlCJMao0SC5Qcgd8H7XWOXo91LIh9SIrmfUevl8pVkpN/cvbWZoDRrnsjOdeIHQsDEMmT1Zy64jhx9Zi+fJB0RjJV+SDje/KfqSlQRU5fPgBxJW0v5SOg4hd6PYsyiJwQpgUoP0h/LzQmyiDgcIWBDrl0akUGYkPATTVm1xFB8TE20hhpgLUZLii22PuBYpc+6HVE7ENSNP0Cfh1BcrIcKGyr6wgLR89JnqyuI6qOE1ePKVv/yAkD0ulZ/4yUbYCxlK0/mLIN4FK2ql/c9izKgZETBqUFODBDlIOMiXIgKMpBgQ65dGpFBuJgbnpotrqOGBwUH+OQoq8jRJQDg2KLfWjB1xGxD0nRDFVYR5CcDPPrCBNPRpI8WV1HtDhOXD2mbMMjJ4xIp2fDM1K2EcZStuHg6DGCS9la/OK2Z1GOjJywfFqAIzNEubwxUY4ERbl8oEMunVqRgTiKmx4qVtcRo4LiYxxd9HWEiHJkUGyxjyn4OiL2ISmaMQrrCJKTsX4dYeLiDpInq+uIVseJq8eUbYXICSum07MVMlK2FY2lbCuAo8eKXMrW6he3PYtyXOSEldICHJchypWMiXIcKMqVAh1y6dSKDMSVuemhanUdsXJQfIyrFH0dIaIcFxRb7KsWfB0R+5AUzaoK6wiSk9X8OsLEvXIkT1bXEeRD/j2mbOMjJzSl07PxGSlbk7GUbTw4ejRxKVubX9z2LMoJkRMmpgU4IUOUE42JcgIoyomBDrl0akUG4urc9NBidR2xelB8jGsUfR0hopwQFFvsaxZ8HRH7kBTNmgrrCJKTj/l1hInrhEmerK4j2h0nrh5TtrUiJ0xKp2drZaRsk4ylbGuBo8ckLmVr94vbnkW5duSEddICXDtDlOsYE+XaoCjXCXTIpVMrMhDX5aaHVqvriHWD4mNcr+jrCBHl2kGxxb4+vI5YFtl5cW4ABqX0Qa93Yq5Jca+vsN4htbOhX++UNzAwUG6ogNFlBVEpX2smL4ku2RGnGvElA+IsF30WF1GWA25Gi2cMrferwEHZSgZlsw/KcrOBoKxYCMoKH5SVvvaaiuRN8FRfVVA8yTqM9NvkzL6egay4LsUX/yXpi5bICa3pQlZLRnGrNXJqshX59Qwt4PqlNWDJpde8UxJkgnyYnTkt3OHbRs6cVomycElauyfKxi0Ukz1RNh7z28gTZeMc9caeKBsHVTbxRNmosG9qpMJOLMW6lifgUsyqOKcYEOdmJEZZg41xXa/2k/WOpNKSpUkCIHOLDFubBl0C9ksYHYxTrZ5jzBE13Y51OU5cPR4ZmxY5YfN0BW1aRlVt84SBcaOPjOUYfrsdGZsGDuWbw+TSpW4ZsaYFbBROC/ipug3kZDq87zbGdW+U3XF/fbF6SPLki1KKGLfwU2/vvWl2RuSEmelpdkbG1DvT2NQ7AxzmZ8Lk0lOvLBRmBGwUzlCYettBTrb0U6+JxdSWfuq1sc2wlZ96e++FlFtHTtgmPc1unTH1bmNs6t0aHOa3gcmlp16pz20dsFG4tcLUOxnkZFs/9ZpYTG3rp14bG8cf91Nv773DbVbkhO3S0+ysjKl3O2NT7yxwmN8OJpeeemVbbFbARuEshal3I5CT7f3Ua2Ixtb2fem0cBdrBT72999qj2ZETdkxPs7Mzpt4djU29s8FhfkeYXHrqldMoswM2CmcrTL0bg5zs5KdeE4upnfzUa+Nw585+6u29N4XsEjlh1/Q0u0vG1Lursal3F3CY3xUml5565RDoLgEbhbsoTL2bgJx8wk+9JhZTn1CYdVxWEJXytRbysfxP2hGnGvGfNJBufIrGSAMUUW4W6DzuThpOB+NYt+TuDai/2sU6U3h+WscCnCy5D6VznpZ+PhXQ/ZarnN0dFQ27ByzuY47j42Y3eGDPalT/cX+0b3czMLDPITHKMkcE3y/qUL5ujL6WjYf+CfJowYmIxRj4npjmOUrOzmvvp+EAG+u6N8puLfFaCDCSJ6dMVJ++JGd3T9TiEcoAxj2MLJTrpo68w/2edoZ7NeL3NDDc72VEnBVSnHO9OMtzDYhznhFxVklxzvfiLM83IM4FdP41zNkjykKi3OGJsvH0YKcnysazJp/xRNk4mby3J8rGObbPFn2/UjLcPRROjkx3XOb8OdiJGj7ci/dhM+nDfQz4cB7vwwrpw88b8OEC3odV0of7wj6kzzGIrWDxuWWOy97XLuVrrQQnyXMMcYNxzgVxtjW6rlOu6aZxHoHB3bEgiXe/QBHwfgH/7sb9wGOqC8F9Zy0fLgQPb8U+XKhU74QHvzaSn/1Bm5PH2qXfJh37a0krWFWqTci7KxwG/EKxJ9GaHzthP35OwY9fNODHz8B+3EfBjwcY8OPesB8/r+DHLxnw42dhP+6r4Mf/Af3Ym0knOf8m8R4YKAI+MOCfjzoQFNlBBU86xYcHKQTBQSaSznKVFP3BoM2ScK64+M+AqD9JuiRhkMlOBmoZZB5Z/H35Nw913Rs9+JJ+OoTzU2sY+SndKLvj/ui4O0QhPmiMhzoQozJRffox+C8rDbaqKUYpZ5M+6FFOZq2DA3YW/HKgS3jOumbdfbX064WJOmbsyyFgX4caTdFJ3Em8XwkUAX9FIQAWFTytFrsXJTwM9ZuJNa/9EqSLFDbhyeA/DBR+6LIbyZGGpg4zkIkcTmKU2Wic+2gPUpbytdoAczi+oTW/kxy4jsCcXWkOI187naBQW0dZCIojSIzKRPXpM91HeqJsnOk+yhNl40z30Z4oG2e6j/FE2TjTfSyd8GgcY1qksKN0nF8Clo8zkO0e31cF+lUv0PJXDQj0a3SNYhX379Uo6AKbiPh4sJ4g/YlzqHt6ox2GuppHKV+rIy+vvV+HA3YV171RdjulYLAQsF+nc1NFovp0/eQbnigb9ZNveqJs1E9O8ETZqJ98yxNlo37ybYWEp9bS2T2RjVN9nQhm4FmkELYeFfDnj8iVx1EgHyfBItTg42iej2aSj6NBPr5jgI9jeD4qJB/HgHycbICPY3k+qiQfx4J8fFeZj1K+VhtXFuGndTo7yDn4e0bPnJK4k3hPCRQBn6Jw5vRUUAxadp+a8DDUb+ZBe2IABU/b1BK9byicYT0S5Py0QJeTUr5W8yFYGCrLouMkhX220w348QTYj99R8OMZBvz4LdiPJyv48fsG/Pht2I/fVfDjD4qdZKqdG7gkLPZiZ0hkN12cIR/o+iGo76LzYeF5nTOVqqy0L8/CcJY7JD5Wc12P7Eu+J7mKzLMyR8j4JjoV35wVLNumUr5mYjH8I04fbWHk93SD+lc7evEjhRihMZ5FYlQmqk8fvTjbE2Xj6MU5nigbRy/O9UTZOHpxnifKxtGL8z1RpfLLBjBe4ImycfHThZ6oUvk1AxgvosWkVTSgCixZRYNSzuYSLWTtn0zeb/hjeMc8vnxc+m3Ssb+2uX0a6APp72yFIuXZIMaLC75xc2pUQCQ5OUeBk3NAjD8xwMkZMCfnKnByLojxEgOcfB/m5DwFTs4DMf7UACc/gDk5X4GT80GMlxrg5IcwJxcocHIBiPFnBjg5E+bkQgVOLgQx/lz5oAfhw4vwAw/ljlPBQwoXgXxcBvLx3/DCissDRcCXB/xp2stBYV0BOlXLh1conMK6wkahAhX9lZzNk5OFiiujQoV8PX7xn0HRvyELblngyYJCElhJmGSClglBBiGLL7P4BefD9jDyV7pRdsf90TH5C4XYoTHiL7NQJKpPn2S5KvBEmTjJcrUnysZJlms8UTZOslzribJxkuU6T5SNkyzXe6JsnGS5wRNl4yTLjUp1Erygc5OdhbkaWTcZiPybrQjqFrBaZlVQtxgQ1C9JjL25n3ElUJaMzt21JfHeGigCvjXAnzRsuxXcz7it4PsZ4sPbwP2M2Ie3FXyTVWrwVwbcZePJfosUkDGu20Fcyb2W2wO9Q6EXR3ttlA+kr6sUDidcBWL8VcEPjPxEgZOrFTi5GsR4R8E5uUSBk2sUOLkGxHhnwTn5qQIn1ypwci2I8a6Cc3KpAifXKXByHYjx7oJz8jMFTq5X4OR6EOM9Befk5wqc3KDAyQ0gxnsLzsllCpzcqMDJjSDG+wrOycEKnNyswMnNIMb7C76uFx/+MsBvi+sEz2fWVQjz2vuAUvma5uXXGM5Ks3DbtPjP4Kg/WTPLGk3WBJKDSs4jc6yM6TKGiGbFT78O9OyL60l07JI1oN+AWgldV90n2aj+l8VTKV8r/yYoPsYHaYw0QBH7g3jhfX4neTD6t+CAoyx2tYPRFsT+WxKj1VHJwsHoh5QyDWwUydqCydvX78C0z6o4f2dgFHm46OKMX0ZMivP3nNHNVsX5ewPifMSIODtIcT7KGV2xKs5HDYjzMSPiXECK83HO6KpVcT5uQJxPGBHnfFKcf+CMbrEqzj8YEOeTRsQ5jxTnU5zRrVbF+ZQBcT5tRJxzSXH+kTO6zao4/2hAnM8YESd6LeuznNHtVsX5rAFxPmdEnO2kOJ/njJ5sVZzPGxDnC0bE2UaK80+c0XOtivNPBsT55764Q/QXcIcoy9ZSvlZ7AO1XoL3S30MKB10eAjG+CAtRg5M7YE4eVuDkYRDjSwY4uRPm5BEFTh4BMb5sgJO7YE4eU+DkMRDjKwY4uRvm5AkFTp4AMb5qgJN7YE6eVODkSRDjXw1wci/MydMKnDwNYnzNACf3wZw8o8DJMyDG1w1wcj/MyXMKnDwHYnzDACcPwJy8oMDJCyDGv8GcpIsrhA+lwMI+2FRpBi9qqSsA5bX3TaViUl+58OUtoK+4mNubt1C9BfKexPt2oAhYOqf7fQcUg5bd7yQ8DPWrMqEtTBVBS/laWYq+Lwb8IP9uwRODhanCZSlfq/nxJQU/vmfAj3fCfnxZwY//MODHu2A/vqLgx/cN+PFu2I+vKvjxnwb8eA/sx78q+PEDA368F/bjawp+FMOL7sf7YD++ruDHwIAf74f9+IaCH0MDfnwA9uPfFPzYAPuRXnuJ3W8q2N0I2x03Gmc/DGdlvhSEJiz+MyTqT9Zgsn6Q3FfyNsk5ZL6UYJBxSmJM9CG+6he6bq2vFJiW47RSezR+QndXYv0vS4elfK28nEK80Bj7kRiVierTF2z090TZePPgAE+UjTcPDvRE2Xjz4CBPlI03Dw72RNl48+AQT5SNNw8O9UTZePPgME+UjTf6DfdE2XhT3ghPVKn8iAGMIz1RpfKrBjAuH/IYay1MAf1vK2rHdyo0puxNNryMBPQV3SrakgE3b9/l+C9JX4yKvhgdRg6J3wMo32hKAYDfwVDnsI9IdHMkwPKokBPz6FCHSHrXbBQ8OoQwv3Ka9F1wh0r6k6I6jbM/qJ0xBjh5D+ZkgAInA0BOxhrg5B8wJwMVOBkIcrKCAU7ehzkZpMDJIJCTFQ1w8k+Yk8EKnAwGORlngJMPYE6GKHAyBORkJQOcuJDlZKgCJ0NBjCsb4CSAORmmwMkwEOMqBjgJYU6GK3AyHMS4qgFOGmBORihwMgLEuJoBThphTkYqcDISxDge5oSu/YgPpToMXx8w/x2wkLs8yEcTyIf4bKLrOiEuNRupEciaVNZAknNLjic5hcxhMmZKjIommiLRhlEf6UZhjPsrYpFaG+OEkMeoDjTvuzI1ca6C4eyoaOJcFcPZ2ayJczUjvI/ncLZo4JPB6ESFx54mggNI6LIb1b8W96QPtDCuTmOkhSTiXB3PskotJwY6Tsxr7xp2AkftGTALgUPy5KyOcBaeAVvTE2XjGbCPeaJsPAO2lifKxjNgkzxRNp4BW5skSiblNRb/6R91KBOgjK0StqII+cek7jYg+nkY/b41Yi08irQOncmGKYB5lxvx+p8yWPpaJ9QREU2OYJXACOF+F4GHMdYNi+/DtXgfNpM+XM+ADyfxPqyQPlzfgA/X5n1YJX24QbF92CK2atSCRzQU2u7WE5XsHtnAJyjSGmH7SY1vyGm8DOqmnOQi78vfe/PudtCfdXe3L60NawCWzul+y2CNXcvuctjlYKhftclyzZAf8CoGkoR1C57wVw34cL2CJ/wtBny4fsET/lYDPtyg4Al/W8F9KFVA8SNdVGoHk8BLQB9KZfRjrqsyKvOVjLcyXojehS/BflZGZlfkpHuygaS7lLOFEXfpRmGN+6NjbDI8BmhgPIuspCsT1afPMmwUeqJMnGXY2BNl4yzDJp4oG2cZNvVE2TjLMMUTZeM+2808UTYOkUxVWELUGnymvm5NW8rXCrv5k/RfyPqvfSFYE5gGiiZwXbfSSb9NOvbX9ngq4D6P9LeRQr1/IxDj5nBwa3BShTnZWIGTjUGM0w1w0gJzsokCJ5uAGLcwwEkrzMmmCpxsCmKcYYCTNpiTKQqcTAExzjTASTvMyWYKnGwGYtwS5oQ+t1E7WxPS64FyR5mzu24RlNferQoeI7IOAPPC2rtNpT9aN1sb8ON02I/TFfy4jQE/bgH7cQsFP25rwI8zYD/OUPDjxw34cSbsx5kKfpxlwI9bwn7cUsGP2xnw41awH7dS8OP2oB8lV1zLdT1FKrmAzGMyBsv4IdoX3uTfPDjjPBVce24HX3/S9hewDrsDmLeGkc/TDbJbbQNjh7D4GGeTGEXck3IEh6Zx5O1z9EBKBsuOcOBN6k5T4UW9o4HA20kBY6Y484pgSEGNFkIaU+RktdGJvzcs9dGIYbvdus9tyd8b0cPPNu7hZ1/q4WeX9fCza3r42c09/Kw9WPbPpkQ/m/7+41teetKxdbG7Rw8/2yv62Zhnp437wl3nz0j+rKOHf+/OHvq8r4f/b41w2f/evj387JAefnZCDz97Jlw2lvEN2f9fHEfxZDYw+hwUfca7w1Ojr0v5WnPc/2Cd/kv9Xfc2KPH3wamfxfY3Zvx/wTK+DlOfPf1uT4+RDs34WdznqOgziTe2Y2Dqc0yiX9CX5bj/0Tr9Z3I1JvH30Sk7k/6eCmGI+4vHzH6uewtTP4t/Nx0zAY+vnMbSkPFvxS3WTHIuiP35//O+Pcj80QMA",
  "debug_symbols": "rZzdrh23DYXf5Vz7QiQlkeyrFEXgJCeFAcMJHLtAEfTdK+pnTVJgxilPbra+eGfW0mjEkURpn99efnz9/us/v/vw6aeff335299/e/n+84ePHz/887uPP//w/suHnz+Nf/3tP+9ezn9+9+Xz6+v4p5fffT+u+uX959dPX17+9unrx4/vXv71/uPX+T/9+sv7T7P88v7z+La8e3n99OMoh+BPHz6+Bv3n3XV1ub+UGu2LqXVc3v6P6+1c3yVzPRdcX++ul/vr2fq+XgolrpeG673dXd8e6l/Izw0ULjkFuRTozQo9pVA7FKrmFMqlYG9VaJJS6JdCz9XBGhRc3qyQqgMRHwXK9ag/KKR6NQnugqq8WSHXDnrdhebq0PulUN+s4BkFLnjBMuXuwtGrKdejmPGOYkm1Awte81x7rg5y1SHVJ9nQDmyp9yT3qx009ZaTgjpI7mkKKxRqSYxYFR2qVr69np6G7CbXmN9zElefbE45CauXBL9dQlMS/Rq+u+RupJdrCkS55uyYhYwXTs1JVLxn+v3o+Szh14245yRML4mWklBCLVQyU7paj0Art21ZnwS8nU5RXTknYQKJ+wB5kmjXzLKV+1H8WaIpJJolJQgSveYkMLFrD1PDZwl0zUa5h9oIT2RgUkLRnJR8qFzPpGZgrhYseCIsnpNQPBG2XNcSOu/eJlJyEpjgDZScBOZnTSxXi3rdSGXOSVwxUltSorZLIvdQq6KDV8tJtAKJlnr3to5H2jVzPaFj3i/g+sP8qqnicaq2nES3S6K/WeJ+rvosYZeE52phyAs0Y3q7RLIW1+vfqr1Z4n5y8yzRrxtJPlS7BiEvb5egkpPAFGuo5Tq4oxa93I+mTxK9SIeEaFKiQKJKTgJTpF44WQuM6WMen6sFIUYG5ppz5O0uiZKTqGgL6pyTcDxUTvYLxvK2c2p52/D+7vcxFq/G2wXEiIqzgPBiKQlnrMf8PmHy5yU8J9GxpPP7+dGzRMM63VuqLbhgTjBSWfR2iZ6TwPtm9ExP9KuOVWHPXY+cam+3PcKfboGQARuJwJ6TaBUS9zH+5yU0J2HnTcN8v+nyLKGGWliuLa5lED8sg/60RM09VO5ozoeU4lO/wp5F99sqUNGHOtSKjlXvN/G+oYHXLlfjv0BDcxoN2R9u3N+ucb+K+YYGcqTcektqYK0/5EpSAylOfkpx3iso0sUqt2PI2Od4qEPHYob7/WLmWUP7GZRZ7xfqzxqu0PD7WPuGxhWvD6m9R42xB1CuPeeWrIfXS6O/XYOz91Kve2k9qYH+IUWzGk7QuM89P2uMDZWjQa0kNbAcGGhZDbo0/O0alutjwph2CVOyHlwvjfsh8hsaopdGe7tGo6TG1aZsufeHXGnPgcl7EWwYDY3+do1s7MsV+5KNfbFLIzk2iOjVpsZ/gUYybquc8VpqTbZHxTgnNTnOSUV6Rhon23SkX6Fhydi/NjZlLOaTGpgDjVR9sk214F40+x7r1zkxLdl61Kse1bIadGn42zVa8h2k6tDI9lPFhoNoNvb/oJF8J1tBzFk2XszQT82Tfd1wvGTI5epRSzv1qKW3pMa190wl92wrYQ1VSWpSw0+81JH8yGkw8j6VW1ajXxqeOWSqch6s3ufh5lGx2zoI3sf1YaPyWWNsTx6NKkmNhqNgtT3M5541rntplmyPdvWNfn+44emZ4AVmD3Oo2GG+zbwIId0t7DmNhnGlt/sDo88aVX+Xmkxq/C492e93Qr6h0S6NntXA8deu97nBZw2lS+N+Y+ihbxgCxR7i1R6OpY9cHJ6rP7x3njWurQx/WBc/a2DbcmhQUgN5Ai3FUxp6bdZpeVjDPWtgR3tgth4Yp7V4+Qs0alIDa8mByXu5jmkrPcTsswaOnij1ntTAfGFMr5P3wji4MTB5L9dYr09r/GcNvTQ8qSFypUxrsk0Fc1IV4qTG1cfEkvWoyAFp5WS8VOQJBibbtCI3pw/Hlv8PDUtq4IDSWH4l26MV1KNJ8l4axhdtmnwHtet9+nTw+GGcxBzK7+dg/LQ/oYocger92YdvaHC7pteS1GiXhpakBnLQY0nccxqGbX+1+37+DQ276uHJ5+LY7lZvmtS43qV+n1N71LDrhI4VqUkN/MbQikpSAz9YMEo+WyNSaHDyXgj5dKOWbFPCARfj+/ncs8bY8IZG9rnw9VxYOamB02zG/3PK8R/jv97/8OHzH34y+1LGhPbdC81Pnp8yP+vope9e2vzs81Pnp81Pn59UVkGrGJePG6Bx/eijVFfRVtFXobE/O0rbpUeuYRgPoZi8Me1ySMUhMB5asUHANX6SMsoW6+BR9ljzjFJ3abv0VUrZJe2Sdym7rLtsu9x6EnrjHsR26ausZZcU7T9K3qXEgYtRDr04jVLbLvsudZe2S19lK7ukXfIuZZdbr4XeuO/Wd6m7tF36KnvojXbptEvepeyy7rLtsu9Sd2m79FXq1tOtp1tPt55uPd16uvV062nojfZSX6WVXdIueZeyy7rLtsu+S93l1rOt51vPt55vPd96vvV863nojf7nGvuho7RdeuxdRUcuB+gAx85BgByokfwPaJFdDegH9IAd8A0RIwvoAB+QA/XAUY54iZ8IUkRMZMsoQmaBb4igWUAH+IAcqAdaJBAD+gE9YAd8Q4TPAjrABySyfgE1sk4B7UAox7skomiBHQjl+VIoB+gAH5AD9UA70A/oATtwlNtRbke5HeV2lCOs4gAfRVwt6Af0wFCOvA1FbE2I4FowlOO0F0V4LZAD9UA7EMrRLBFjC+yAb4gwW0AH+IAcqAdCOfpGBNsCPWAHfEMEXIwmFBG3IJSjESLm+nwH1wPtQD+gcUAvwOLgaYBHVi/e2DFgxDON2FvAB+RAKEc1Iv4WhHJUIyIw0voUIbggxpISY0CMJnMwiPEkRoGIwdjP4IjBOKzCEYMLYmSKN37E4AI9YAd8wxynJtABPiAH6oGjTEeZjjId5YjBSDJyxOACOhCjYNxFxOCCeqAd6Af0gB3wDRGDC+jAUZajLEdZjrIc5YjBSMtwxOAC3xAxuCCU5+jKB+RAPdAO9AN6wA74hohBm8M0HQjlGLAjBhfUA+1AP6AHQjnaOWIwJpocMbhgKMeygiMGPfpGxOCCeqAd6Af0gB0I5ahzxOCCUI46RwzGwW2OGKQ4m8QRhJsaKOYMcRiMdc5qQlUN5IciFDcRiEHTI/ytgqZHVMWmR9TFpocHGWjOnqIuEZQ0J1IRlZvCY06mIi5pTqMiMDc1UAcpyEC+Scr0aEHTI6ZHhUECqqAG6iAFTQ8P8kNUQARiUHjEtEsiWDc1UAeFR0zLZM4zF4VHpLFlzTUnzdmmBIVHTKRkzjgXVVADTY+YI8+Z5yID+aE5/+Q54SQQgwRUQQ3UQQoKj5iEyJyRxixE5px0UXjEoCwRyHNFJFVAFRQeNVQimClGZolo3hQedU6OwyMGTImA3hQeMUBKhPQmAVVQA3WQggzkhyK0N8Gjw6PDo8Ojw6PDo8Ojw6PDQ+Gh8FB4KDwUHgoPhYfCQ+Gh8DB4GDwMHgYPg4fBw+Bh8DB4GDwcHg4Ph4fDw+Hh8HB4ODwcHn48aikgAjFIQBXUQB2kIAPBg+BB8CB4EDwIHgQPggfBg+BB8GB4MDwYHgwPhgfDg+HB8GB4MDwEHgIPgYfAQ+Ah8BB4CDwEHgKPCo8KjwqPCo8KjwqPCo8KjwqPCo8Z5zHHrSvOJ02PuaidHi2ogqZH5AlWnMfieMX5pOnhQX5oxfkkAjFIQBXUQB2kIHh0eCg8FB4KD4WHwkPhofBQeCg8FB4GD4OHwcPgYfAweBg8DB4GD4OHw8Ph4fBweDg8HB4OD4eHw8OPRysFRCAGCaiCGqiDFGQgeBA8CB4ED4IHwWPGeaxB2ozzReERy5E24zxOnLcZ53E2sM04j7VFm3G+iEECqqAG6iAFGcgPCTwEHgKPGeexlmkzzhc1UAcpyEB+aMb5IgLNvFW0wYzzWB21GeexE95mnC/qoJkRi3aZcb5oZsV6pJMKiEAMEtD0iPzfjPNFHaQgA/mhGeeLCDQ9oq1mnMc2SZtxHmuVNuN8UQcpaObiIhk243zSjPNFBGJQeMSCpM04X9RAHaSg6RE1nXE+acZ5/DKrzThfxCABVVB4xCqlzThfpCAD+aEZ54sIxCABVdD0iHaZcb5IQQbyTX3G+SICMUhAFdRAHaQgA8GD4EHwIHgQPAgeBA+CB8GD4DHj3DlSmqetOhNoetQgAVVQA3WQggzkh2acxyKwzzhfxCB4CDxmnK9vO0hBBvJDFR4VHhUeM84XVRA8KjwqPCo8KjxmnPtM+BKIQbiPhvuYcb6+7SAFGcgPdXh0eHR4zDhfVEHw6PDo8Ojw6PBQeCg8FB4KD4WHwkPhofBQeCg8DB4GD4OHwcPgYfAweBg8DB4GD4eHw8Ph4fBweDg8HB4OD4eHHw8tBUQgBgloekRyfsX5pA5SkIH80IrzSQRikIDgQfAgeBA8CB4ED4YHw4PhwfBgeDA8GB4MD4YHw0PgIfAQeAg8BB4rzj2oz19gBynIQH4o4nz+sUJdu0aTGCSgCmqgDlKQgfxQg0eDR4NHg8fcT4o/iaBzRykyTzr3lCLfpHNXKfJNOveVytzYmR5xv3NvaRGBGDR3wOJ+5x7TogbqIAWFR2SodO42xTafzv2myDLp3HGKLJPOPadFAqqg6RG7knPvaZGCDOSH5h7UIgIxSEAVBA+Dh8HD4GHwcHg4PBweDg+Hh8PD4eHTY26fTY94Hu6bLOKcI89lEeebGCSgCmqgDgqPyIxZxPkmP0QFRCAGCaiCGqiD4EHTg4Omh8QWYAFNj9g0/9f7zx/ef//x9deX+cecf/r66Yff/W3nL//+5Xxz/vrzL59//uH1x6+fX2NTe343trn/Cw==",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
