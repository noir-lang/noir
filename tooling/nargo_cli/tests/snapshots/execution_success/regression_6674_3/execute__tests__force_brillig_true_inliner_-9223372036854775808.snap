---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "5638254368791177012",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "5727012404371710682": {
        "error_kind": "string",
        "string": "push out of bounds"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "6": {
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n",
      "path": "std/collections/bounded_vec.nr"
    },
    "50": {
      "source": "use std::mem::zeroed;\n\npub struct PrivateAccumulatedData {\n    pub public_call_requests: [Counted<Field>; 4],\n}\n\npub struct PrivateAccumulatedDataBuilder {\n    pub l2_to_l1_msgs: BoundedVec<Field, 4>,\n    pub public_call_requests: BoundedVec<Counted<Field>, 4>,\n    pub private_call_stack: BoundedVec<Field, 4>,\n}\n\nimpl PrivateAccumulatedDataBuilder {\n    pub fn finish(self) -> PrivateAccumulatedData {\n        PrivateAccumulatedData { public_call_requests: self.public_call_requests.storage() }\n    }\n}\n\npub struct Counted<T> {\n    pub inner: T,\n    pub counter: u32,\n}\n\nimpl<T> Counted<T> {\n    pub fn new(inner: T, counter: u32) -> Self {\n        Self { inner, counter }\n    }\n}\n\npub struct PrivateKernelCircuitPublicInputs {\n    pub end: PrivateAccumulatedData,\n}\n\npub struct PrivateKernelData {\n    pub public_inputs: PrivateKernelCircuitPublicInputs,\n}\n\npub struct FixtureBuilder2 {\n    pub public_teardown_call_request: Field,\n    pub private_call_requests: BoundedVec<Field, 4>,\n    pub public_call_requests: BoundedVec<Counted<Field>, 4>,\n    pub counter: u32,\n}\n\nimpl FixtureBuilder2 {\n    pub fn new() -> Self {\n        let mut builder: FixtureBuilder2 = zeroed();\n        builder.counter = 1;\n        builder\n    }\n\n    pub fn to_private_accumulated_data_builder(self) -> PrivateAccumulatedDataBuilder {\n        PrivateAccumulatedDataBuilder {\n            l2_to_l1_msgs: zeroed(),\n            public_call_requests: self.public_call_requests,\n            private_call_stack: vec_reverse(self.private_call_requests),\n        }\n    }\n\n    pub fn to_private_accumulated_data(self) -> PrivateAccumulatedData {\n        self.to_private_accumulated_data_builder().finish()\n    }\n\n    pub fn to_private_kernel_circuit_public_inputs(self) -> PrivateKernelCircuitPublicInputs {\n        PrivateKernelCircuitPublicInputs { end: self.to_private_accumulated_data() }\n    }\n\n    pub fn to_private_kernel_data(self) -> PrivateKernelData {\n        let public_inputs =\n            PrivateKernelCircuitPublicInputs { end: self.to_private_accumulated_data() };\n        PrivateKernelData { public_inputs }\n    }\n\n    pub fn add_public_call_request(&mut self) {\n        self.public_call_requests.push(Counted::new(zeroed(), self.next_counter()));\n    }\n\n    pub fn append_public_call_requests(&mut self, num: u32) {\n        for _ in 0..num {\n            self.add_public_call_request();\n        }\n    }\n\n    pub fn set_public_teardown_call_request(&mut self) {\n        let mut fields = [0; 5];\n        for i in 0..5 {\n            fields[i] = i as Field;\n        }\n\n        self.public_teardown_call_request = zeroed();\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.counter;\n        self.counter += 1;\n        counter\n    }\n}\n\nstruct PrivateKernelTailToPublicInputsBuilder {\n    previous_kernel: FixtureBuilder2,\n}\n\nimpl PrivateKernelTailToPublicInputsBuilder {\n    pub unconstrained fn execute(&mut self) {\n        let kernel = PrivateKernelTailToPublicCircuitPrivateInputs {\n            previous_kernel: self.previous_kernel.to_private_kernel_data(),\n        };\n        let mut output_composer = PrivateKernelCircuitPublicInputsComposer::new_from_previous_kernel(\n            kernel.previous_kernel.public_inputs,\n        );\n        output_composer.sort_ordered_values();\n    }\n}\n\npub struct PrivateKernelTailToPublicCircuitPrivateInputs {\n    previous_kernel: PrivateKernelData,\n}\n\npub struct PrivateKernelCircuitPublicInputsComposer {\n    public_inputs: PrivateKernelCircuitPublicInputsBuilder,\n}\n\nimpl PrivateKernelCircuitPublicInputsComposer {\n    pub unconstrained fn sort_ordered_values(&mut self) {\n        // Note hashes, nullifiers, and private logs are sorted in the reset circuit.\n        self.public_inputs.end.l2_to_l1_msgs.storage =\n            sort_by_counter_desc(self.public_inputs.end.l2_to_l1_msgs.storage);\n        self.public_inputs.end.public_call_requests.storage =\n            sort_by_counter_desc(self.public_inputs.end.public_call_requests.storage);\n    }\n}\n\nimpl PrivateKernelCircuitPublicInputsComposer {\n    pub fn new_from_previous_kernel(\n        previous_kernel_public_inputs: PrivateKernelCircuitPublicInputs,\n    ) -> Self {\n        let mut public_inputs: PrivateKernelCircuitPublicInputsBuilder = zeroed();\n        let start = previous_kernel_public_inputs.end;\n        public_inputs.end.public_call_requests = BoundedVec {\n            storage: start.public_call_requests,\n            len: start.public_call_requests.len(),\n        };\n        PrivateKernelCircuitPublicInputsComposer { public_inputs }\n    }\n}\n\npub struct PrivateKernelCircuitPublicInputsBuilder {\n    end: PrivateAccumulatedDataBuilder,\n}\n\nfn vec_reverse<T, let N: u32>(vec: BoundedVec<T, N>) -> BoundedVec<T, N> {\n    let mut reversed = BoundedVec::new();\n    let len = vec.len();\n    for i in 0..N {\n        if i < len {\n            reversed.push(vec.get_unchecked(len - i - 1));\n        }\n    }\n    reversed\n}\n\npub unconstrained fn sort_by_counter_desc<T, let N: u32>(array: [T; N]) -> [T; N] {\n    sort_by(array)\n}\n\npub unconstrained fn sort_by<T, let N: u32>(array: [T; N]) -> [T; N] {\n    let mut result = array;\n    get_sorting_index(array);\n    result\n}\n\nunconstrained fn get_sorting_index<T, let N: u32>(array: [T; N]) {\n    let _ = [0; 4];\n    let mut a = array;\n    for i in 1..4 {\n        for j in 0..i {\n            a[i] = a[j];\n        }\n    }\n}\n\nunconstrained fn main() {\n    let mut previous_kernel = FixtureBuilder2::new();\n    let mut builder = PrivateKernelTailToPublicInputsBuilder { previous_kernel };\n    builder.previous_kernel.append_public_call_requests(4);\n    assert_eq(builder.previous_kernel.public_call_requests.storage[3].counter, 4);\n    builder.previous_kernel.set_public_teardown_call_request();\n    builder.execute();\n    assert_eq(builder.previous_kernel.public_call_requests.storage[3].counter, 4);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
