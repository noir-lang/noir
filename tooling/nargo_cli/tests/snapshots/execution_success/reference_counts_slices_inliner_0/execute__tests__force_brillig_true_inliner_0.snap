---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8262467739384083083": {
        "error_kind": "string",
        "string": "There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before slice_refcount call)"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12390149874551504741": {
        "error_kind": "string",
        "string": "after refcount_1 we clone once in passing slice to copy_mut, once to slice_refcount after, and once within copy_mut"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "15146802936675446448": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh slice and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "// This test is exactly the same as `reference_counts_inliner_0` which uses\n// arrays rather than slices.\n// This test exists to make sure that our reference counting debug methods match\n// between arrays and slices.\n// We could most likely combine the code for these tests (e.g. using generics),\n// but it is simpler to debug isolated tests.\n// It should only be necessary to have a test at one inliner setting, as we\n// are just checking for discrepancies between the array and slice debugging builtin functions.\n// The actual functionality of reference counting is tested with the `reference_counts_*` tests.\n// We went with testing at an inliner aggressiveness of zero, as this is generally\n// the most useful inliner setting for unconstrained functions.\nuse std::mem::slice_refcount;\n\nfn main() {\n    let mut slice = &[0, 1, 2];\n    assert_refcount(slice, 1, true);\n\n    borrow(slice, slice_refcount(slice));\n    borrow_mut(&mut slice, slice_refcount(slice));\n    let _ = copy_mut(slice, slice_refcount(slice));\n\n    borrow_mut_two(&mut slice, &mut slice, slice_refcount(slice));\n\n    let mut u32_slice = &[0, 1, 2];\n    let rc1 = slice_refcount(slice);\n    let rc2 = slice_refcount(u32_slice);\n    borrow_mut_two_separate(&mut slice, &mut u32_slice, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(slice: [Field], rc_before_call: u32) {\n    assert_refcount(slice, rc_before_call, true);\n    println(slice[0]);\n}\n\nfn borrow_mut(slice: &mut [Field], rc_before_call: u32) {\n    assert_refcount(*slice, rc_before_call, true);\n    slice[0] = 3;\n    println(slice[0]);\n}\n\n// Returns a new slice (a copy) to prevent SSA from optimizing away mutations.\nfn copy_mut(mut slice: [Field], rc_before_call: u32) -> [Field] {\n    assert_refcount(slice, rc_before_call, true);\n    slice = &[4, slice[1], slice[2]];\n    println(slice[0]);\n    slice\n}\n\nfn borrow_mut_two(slice1: &mut [Field], slice2: &mut [Field], rc_before_call: u32) {\n    assert_refcount(*slice1, rc_before_call, true);\n    assert_refcount(*slice2, rc_before_call + 1, true); // should be a copy\n    slice1[0] = 5;\n    slice2[0] = 6;\n    println(slice1[0]); // slice1 & 2 alias, so this should also print 6\n    println(slice2[0]);\n}\n\nfn borrow_mut_two_separate(\n    slice1: &mut [Field],\n    slice2: &mut [u32],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*slice1, rc_before_call1, true);\n    assert_refcount(*slice2, rc_before_call2, true);\n    slice1[0] = 7;\n    slice2[0] = 8;\n    println(slice1[0]);\n    println(slice2[0]);\n}\n\nfn assert_refcount<T>(slice: [T], mut expected: u32, expect_copy: bool) {\n    let count = slice_refcount(slice);\n\n    if expect_copy {\n        expected += 1;\n    }\n\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut slice: [Field] = &[0, 1, 2];\n\n    let refcount_0 = slice_refcount(slice);\n    borrow_mut_two(&mut slice, &mut slice, refcount_0);\n\n    let refcount_1 = slice_refcount(slice);\n    let slice_2 = copy_mut(slice, refcount_1 + 1);\n    let refcount_2 = slice_refcount(slice);\n\n    assert_eq(slice[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(slice_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh slice and not decrease its RC\",\n        );\n\n        assert_eq(\n            refcount_1,\n            2,\n            \"There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before slice_refcount call)\",\n        );\n        assert_eq(\n            refcount_2,\n            refcount_1 + 3,\n            \"after refcount_1 we clone once in passing slice to copy_mut, once to slice_refcount after, and once within copy_mut\",\n        );\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
