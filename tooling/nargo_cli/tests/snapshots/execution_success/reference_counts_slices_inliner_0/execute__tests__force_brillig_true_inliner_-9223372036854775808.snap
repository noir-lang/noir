---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8262467739384083083": {
        "error_kind": "string",
        "string": "There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before slice_refcount call)"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12390149874551504741": {
        "error_kind": "string",
        "string": "after refcount_1 we clone once in passing slice to copy_mut, once to slice_refcount after, and once within copy_mut"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "15146802936675446448": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh slice and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "td3fbhRXEoDxd/G1L7qqzp+qvMpqhYCQyJIFEZCVVoh33zaJezacc9yqD/omMht+Z5bU57Gn3NN8ufv13Zs/f3/18P63D5/ufvnXl7vHD29ff3748H7/1Zev93dvPj48Pj78/ur//+e77ekfVb/9/k9/vH7/9MtPn19//Hz3i9t2f/fu/a9PH8nuf3t4fHf3S92+/vv+rlpalLSoadHSoqeFp0VkRdvSQtIiPfOWnnlLz7ylZ97SM2/pmbf0zFt65j09856eeU/PvKdn3tMz7+mZ9/TMe3rmPT3znp65p2fu6Zl7euaenrkvZu7PosX3oqZFS4ueFp4WkRWxpYWkhaaFpUV65pGeeaRnHumZR3rmkZ65bFuezKcez5+FITKQ+dh7O4gOxPKk5EnNk5YnPU88TyJNZMsTyZP89CU/fclPX/LTl/z0JT99mU4/ijyTNpLp9EP8IPY90S1PJE80TyxPSp7UPGl50vPE8yQ/fctP3/LTt/z0LT99y0/f8tO3/PRtPv2wv8n+xbQMZj7+3m+mDibypmzACDAKjAFTgKnANGA6MKCDAjqooIMKOqiggwo6qKCDCjqY7/T27w/lQD58mZ6v9fZvkPWGhmeR+WbvDAVA8/3eGRKClCAjqBBUCWoEzYuQ48vK/uHwGmy+9ztDAdB8+3eGhCAlyAgqBFWCGkGkiE6K6KQIJ0U4KcJJEU6KcFKEkyKcFOGkCCdFOCkiSBFBighSRJAighQRpIggRQQpIkgRAYrQbSNoUYS1A9U+ICXICCoEVYIaQZ0gJygAkkUR/XgpvOc5oHkR+yiekbY6ICXICCoEVYIaQZ0gJygAmq8fzxApQhdFxPF9uW3Ds5EaQYWgSlADaL5a2rc6x+vcYmVAAdB8uXSGpsPVZs+vqPfZ6oDKHHk5UAzPRvO9zxlqBHWCHKD5Hke7PD/Dai/Dp8Z8kaO9xoF6G1AhqBLUCOoEOUEBUNsIInOa71jOkBFEimikiEaKaKSIRopopIhOiuikiE6K6KSIToropIhOiuikiE6K6KQIJ0U4KcJJEU6KcFKEkyKcFOGkCCdFOCkiSBFBighSRJAighQRpIggRQQpIkgRAYqwbSNICFKCjKBCUCWoEdQJcoJIEUKKEFKEkCKEFCGkCCFFCClCSBFCihBShJIilBShpAglRSgpQkkRSopQUoSSIpQUYaQII0UYKcJIEUaKMFKEkSKMFGGLIuLYhXn5xy7sfvjNfvze0NtlB6p/nR/Xnl+2i8+Xi8/Xi8+3i88vF59fLz6/XXx+v/j87OfXE1qscL3rgbwPSAhSgoyg+Q8qan9+v4jUCeoEOUEB0OIyuRMkBClBRtD0CWP/oe7tJzbDG3tscZncCWoEdYKcoABocZncCRKClKB5EeX4ydr+4fBstLhM7gRVguZFFK03ZAPqBGV/App82u9x7fm+XXy+XHy+Xny+XXx+ufj8edSuz68VxMvwWmFxpd8JCoAWV/qdICFICTKCCkGVoEbQ4luh7XhCrRPkBEUelcWVfidICFKCjKBCUCVo8c1xO66Kq60MqBPkBC2KqHpD2/docaXfCRKClCAjqBBUCWoEdYKcoOzLpdzXv6LbxefLxefrxefbxeeXi8+vF58/X5uKH7tW3b5/6VsWi/SX0WKRfoKEICXICCoEVYLmT3P9uMWBdK8D6gQ5QQHQ4prXEyQEKUFGUCFo8c2xHJ/kPqwoSmkEdYIWL5du15D7cEuOUgKguhG0erl0+zPp8GeqSpARtHi5JLc/k45/pkpQI6gT5AQFQIvN8QkSgpQgI4gU0UgRjRTRSBGNFNFIEZ0U0UkRnRTRSRE9u1JJfpfX68Xnt4vP7xef7xefH9ee79vF50/77OV5idt9G0jNk5YnPU88TyJN5ovfl4nkieaJ5cn82Snq8W1PxLCpWyx8T1AjqBPkBEUe1cXC9wQJQUqQEVQIqgQ1gjpBThApQkgRQooQUsTisuNNn58idBveF1kXlx2foEpQI2h+9dK2HVfibMM7ZevisuMTFAAtLjs+QUKQEmQEFYIqQYsijjvs7h8Ot/JfXHZ8gpygRRHdDzRcXVQX29ITJAQpQUZQIagS1AjqBDlBpIhCilhc9SvbsWsW2QakBBlBiyLieC6Xbfj6tLiS9gQ1gjpBTlAAtLj69QQJQUqQEUSKWNwqQW73wZDhGrq6uFXCCeoELX7GpuWGbEAB0OJWCSLthn7gaqu6uKvCzztfLz7fLj6/XHx+vfj8dvH5PXn+N+QEzT99bvc92j8cXiUs7itxgoSgRei3pzkdn+YW95U4QYsklz9tTo6014vPbxef3y8+3y8+P64937eLz59GbbfVtXkbvq2d76PPUCWoEdQJcoICoPlu+gwJQUrQ/GnOjqWVWoyoEFQJagR1gpygyKO2uDXGCRKClCAjqBBUCWoEdYKcIFKEkCKEFLG4NUbZjtvwlboNyAgqBFWCGkGdICcoAFrsqE/QvIjSjqVVGf7CtLbYUZ8gI2hRRG03VAdUCWoEdYKcoABosaM+QUKQEmQEkSIWO+rixwuz4j6gRlAnaFFErzdUBhQALXbUJ0gIUoKMoEJQJagR1AkiRSx21PW24a/Dhr8tdtQnSAhaFBHlhn7gBhVtsc7+eeeXi8+vF5/fLj6/X3y+X3x+JM9/QouF/v7z1wMNu8+22NKfICVo/jlRj7+2Ykc/cN1hW+zTf9759eLz28Xn94vP94vPj2vPn6/ZbTveY7x/OHzOzdfsZ6gQVAlqBHWCnKAAaL5kPkNCECnCSRFOinBShJMinBThpAgnRQQpIkgRQYoIUkSQIoIUEaSIIEUEKSJAEX3bCBKClCAjaFHEcS2rbcUHtCiiPn8jabKVATWCOkFOUAAkG0FCkBJkBBWCSBFCihBShJAihBShpAglRSgpQkkRSoqY76hN1A9UYkCNoE6QExQAzXfUZ0gIUoKMoHkR4vVAMaJKUCOoE7Qooh1XCui2DSgAKhtBQpASZAQVgipBjaBOECmikCIqKaKSIiopopIiKimikiLme19TtQOV4evTfJlretyUdf9w+MZ3vqE9QwHQfO26/065oeEpbL52PUN6ivrwsmG+dj1DhaB5EXb8VH3/cPwzNYI6Qb5A24H6EOx86XiC5pcG/xPZgIQgJWheRDn+dlOrwz2l+mJneYIqQY2geRH7j+if0f4zlQE5QQGQg6souwtBStD0P8RL2/I+X9S9SOZrupeJ5InmieVJyZOaJy1Pep7kpx/p6fu25YnkieaJ5UnJk5onLU96nnie5Kcv+elLfvqSn77kpy/56Ut++pKfvuSnL/npS376mp++5qev+elrfvqan77mp6/56Wt++pqfvuanb/npW376lp++5adv+elbfvqWn77lp2/56Vt++iU//ZKffslPv+SnX/LTL/npl/z0S376JT/9kp9+zU+/5qdf89Ov+enX/PRrfvo1P/2an37NT7/mp9/y02/56bf89Ft++i0//ZaffstPv+Wn3/LTb/np9/z0e376PT/9np9+z0+/p29q6b3lSc+T9E0t3fN/fM/H7/n4PR9/ftnl+WWX55ddnl92eX7Z5flll+eXXZ5fdnl+2eX5ZZfnl12eX3ZFftkV+WVX5JddkV92RX7ZFfllV+SXXZFfdkV+2RX5ZVfkl12RX3ZFftkV+WVX5JddkV92RX7ZFfllV+SXXZFfdkV+2RX5ZVdo+m7Ooem7OUfNP0oFj1LyZP5mnHa7t1ob7v0Zi3dtNT/eVdWGWw7E4q1YL6PFW7FOkBCkBE3/g2uX4/1bfbgtbize/9Tr8UbL/Ue3A3KCAqDF/bhOkBCkBBlBhSAyp8Wds05QJ4gU0UkRTopwUoSTIpwU4aQIJ0U4KcJJEU6KcFJEkCKCFBGkiCBFBCkiSBFBighSRJAiAhQh27YhJUgpUoZUQaoi1ZDqSDlSqA1BbQhqQ1AbgtoQ1IagNgS1IagNQW0IakNRG4raUNSGojYUtaGoDUVtKGpDURuK2jDUhqE2DLVhqA1DbRhqw1Abhtow1IahNgpqo6A2CmqjoDYKaqOgNgpqo6A2CmqjoDYqaqOiNhZ3wOrHzlG9/MAdjPYHsKsfoFz9APXqB2hXP0C/+gH86geIix9gsan9iQ8gVz9A9hPtLzX/7PF+/OVZPvwNQbuqSDWkOlH5i052I8AoMAZMAaYC04DpwDgwkTcOOnDQgYMOHHTgoAMHHTjowEEHDjpw0EGADgJ0EKCDAB0E6CBABwE6CNBBgA7yF+SI5K/I2Y0Ao8AYMAWYCkwDpgPjwIAOBHQgoAMBHQjoQEAHAjoQ0IGADgR0IKADBR0o6EBBBwo6UNCBgg4UdKCgAwUdKOjAQAcGOjDQgYEODHRgoAMDHRjowEAHBjoooIMCOiiggwI6KKCDAjoooIMCOiigg/kW9qXrCvcvjVvOfN1/9Z/XHx9ev3l892kXT//yz/dvPz98eP/3Lz//94/nf/Pm48Pj48Pvr/74+OHtu1///Pju1eOHt0//7m57+sdTGqH1Pur27fvc/Zeqfq9m3/6v7b/c///p/f6Psj/u/tj/Aw==",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "// This test is exactly the same as `reference_counts_inliner_0` which uses\n// arrays rather than slices.\n// This test exists to make sure that our reference counting debug methods match\n// between arrays and slices.\n// We could most likely combine the code for these tests (e.g. using generics),\n// but it is simpler to debug isolated tests.\n// It should only be necessary to have a test at one inliner setting, as we\n// are just checking for discrepancies between the array and slice debugging builtin functions.\n// The actual functionality of reference counting is tested with the `reference_counts_*` tests.\n// We went with testing at an inliner aggressiveness of zero, as this is generally\n// the most useful inliner setting for unconstrained functions.\nuse std::mem::slice_refcount;\n\nfn main() {\n    let mut slice = &[0, 1, 2];\n    assert_refcount(slice, 1, true);\n\n    borrow(slice, slice_refcount(slice));\n    borrow_mut(&mut slice, slice_refcount(slice));\n    let _ = copy_mut(slice, slice_refcount(slice));\n\n    borrow_mut_two(&mut slice, &mut slice, slice_refcount(slice));\n\n    let mut u32_slice = &[0, 1, 2];\n    let rc1 = slice_refcount(slice);\n    let rc2 = slice_refcount(u32_slice);\n    borrow_mut_two_separate(&mut slice, &mut u32_slice, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(slice: [Field], rc_before_call: u32) {\n    assert_refcount(slice, rc_before_call, true);\n    println(slice[0]);\n}\n\nfn borrow_mut(slice: &mut [Field], rc_before_call: u32) {\n    assert_refcount(*slice, rc_before_call, true);\n    slice[0] = 3;\n    println(slice[0]);\n}\n\n// Returns a new slice (a copy) to prevent SSA from optimizing away mutations.\nfn copy_mut(mut slice: [Field], rc_before_call: u32) -> [Field] {\n    assert_refcount(slice, rc_before_call, true);\n    slice = &[4, slice[1], slice[2]];\n    println(slice[0]);\n    slice\n}\n\nfn borrow_mut_two(slice1: &mut [Field], slice2: &mut [Field], rc_before_call: u32) {\n    assert_refcount(*slice1, rc_before_call, true);\n    assert_refcount(*slice2, rc_before_call + 1, true); // should be a copy\n    slice1[0] = 5;\n    slice2[0] = 6;\n    println(slice1[0]); // slice1 & 2 alias, so this should also print 6\n    println(slice2[0]);\n}\n\nfn borrow_mut_two_separate(\n    slice1: &mut [Field],\n    slice2: &mut [u32],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*slice1, rc_before_call1, true);\n    assert_refcount(*slice2, rc_before_call2, true);\n    slice1[0] = 7;\n    slice2[0] = 8;\n    println(slice1[0]);\n    println(slice2[0]);\n}\n\nfn assert_refcount<T>(slice: [T], mut expected: u32, expect_copy: bool) {\n    let count = slice_refcount(slice);\n\n    if expect_copy {\n        expected += 1;\n    }\n\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut slice: [Field] = &[0, 1, 2];\n\n    let refcount_0 = slice_refcount(slice);\n    borrow_mut_two(&mut slice, &mut slice, refcount_0);\n\n    let refcount_1 = slice_refcount(slice);\n    let slice_2 = copy_mut(slice, refcount_1 + 1);\n    let refcount_2 = slice_refcount(slice);\n\n    assert_eq(slice[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(slice_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh slice and not decrease its RC\",\n        );\n\n        assert_eq(\n            refcount_1,\n            2,\n            \"There is 1 clone after `borrow_mut_two` and before `refcount_1` is defined (cloned before slice_refcount call)\",\n        );\n        assert_eq(\n            refcount_2,\n            refcount_1 + 3,\n            \"after refcount_1 we clone once in passing slice to copy_mut, once to slice_refcount after, and once within copy_mut\",\n        );\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
