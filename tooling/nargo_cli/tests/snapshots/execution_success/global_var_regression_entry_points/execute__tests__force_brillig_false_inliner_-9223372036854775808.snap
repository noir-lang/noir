---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+1U207EIBCFthutGzVxX/QvoEChb5t4+Q9qy3f0091mGTtLW2OysBrjJA23cjgcZg4lx8gPX+H70FIyD5jb+5adFzwiFsN8s9TEM4QlWC1lr6ueC25Z1bRGMana2nDDlVFdZYTojTS6aRvNGi5Fz51qRO+OUXh+M9K/XPCUPClJkxh5aoHzCInhEPGlaqQLcxCQRE++LYN56kXYR7pvucApFr5hsi7J/L0i8hclOS2+FPoAZgJ8duVxXoYJP7zLGLd+jHMG9lz7dejfoz1jvCJs2J9St8O7q8S68R1Z1wpy7nkgnxHr3K3XeDdBz8w/fCfMI1wL98K/W3SPYoivoTaTseYef0MWDBadvwn+f/TjG3QXaIszeDptuRPWWWW7Tr7bhwCfIM1Gnf6IV+pLeWWimqxK9PYJ8Be9Et8Fzv3KK2EN1xz441jXd2Tqhz76hs69kI/WP+mja16XB2NcDxk51Zmu4P572/e87QO9fnNl4g0AAA==",
  "debug_symbols": "pZLbisMgEIbfZa69iPGQja9SSjCJLYKYYHVhCXn3HUNtsyxdlvTGcQ7/54F/gdH06dpZf5luoE4L9ME6Z6+dmwYd7eSxukCVFypBUQK0AcVWjKXGV8zKeBeDMbmz0yN11sH4CMon5wh8ape2odus/RajDtitCBg/YkTgxTqTdyt5qqvXUsoFvatxKx8AQf9P4OJJaF4R6j8ITPJCYLI9cgfBZCEITo8QWF0Akr+pP/ICwdq7XsjmPX1T/9CfMdODDb+cKTYv4r/VoBoCDNTHmg8IVvfO5KnMSX4oIkzj11w6xfBzmAYzpmDyATvX43qiLan5+WH6XSnf6xs=",
  "file_map": {
    "51": {
      "source": "mod consts;\nuse consts::EXPONENTIATE;\n\nfn main(x: Field, y: pub Field) {\n    // Safety: testing context\n    unsafe {\n        assert(entry_point_only_const_global(x) == 2);\n        check_acc_entry_point(x, y);\n        assert(entry_point_only_const_global(x) == 2);\n        entry_point_inner_func_globals(x as Field, y);\n        // NOTE: We want a lot of these calls to display clearly\n        // that execution time has not been tainted by accidentally initializing globals\n        // for entry points which do not use them.\n        assert(entry_point_no_globals(x, y) == 1);\n        assert(entry_point_no_globals(x, y) == 1);\n        assert(entry_point_only_const_global(x) == 2);\n        assert(entry_point_only_const_global(x) == 2);\n        assert(entry_point_only_const_global(x) == 2);\n        assert(entry_point_only_const_global(x) == 2);\n        assert(entry_point_only_const_global(x) == 2);\n        assert(entry_point_no_globals(x, y) == 1);\n        assert(entry_point_no_globals(x, y) == 1);\n        assert(entry_point_no_globals(x, y) == 1);\n    }\n}\n\nunconstrained fn check_acc_entry_point(x: Field, y: Field) {\n    let mut acc: Field = 0;\n    for i in 0..2 {\n        for j in 0..2 {\n            acc += EXPONENTIATE[i][j];\n        }\n    }\n    assert(!acc.lt(x));\n    assert(x != y);\n\n    assert(inner(x + 1) == 2);\n}\n\nfn inner(x: Field) -> Field {\n    x + 1\n}\n\nunconstrained fn entry_point_only_const_global(x: Field) -> Field {\n    inner(x + 1)\n}\n\nunconstrained fn entry_point_no_globals(x: Field, y: Field) -> Field {\n    x + y\n}\n\nunconstrained fn entry_point_inner_func_globals(x: Field, y: Field) {\n    one_more_wrapper(x, y);\n}\n\nunconstrained fn one_more_wrapper(x: Field, y: Field) {\n    check_acc_entry_point(x, y);\n    check_acc_entry_point(x, y);\n    check_acc_entry_point(x, y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "entry_point_only_const_global",
    "entry_point_no_globals"
  ]
}
