---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "[noir_version]",
  "hash": "[hash]",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "4717959987348973079": {
        "error_kind": "string",
        "string": "the original should not be mutated by copy_mut, only borrow_mut_two"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6055981641117986912": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array with an RC of 1"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12435520423058260345": {
        "error_kind": "string",
        "string": "borrow_mut_two should create a fresh array and not decrease its RC"
      },
      "15646392865860948187": {
        "error_kind": "string",
        "string": "the copy should have the expected content"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "use std::mem::array_refcount;\n\nfn main() {\n    let mut array = [0, 1, 2];\n    assert_refcount(array, 1);\n\n    borrow(array, array_refcount(array));\n    borrow_mut(&mut array, array_refcount(array));\n    let _ = copy_mut(array, array_refcount(array));\n\n    borrow_mut_two(&mut array, &mut array, array_refcount(array));\n\n    let mut u32_array = [0, 1, 2];\n    let rc1 = array_refcount(array);\n    let rc2 = array_refcount(u32_array);\n    borrow_mut_two_separate(&mut array, &mut u32_array, rc1, rc2);\n\n    // Safety: test\n    regression_7297();\n}\n\nfn borrow(array: [Field; 3], rc_before_call: u32) {\n    assert_refcount(array, rc_before_call);\n    println(array[0]);\n}\n\nfn borrow_mut(array: &mut [Field; 3], rc_before_call: u32) {\n    // Optimization: inc_rc isn't needed since there is only one array (`array`)\n    // of the same type that `array` can be modified through\n    assert_refcount(*array, rc_before_call + 0);\n    array[0] = 3;\n    println(array[0]);\n}\n\n// Returning a copy of the array, otherwise the SSA can end up optimizing away\n// the `array_set`, with the whole body just becoming basically `println(4);`.\nfn copy_mut(mut array: [Field; 3], rc_before_call: u32) -> [Field; 3] {\n    assert_refcount(array, rc_before_call + 1);\n    array[0] = 4;\n    println(array[0]);\n    array\n}\n\n/// Borrow the same array mutably through both parameters, inc_rc is necessary here, although\n/// only one is needed to bring the rc from 1 to 2.\nfn borrow_mut_two(array1: &mut [Field; 3], array2: &mut [Field; 3], rc_before_call: u32) {\n    assert_refcount(*array1, rc_before_call + 1);\n    assert_refcount(*array2, rc_before_call + 1);\n    array1[0] = 5;\n    array2[0] = 6;\n    println(array1[0]); // array1 & 2 alias, so this should also print 6\n    println(array2[0]);\n}\n\n/// Borrow a different array: we should be able to reason that these types cannot be mutably\n/// aliased since they're different types so we don't need any inc_rc instructions.\nfn borrow_mut_two_separate(\n    array1: &mut [Field; 3],\n    array2: &mut [u32; 3],\n    rc_before_call1: u32,\n    rc_before_call2: u32,\n) {\n    assert_refcount(*array1, rc_before_call1 + 0);\n    assert_refcount(*array2, rc_before_call2 + 0);\n    array1[0] = 7;\n    array2[0] = 8;\n    println(array1[0]);\n    println(array2[0]);\n}\n\nfn assert_refcount<T>(array: [T; 3], expected: u32) {\n    let count = array_refcount(array);\n\n    // All ref counts are zero when running this as a constrained program\n    if std::runtime::is_unconstrained() {\n        if count != expected {\n            // Brillig doesn't print the actual & expected arguments on assertion failure\n            println(f\"actual = {count}, expected = {expected}\");\n        }\n        assert_eq(count, expected);\n    } else {\n        assert_eq(count, 0);\n    }\n}\n\nfn regression_7297() {\n    let mut array = [0, 1, 2];\n\n    let refcount_0 = array_refcount(array);\n    borrow_mut_two(&mut array, &mut array, refcount_0);\n    let refcount_1 = array_refcount(array);\n    let array_2 = copy_mut(array, refcount_1);\n    let refcount_2 = array_refcount(array);\n\n    // Mutation of the original could occur if we double decremented the RC and then went back to 1 by accident.\n    // For this to come out we have to run the test with `--inliner-aggressiveness -9223372036854775808`\n    assert_eq(array[0], 6, \"the original should not be mutated by copy_mut, only borrow_mut_two\");\n    assert_eq(array_2[0], 4, \"the copy should have the expected content\");\n\n    if std::runtime::is_unconstrained() {\n        // Double decrementing the RC could occur if we don't realize that array mutation made a copy,\n        // which decreases the RC of the original and sets the new one to 1.\n        // This assertion is redundant with the one following it, but it's here because `assert_eq` doesn't print\n        // what actual values that cause it to fail, so this is a way to highlight the bug about the refcount of\n        // still live arrays going to zero, without any doubt that it's just not 1, as it should be.\n        assert(\n            refcount_1 != 0,\n            \"borrow_mut_two should create a fresh array and not decrease its RC\",\n        );\n        assert_eq(refcount_1, 1, \"borrow_mut_two should create a fresh array with an RC of 1\");\n        assert_eq(refcount_2, refcount_1);\n    }\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
