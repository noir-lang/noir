---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "10882471991489596736",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "// Converts an array into a slice.\nfn as_slice_push<T, let N: u32>(xs: [T; N]) -> [T] {\n    let mut slice = &[];\n    for elem in xs {\n        slice = slice.push_back(elem);\n    }\n    slice\n}\n\n// Expected that x == 0 and y == 1\nfn main(x: Field, y: pub Field) {\n    let xs: [Field; 0] = [];\n    let ys: [Field; 1] = [1];\n    let zs: [Field; 2] = [1, 2];\n    let ws: [Field; 3] = [1; 3];\n    let qs: [Field; 4] = [3, 2, 1, 0];\n\n    let mut dynamic: [Field; 4] = [3, 2, 1, 0];\n    let dynamic_expected: [Field; 4] = [1000, 2, 1, 0];\n    dynamic[x] = 1000;\n\n    assert(x != y);\n    assert(xs.as_slice() == as_slice_push(xs));\n    assert(ys.as_slice() == as_slice_push(ys));\n    assert(zs.as_slice() == as_slice_push(zs));\n    assert(ws.as_slice() == as_slice_push(ws));\n    assert(qs.as_slice() == as_slice_push(qs));\n\n    assert(dynamic.as_slice()[0] == dynamic_expected[0]);\n    assert(dynamic.as_slice()[1] == dynamic_expected[1]);\n    assert(dynamic.as_slice()[2] == dynamic_expected[2]);\n    assert(dynamic.as_slice()[3] == dynamic_expected[3]);\n    assert(dynamic.as_slice().len() == 4);\n\n    regression_4609_append_slices(x, y);\n    regression_4609_append_dynamic_slices(x, y);\n}\n\nfn regression_4609_append_slices(x: Field, y: Field) {\n    let sl = [x, 1, 2, 3].as_slice();\n    let sl2 = [y, 5, 6].as_slice();\n    let sl3 = sl.append(sl2);\n    assert(sl3[0] == x);\n    assert(sl3[4] == y);\n}\n\nfn regression_4609_append_dynamic_slices(x: Field, y: Field) {\n    let mut sl = [x, 1, 2, 3].as_slice();\n    sl[x] = x + 10;\n    let mut sl2 = [y, 5, 6].as_slice();\n    sl2[y] = y + 5;\n    let sl3 = sl.append(sl2);\n    assert(sl3[0] == 10);\n    assert(sl3[4] == y);\n    assert(sl3[5] == 6);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
