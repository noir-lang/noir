---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "16955521588773367337",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "zd3bjhxFFkDRf+lnHiLO/fAro9HIgBlZsmxkzEgjxL9Pgago6LBoMdWK2m9udzq9VFW9O28n8+en795+89O///Xuw/cff3z6+h8/P73/+O2bz+8+frh89fPT+O2vfvzhzYdfv/rx85tPn5++njK+enr74bvLn8J++erp+3fv3z597eOXr7ZF1eP3RbX9rxedY+p1tUPmHxf+51dPkwIRCkQpEKNAnAIJCiQpkKJAGhM0TloxbZ0Pi2s8lxytq63VDqvnEsNIHCMJjCQxksJI+kES1+fbakcbGzdJPH9NZGIkgpEoRmIYiWMkgZEcbWz5kvTWk3qUZHtNTjZ2Trmu9vI/PN8NHY+S+HPJycZOXe/OtOefExWMRDESw0gcIwmMJDGSwkiaIrGBkWAaaw9r7PPfxaYYiWEkjpEcbWzEkqQ9lyRGUo+S9HPJ0cb2Wu3ctqh9YCQTIxGMRDESw0gcIwmMJDGSwkgwjY2TjRVZ53dEnx8riImRCEaiGIlhJI6RBEaSGElhJE2RJKaxiWlsYhqbmMYmprGJaWxiGpuYxubRxkYvSeZzSVMkNTCSiZEIRqIYiWEkjpEERpIYCaaxhWlsYxrbmMY2prGNaWxjGtuYxvbJxupYq9X5/Cxtn2ysSi6JjeeSwkjubayN+fuiZvKCxH1t23tsV7mPwaFMDkU4FD1JKVuUlo1iHIo/ipIbJQ5SYtRa7dw/K8mhFIfSGMocHMrkUIRDUQ7FOBTnUDi1nUdra3OtdptymrM4lMZQZHAok0MRDkU5FONQjta21n5qtG+U4FCSQykOpTEUHRzK5FCEQzlZ25xr0yl1u8vD3aNgZtfV+3hp0a7r8RXr3inOocQ5io/Za1nZPyvJoRSH0icp674G/qV7ggwOZXIowqEoh2IcinMowaEkh1IcCqe2zqmtc2rrnNo6p7Z+tLa9lp3DNopzKMGhJIdysrYzc1H2nQ9vDCUGh3KytqLX/evLH3ujCIeiHIpxKM6hnKyt5Pp1KLXtM0dyKMWhNIaSg0OZHIpwKMqhGIfiHAqntsmpbXJqm5zaFqe2xaltnaytrtsRuW43RpqlHIpxKM6hBIeSD6LU2CjFoZysrc3rtdlusl0m3pza9snamvl6VfYLjFo4FOVQjEPxR1G2Iwl9sraWuii1U07W1sei+H79yt2jZJeDwdfV//lu519YNGOxM7erkO+eJXs1itw9S/aKlMmhCIeiHIo9iFLb49zuniX7W5S6UXp/VYJDSQ6lOJTGUObgUCaHcrK2tR4g5rU/JnLqoyj7q3KytnW7PKJsfwySP4iyPxtqnqxt3S4E6LG/QcmhnKxtrSvWLyrfKI2hyOBQJociHIpyKMahOIcSHEpyKJzaCqe2yqmtcmqrJ2vbayMhxnbhoqhyKMahHKxt3EaVYkhulOBQkkMpDqUxFBscyuRQhENRDsU4FE5tjVNb49TWOLU1Tm39aG3XdEOM2g6A+eRQhENRDuVkbee4Plo55hwbxTmU4FCSQykOpTGUGBzK5FCEQzlZ22nrN/MM2SjGoRytbV8v5wzZD2pEcCjJoRSH0hhKDg7lZG1l3e09ZLvbu9w9S+ZpayMx/nrR2bIetty6vyrKodijKL1R/CTF12rbt8sj7p4le0VKcijFoTSGcvcs2StSJociHIpyKMahcGpbnNrWwdrKWNMNMuZ24WIVh9KPomzXxfU4SdFYFNu2V+6eJYu5dsn9hUVl+pUtX9hRvXuW7BUpyqHYoyjb6Ya7Z8n+FiVrUWr/CQoOJTmU4lCaQtG7Z8lekTI5FOFQlEMxDgVTWx2Y2urA1FYHprY6OLWdJ2t7u3Wd7Leu0zk5FHkQxWyjnKzt5UTYoqRsFHsUJTfK3bWN66LRL1Fs7b6J1f6qBIeSj6Lsb1AdpPh65Ii47IlrDOXuWbL/l7LdyELvniX7WxSTRfGxUYRDUQ7FOBTnUIJDSQ6lOJTGUHRwKJzaKqe2erS261nesj/LW++eJcv1iLRUfYGScb3x1uX89v6qOIcSHEpyKMWhNIZy9yzZK1ImhyIHKX3bZ+599/3uWbJXpBiH4hzKwdpeTrNcV3s5zeEbJTmUk7Xtthtl2323xlB8PIiy3WpXfZ78rKwb+l3OLeyvinAoyqEYh3KwtnobP9F9/EQ9OJTkUIpDaQwlxsmfoJ7rJ6i3U1MxORThUJRDOVnbqes389yPr4RzKMGhJIdSHEpjKDk4lMmhnKztzJW4mVviUh9E2R6uoXmytqLXYb/L2bmd4hxKPIji23nmPFlbuX1WZL8mIYtDaQylBocyORThUJRDMQ7FOZTgUE7WVsc61KP7EcqqB1H2I5R1sra6rou7nCjcKD04lPkoSm2Uk7U1XYd6zLaPbSuHYhyKcyjBoSSHUhxKUyg2BocyORRMbW0cre26UuNyUnlslJO19Vj7zL4979CGcygnaxu3rbgQ2ygna5tjvSo591elOJSTtY2KRdmeH2RzcCiTQxEORTkU41CcQwkOJTmU4lA4tRVObYVTW+HUVji1FU5thVNb4dRWOLUVTm2FU1vl1FY5tVVObZVTW+XUVjm1VU5tlVNb5dRWObU1Tm2NU1vj1NY4tTVObY1TW+PU1ji1NU5tjVNb59TWObV1Tm2dU1vn1NY5tXVObZ1TW+fU1jm1DU5tg1Pb4NQ2OLUNTm2DU9vg1DY4tQ1ObYNT2+TUNjm1TU5tk1Pb5NQ2ObVNTm2TU9vk1DY5tS1ObYtT2+LUtji1LU5ti1Pb4tS2OLUtTm2LU9vm1LY5tW1ObZtT2+bUtjm1bU5tm1Pb5tS2MbX1gamtD0xtfWBq6wNTWx+Y2vrA1NYHprZ+dpbM1i0bcnukq5+dJftrSj+I4s/vYORHZ8kydVFqbpTJocijKLlRTta2ag0RV9tGMQ7lZG0relG+8FkJDiU5lOJQGkM5Okv2AmVyKMKhKIdiHAqntsKprXBqK5zaCqe2yqmtcmqrnNoqp7bKqa1yaquc2iqntsqprXJqa5zaGqe2xqmtcWprnNoap7bGqa1xamuc2hqnts6prXNq65zaOqe2zqmtc2rrnNo6p7bOqa1zahuc2gantsGpbXBqG5zaBqe2waltcGobnNoGp7bJqW1yapuc2iantidnyWzU9UoNm2NslIO1NdHrZVcmLhslTlLiRtmv1Lh/lkyv73/mSxST60UjZrq/QcWhNIZy/yzZ61EmhyIcinIoxqE4hxIcCqe2xaltcWrbnNo2p7bNqW1zatuc2vbJ2rpcl7XLmcKNEhxKcijFoTSFEmNwKJNDEQ5FORTjUDC1jYGpbQxMbWNgahuDU9vJqe3k1HZyajs5tZ2c2k5ObefR2q4HUtrlGNNGOVrbXpQQ3yh31zavlPrz89P3RcPXPHNc9gU3SmMo98+SvR5lHqRYXh9eGvYFinAoepBy+TVzpYTkRjEOxTmU4FCSQzlZ2/AbJXZKYyg6OJTJoQiHohyKcSjOoRytbV0fQR855kY5WducN4ptGwl3z5LVOm5fL21mR9vaiuvtopG4e5bs9Sh3z5K9ImVyKHKSEroouf0E3T1L9ooU41CcQwkOJTmU4lAaQ/HBoUwO5Wht264Hy8bojaIcinEozqEEh5IcSnEoB2ubQ8ei2HY0OwaHMjkU4VCUQzEOxTmU4FCSQykOhVPb5NQ2ObVNTm2TU9vk1DY5tU1ObZNT2+TUNjm1raO1XXeIztFjo0wO5Whtc01ujtz2g0o5FONQnEMJDiU5lOJQGkPpwaFMDuVkbee6lCbnfilNK4diHIpzKMGhJIdSHEpTKDkGhzI5FExtc2Bqe9k14lAwtc2BqW0OTG1zYGqbg1Pbyant5NR2cmo7ObWdR2vra+djRmwU51CCQ0kOpTiUxlBkcCiTQxEORTkUTm2FU1vh1FY4tRVObYVTW+XUVjm1VU5tlVNb5dRWObVVTm31aG3XDYgvW4+9UThHEpRzJOHkLFnebst82TiZG2VyKMKhKIdiHIpzKMGhJIdysraSN0rvlMZQfHAonNo6p7aunDfIOBTnUIJDSQ6FU1vn1DY4tT06S/YCRTgUTm2DU9vg1DY4tQ1ObY/OkqnenjVk2/GVo7Nkf005Okv2AoWzbZucbdujs2QvvEHGoTiHEhxKciic2iantsWp7dFZshcowqFwaluc2hantsWpbXFqW5zaFqe2zaltc2rbnNo2p7bNqW1zatuc2jants2pbWNqWwNT2xqY2tbA1LYGprY1MLWtgaltDUxta2BqWwNT2xqc2k5ObSentpNT28mp7eTUdnJqOzm1nZzaTk5tJ6e2wqmtcGp7dJZMbzfI0dopyqEYh+IcSnAoyaEUh9IYytFZshcok0Ph1FY5tVVObZVTW+XUVjm1VU5tlVNb49TWOLU1Tm2NU1vj1NY4tTVObY1TW+PU1ji1dU5tnVNb59T26CyZjTX7bjI2ysnamq5nTZnJRnEOJTiU5FCKQ2kM5egs2QuUyaEIh6IcCqe2waltcGobnNoGp7bBqW1yapuc2ubDalsb5WhtQxZle35QHZ0l87FeFdf9DTpZW7c17OdpG+Vkbb3qSom57QfdP0uW/fuiLf4CJcWvlMs5541SHEpjKPfPkr0eZZ6k+I2SW1funyV7PYpyKMahOIcSHEpyKEdr2+tYXI3td1A1htKDQ5kcinAoyqEYh+IcysnaXjZJFqV9oySHUhxKUyg9BocyORThUJRDOVnbtrXP3J4bxTmU4FCSQykO5WBta/iVUiOf7773HBzK5FCEQ1EOxTgU51CCQ0kOpTgUTm2FU1vh1FY4tRVObYVTW+HUVji1FU5thVNb4dRWObXVo7Xt62prbsfiWo/WdvZ6VdQ2inIoJ2s7Tdcb5LVRnEMJDiU5lOJQGkOxwaGcrO3s6xnVktEbRTgU5VCMQ3EOJTiU5FCKQ2kMxQeHwqmtn6ytiC3KvkHpJ2srt50PSdkoxqGcrK1ULkr/eT/o8sU3n969f//u3/96//HbN5/fffzw4+WfXv76P28+vXvzzfu3v3/5/U8fvv3Ddz//94frd67//odPH799+91Pn97+uqbfvndZ/f8A",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/slice_dynamic_index/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "directive_integer_quotient",
    "directive_invert"
  ]
}
