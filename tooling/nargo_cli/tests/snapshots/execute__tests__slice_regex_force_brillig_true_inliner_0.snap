---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "8015721519311710062",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
