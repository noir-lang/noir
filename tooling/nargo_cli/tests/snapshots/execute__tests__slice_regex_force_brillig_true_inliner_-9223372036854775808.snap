---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "8015721519311710062",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/slice_regex/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
