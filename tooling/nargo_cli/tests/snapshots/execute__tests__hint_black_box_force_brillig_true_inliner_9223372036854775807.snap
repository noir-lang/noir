---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "9444591037418029896",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      },
      {
        "name": "b",
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 32
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+VbvY7kRBCuHo896/nRjEAXIIEEwSWIwJ7/lU7iAg4kJGIkEuSbnRUJ7zAPQIBEwoMQIJEQ8QIkSCQkCJFecOndja5rXf5c3TPedc/s6Syt2tNdXf/9dbntNfT6MvZvf3Vt26H6xTSPbZvd7cpb5JWF1NME0rPiZEPui8e+sjcpzN93Ry0anILcNvmvs/kyVexrUf9ZKngG4D9l/t0w/LOe5fPZrsqfQG4EdNocpnkiaJ4AzYiqICD58JjMVZ5/8epvTOX9xN6nwC9E/kid2vb/u4r+LGtgbc1MOSZjQlYXnI/3sf2dOOiZXwz0D4S/l0bnKXXoenRIFB0kfQw6MP17Hh00P8QNdYg9fmD6D+j8fviIDvuh67CrAzyZ/qFtU5DVdo6/I/gSyAqLb7Mpxqnr8Dv6iOk/vkc+CoRBxYjcOWOojslajuG6O7TW0N9Mz1WLlueJokPHo0NP0UHSJ6AD0889Omh+SBrqkHj8wPRrOr8fHtFhP3QddiGWMv1j26aKrqHXE8vS6gxzGr2WBuQRVest1LVPQdd+7tvHpH864Dst5yfKmGv/k3ISRc7bzgsxmUCObFkO9rGc0HvXhOprBveuXhjZC+Z/EYZ/PhI80bZ9+7XoN1Q+L8dUxl7O7YlxSf+hKXl+Y/vGQKNhu1bXSHpXbf+tbdl/fQriPxWHWZav7hiBLchDtkT+/J8ofklAjiu+W9EvdT82vkw/EfH9zvZxfKX9Kcjj367aHuPL9N/b9pzxTRWbQqz9QRj+M4w5kb7GWP5dMVvK6lM91iH2fc02qT+uIZlHmKsar35DXoHzdYbrSrNbwyhNV80O06JP3iZe2rlgk7WjyZHzGNN9e2porGSdGC8kpmv51aE6vvE9UYn53PeDbfe10KUp57jyPfX4TtuTDu2VP5Ius2ktFIm98ifbp8UN85B/H1sLMf3Ptr0PtZAc65xGr4UBeRH51zHrMwyjzwzXCZG+Tobgu9vWilJWn+p5E2Lf1WzzrUeJAYifGq9BQ17njKn09RBsGyr0GuaPmGZX58VjXTE2gLF4V/fJHkcfmZLulPuTrzYKVO9m6HOJo1rOdKgeMxmvGPp+sa22PzWtIVJFn0P7069UlSnPXo/Zn5j+ueD5m70fK/MN3Gv7k/auFfen320b+HlK3Z9SsE+OYd0U6B14hvWEy3+sW0fxk8RWrDf+sK2Wl7imXfij1U1Mp+3tPRjT6tE2zwB9Z3Rj0EnDnHPXxD1hD+KRryb+07ZabHtU9R32+TCnB/6RvqP2/JPjuwrEtL+oalMk/KC96zHgJ6b/T/D829771jxiqIybpHe9B/qHqv4LhR0aprGskUffu9r37z21j3NnQPUc+N+2+7Xyhanqf1/O2BAvJL3EC46Dti8PYEzOixvKwf2Ha53EQc/8sDZ6Zlv5rlXDbPRDpOgn1zu/F9FwJBK6Mo68qfFmW8aKnb54m4ZyEEtvG+8XttXibcjtB+37A5mDGO9I0V3WwueMty+vm8Zby5024o3nTbeN99AKbhpv7dzu2HinQlc+mzvm+TLQGcDNOdPNM7fDpqEYl/QPhA+/NFU/aecE2nsM1EHSo93SXzIuIzosW8sJlO3KIZf973tyyHeGoq29Y3OoL3Td2vtjztAD4cnCKD7SbHKtw4eeHNKwQPsGxhd3tFv6S4uxT7Z2xuHDofQI+z/x5JAPj9vCIf5e4uZZflfStZUnq3XGn0zfnAfGVK2VCOTHQL+wDKTfue3eQc/rVZFfz4rrYlFcXc03Bdbv+0t+/922/PmiWG2KVZ5fzvPtPF+cWn6xmq030/lm9XQxK2bLg/Zzf29XjnMcI9EX23vGygtJD2OpGOvuqvL79jc/7yEv1iMG+s8tA/4fhUTM4fkTRX4C8it6K30Sg5BXpPTJmu9TOylEXDeL5dPNq+TKtvn+5/TUebVdX15ll9fbIs/z6VW2PST/JVzz4XuRNgAA",
  "debug_symbols": "tZzbTuNKEEX/Jc956Krq6gu/cjQacQmjSCigAEc6Qvz7cUY4QenG1o6zX0bx4LUg7Kqm0237Y/WwuXv/83u7e3x+Xd3887F6er6/fds+74ajj8/16m6/fXra/vn9/b9X4fCP5L/nv77c7g6Hr2+3+7fVjaiuV5vdw/DKbOAft0+b1Y2Hz3Vzqormr3NVLH4/+dd6JYWrr1S9Bq5euHrl6o2rj1y9c/WJq+d2rXK7Vrlda9yuNW7XGrdrbbZr0zkRYcJhIsFEtwNU6vjW23deYKKiRAwwITDRLRBL6YuwXM8Jg4lu5uZjYVkJS4owOlefuPrM1ReuvlL1Hrh64eqVqzeuntu1zu1a53atc7vWuV3r3K5Ns11r54TAhMKEwUSECYeJBBMZJgpMVJTIcOYZzjzDmWc48wxnnuHMM5x5hjPPcOa5m3lM46w55jQzKHybZ6qGM30JXL1w9crV58V6K0e9nU/A6/LfvaejPuVz/ezvvvmBFCYMJiJMdDvZw/jWvcmtdjs51hMhS8qiZq6+UPUSZLF/qqolxMX+qbKW4HP+ZgU5JBzJOFJwpDu6u4/d4KlBJOCI4IjiiOFIxBHHkYQjGUcKjuDpK56+4ukrnr7i6SuevuLpK56+4ukrnr7i6Ruefn8l2+MJyTOjsdnxQ6VZafxK9hvZH8l+J/sT2Z/J/kL2V66/vxtwRT+5f+Py+nc7+t0b//L6yXr0Nx8OJM7VT24mwLHCiAccERzpj6V1zC+JNIjNIO38v7+CPI04jiQcyThScKTCSH/ldBoRHFEcwdNPePoJTz/h6Sc8/YSnn/D0M55+fxHVywmZ29+fHrT7S65X9BvZH8l+J/sT2Z/J/kL2V66/v2p9RT+5f8vy+p+cdJXl9TM56Sqz9ZMapMJIDTgiONIdS2sel1BrbSZd/VXvaSTiiONIwpGMIwVHKopo6KZf0wlpr+QVHOmn73JEfKZTYh7PHV5q4zeyP5L9TvYnsj+T/YXsr1x/fzfhin4h+8n9K8vr8/jHZ3hZG//ifE8boepyfvWA/nB3Q5Bx+jC8zA0kl0B6CWSXQN0xb9iBGMf5YZug+XPy070AqRyhNv2frvCfhvIlULkE6l9jbzWMUAwNZMKtaFOy38j+SPY72U8esSyT/YU7Ihp5xI2B7BeyX8l+I/uXr81MfbbWmMn+QvZXrt8D2b98bWZqbUNdyX4j+yPZ72R/IvuXbwhP1mcKZL+Q/Ur2G9kfqRvOmpzsT2R/JvsL2V+5/v7e2tUuj9X+3hrkP14s3bk8Vvt7a1f0O9mfyP5M9heyv3L9P9wRcq3Lt7UI2a9kv5H9kex3sr9f/9e6aUbL8huiJuv/CnflTPuF7Fey38j+SPY72Z8W+yf7q2ayv5D9leq3EMh+Ifo/h6N/b/fb27unzddjvR7fd/ffnvL19t/L5uyBXy/75/vNw/t+c3j01+mpX4c+NUlr0/TrcKvR4TDEtYV6OJS/Xw1rEx2+6/Cd/wc=",
  "file_map": {
    "50": {
      "source": "use std::hint::black_box;\n\nfn main(a: u32, b: u32) {\n    // This version unrolls into a number of additions\n    assert_eq(loop_(5, a), b);\n    // This version simplifies into a single `constraint 50 == b`\n    assert_eq(loop_(5, 10), b);\n    // This version should not simplify down to a single constraint,\n    // it should treat 10 as opaque:\n    assert_eq(loop_(5, black_box(10)), b);\n\n    // Check array handling.\n    let arr = [a, a, a, a, a];\n\n    assert_eq(array_sum(arr), b);\n    assert_eq(array_sum(black_box(arr)), b);\n\n    assert_eq(slice_sum(arr.as_slice()), b);\n    assert_eq(slice_sum(black_box(arr).as_slice()), b);\n\n    // This doesn't work because by calling `black_box` on a slice the compiler\n    // loses track of the length, and then cannot unroll the loop for ACIR.\n    //assert_eq(slice_sum(black_box(arr.as_slice())), b);\n\n    // But we can pass a blackboxed slice to Brillig.\n    // Safety: testing context\n    let s = unsafe { brillig_slice_sum(black_box(arr.as_slice())) };\n    assert_eq(s, b);\n\n    let mut d = b;\n    // This gets completely eliminated:\n    let mut c = 0;\n    set_ref(&mut c, &mut d);\n    assert_eq(c, b);\n\n    // This way the constraint is preserved:\n    let mut c = 0;\n    set_ref(&mut c, &mut black_box(d));\n    assert_eq(c, b);\n\n    // A reference over the output of black box is not the original variable:\n    let mut c = 0;\n    set_ref(&mut black_box(c), &mut d);\n    assert_eq(c, 0);\n\n    // This would cause a causes a crash during SSA passes unless it's a Brillig runtime:\n    //  > Could not resolve some references to the array. All references must be resolved at compile time\n    // The SSA cannot have Allocate by the time we start generating ACIR, but `black_box` prevents them\n    // from being optimised away during SSA passes.\n    // If we use `--force-brillig` then the it doesn't crash but the assertion fails because `mem2reg`\n    // eliminates the storing to the reference.\n    //let mut c = 0;\n    //set_ref(black_box(&mut c), black_box(&mut d));\n    //assert_eq(c, b);\n}\n\nfn loop_(n: u32, k: u32) -> u32 {\n    let mut sum = 0;\n    for _ in 0..n {\n        sum = sum + k;\n    }\n    sum\n}\n\nfn array_sum<let N: u32>(xs: [u32; N]) -> u32 {\n    let mut sum = 0;\n    for i in 0..N {\n        sum = sum + xs[i];\n    }\n    sum\n}\n\nfn slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nunconstrained fn brillig_slice_sum(xs: [u32]) -> u32 {\n    let mut sum = 0;\n    for x in xs {\n        sum = sum + x;\n    }\n    sum\n}\n\nfn set_ref(c: &mut u32, b: &mut u32) {\n    *c = *b;\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/hint_black_box/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
