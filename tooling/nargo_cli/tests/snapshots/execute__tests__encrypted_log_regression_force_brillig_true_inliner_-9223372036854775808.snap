---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "3215626760925584142",
  "abi": {
    "parameters": [
      {
        "name": "eph_pk_bytes",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_header_ciphertext",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "incoming_body_ciphertext",
        "type": {
          "kind": "array",
          "length": 9,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "flag",
        "type": {
          "kind": "boolean"
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 15,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "8193989641828211937": {
        "error_kind": "string",
        "string": "ciphertext length mismatch"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "ndnbTuMwEIDhd8l1L+yxPR73VVYrVCCgSlWLelhpVfXdN6k2KcIuqP8NIqgfOfTHKZNz99o/n96f1tu33aFb/jp3m93L6rjebYet82XRPe/Xm836/enzjzs3fjG9vv7wsdqOm4fjan/slr64suj67Wu3FBfD8Bve1pu+WyZ3+b3oLANjwJTHTXHAeGAEmABMBCY9brxrIhGTCYnVSAnKBBlBBSDvCPIECUGBoEgQKcKTIjwpwpMiPClCSBFCihBShLSLCN5NKHhfoUhQIkgBCu2rZz5PyMQq1D4ni2FG2VWofU7F2YSKlAopQZkgI6hZeXBpyig4rTKKzcqHt2naUxjOoEKeIGkfXr4hlyoUCIoEJYKUoEyQEVQASo4gTxApIt0posQbihWKBCWClKAM/p6SEUSKUFKEkiKUFKFkjVCyRihZI5SsEUrWCCVrhJIiMiki37lrpDyjXN3dsxAUCIoEtYuQ+Z+uIKG+EEpQJsgIKgBZu4goM4qh+sRiniAhKBAUCWoXocVPKEu1LLfnMT+hTJAB1B6VhGxuRlbd1NrziJDLfPVMtEKZ7MkIalduPt0O72vl4hxBniAhqF253YK1pBWKBCWClKBMkBFUAGrPjb6vXLwnSAgKBEWCEkFKUCbICCoACSlCSBFCirgzzfl2xiJ3pjk/oPbkw9I8kDYtFTKCCkDBEXRnQpVvwyarLkQQggJBkaBEkBKUCbLH53sSCkDREeQJEoICQZGgRJASlAkiRURSRHq4iMuw9We1X6+eN/3/x7Bvp+3Lp6eyx78f/ZcHtB/73Uv/etr346Pa21PacecyLEdibjiY8d3PbnH9/vqpo9jCuzBujQkOBzW8UIcDGA7iHw==",
  "file_map": {
    "50": {
      "source": "// The code below is inspired by [compute_encrypted_log](https://github.com/AztecProtocol/aztec-packages/blob/b42756bc10175fea9eb60544759e9dbe41ae5e76/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr#L111)\n// which resulted in a bytecode size blowup when compiled to ACIR, see https://github.com/noir-lang/noir/issues/6929\n// The issue was around `encrypted_bytes[offset + i]` generating large amounts of gates, as per the `flamegraph.sh` tool in aztec-packages.\n// The details around encryption and addresses have been stripped away, focusing on just copying bytes of equivalent size arrays.\n\n// Original values which resulted in huge bytecode even on this example (500K long SSA)\n// global PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 18;\n// global ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n// global EPH_PK_SIZE: u32 = 32;\n// global HEADER_SIZE: u32 = 48;\n// global OVERHEAD_PADDING: u32 = 15;\n\n// Using the same formulas with smaller numbers; the effect is the same, but the SSA is more manageable.\nglobal PRIVATE_LOG_SIZE_IN_FIELDS: u32 = 4;\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 5;\nglobal EPH_PK_SIZE: u32 = 3;\nglobal HEADER_SIZE: u32 = 2;\nglobal OVERHEAD_PADDING: u32 = 1;\n\n// Unused because encryption didn't play a role:\n// global OVERHEAD_SIZE: u32 = EPH_PK_SIZE + HEADER_SIZE + OVERHEAD_PADDING;\n// global PLAINTEXT_LENGTH_SIZE: u32 = 2;\n// global MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n//     ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\nglobal BODY_SIZE: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - EPH_PK_SIZE - HEADER_SIZE - OVERHEAD_PADDING;\n\nfn main(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> pub [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] {\n    compute_encrypted_log(\n        eph_pk_bytes,\n        incoming_header_ciphertext,\n        incoming_body_ciphertext,\n        flag,\n    )\n}\n\nfn compute_encrypted_log<let M: u32>(\n    eph_pk_bytes: [u8; EPH_PK_SIZE],\n    incoming_header_ciphertext: [u8; HEADER_SIZE],\n    incoming_body_ciphertext: [u8; BODY_SIZE],\n    flag: bool,\n) -> [u8; M] {\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // NOTE: Adding a conditional variable can result in the array being fully copied, item by item,\n    // in each iteration in the second loop that copies incoming_body_ciphertext into encrypted_bytes.\n    // Depending on where we place the `flag` we either get the item-by-item copying (blowup),\n    // or just a single array item gets read and a new array constructed in each iteration (no blowup).\n\n    // If the `flag` is here then it blows up.\n    if flag {\n        // eph_pk\n        for i in 0..EPH_PK_SIZE {\n            encrypted_bytes[offset + i] = eph_pk_bytes[i];\n        }\n        offset += EPH_PK_SIZE;\n\n        // If the `flag` is here then it blows up.\n        // if flag {\n\n        // incoming_header\n        for i in 0..HEADER_SIZE {\n            encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n        }\n        offset += HEADER_SIZE;\n\n        // Padding.\n        offset += OVERHEAD_PADDING;\n\n        // If the `flag` is here then it does not blow up.\n        //if flag {\n        // incoming_body\n        // Then we fill in the rest as the incoming body ciphertext\n        let size = M - offset;\n\n        // NOTE: This made the bytecode size blowup disappear in aztec packages,\n        // but in this reproduction the size seems to be statically known regardless.\n        // let size = M - 32 - HEADER_SIZE - OVERHEAD_PADDING;\n\n        assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n        for i in 0..size {\n            encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n        }\n    }\n\n    encrypted_bytes\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/encrypted_log_regression/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
