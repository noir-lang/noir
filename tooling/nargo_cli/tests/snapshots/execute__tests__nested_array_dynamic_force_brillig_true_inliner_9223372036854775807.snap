---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "524947131582973539",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
