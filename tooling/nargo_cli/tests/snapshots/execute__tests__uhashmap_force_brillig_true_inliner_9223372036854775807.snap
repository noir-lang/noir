---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "11723795424994591957",
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": {
          "kind": "array",
          "length": 6,
          "type": {
            "kind": "struct",
            "path": "Entry",
            "fields": [
              {
                "name": "key",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "value",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "1359149291226868540": {
        "error_kind": "string",
        "string": "hashmap.len() does not match input length."
      },
      "2386996775688025706": {
        "error_kind": "fmtstring",
        "length": 39,
        "item_types": [
          {
            "kind": "array",
            "length": 3,
            "type": {
              "kind": "field"
            }
          }
        ]
      },
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3078107792722303059": {
        "error_kind": "string",
        "string": "Got incorrect iteration of values."
      },
      "3316745884754988903": {
        "error_kind": "fmtstring",
        "length": 36,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "4105629585450304037": {
        "error_kind": "string",
        "string": "UHashMap after one insert should have a length of 1 element."
      },
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "6665645948190457319": {
        "error_kind": "string",
        "string": "CtHashMaps should be equal."
      },
      "6693878053340631133": {
        "error_kind": "fmtstring",
        "length": 79,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "7233212735005103307": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "7511829951750337011": {
        "error_kind": "fmtstring",
        "length": 37,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "8082322909743101849": {
        "error_kind": "string",
        "string": "UHashMap after one insert and corresponding removal should be empty."
      },
      "9576462532509309328": {
        "error_kind": "fmtstring",
        "length": 82,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "9862881900111276825": {
        "error_kind": "fmtstring",
        "length": 35,
        "item_types": [
          {
            "kind": "field"
          }
        ]
      },
      "9965974553718638037": {
        "error_kind": "fmtstring",
        "length": 81,
        "item_types": [
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          },
          {
            "kind": "integer",
            "sign": "unsigned",
            "width": 32
          }
        ]
      },
      "10951819287827820458": {
        "error_kind": "string",
        "string": "Got incorrect iteration of entries."
      },
      "11665340019033496436": {
        "error_kind": "string",
        "string": "Value has been removed, but is still available (not none)."
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "12632160011611521689": {
        "error_kind": "string",
        "string": "Got none value."
      },
      "13674703438729013973": {
        "error_kind": "string",
        "string": "UHashMap length is invalid."
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "14241324264716156348": {
        "error_kind": "string",
        "string": "CtHashMaps should not be equal."
      },
      "15366650908120444287": {
        "error_kind": "fmtstring",
        "length": 48,
        "item_types": [
          {
            "kind": "field"
          },
          {
            "kind": "field"
          }
        ]
      },
      "15583592523844085222": {
        "error_kind": "string",
        "string": "Pair should have been removed, since it does not match predicate."
      },
      "16291778408346427203": {
        "error_kind": "string",
        "string": "Got incorrect iteration of keys."
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "16986922238178214607": {
        "error_kind": "string",
        "string": "UHashMap should have retained 2 elements."
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "4": {
      "source": "unconstrained fn partition<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_recursive<T, Env, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn[Env](T, T) -> bool,\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\npub(crate) unconstrained fn quicksort<T, Env, let N: u32>(\n    _arr: [T; N],\n    sortfn: fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n",
      "path": "std/array/quicksort.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "9": {
      "source": "use crate::cmp::Eq;\nuse crate::default::Default;\nuse crate::hash::{BuildHasher, Hash, Hasher};\nuse crate::option::Option;\n\n// An unconstrained hash table with open addressing and quadratic probing.\n// Note that \"unconstrained\" here means that almost all operations on this\n// map are unconstrained and importantly are not constrained afterward either.\n// This map is meant to be used in unconstrained or comptime code where this\n// is not an issue.\n//\n// Compared to the constrained HashMap type, UHashMap can grow automatically\n// as needed and is more efficient since it can break out of loops early.\npub struct UHashMap<K, V, B> {\n    _table: [Slot<K, V>],\n\n    // Amount of valid elements in the map.\n    _len: u32,\n\n    _build_hasher: B,\n}\n\n// Data unit in the UHashMap table.\n// In case Noir adds support for enums in the future, this\n// should be refactored to have three states:\n// 1. (key, value)\n// 2. (empty)\n// 3. (deleted)\nstruct Slot<K, V> {\n    _key_value: Option<(K, V)>,\n    _is_deleted: bool,\n}\n\nimpl<K, V> Default for Slot<K, V> {\n    fn default() -> Self {\n        Slot { _key_value: Option::none(), _is_deleted: false }\n    }\n}\n\nimpl<K, V> Slot<K, V> {\n    fn is_valid(self) -> bool {\n        !self._is_deleted & self._key_value.is_some()\n    }\n\n    fn is_available(self) -> bool {\n        self._is_deleted | self._key_value.is_none()\n    }\n\n    fn key_value(self) -> Option<(K, V)> {\n        self._key_value\n    }\n\n    fn key_value_unchecked(self) -> (K, V) {\n        self._key_value.unwrap_unchecked()\n    }\n\n    fn set(&mut self, key: K, value: V) {\n        self._key_value = Option::some((key, value));\n        self._is_deleted = false;\n    }\n\n    // Shall not override `_key_value` with Option::none(),\n    // because we must be able to differentiate empty\n    // and deleted slots for lookup.\n    fn mark_deleted(&mut self) {\n        self._is_deleted = true;\n    }\n}\n\n// While conducting lookup, we iterate attempt from 0 to N - 1 due to heuristic,\n// that if we have went that far without finding desired,\n// it is very unlikely to be after - performance will be heavily degraded.\nimpl<K, V, B> UHashMap<K, V, B> {\n    // Creates a new instance of UHashMap with specified BuildHasher.\n    // docs:start:with_hasher\n    pub fn with_hasher<H>(_build_hasher: B) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let _table = &[Slot::default()];\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    pub fn with_hasher_and_capacity<H>(_build_hasher: B, capacity: u32) -> Self\n    where\n        B: BuildHasher<H>,\n    {\n        // docs:end:with_hasher\n        let mut _table = &[];\n        for _ in 0..capacity {\n            _table = _table.push_back(Slot::default());\n        }\n        let _len = 0;\n        Self { _table, _len, _build_hasher }\n    }\n\n    // Clears the map, removing all key-value entries.\n    // docs:start:clear\n    pub fn clear(&mut self) {\n        // docs:end:clear\n        self._table = &[Slot::default()];\n        self._len = 0;\n    }\n\n    // Returns true if the map contains a value for the specified key.\n    // docs:start:contains_key\n    pub fn contains_key<H>(self, key: K) -> bool\n    where\n        K: Hash + Eq,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:contains_key\n        // Safety: unconstrained context\n        unsafe { self.get(key) }.is_some()\n    }\n\n    // Returns true if the map contains no elements.\n    // docs:start:is_empty\n    pub fn is_empty(self) -> bool {\n        // docs:end:is_empty\n        self._len == 0\n    }\n\n    // Returns a BoundedVec of all valid entries in this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:entries\n    pub fn entries(self) -> [(K, V)] {\n        // docs:end:entries\n        let mut entries = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                // SAFETY: slot.is_valid() should ensure there is a valid key-value pairing here\n                let key_value = slot.key_value().unwrap_unchecked();\n                entries = entries.push_back(key_value);\n            }\n        }\n\n        let self_len = self._len;\n        let entries_len = entries.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {entries_len}.\";\n        assert(entries.len() == self._len, msg);\n\n        entries\n    }\n\n    // Returns a BoundedVec containing all the keys within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:keys\n    pub fn keys(self) -> [K] {\n        // docs:end:keys\n        let mut keys = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (key, _) = slot.key_value_unchecked();\n                keys = keys.push_back(key);\n            }\n        }\n\n        let self_len = self._len;\n        let keys_len = keys.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {keys_len}.\";\n        assert(keys.len() == self._len, msg);\n\n        keys\n    }\n\n    // Returns a BoundedVec containing all the values within this UHashMap.\n    // The length of the returned vector will always match the length of this UHashMap.\n    // docs:start:values\n    pub fn values(self) -> [V] {\n        // docs:end:values\n        let mut values = &[];\n\n        for slot in self._table {\n            if slot.is_valid() {\n                let (_, value) = slot.key_value_unchecked();\n                values = values.push_back(value);\n            }\n        }\n\n        let self_len = self._len;\n        let values_len = values.len();\n        let msg =\n            f\"Amount of valid elements should have been {self_len} times, but got {values_len}.\";\n        assert(values.len() == self._len, msg);\n\n        values\n    }\n\n    // For each key-value entry applies mutator function.\n    // docs:start:iter_mut\n    pub unconstrained fn iter_mut<H>(&mut self, f: fn(K, V) -> (K, V))\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = f(entry.0, entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each key applies mutator function.\n    // docs:start:iter_keys_mut\n    pub unconstrained fn iter_keys_mut<H>(&mut self, f: fn(K) -> K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:iter_keys_mut\n        let mut entries = self.entries();\n        let mut new_map = UHashMap::with_hasher(self._build_hasher);\n\n        for entry in entries {\n            let (key, value) = (f(entry.0), entry.1);\n            new_map.insert(key, value);\n        }\n\n        self._table = new_map._table;\n    }\n\n    // For each value applies mutator function.\n    // docs:start:iter_values_mut\n    pub fn iter_values_mut(&mut self, f: fn(V) -> V) {\n        // docs:end:iter_values_mut\n        for i in 0..self._table.len() {\n            let mut slot = self._table[i];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                slot.set(key, f(value));\n                self._table[i] = slot;\n            }\n        }\n    }\n\n    // Retains only the elements specified by the predicate.\n    // docs:start:retain\n    pub fn retain(&mut self, f: fn(K, V) -> bool) {\n        // docs:end:retain\n        for index in 0..self._table.len() {\n            let mut slot = self._table[index];\n            if slot.is_valid() {\n                let (key, value) = slot.key_value_unchecked();\n                if !f(key, value) {\n                    slot.mark_deleted();\n                    self._len -= 1;\n                    self._table[index] = slot;\n                }\n            }\n        }\n    }\n\n    // Amount of active key-value entries.\n    // docs:start:len\n    pub fn len(self) -> u32 {\n        // docs:end:len\n        self._len\n    }\n\n    // Get the current capacity of the inner table.\n    // docs:start:capacity\n    pub fn capacity(self: Self) -> u32 {\n        // docs:end:capacity\n        self._table.len()\n    }\n\n    // Get the value by key. If it does not exist, returns none().\n    // docs:start:get\n    pub unconstrained fn get<H>(self, key: K) -> Option<V>\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:get\n        let mut result = Option::none();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, value) = slot.key_value_unchecked();\n                if current_key == key {\n                    result = Option::some(value);\n                    break;\n                }\n            }\n        }\n\n        result\n    }\n\n    // Insert key-value entry. In case key was already present, value is overridden.\n    // docs:start:insert\n    pub unconstrained fn insert<H>(&mut self, key: K, value: V)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:insert\n        self.try_resize();\n\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n            let mut insert = false;\n\n            // Either marked as deleted or has unset key-value.\n            if slot.is_available() {\n                insert = true;\n                self._len += 1;\n            } else {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    insert = true;\n                }\n            }\n\n            if insert {\n                slot.set(key, value);\n                self._table[index] = slot;\n                break;\n            }\n        }\n    }\n\n    unconstrained fn try_resize<H>(&mut self)\n    where\n        B: BuildHasher<H>,\n        K: Eq + Hash,\n        H: Hasher,\n    {\n        if self.len() + 1 >= self.capacity() / 2 {\n            let capacity = self.capacity() * 2;\n            let mut new_map = UHashMap::with_hasher_and_capacity(self._build_hasher, capacity);\n\n            for entry in self.entries() {\n                new_map.insert(entry.0, entry.1);\n            }\n            *self = new_map;\n        }\n    }\n\n    // Removes a key-value entry. If key is not present, UHashMap remains unchanged.\n    // docs:start:remove\n    pub unconstrained fn remove<H>(&mut self, key: K)\n    where\n        K: Eq + Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        // docs:end:remove\n        let hash = self.hash(key);\n\n        for attempt in 0..self._table.len() {\n            let index = self.quadratic_probe(hash, attempt as u32);\n            let mut slot = self._table[index];\n\n            // Not marked as deleted and has key-value.\n            if slot.is_valid() {\n                let (current_key, _) = slot.key_value_unchecked();\n                if current_key == key {\n                    slot.mark_deleted();\n                    self._table[index] = slot;\n                    self._len -= 1;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Apply UHashMap's hasher onto key to obtain pre-hash for probing.\n    fn hash<H>(self, key: K) -> u32\n    where\n        K: Hash,\n        B: BuildHasher<H>,\n        H: Hasher,\n    {\n        let mut hasher = self._build_hasher.build_hasher();\n        key.hash(&mut hasher);\n        hasher.finish() as u32\n    }\n\n    // Probing scheme: quadratic function.\n    // We use 0.5 constant near variadic attempt and attempt^2 monomials.\n    // This ensures good uniformity of distribution for table sizes\n    // equal to prime numbers or powers of two.\n    fn quadratic_probe(self: Self, hash: u32, attempt: u32) -> u32 {\n        (hash + (attempt + attempt * attempt) / 2) % self._table.len()\n    }\n}\n\n// Equality class on UHashMap has to test that they have\n// equal sets of key-value entries,\n// thus one is a subset of the other and vice versa.\n// docs:start:eq\nimpl<K, V, B, H> Eq for UHashMap<K, V, B>\nwhere\n    K: Eq + Hash,\n    V: Eq,\n    B: BuildHasher<H>,\n    H: Hasher,\n{\n    fn eq(self, other: UHashMap<K, V, B>) -> bool {\n        // docs:end:eq\n        let mut equal = false;\n\n        if self.len() == other.len() {\n            equal = true;\n            for slot in self._table {\n                // Not marked as deleted and has key-value.\n                if equal & slot.is_valid() {\n                    let (key, value) = slot.key_value_unchecked();\n                    // Safety: unconstrained context\n                    let other_value = unsafe { other.get(key) };\n\n                    if other_value.is_none() {\n                        equal = false;\n                    } else {\n                        let other_value = other_value.unwrap_unchecked();\n                        if value != other_value {\n                            equal = false;\n                        }\n                    }\n                }\n            }\n        }\n\n        equal\n    }\n}\n\n// docs:start:default\nimpl<K, V, B, H> Default for UHashMap<K, V, B>\nwhere\n    B: BuildHasher<H> + Default,\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        // docs:end:default\n        UHashMap::with_hasher(B::default())\n    }\n}\n",
      "path": "std/collections/umap.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "20": {
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n",
      "path": "std/hash/poseidon2.nr"
    },
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n",
      "path": "std/option.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use std::collections::umap::UHashMap;\nuse std::hash::BuildHasherDefault;\nuse std::hash::poseidon2::Poseidon2Hasher;\n\ntype K = Field;\ntype V = Field;\n\n// It is more convenient and readable to use structs as input.\nstruct Entry {\n    key: Field,\n    value: Field,\n}\n\nglobal HASHMAP_LEN: u32 = 6;\n\nglobal FIELD_CMP: fn(Field, Field) -> bool = |a: Field, b: Field| a.lt(b);\n\nglobal K_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal V_CMP: fn(Field, Field) -> bool = FIELD_CMP;\nglobal KV_CMP: fn((K, V), (K, V)) -> bool = |a: (K, V), b: (K, V)| a.0.lt(b.0);\n\nglobal ALLOCATE_HASHMAP: fn() -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> =\n    || -> UHashMap<K, V, BuildHasherDefault<Poseidon2Hasher>> UHashMap::default();\n\nunconstrained fn main(input: [Entry; HASHMAP_LEN]) {\n    test_sequential(input[0].key, input[0].value);\n    test_multiple_equal_insert(input[1].key, input[1].value);\n    test_value_override(input[2].key, input[2].value, input[3].value);\n    test_insert_and_methods(input);\n    test_hashmaps_equality(input);\n    test_retain();\n    test_iterators();\n    test_mut_iterators();\n\n    doc_tests();\n}\n\n// Insert, get, remove.\nunconstrained fn test_sequential(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    hashmap.insert(key, value);\n    assert(hashmap.len() == 1, \"UHashMap after one insert should have a length of 1 element.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n\n    hashmap.remove(key);\n    assert(\n        hashmap.is_empty(),\n        \"UHashMap after one insert and corresponding removal should be empty.\",\n    );\n    let got = hashmap.get(key);\n    assert(got.is_none(), \"Value has been removed, but is still available (not none).\");\n}\n\n// Insert same pair several times.\nunconstrained fn test_multiple_equal_insert(key: K, value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for _ in 0..HASHMAP_LEN {\n        hashmap.insert(key, value);\n    }\n\n    let len = hashmap.len();\n    assert(len == 1, f\"UHashMap length must be 1, got {len}.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(value == got, f\"Inserted {value} but got {got} for the same key.\");\n}\n\n// Override value for existing pair.\nunconstrained fn test_value_override(key: K, value: V, new_value: V) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New hashmap should be empty.\");\n\n    hashmap.insert(key, value);\n    hashmap.insert(key, new_value);\n    assert(hashmap.len() == 1, \"UHashMap length is invalid.\");\n\n    let got = hashmap.get(key);\n    assert(got.is_some(), \"Got none value.\");\n    let got = got.unwrap_unchecked();\n    assert(got == new_value, f\"Expected {new_value}, but got {got}.\");\n}\n\n// Insert several distinct pairs and test auxiliary methods.\nunconstrained fn test_insert_and_methods(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    for entry in input {\n        println(f\"Inserting {entry}\");\n        hashmap.insert(entry.key, entry.value);\n    }\n\n    println(hashmap.len());\n    assert(hashmap.len() == HASHMAP_LEN, \"hashmap.len() does not match input length.\");\n\n    for entry in input {\n        let entry_key = entry.key;\n        assert(hashmap.contains_key(entry.key), f\"Not found inserted key {entry_key}.\");\n    }\n\n    hashmap.clear();\n    assert(hashmap.is_empty(), \"UHashMap after clear() should be empty.\");\n}\n\n// Insert several pairs and test retaining.\nunconstrained fn test_retain() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n    assert(hashmap.is_empty(), \"New UHashMap should be empty.\");\n\n    let (key, value) = (5, 11);\n    hashmap.insert(key, value);\n    let (key, value) = (2, 13);\n    hashmap.insert(key, value);\n    let (key, value) = (11, 5);\n    hashmap.insert(key, value);\n\n    let predicate = |key: K, value: V| -> bool { key * value == 55 };\n    hashmap.retain(predicate);\n\n    assert(hashmap.len() == 2, \"UHashMap should have retained 2 elements.\");\n    assert(\n        hashmap.get(2).is_none(),\n        \"Pair should have been removed, since it does not match predicate.\",\n    );\n}\n\n// Equality trait check.\nunconstrained fn test_hashmaps_equality(input: [Entry; HASHMAP_LEN]) {\n    let mut hashmap_1 = ALLOCATE_HASHMAP();\n    let mut hashmap_2 = ALLOCATE_HASHMAP();\n\n    for entry in input {\n        hashmap_1.insert(entry.key, entry.value);\n        hashmap_2.insert(entry.key, entry.value);\n    }\n\n    assert(hashmap_1 == hashmap_2, \"CtHashMaps should be equal.\");\n\n    hashmap_2.remove(input[0].key);\n\n    assert(hashmap_1 != hashmap_2, \"CtHashMaps should not be equal.\");\n}\n\n// Test entries, keys, values.\nunconstrained fn test_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(keys == [2, 5, 11], \"Got incorrect iteration of keys.\");\n    assert(values == [3, 7, 13], \"Got incorrect iteration of values.\");\n    assert(entries == [(2, 3), (5, 7), (11, 13)], \"Got incorrect iteration of entries.\");\n}\n\n// Test mutable iteration over keys, values and entries.\nunconstrained fn test_mut_iterators() {\n    let mut hashmap = ALLOCATE_HASHMAP();\n\n    hashmap.insert(2, 3);\n    hashmap.insert(5, 7);\n    hashmap.insert(11, 13);\n\n    let f = |k: K| -> K { k * 3 };\n    hashmap.iter_keys_mut(f);\n\n    let f = |v: V| -> V { v * 5 };\n    hashmap.iter_values_mut(f);\n\n    let keys: [K; 3] = hashmap.keys().as_array().sort_via(K_CMP);\n    let values: [V; 3] = hashmap.values().as_array().sort_via(V_CMP);\n\n    assert(keys == [6, 15, 33], f\"Got incorrect iteration of keys: {keys}\");\n    assert(values == [15, 35, 65], \"Got incorrect iteration of values.\");\n\n    let f = |k: K, v: V| -> (K, V) { (k * 2, v * 2) };\n    hashmap.iter_mut(f);\n\n    let entries: [(K, V); 3] = hashmap.entries().as_array().sort_via(KV_CMP);\n\n    assert(entries == [(12, 30), (30, 70), (66, 130)], \"Got incorrect iteration of entries.\");\n}\n\n// docs:start:type_alias\ntype MyMap = UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>>;\n// docs:end:type_alias\n\n/// Tests examples from the stdlib cthashmap documentation\nunconstrained fn doc_tests() {\n    // docs:start:default_example\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    assert(hashmap.is_empty());\n    // docs:end:default_example\n    // docs:start:with_hasher_example\n    let my_hasher: BuildHasherDefault<Poseidon2Hasher> = Default::default();\n    let hashmap: UHashMap<u8, u32, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::with_hasher(my_hasher);\n    assert(hashmap.is_empty());\n    // docs:end:with_hasher_example\n    // docs:start:insert_example\n    let mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    map.insert(12, 42);\n    assert(map.len() == 1);\n    // docs:end:insert_example\n    get_example(map);\n\n    // docs:start:remove_example\n    map.remove(12);\n    assert(map.is_empty());\n\n    // If a key was not present in the map, remove does nothing\n    map.remove(12);\n    assert(map.is_empty());\n    // docs:end:remove_example\n    // docs:start:is_empty_example\n    assert(map.is_empty());\n\n    map.insert(1, 2);\n    assert(!map.is_empty());\n\n    map.remove(1);\n    assert(map.is_empty());\n    // docs:end:is_empty_example\n    // docs:start:len_example\n    // This is equivalent to checking map.is_empty()\n    assert(map.len() == 0);\n\n    map.insert(1, 2);\n    map.insert(3, 4);\n    map.insert(5, 6);\n    assert(map.len() == 3);\n\n    // 3 was already present as a key in the hash map, so the length is unchanged\n    map.insert(3, 7);\n    assert(map.len() == 3);\n\n    map.remove(1);\n    assert(map.len() == 2);\n    // docs:end:len_example\n    // docs:start:capacity_example\n    let empty_map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>> =\n        UHashMap::default();\n    assert(empty_map.len() == 0);\n    println(empty_map.capacity());\n    // docs:end:capacity_example\n    // docs:start:clear_example\n    assert(!map.is_empty());\n    map.clear();\n    assert(map.is_empty());\n    // docs:end:clear_example\n    // docs:start:contains_key_example\n    if map.contains_key(7) {\n        let value = map.get(7);\n        assert(value.is_some());\n    } else {\n        println(\"No value for key 7!\");\n    }\n    // docs:end:contains_key_example\n    entries_examples(map);\n    iter_examples(map);\n\n    // docs:start:retain_example\n    map.retain(|k, v| (k != 0) & (v != 0));\n    // docs:end:retain_example\n    // docs:start:eq_example\n    let mut map1: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n    let mut map2: UHashMap<Field, u64, BuildHasherDefault<Poseidon2Hasher>> = UHashMap::default();\n\n    map1.insert(1, 2);\n    map1.insert(3, 4);\n\n    map2.insert(3, 4);\n    map2.insert(1, 2);\n\n    assert(map1 == map2);\n    // docs:end:eq_example\n}\n\n// docs:start:get_example\nfn get_example(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // Safety: testing context\n    let x = unsafe { map.get(12) };\n\n    if x.is_some() {\n        assert(x.unwrap() == 42);\n    }\n}\n// docs:end:get_example\n\nfn entries_examples(map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>) {\n    // docs:start:entries_example\n    let entries = map.entries();\n\n    // The length of a hashmap may not be compile-time known, so we\n    // need to loop over its capacity instead\n    for i in 0..map.capacity() {\n        if i < entries.len() {\n            let (key, value) = entries[i];\n            println(f\"{key} -> {value}\");\n        }\n    }\n    // docs:end:entries_example\n    // docs:start:keys_example\n    let keys = map.keys();\n\n    for key in keys {\n        // Safety: testing context\n        let value = unsafe { map.get(key) }.unwrap_unchecked();\n        println(f\"{key} -> {value}\");\n    }\n    // docs:end:keys_example\n    // docs:start:values_example\n    let values = map.values();\n\n    for value in values {\n        println(f\"Found value {value}\");\n    }\n    // docs:end:values_example\n}\n\nunconstrained fn iter_examples(\n    mut map: UHashMap<Field, Field, BuildHasherDefault<Poseidon2Hasher>>,\n) {\n    // docs:start:iter_mut_example\n    // Add 1 to each key in the map, and double the value associated with that key.\n    map.iter_mut(|k, v| (k + 1, v * 2));\n    // docs:end:iter_mut_example\n    // docs:start:iter_keys_mut_example\n    // Double each key, leaving the value associated with that key untouched\n    map.iter_keys_mut(|k| k * 2);\n    // docs:end:iter_keys_mut_example\n    // docs:start:iter_values_mut_example\n    // Halve each value\n    map.iter_values_mut(|v| v / 2);\n    // docs:end:iter_values_mut_example\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
