---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "8015721519311710062",
  "abi": {
    "parameters": [],
    "return_type": null,
    "error_types": {
      "5019202896831570965": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "22": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "50": {
      "source": "struct Match {\n    succeeded: bool,\n    match_ends: u32,\n    leftover: [u8],\n}\n\nimpl Match {\n    fn empty(leftover: [u8]) -> Self {\n        Match { succeeded: true, match_ends: 0, leftover }\n    }\n}\n\nimpl Eq for Match {\n    fn eq(self, other: Self) -> bool {\n        (self.succeeded == other.succeeded) & (self.match_ends == other.match_ends)\n        // (self.leftover == other.leftover)\n    }\n}\n\n// TODO: load match into str<N> and assert that it's the correct length\n// impl<N> From<Match> for str<N>\n\ntrait Regex {\n    fn find_match(self, input: [u8]) -> Match;\n}\n\n// Empty\nimpl Regex for () {\n    fn find_match(_self: Self, input: [u8]) -> Match {\n        Match::empty(input)\n    }\n}\n\n// Exact\nimpl<let N: u32> Regex for str<N> {\n    fn find_match(self, input: [u8]) -> Match {\n        let mut leftover = input;\n        let mut matches_input = true;\n        let self_as_bytes = self.as_bytes();\n        for c in self_as_bytes {\n            if leftover.len() != 0 {\n                let (first_elem, popped_slice) = leftover.pop_front();\n                leftover = popped_slice;\n                matches_input &= first_elem == c;\n            } else {\n                matches_input = false;\n            }\n        }\n        if matches_input {\n            Match { succeeded: true, match_ends: self_as_bytes.len(), leftover }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// And\nimpl<T, U> Regex for (T, U)\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.0.find_match(input);\n        if lhs_result.succeeded {\n            let rhs_result = self.1.find_match(lhs_result.leftover);\n            if rhs_result.succeeded {\n                Match {\n                    succeeded: true,\n                    match_ends: lhs_result.match_ends + rhs_result.match_ends,\n                    leftover: rhs_result.leftover,\n                }\n            } else {\n                Match { succeeded: false, match_ends: 0, leftover: input }\n            }\n        } else {\n            Match { succeeded: false, match_ends: 0, leftover: input }\n        }\n    }\n}\n\n// N T's: (T, (T, (T, T)))\nstruct Repeated<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Repeated<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let mut result = Match::empty(input);\n        for _ in 0..N {\n            if result.succeeded {\n                let next_result = self.inner.find_match(result.leftover);\n                result = Match {\n                    succeeded: next_result.succeeded,\n                    match_ends: result.match_ends + next_result.match_ends,\n                    leftover: next_result.leftover,\n                };\n            }\n        }\n        result\n    }\n}\n\nstruct Or<T, U> {\n    lhs: T,\n    rhs: U,\n}\n\nimpl<T, U> Regex for Or<T, U>\nwhere\n    T: Regex,\n    U: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let lhs_result = self.lhs.find_match(input);\n        if lhs_result.succeeded {\n            lhs_result\n        } else {\n            self.rhs.find_match(input)\n        }\n    }\n}\n\nstruct Question<T> {\n    inner: T,\n}\n\nimpl<T> Regex for Question<T>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        Or { lhs: self.inner, rhs: () }.find_match(input)\n    }\n}\n\n// 0 <= num_matches <= N\nstruct Star<T, let N: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32> Regex for Star<T, N>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        let regex: Repeated<_, N> = Repeated { inner: Question { inner: self.inner } };\n        regex.find_match(input)\n    }\n}\n\n// 0 < num_matches <= N\nstruct Plus<T, let N: u32, let N_PRED: u32> {\n    inner: T,\n}\n\nimpl<T, let N: u32, let N_PRED: u32> Regex for Plus<T, N, N_PRED>\nwhere\n    T: Regex,\n{\n    fn find_match(self, input: [u8]) -> Match {\n        std::static_assert(N_PRED + 1 == N, \"N - 1 != N_PRED\");\n        let star: Star<T, N_PRED> = Star { inner: self.inner };\n        (self.inner, star).find_match(input)\n    }\n}\n\nfn main() {\n    // gr(a|e)y\n    let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"gray\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // NOTE: leftover ignored in Eq: Match\n    let result = graey_regex.find_match(\"grey\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 4, leftover: &[] });\n\n    // colou?r\n    let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n\n    let result = colour_regex.find_match(\"color\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n\n    let result = colour_regex.find_match(\"colour\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n\n    // parse the empty string three times\n    // EMPTY{3}\n    let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n\n    let result = three_empties_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{0}\n    let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n\n    let result = zero_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 0, leftover: &[] });\n\n    // 1{1}\n    let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n\n    let result = one_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 1, leftover: &[] });\n\n    // 1{2}\n    let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n\n    let result = two_ones_regex.find_match(\"111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n\n    // 1{3}\n    let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n\n    let result = three_ones_regex.find_match(\"1111\".as_bytes().as_slice());\n    println(result);\n    assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    // TODO(https://github.com/noir-lang/noir/issues/6285): re-enable these cases and complete the test using array_regex below\n    //\n    // // 1*\n    // let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n    //\n    // let result = ones_regex.find_match(\"11000\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"11\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 2, leftover: &[] });\n    //\n    // let result = ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    //\n    // // 1+\n    // let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n    //\n    // let result = nonempty_ones_regex.find_match(\"111111\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // 2^n-1 in binary: 1+0\n    // let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n    //\n    // let result = pred_pow_two_regex.find_match(\"1110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 3, leftover: &[] });\n    //\n    // // (0|1)*\n    // let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n    //\n    // let result = binary_regex.find_match(\"110100\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 5, leftover: &[] });\n    //\n    // // even numbers in binary: 1(0|1)*0\n    // let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n    //\n    // let result = even_binary_regex.find_match(\"1111110\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match { succeeded: true, match_ends: 6, leftover: &[] });\n    // 2-letter capitalized words: [A-Z][a-z]\n    // numbers: \\d+\n    // [0-9]+\n    // words: \\w+\n    // [a-Z]+\n    // adapted URL parser: (https?:\\/\\/)?([\\da-z.\\-]+)\\.([a-z.]+)([\\/\\w \\.\\-]*)*\\/?\n    // // panics (at compile time) when input string is too short\n    // let foo_regex = (\n    //     \"colo\",\n    //     (\n    //         Question {\n    //             inner: \"u\",\n    //         },\n    //         \"r\"\n    //     )\n    // );\n    //\n    // let result = foo_regex.find_match(\"colo\".as_bytes().as_slice());\n    // println(result);\n    // assert_eq(result, Match {\n    //     succeeded: true,\n    //     match_ends: 4,\n    //     leftover: &[],\n    // });\n}\n\n// TODO\n// array_regex execution_success test:\n// use to complete test once https://github.com/noir-lang/noir/issues/6285 is resolved\n//\n// // offset <= len <= N\n// struct Bvec<T, let N: u32> {\n//     inner: [T; N],\n//\n//     // elements at indices < offset are zero\n//     offset: u32,\n//\n//     // elements at indices >= len are zero\n//     len: u32,\n// }\n//\n// impl<T, let N: u32> Eq for Bvec<T, N> where T: Eq {\n//     fn eq(self, other: Self) -> bool {\n//         (self.inner == other.inner) &\n//             (self.offset == other.offset) &\n//             (self.len == other.len)\n//     }\n// }\n//\n// impl<T, let N: u32> Bvec<T, N> {\n//     fn empty() -> Self {\n//         Self { inner: [std::mem::zeroed(); N], offset: 0, len: 0 }\n//     }\n//\n//     fn new(array: [T; N]) -> Self {\n//         let mut result = Bvec::empty();\n//         for x in array {\n//             result = result.push(x);\n//         }\n//         result\n//     }\n//\n//     // pushing when len == N is a no-op\n//     fn push(self, x: T) -> Self {\n//         let mut inner = self.inner;\n//         let mut len = self.len;\n//         if self.len < N {\n//             inner[self.len] = x;\n//             len += 1;\n//         }\n//\n//         Self { inner, offset: self.offset, len }\n//     }\n//\n//     fn pop_front(self) -> (T, Self) {\n//         assert(self.offset <= self.inner.len());\n//         assert(self.len != 0);\n//\n//         let first_elem = self.inner[self.offset];\n//         let popped_slice = Self { inner: self.inner, offset: self.offset + 1, len: self.len - 1 };\n//\n//         (first_elem, popped_slice)\n//     }\n// }\n//\n// struct Match<let N: u32> {\n//     succeeded: bool,\n//     match_ends: u32,\n//     leftover: Bvec<u8, N>,\n// }\n//\n// impl<let N: u32> Match<N> {\n//     fn empty(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: true, match_ends: 0, leftover }\n//     }\n//\n//     fn failed(leftover: Bvec<u8, N>) -> Self {\n//         Match { succeeded: false, match_ends: 0, leftover }\n//     }\n// }\n//\n// impl<let N: u32> Eq for Match<N> {\n//     fn eq(self, other: Self) -> bool {\n//         (self.succeeded == other.succeeded) &\n//             (self.match_ends == other.match_ends) &\n//             (self.leftover == other.leftover)\n//     }\n// }\n//\n// // TODO: load match into str<N> and assert that it's the correct length\n// // impl<N> From<Match> for str<N>\n//\n// trait Regex {\n//     // Perform a match without backtracking\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N>;\n// }\n//\n// // Empty\n// impl Regex for () {\n//     fn find_match<let N: u32>(_self: Self, input: Bvec<u8, N>) -> Match<N> {\n//         Match::empty(input)\n//     }\n// }\n//\n// // Exact\n// impl<let M: u32> Regex for str<M> {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut leftover = input;\n//         let mut matches_input = true;\n//         let self_as_bytes = self.as_bytes();\n//         for c in self_as_bytes {\n//             if leftover.len != 0 {\n//                 let (first_elem, popped_slice) = leftover.pop_front();\n//                 leftover = popped_slice;\n//                 matches_input &= first_elem == c;\n//             } else {\n//                 matches_input = false;\n//             }\n//         }\n//         if matches_input {\n//             Match {\n//                 succeeded: true,\n//                 match_ends: self_as_bytes.len(),\n//                 leftover,\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // And\n// impl<T, U> Regex for (T, U) where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.0.find_match(input);\n//         if lhs_result.succeeded {\n//             let rhs_result = self.1.find_match(lhs_result.leftover);\n//             if rhs_result.succeeded {\n//                 Match {\n//                     succeeded: true,\n//                     match_ends: lhs_result.match_ends + rhs_result.match_ends,\n//                     leftover: rhs_result.leftover,\n//                 }\n//             } else {\n//                 Match {\n//                     succeeded: false,\n//                     match_ends: 0,\n//                     leftover: input,\n//                 }\n//             }\n//         } else {\n//             Match {\n//                 succeeded: false,\n//                 match_ends: 0,\n//                 leftover: input,\n//             }\n//         }\n//     }\n// }\n//\n// // N T's: (T, (T, (T, T)))\n// struct Repeated<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Repeated<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::empty(input);\n//         for _ in 0..M {\n//             if result.succeeded {\n//                 let next_result = self.inner.find_match(result.leftover);\n//                 result = Match {\n//                     succeeded: next_result.succeeded,\n//                     match_ends: result.match_ends + next_result.match_ends,\n//                     leftover: next_result.leftover,\n//                 };\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// struct Or<T, U> {\n//     lhs: T,\n//     rhs: U,\n// }\n//\n// impl<T, U> Regex for Or<T, U> where T: Regex, U: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let lhs_result = self.lhs.find_match(input);\n//         if lhs_result.succeeded {\n//             lhs_result\n//         } else {\n//             self.rhs.find_match(input)\n//         }\n//     }\n// }\n//\n// struct Question<T> {\n//     inner: T,\n// }\n//\n// impl<T> Regex for Question<T> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         Or {\n//             lhs: self.inner,\n//             rhs: (),\n//         }.find_match(input)\n//     }\n// }\n//\n// // 0 <= num_matches <= N\n// struct Star<T, let N: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32> Regex for Star<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let regex: Repeated<_, M> = Repeated {\n//             inner: Question { inner: self.inner },\n//         };\n//         regex.find_match(input)\n//     }\n// }\n//\n// // 0 < num_matches <= N\n// struct Plus<T, let N: u32, let N_PRED: u32> {\n//     inner: T,\n// }\n//\n// impl<T, let M: u32, let M_PRED: u32> Regex for Plus<T, M, M_PRED> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         std::static_assert(M_PRED + 1 == M, \"M - 1 != M_PRED\");\n//         let star: Star<T, M_PRED> = Star { inner: self.inner };\n//         (\n//             self.inner,\n//             star\n//         ).find_match(input)\n//     }\n// }\n//\n// // Repeated is to (,) as AnyOf is to Or\n// struct AnyOf<T, let N: u32> {\n//     inner: [T; N],\n// }\n//\n// impl<T, let M: u32> Regex for AnyOf<T, M> where T: Regex {\n//     fn find_match<let N: u32>(self, input: Bvec<u8, N>) -> Match<N> {\n//         let mut result = Match::failed(input);\n//         for i in 0..M {\n//             if !result.succeeded {\n//                 result = self.inner[i].find_match(result.leftover);\n//             }\n//         }\n//         result\n//     }\n// }\n//\n// fn reverse_array<T, let N: u32>(input: [T; N]) -> [T; N] {\n//     let mut output = [std::mem::zeroed(); N];\n//     for i in 0..N {\n//         output[i] = input[N - (i + 1)];\n//     }\n//     output\n// }\n//\n// fn main() {\n//     assert_eq(reverse_array([1, 2, 3, 4]), [4, 3, 2, 1]);\n//\n//     let mut xs: Bvec<u8, 3> = Bvec::empty();\n//\n//     xs = xs.push(0);\n//     assert_eq(xs, Bvec { inner: [0, 0, 0], offset: 0, len: 1 });\n//\n//     xs = xs.push(1);\n//     assert_eq(xs, Bvec { inner: [0, 1, 0], offset: 0, len: 2 });\n//\n//     xs = xs.push(2);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     xs = xs.push(3);\n//     assert_eq(xs, Bvec { inner: [0, 1, 2], offset: 0, len: 3 });\n//\n//     let ys = Bvec::new([0, 1, 2]);\n//     assert_eq(xs, ys);\n//\n//     // test that pop_front gives all contents, in order,\n//     // followed by std::mem::zeroed()\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 0);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 1);\n//\n//     xs = new_xs;\n//     println(xs);\n//     let (x, new_xs) = xs.pop_front();\n//     assert_eq(x, 2);\n//\n//     xs = new_xs;\n//     println(xs);\n//     if xs.len != 0 {\n//         let (x, _new_xs) = xs.pop_front();\n//         assert_eq(x, std::mem::zeroed());\n//     }\n//\n//     assert_eq(new_xs, Bvec { inner: [0, 1, 2], offset: 3, len: 0 });\n//\n//     // gr(a|e)y\n//     let graey_regex = (\"gr\", (Or { lhs: \"a\", rhs: \"e\" }, \"y\"));\n//\n//     let result = graey_regex.find_match(Bvec::new(\"gray\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = graey_regex.find_match(Bvec::new(\"grey\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // colou?r\n//     let colour_regex = (\"colo\", (Question { inner: \"u\" }, \"r\"));\n//\n//     let result = colour_regex.find_match(Bvec::new(\"color\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = colour_regex.find_match(Bvec::new(\"colour\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 6);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // parse the empty string three times\n//     // EMPTY{3}\n//     let three_empties_regex: Repeated<(), 3> = Repeated { inner: () };\n//\n//     let result = three_empties_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{0}\n//     let zero_ones_regex: Repeated<str<1>, 0> = Repeated { inner: \"1\" };\n//\n//     let result = zero_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 3);\n//\n//     // 1{1}\n//     let one_ones_regex: Repeated<str<1>, 1> = Repeated { inner: \"1\" };\n//\n//     let result = one_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // 1{2}\n//     let two_ones_regex: Repeated<str<1>, 2> = Repeated { inner: \"1\" };\n//\n//     let result = two_ones_regex.find_match(Bvec::new(\"111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1{3}\n//     let three_ones_regex: Repeated<str<1>, 3> = Repeated { inner: \"1\" };\n//\n//     let result = three_ones_regex.find_match(Bvec::new(\"1111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 3);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1*\n//     let ones_regex: Star<str<1>, 5> = Star { inner: \"1\" };\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11000\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 3);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"11\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 2);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 1+\n//     let nonempty_ones_regex: Plus<str<1>, 5, 4> = Plus { inner: \"1\" };\n//\n//     let result = nonempty_ones_regex.find_match(Bvec::new(\"111111\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // 2^n-1 in binary: 1+0\n//     let pred_pow_two_regex = (nonempty_ones_regex, \"0\");\n//\n//     let result = pred_pow_two_regex.find_match(Bvec::new(\"1110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // (0|1)*\n//     let binary_regex: Star<Or<str<1>, str<1>>, 5> = Star { inner: Or { lhs: \"0\", rhs: \"1\" } };\n//\n//     let result = binary_regex.find_match(Bvec::new(\"110100\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 5);\n//     assert_eq(result.leftover.len, 1);\n//\n//     // even numbers in binary: 1(0|1)*0\n//     let even_binary_regex = (\"1\", (binary_regex, \"0\"));\n//\n//     let result = even_binary_regex.find_match(Bvec::new(\"1111110\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 7);\n//     assert_eq(result.leftover.len, 0);\n//\n//     // digit: \\d+\n//     // [0-9]\n//     let digit_regex = AnyOf {\n//         inner: [\n//             \"0\",\n//             \"1\",\n//             \"2\",\n//             \"3\",\n//             \"4\",\n//             \"5\",\n//             \"6\",\n//             \"7\",\n//             \"8\",\n//             \"9\"\n//         ]\n//     };\n//\n//     let result = digit_regex.find_match(Bvec::new(\"157196345823795\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 1);\n//     assert_eq(result.leftover.len, 14);\n//\n//     let result = digit_regex.find_match(Bvec::new(\"hi\".as_bytes()));\n//     println(result);\n//     assert(!result.succeeded);\n//     assert_eq(result.match_ends, 0);\n//     assert_eq(result.leftover.len, 2);\n//\n//     // digits: \\d+\n//     // [0-9]+\n//     let digits_regex: Plus<AnyOf<str<1>, 10>, 32, 31> = Plus { inner: digit_regex };\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let result = digits_regex.find_match(Bvec::new(\"123456789012345 then words\".as_bytes()));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 15);\n//     assert_eq(result.leftover.len, 11);\n//\n//     // multiples of 10\n//     // apply to a reversed input string (because there isn't backtracking)\n//     // 0\\d+\n//     let backwards_mult_of_10_regex = (\"0\", digits_regex);\n//\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(\"1230\".as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 4);\n//     assert_eq(result.leftover.len, 0);\n//\n//     let ten_pow_16: str<17> = \"10000000000000000\";\n//     let result = backwards_mult_of_10_regex.find_match(Bvec::new(reverse_array(ten_pow_16.as_bytes())));\n//     println(result);\n//     assert(result.succeeded);\n//     assert_eq(result.match_ends, 17);\n//     assert_eq(result.leftover.len, 0);\n//     // adapted URL parser: (https?:\\/\\/)?([\\da-c.\\-]+)\\.([a-c.]+)([\\/\\w \\.\\-]*)*\\/?\n// }\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
