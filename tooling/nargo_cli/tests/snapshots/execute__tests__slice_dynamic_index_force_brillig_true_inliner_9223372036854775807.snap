---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "13819803046210490551",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "2920182694213909827": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "50": {
      "source": "fn main(x: Field) {\n    // The parameters to this function must come directly from witness values (inputs to main).\n    regression_dynamic_slice_index(x - 1, x - 4);\n}\n\nfn regression_dynamic_slice_index(x: Field, y: Field) {\n    let mut slice = &[];\n    for i in 0..5 {\n        slice = slice.push_back(i as Field);\n    }\n    assert(slice.len() == 5);\n\n    dynamic_slice_index_set_if(slice, x, y);\n    dynamic_slice_index_set_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_else(slice, x, y);\n    dynamic_slice_index_set_nested_if_else_if(slice, x, y + 1);\n    dynamic_slice_index_if(slice, x);\n    dynamic_array_index_if([0, 1, 2, 3, 4], x);\n    dynamic_slice_index_else(slice, x);\n\n    dynamic_slice_merge_if(slice, x);\n    dynamic_slice_merge_else(slice, x);\n    dynamic_slice_merge_two_ifs(slice, x);\n    dynamic_slice_merge_mutate_between_ifs(slice, x, y);\n    dynamic_slice_merge_push_then_pop(slice, x, y);\n}\n\nfn dynamic_slice_index_set_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[3] == 2);\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_index_set_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 > 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice[x - 1] = slice[x];\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 0);\n}\n// This tests the case of missing a store instruction in the else branch\n// of merging slices\nfn dynamic_slice_index_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    } else {\n        assert(slice[x] == 0);\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_array_index_if(mut array: [Field; 5], x: Field) {\n    if x as u32 < 10 {\n        assert(array[x] == 4);\n        array[x] = array[x] - 2;\n    } else {\n        assert(array[x] == 0);\n    }\n    assert(array[4] == 2);\n}\n// This tests the case of missing a store instruction in the then branch\n// of merging slices\nfn dynamic_slice_index_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n    }\n    assert(slice[4] == 2);\n}\n\nfn dynamic_slice_merge_if(mut slice: [Field], x: Field) {\n    if x as u32 < 10 {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n\n        slice = slice.push_back(10);\n        // Having an array set here checks whether we appropriately\n        // handle a slice length that is not yet resolving to a constant\n        // during flattening\n        slice[x] = 10;\n        assert(slice[slice.len() - 1] == 10);\n        assert(slice.len() == 6);\n\n        slice[x] = 20;\n        slice[x] = slice[x] + 10;\n\n        slice = slice.push_front(11);\n        assert(slice[0] == 11);\n        assert(slice.len() == 7);\n        assert(slice[5] == 30);\n\n        slice = slice.push_front(12);\n        assert(slice[0] == 12);\n        assert(slice.len() == 8);\n        assert(slice[6] == 30);\n\n        let (popped_slice, last_elem) = slice.pop_back();\n        assert(last_elem == 10);\n        assert(popped_slice.len() == 7);\n\n        let (first_elem, rest_of_slice) = popped_slice.pop_front();\n        assert(first_elem == 12);\n        assert(rest_of_slice.len() == 6);\n\n        slice = rest_of_slice.insert(x as u32 - 2, 20);\n        assert(slice[2] == 20);\n        assert(slice[6] == 30);\n        assert(slice.len() == 7);\n\n        let (removed_slice, removed_elem) = slice.remove(x as u32 - 1);\n        // The deconstructed tuple assigns to the slice but is not seen outside of the if statement\n        // without a direct assignment\n        slice = removed_slice;\n\n        assert(removed_elem == 1);\n        assert(slice.len() == 6);\n    } else {\n        assert(slice[x] == 0);\n        slice = slice.push_back(20);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 30);\n}\n\nfn dynamic_slice_merge_else(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_else(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 1);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[1] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        if y != 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 5 {\n                // We should not hit this case\n                assert(slice[x] == 22);\n            } else {\n                slice[x] = 10;\n                slice = slice.push_back(15);\n                assert(slice.len() == 6);\n            }\n            assert(slice[4] == 10);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 10);\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_index_set_nested_if_else_if(mut slice: [Field], x: Field, y: Field) {\n    assert(slice[x] == 4);\n    assert(slice[y] == 2);\n    slice[y] = 0;\n    assert(slice[x] == 4);\n    assert(slice[2] == 0);\n    if x as u32 < 10 {\n        slice[x] = slice[x] - 2;\n        // TODO: this panics as we have a load for the slice in flattening\n        if y == 1 {\n            slice[x] = slice[x] + 20;\n        } else {\n            if x == 4 {\n                slice[x] = 5;\n            }\n            assert(slice[4] == 5);\n        }\n    } else {\n        slice[x] = 0;\n    }\n    assert(slice[4] == 5);\n}\n\nfn dynamic_slice_merge_two_ifs(mut slice: [Field], x: Field) {\n    if x as u32 > 10 {\n        assert(slice[x] == 0);\n        slice[x] = 2;\n    } else {\n        assert(slice[x] == 4);\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(10);\n    }\n\n    assert(slice.len() == 6);\n    assert(slice[slice.len() - 1] == 10);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    assert(slice.len() == 7);\n    assert(slice[slice.len() - 1] == 15);\n\n    slice = slice.push_back(20);\n    assert(slice.len() == 8);\n    assert(slice[slice.len() - 1] == 20);\n}\n\nfn dynamic_slice_merge_mutate_between_ifs(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 50;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n    } else {\n        slice[x] = slice[x] - 2;\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 8);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    slice = slice.push_back(15);\n\n    if x != 20 {\n        slice = slice.push_back(50);\n    }\n\n    slice = slice.push_back(60);\n    assert(slice.len() == 11);\n    assert(slice[x] == 50);\n    assert(slice[slice.len() - 4] == 30);\n    assert(slice[slice.len() - 3] == 15);\n    assert(slice[slice.len() - 2] == 50);\n    assert(slice[slice.len() - 1] == 60);\n}\n\nfn dynamic_slice_merge_push_then_pop(mut slice: [Field], x: Field, y: Field) {\n    if x != y {\n        slice[x] = 5;\n        slice = slice.push_back(y);\n        slice = slice.push_back(x);\n        assert(slice.len() == 7);\n\n        let (popped_slice, elem) = slice.pop_back();\n        assert(slice.len() == 7);\n        assert(elem == x);\n        slice = popped_slice;\n    } else {\n        slice = slice.push_back(x);\n    }\n\n    slice = slice.push_back(30);\n    assert(slice.len() == 7);\n\n    if x == 20 {\n        slice = slice.push_back(20);\n    }\n\n    let (slice, elem) = slice.pop_back();\n    assert(elem == 30);\n\n    let (_, elem) = slice.pop_back();\n    assert(elem == y);\n}\n",
      "path": ""
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
