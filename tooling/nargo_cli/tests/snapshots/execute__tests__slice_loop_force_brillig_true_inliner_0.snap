---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "17498422866154132562",
  "abi": {
    "parameters": [
      {
        "name": "points",
        "type": {
          "kind": "array",
          "length": 3,
          "type": {
            "kind": "struct",
            "path": "Point",
            "fields": [
              {
                "name": "x",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "y",
                "type": {
                  "kind": "field"
                }
              }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "tdrRSiMxFMbxd5nrXuScJCeJr7IsS9VRCqWVWhcW8d13RlrX7YTKP5IbMTK/Q+h3ZmxP8zrcj7cvj782u4f983Dz43XY7u/Wx81+N61e31bD7WGz3W4ef33+8+DmH1ber39+Wu/m5fNxfTgONz7oahh39/NvefIPm+043ET39nM1JK2KVE4iOH8pfE1E9ScRp8suRMAiV0WxsyjpUhQqsqsJi+EkLNulECwUC49FwCJiYVgkLDIWhYqCMy8484IzLzjzgjMvOPNSz1zPTwaLl0+GkrDIWBQqxDlOhBPlxHMSOImcGCeJk8wJT194+sLTF56+8PSFpy88feHpC49SeJRajTK7eCJZ//sfv1pcKvl8qSwed6LStbp2re67Vg9dq8eu1a1r9dS1eu5avfSs7rveq/67/a4fl6rIovp3e0Y1n6v7sqj+Vc/45YYyJwWT4DgRTrpGF0LX6rFrdetaPXWtnrtWLz2rR9fzdo/Stbp2rR7pOEmicZI4yZzg0ZiY40Q4UU48J4ETnr7x9I2nbzx9PhiVxNNPPP3E068PYIM7j3KCdwsSOImcGCeJk8xJwaQ+Hb5OhBPlhKefefqZp595+pmnn3n69THxta84pD4nvk6EE+XEcxI4iZwYJ4mTzAlOX53jRDhRTjwngZPIiXGSOMmc8PSFp18fv117a631mdp1EjkxThInmZOCSX2idJ0IJ8oJT9/z9D1P3/P062Oj6WPNufunjyvhAwV7R0HrKNgHMrdAvgWllu3lFtTyQtQnCV8haUHagnwLCi0oNoRbHx18hVILyi2oNCBzLUhaUMtNaC03oYUW1NIR1tIR1tIR1tIR1tIRqaUjUktHJNwRb9Pq9/qwWd9ux9NZs4eX3d2no2fHP0/jxSm0p8P+brx/OYzzebR/R9HmzlK/8n7aytwwmmVa2PyWfH4FVPxKJc9LeV+WlapMO5h28Rc=",
  "file_map": {
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "struct Point {\n    x: Field,\n    y: Field,\n}\n\nimpl Point {\n    fn serialize(self) -> [Field; 2] {\n        [self.x, self.y]\n    }\n}\n\nfn sum(values: [Field]) -> Field {\n    let mut sum = 0;\n    for value in values {\n        sum = sum + value;\n    }\n    sum\n}\n\nfn main(points: [Point; 3]) {\n    let mut serialized_points = &[];\n    for point in points {\n        serialized_points = serialized_points.append(point.serialize().as_slice());\n    }\n    // Do a compile-time check that needs the previous loop to be unrolled\n    if serialized_points.len() > 5 {\n        let empty_point = Point { x: 0, y: 0 };\n        serialized_points = serialized_points.append(empty_point.serialize().as_slice());\n    }\n    // Do a sum that needs both the previous loop and the previous if to have been simplified\n    assert_eq(sum(serialized_points), 21);\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/slice_loop/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
