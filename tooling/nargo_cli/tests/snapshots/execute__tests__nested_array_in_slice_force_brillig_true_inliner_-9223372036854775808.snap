---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "7969957169502339280",
  "abi": {
    "parameters": [
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+WdS4gkSRnHozIrp7uqurtqemZ2Hjs70709PY+dmZ6qrn7uzOjg9oh4EBTBi7D0vPYkIiiLB6HOehG8KB4UPKzgwZMX8bRehD14ENabuiCuLIggguhBNGfyq/rXv/4dnTUd0dW7m9B0VkTk9/hFfPFFZmVmVdxgqxT/q/TZiTb3iv/tg22dgLLa0lDfZm2uFx7Xis8J1KcBna2R3pDyt9prmzXhX0D7u7VCZkw+JjOC/PZUIefTvYF89iXfZovPOIbsmOn//824wX6r2K/RMTH6NiL79glhfwK+5dtrvUGdc+HjYqcXxbe+/Ptx5HcbxVh4Lx0eC8YvIKtVjpGAsvvxXQ0uu7NmMZWBbBtHpveYi9I/axXS59zwHONIf51sDT0eK6TP7GE+Nn6M3ZSwtSXqcI7AOtQzJfQoWWlAWTau4o2zjTUeSwFlr9eEv4Fkb1gfT4Nsjo8a9UsY3eXjw/TXydZY8VEje5gPx0dd2NoSdbjAxTrUUxd6lKxjAWXZuGoK2eY3j8HQ6wBmX3WjcY62JW50bGK/ZVTWLf7n/ryfDo7Zaz485mE3LexR7DJiFymO2jwGkF3Nww7HQF2ws7LbLhy7rCQ7Hnf1yOwagl3dw64BdbaP7KzsNReOnRp38fJOu593GuFlb5jsmeCyO+s2L8+CbM5pc1A+iZxm+utka6ycNkf2MB/OaU1ha0vUcR5qCj1NoUfJagSUZeMq4rpsM158bGzFi4+NbetjHBMcH8hyEvFh+usuarx2fGMN+XB8tIStLVHH8dESelpCj5LVCCjLxpXKveZ3TeiNkXvNFsy9DcEwofYcHxmVvVH8D5F754Q9it0ssZuJzK4p2M142GFcNwU7K/uqC8dutiQ7HneR5qA2xw+ya3rYYfy0BDsre9OFY6fGXcQ1Xz/vtMLL3jbZx4PL7vSvY8yDbM5pJ6B8EjnN9NfJ1lg57QTZw3w4p50UtrZEHee0k0LPSaFHyWoFlGXjKuKabzdefGw8iBcfGw+tj3FMcHwgy0nEh+mvu6jx2vGNNeTD8XFK2NoSdRwfp4SeU0KPktUKKMvGlcq95ndN6I2Re80WzL1q3ZxQe46PjMp+WPwPkXtPCHsUu3lidzwyu5OC3XEPO4zrk4Kdlf3EhWM3X5Idj7tIc1Cb4wfZnfSww/g5JdhZ2c9cOHZq3EVc8/Xzzqnwsh+a7BeCy+5s2rx8GmRzTjsD5ZPIaaa/TrbGymlnyB7mwzntrLC1Jeo4p50Ves4KPUrWqYCybFxFXPM9ihcfG4/jxcfGE+tjHBMcH8hyEvFh+usuarx2fGMN+XB8nBO2tkQdx8c5oeec0KNknQooy8aVyr3md03ojZF7zRbMvWrdnFB7jo+Myn5b/A+Re88IexS708Tuhcjszgp2L3jYYVyfFeys7PcuHLvTJdnxuIs0B7U5fpDdWQ87jJ9zgp2V/dGFY1d23PE9Becis3vRjbI752H3ItTZPrKzsvddOHbPe0/Bi5HZnXej7F70sDsPdbaP7Kzs7y4cO3VPwaw4rrLHf9PDZXgPL/tzr/jfPtjWv2/7pfCy+/fzXQgvu/+98cXwsvvXJxehTwKO7f753FIc+V0bxy+74fHFPpl+G6sL0H6csYq66iQr1hpU+bYAZRyjL4M9yGAvWS+PKasm6mL06aLHb9Q/67FV+XE+IJMsoKzpgLJeCihrNqCsuYCyLgSUNR9Q1omAsi4GlHU6oCxbf9q6aRHqFor9yPNEf91kc3tV+IG2JdQe9/Mto7LFYtJX66ZFN8pu0cNuQdhjdccEO25bgT/7nJL+dI/jUmF3Io7Lt/u9Z/8j5+01s+dSIS/bw48lqMf216FvPkiHbV6OY3OXbUb2C6AT9eNnbH8J2lifNIX/LEvpxnG30xtmcSUyi8vOz+IK2X9FtL8MbS4Ri2UhqyaOC+jbqs9WjKvLZM+1yKyvOj/ra8T6mmh/VfBUc/g1qsPjlg/H7/78/kohD+d31Gm2JdQe9/Mto7J7nvn9qoed6cq3lhsdp1c97BaJ3SuR2V13o+xe8bC7DnW2j+ys7DMB2S0Ke/hzBoys7jzVWdvPFbbVhE8hGeOakZn55vKaGx0Xh9X3rDPfxu37L3r6HtcSan3hi5vUw47jJlafmh833Ci7625vdjegzvaRnZV9OSC7xZLs+Brw4gTYLQZg9yggO35mGvnciMJn9ZFdp7jpRjerWwHdy1R3C+rQft5S+ow+5ez+lg7kcju2B8eR2cZz8ddovo30PLqcb/k5fbS3Qm0T4LPXGKi44fMlHKup0Hm/N6xvGRgpPUtQj+3fhLHN5zNxxuNgXanOTxZAJ+rnGE3d/vN45pGldOP43ekNs1iJzOLmPixWyP4V0f4mtFkmFjc8sm56WOT7fL7Rjszi1j4s2mR/W7THOesmsVgRspriuBuH43c/f3UKeZi/UKfZllB73M+3jMq+48lftzzsTFe+tdzoOLrlYbdC7DqR2a26UXYdD7tVqLN9ZGdl3wvIbkXYw59NP85dL1Gdtf0B5T/0KXb+M12+uZa/94zV98YD+x51mm2JGx2n2A/M90eevsdcrPKzL24yDzuOm1uR2am4ueVhVzZu3grIbqUkO36mMVY8mB9dwW7Vw64LdbaP7Kzs5wHZzQp7asKecHy6/XdZrbnRzerWQfcNqtuAOrSfN3W+ge9PGed8A8eR2cZz8a9ovo30LgQ53/I7Ivj7X2x7HvjsNQYqbvh8A8dqKnTe7w3rw2tgSs8S1GP7t2Fs8/lGnPE4WFfivT1qXYn6OUZTkqHmolmPLKUb43anN8xiPTKLtX1YrJP966L9GrQ5Tyy6HllrHhb5Pp9vbERmsb4Piw2yf0O0Rx/XiEUmZDXFcd3D8bufvzYLeZi/UKfZllB73HduEONW9q4nf6172JmufGu5vceRYse5bTMyuy03ym7Tw24L6mwf2VnZHwKyUzmNP5t+nLsuUJ21/TPlP/Qpdv4zXb65lu+FjNX3xgP7HnWabYkbHafYD8z3A0/fYy5W+dkXN7Medhw3kfKON27WPezKxs0/ArLLPOywjp+njbUe9LFTfTkuu/942I17vjEv7Ik7X3T774nadqOb1b0KurtUdxvqeO5x5D9u6NNBzjfMNj7fmCrg1oRtsefbefCZ7a2QHRU6pux3Fl3wu8x3FtZ+puAyiXOIJfDnec8hlqCNMVPzC8tSuvE9KTu9YRbbkVls7cNim+zfFu1xTlgiFl2PrC0Pi3yfzyFis9jvfrQyLPC+Ml7vzAtZTXFc93D87uckm7swJ22Lfkjc6Dxs+/mWUdkCxDjnpMsedqYr39Ra6LKHHefzVyOzuy3Yvephh3nK9pGdlV0NyE7FFH9W31lcpDpru0I5DX2KndNMl2+u5WeeYvW98cC+R528lrssuCu+a56+H3ct1xX2lFkHR7o/1hs3lz3sysbNnYDs5kuy4+ezY8WD+XHHjbK77WF3B+psH9lZ2U5AdqeFPTVhT8BziP49Unfd6GZ1nwDdfA7xSahD+3lT5xDm00HOIcw2nos/T/NtpPe6yPnWdJWZb2PZ5Rv3apyNO+6/dATm20jnPF523QDsXp/AfMvvdIgznwzY3RXs7njY3YW6u4Kdlb0RkN0ZYU9N2BNwvn3Mcypuak6dp7p7UIf286bmW/PpIPOt2cbz7dePwDUbRzaZjdg2gX2sc2703sp82+kN+5VA3b0gPnVXmeV3CyX5c4rfLPatn9LewP6Foizvz7nqoF1eVwU7q+RDpN856V8TUL8Fhb+tg/rxM7ZXvzXVEsdbfyg+VQ+fKQ+fSL9l0i3rb534qN8OQgbLxAePx3tMmM+Uh0/1iPGpHoBPxcNnherw2WDTmZe99Zxx+FEaZxyH6rezPs7j7Hnj8OMyTz1vHJpOjMOmG83t/C7WSeQ5tOd585z5pnLmh9U3fi4j9fg2iXGNvo07rm+SbypG1HhNye9IfVr69+fMtkRw8P3+3C8952QVN8oOy/icLBX2KHZTxC6dALs0ALu3A7KbEvbwZ9OPc0tCddb2N3ROF+u3JdU5HfuiWOC9pTu9YR/sXOqvcC71DuUOPBfk3JHF8bU/B1WFP2gP33egrm1gH/K9l6mQpfLK9OH43ea8gnGEOs22xI2OA8xJGZW964mjqoed6co39c5F37rWjvuon3+fJz54/LSHj29dmxwxPskB+FQ8fPicCde1pjMvqxcNVfzy3BRpHu765hq0h31XPDGmeW6qClk1ofteEL+63ZqwM5Ds/jM/OEYq5FOk9Wzpd7ib/rqLGl8dXiuZPcwHr9nldQ1ha0vU8bXbhtDTEHqUrCygrCnw5+nxvUGd9ce4c+AkYjwRPpWNcc4ReHzNw8eXQ9Mjxucgc2DFw6dKdcfIN+d0jsAY5xyRxOGz61tToT2mX+Wz6uHY+sDXlz5bMT/x2pltRT9ir52tj/daO5ttiRsdR/iu8IzKTheOqLVzIthhme/8PfGw4zFwLDI7dd5xzMOu7HnHxYDsqiXZ8TlbdQLsqgHYXQnIblrYEzdXjP/8RUp1eP8Z2s9bSp/Rp3G/y8dxxM9fWN1aIS/2tTV13Yfn1Nh5PiXOFbKnTJ5HPpeKfRW3fK7zYbuGf4V8U9fw1TXw5HD8Ln2d22wb91rtpzzz1ZSHnenKt5bbe1yUWWPEugbrY6f6clx2n53AGoPzZKTz8D67hmBX97DDc8iGYGdlXzikPNmIwmeyedJ8ipEnXz9CeXI6ju7SeRL142dsj3z4+2Bf3MYZlwPfpvfxrUG+qWtF6D9/H5wKWU03qXgczFczhTycrxqiHxJqj/v5llHZVzzz1bSHnenKN5Unp4mdL09GigcvO9WX47L7xgTy5Byxm4nMblawm/Gww2f9ZwU7K/tWQHZzwp647zsImyfRft5UnjSfYuTJbx+hPBnpXRWl8yT/tpN6Rwfy4fdLJUKW+TYX2bfZfXzj35qaE+3Rf989C3NUh8clh+N3f75qFvJwvpoT/ZBQe9zPt4zKvu+Zr8Z9d4saF2XyZOx3tyh2qi/HZffjCeTJE8SuGZldS7Breti1oM72kZ2V/TQguxPCnpqw56jmSbSfN5UnzacYefIXRyhPxum78nkS9fN4VnlyqdhXcdsi345H9q21j2/Hybfjoj36z+9ESYUs9Z3w4cTjYL4yW6p7+GG2JYIDMsio7Nee+aoi2GGZL09WPOw4HiJ9R+1llwRg905Adqkrx46fNY4Ub31284Ldcbc3O5z/5gU7K/tdQHZnhD1xn5Xt9PPkWTe6WR3/Pj3W4W+hj/ussfk0bp7EcWS28X3pfzoCebLhBt8pVXvh9W9uPRvfT/n2BhyYNerPqP1fisb4HYT9rx7Aziebu50n3d0nu+u7jx6tPdxV7w5MgFNo/bub3a2Hq2sPNx+sd3e7G4eu/+H6xoOHa+u77ced/OPqfvrzGHgPYsD0O2EXy0k9sltC1mu9Z/9j35PE9+ihrvy+mn/SfInP5PP6Ld/u9wb12P7f6UDmv4p9lXOMQcPp91/w/Uax7yuY9viL+jNq/1/IOVerwwx93+fnG68X1LV23/OGeD8UfwcT+/ul2j68kOdQ++revJT/iYeXuv+B/UZe6h7XvexVz7NWqA7tyYQsdZ/YMZLlu28133Z6z/6XjV+73pD1QG5vcMzT9sXnKsjD9uZXRu3nqwN9J+He36eyhL683ZWinfGeBlsCjstV820K7SB7UH9TtLf9yLZ2fbZOCVsV43Fz0FRvuKzWG22PnKZIdx3bU10D6qqkZ6b4jGMNZZkdGbVfLsaN9dM0HGPHt4R+7DPWpfRjDLOsVJRZ+3xsXyhs7N+DA7oDjpcOxlGM9dHjre1H7e0nj3c7nc7qo/bj/dZH/wMF7ZovbbgAAA==",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nfn main(y: Field) {\n    let foo_one = Foo { a: 1, b: [2, 3, 20], bar: Bar { inner: [100, 101, 102] } };\n    let foo_two = Foo { a: 4, b: [5, 6, 21], bar: Bar { inner: [103, 104, 105] } };\n    let foo_three = Foo { a: 7, b: [8, 9, 22], bar: Bar { inner: [106, 107, 108] } };\n    let foo_four = Foo { a: 10, b: [11, 12, 23], bar: Bar { inner: [109, 110, 111] } };\n    let mut x = &[foo_one];\n    x = x.push_back(foo_two);\n    x = x.push_back(foo_three);\n    x = x.push_back(foo_four);\n\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    if y != 2 {\n        x[y - 2].a = 50;\n    } else {\n        x[y - 2].a = 100;\n    }\n    assert(x[y - 2].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/nested_array_in_slice/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
