---
source: tooling/nargo_cli/tests/execute.rs
expression: artifact
---
{
  "noir_version": "",
  "hash": "524947131582973539",
  "abi": {
    "parameters": [
      {
        "name": "x",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "struct",
            "path": "Foo",
            "fields": [
              {
                "name": "a",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "b",
                "type": {
                  "kind": "array",
                  "length": 3,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "bar",
                "type": {
                  "kind": "struct",
                  "path": "Bar",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "array",
                        "length": 3,
                        "type": {
                          "kind": "field"
                        }
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "visibility": "private"
      },
      {
        "name": "y",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      }
    ],
    "return_type": null,
    "error_types": {
      "12049594436772143978": {
        "error_kind": "string",
        "string": "array ref-count underflow detected"
      },
      "14225679739041873922": {
        "error_kind": "string",
        "string": "Index out of bounds"
      },
      "16761564377371454734": {
        "error_kind": "string",
        "string": "Array index out of bounds"
      },
      "17843811134343075018": {
        "error_kind": "string",
        "string": "Stack too deep"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "50": {
      "source": "struct Bar {\n    inner: [Field; 3],\n}\n\nstruct Foo {\n    a: Field,\n    b: [Field; 3],\n    bar: Bar,\n}\n\nstruct FooParent {\n    array: [Field; 3],\n    foos: [Foo; 4],\n}\n\nfn main(mut x: [Foo; 4], y: pub Field) {\n    assert(x[y - 3].a == 1);\n    assert(x[y - 3].b == [2, 3, 20]);\n    assert(x[y - 2].a == 4);\n    assert(x[y - 2].b == [5, 6, 21]);\n    assert(x[y - 1].a == 7);\n    assert(x[y - 1].b == [8, 9, 22]);\n    assert(x[y].a == 10);\n    assert(x[y].b == [11, 12, 23]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n    // Check dynamic array set\n    if y != 2 {\n        x[y].a = 50;\n    } else {\n        x[y].a = 100;\n    }\n    assert(x[3].a == 50);\n\n    if y == 2 {\n        x[y - 1].b = [50, 51, 52];\n    } else {\n        x[y - 1].b = [100, 101, 102];\n    }\n    assert(x[2].b == [100, 101, 102]);\n\n    assert(x[y - 3].bar.inner == [100, 101, 102]);\n    assert(x[y - 2].bar.inner == [103, 104, 105]);\n    assert(x[y - 1].bar.inner == [106, 107, 108]);\n    assert(x[y].bar.inner == [109, 110, 111]);\n\n    let foo_parent_one = FooParent { array: [0, 1, 2], foos: x };\n    let foo_parent_two = FooParent { array: [3, 4, 5], foos: x };\n    let mut foo_parents = [foo_parent_one, foo_parent_two];\n\n    assert(foo_parents[y - 3].foos[y - 3].b == [2, 3, 20]);\n    assert(foo_parents[y - 3].foos[y - 2].b == [5, 6, 21]);\n    assert(foo_parents[y - 3].foos[y - 1].b == [100, 101, 102]);\n    assert(foo_parents[y - 3].foos[y].b == [11, 12, 23]);\n\n    assert(foo_parents[y - 3].foos[y].a == 50);\n\n    assert(foo_parents[1].foos[1].b == [5, 6, 21]);\n    if y == 2 {\n        foo_parents[y - 2].foos[y - 2].b = [10, 9, 8];\n    } else {\n        foo_parents[y - 2].foos[y - 2].b = [20, 19, 18];\n    }\n    assert(foo_parents[1].foos[1].b == [20, 19, 18]);\n\n    assert(foo_parents[1].foos[1].b[2] == 18);\n    if y == 3 {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 5000;\n    } else {\n        foo_parents[y - 2].foos[y - 2].b[y - 1] = 1000;\n    }\n    assert(foo_parents[1].foos[1].b[2] == 5000);\n    // Set a dynamic array value\n    foo_parents[y - 2].foos[y - 3].b = foo_parents[y - 2].foos[y - 2].b;\n    assert(foo_parents[1].foos[0].b == [20, 19, 5000]);\n}\n",
      "path": "/Users/asterite/Projects/noir/test_programs/execution_success/nested_array_dynamic/src/main.nr"
    }
  },
  "names": [
    "main"
  ],
  "brillig_names": [
    "main"
  ]
}
