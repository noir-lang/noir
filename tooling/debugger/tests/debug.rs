#[cfg(test)]
mod tests {
    // Some of these imports are consumed by the injected tests
    use assert_cmd::cargo::cargo_bin;

    use rexpect::spawn_bash;

    // include tests generated by `build.rs`
    include!(concat!(env!("OUT_DIR"), "/debug.rs"));

    pub fn debugger_execution_success(test_program_dir: &str) {
        let nargo_bin =
            cargo_bin("nargo").into_os_string().into_string().expect("Cannot parse nargo path");

        let timeout_seconds = 30;
        let mut dbg_session =
            spawn_bash(Some(timeout_seconds * 1000)).expect("Could not start bash session");

        // Start debugger and test that it loads for the given program.
        dbg_session
            .execute(
                &format!(
                    "{nargo_bin} debug --program-dir {test_program_dir} --force-brillig --expression-width 3"
                ),
                ".*\\Starting debugger.*",
            )
            .expect("Could not start debugger");

        // While running the debugger, issue a "continue" cmd,
        // which should run to the program to end given
        // we haven't set any breakpoints.
        // ">" is the debugger's prompt, so finding one
        // after running "continue" indicates that the
        // debugger has not panicked until the end of the program.
        dbg_session
            .send_line("c")
            .expect("Debugger panicked while attempting to step through program.");
        dbg_session
            .exp_string(">")
            .expect("Failed while waiting for debugger to step through program.");

        // Run the "quit" command, then check that the debugger confirms
        // having successfully solved the circuit witness.
        dbg_session.send_line("quit").expect("Failed to quit debugger");
        dbg_session
            .exp_regex(".*Circuit witness successfully solved.*")
            .expect("Expected circuit witness to be successfully solved.");

        // Exit the bash session.
        dbg_session.send_line("exit").expect("Failed to quit bash session");
    }

    #[test]
    fn debugger_expected_call_stack() {
        let nargo_bin =
            cargo_bin("nargo").into_os_string().into_string().expect("Cannot parse nargo path");

        let timeout_seconds = 30;
        let mut dbg_session =
            spawn_bash(Some(timeout_seconds * 1000)).expect("Could not start bash session");

        let test_program_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("../../test_programs/execution_success/regression_7195");
        let test_program_dir = test_program_path.display();

        // Start debugger and test that it loads for the given program.
        dbg_session
            .execute(
                &format!(
                    "{nargo_bin} debug --raw-source-printing true --program-dir {test_program_dir} --force-brillig --expression-width 3"
                ),
                ".*\\Starting debugger.*",
            )
            .expect("Could not start debugger");

        let num_steps = 16;
        for step_number in 1..=num_steps {
            // While running the debugger, issue a "next" cmd,
            // which should run to the program to the next source line given
            // we haven't set any breakpoints.
            // ">" is the debugger's prompt, so finding one
            // after running "next" indicates that the
            // debugger has not panicked for this step.
            dbg_session
                .send_line("next")
                .expect("Debugger panicked while attempting to step through program.");
            dbg_session
                .exp_string(">")
                .expect("Failed while waiting for debugger to step through program.");

            if step_number == num_steps {
                let mut lines = vec![];
                while let Ok(line) = dbg_session.read_line() {
                    if !(line.starts_with(">next")
                        || line.starts_with("At ")
                        || line.starts_with("..."))
                    {
                        lines.push(line);
                    }
                }

                let lines_expected_to_contain: Vec<&str> = vec![
                    "> next",
                    "    let x = unsafe { baz(x) };",
                    "unconstrained fn baz(x: Field) -> Field {",
                    "> next",
                    "    let x = unsafe { baz(x) };",
                    "unconstrained fn baz(x: Field) -> Field {",
                    "> next",
                    "    let x = unsafe { baz(x) };",
                    "}",
                    "> next",
                    "    let x = unsafe { baz(x) };",
                    "> next",
                    "    foo(x);",
                    "fn foo(x: Field) {",
                    "> next",
                    "    foo(x);",
                    "fn foo(x: Field) {",
                    "> next",
                    "    foo(x);",
                    "    let y = unsafe { baz(x) };",
                    "unconstrained fn baz(x: Field) -> Field {",
                    "> next",
                    "    foo(x);",
                    "    let y = unsafe { baz(x) };",
                    "unconstrained fn baz(x: Field) -> Field {",
                    "> next",
                    "    foo(x);",
                    "    let y = unsafe { baz(x) };",
                    "}",
                    "> next",
                    "    foo(x);",
                    "    let y = unsafe { baz(x) };",
                    "> next",
                    "    foo(x);",
                    "    bar(y);",
                    "fn bar(y: Field) {",
                    "> next",
                    "    foo(x);",
                    "    bar(y);",
                    "fn bar(y: Field) {",
                    "> next",
                    "    foo(x);",
                    "    bar(y);",
                    "    assert(y != 0);",
                ];

                for (line, line_expected_to_contain) in
                    lines.into_iter().zip(lines_expected_to_contain)
                {
                    let ascii_line: String = line.chars().filter(char::is_ascii).collect();
                    let line_expected_to_contain = line_expected_to_contain.trim_start();
                    assert!(
                        ascii_line.contains(line_expected_to_contain),
                        "{:?}\ndid not contain\n{:?}",
                        ascii_line,
                        line_expected_to_contain,
                    );
                }
            }
        }

        // Run the "quit" command
        dbg_session.send_line("quit").expect("Failed to quit debugger");

        // Exit the bash session.
        dbg_session.send_line("exit").expect("Failed to quit bash session");
    }
}
