{
  "name": "EcdsaAccount",
  "functions": [
    {
      "name": "compute_note_hash_and_nullifier",
      "functionType": "unconstrained",
      "isInternal": false,
      "parameters": [
        {
          "name": "contract_address",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "nonce",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "storage_slot",
          "type": {
            "kind": "field"
          },
          "visibility": "private"
        },
        {
          "name": "preimage",
          "type": {
            "kind": "array",
            "length": 5,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "private"
        }
      ],
      "returnTypes": [
        {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "field"
          }
        }
      ],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "constructor",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "signing_pub_key_x",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        },
        {
          "name": "signing_pub_key_y",
          "type": {
            "kind": "array",
            "length": 32,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    },
    {
      "name": "entrypoint",
      "functionType": "secret",
      "isInternal": false,
      "parameters": [
        {
          "name": "payload",
          "type": {
            "kind": "struct",
            "name": "EntrypointPayload",
            "fields": [
              {
                "name": "flattened_args_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_selectors",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "flattened_targets",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "kind": "field"
                  }
                }
              },
              {
                "name": "nonce",
                "type": {
                  "kind": "field"
                }
              }
            ]
          },
          "visibility": "public"
        },
        {
          "name": "signature",
          "type": {
            "kind": "array",
            "length": 64,
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 8
            }
          },
          "visibility": "public"
        }
      ],
      "returnTypes": [],
      "bytecode": "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",
      "verificationKey": "0000000200000800000000740000000f00000003515f3109623eb3c25aa5b16a1a79fd558bac7a7ce62c4560a8c537c77ce80dd339128d1d37b6582ee9e6df9567efb64313471dfa18f520f9ce53161b50dbf7731bc5f900000003515f322bc4cce83a486a92c92fd59bd84e0f92595baa639fc2ed86b00ffa0dfded2a092a669a3bdb7a273a015eda494457cc7ed5236f26cee330c290d45a33b9daa94800000003515f332729426c008c085a81bd34d8ef12dd31e80130339ef99d50013a89e4558eee6d0fa4ffe2ee7b7b62eb92608b2251ac31396a718f9b34978888789042b790a30100000003515f342be6b6824a913eb7a57b03cb1ee7bfb4de02f2f65fe8a4e97baa7766ddb353a82a8a25c49dc63778cd9fe96173f12a2bc77f3682f4c4448f98f1df82c75234a100000003515f351f85760d6ab567465aadc2f180af9eae3800e6958fec96aef53fd8a7b195d7c000c6267a0dd5cfc22b3fe804f53e266069c0e36f51885baec1e7e67650c62e170000000c515f41524954484d455449430d9d0f8ece2aa12012fa21e6e5c859e97bd5704e5c122064a66051294bc5e04213f61f54a0ebdf6fee4d4a6ecf693478191de0c2899bcd8e86a636c8d3eff43400000003515f43224a99d02c86336737c8dd5b746c40d2be6aead8393889a76a18d664029096e90f7fe81adcc92a74350eada9622ac453f49ebac24a066a1f83b394df54dfa0130000000c515f46495845445f42415345060e8a013ed289c2f9fd7473b04f6594b138ddb4b4cf6b901622a14088f04b8d2c83ff74fce56e3d5573b99c7b26d85d5046ce0c6559506acb7a675e7713eb3a00000007515f4c4f4749430721a91cb8da4b917e054f72147e1760cfe0ef3d45090ac0f4961d84ec1996961a25e787b26bd8b50b1a99450f77a424a83513c2b33af268cd253b0587ff50c700000003515f4d05dbd8623b8652511e1eb38d38887a69eceb082f807514f09e127237c5213b401b9325b48c6c225968002318095f89d0ef9cf629b2b7f0172e03bc39aacf6ed800000007515f52414e474504b57a3805e41df328f5ca9aefa40fad5917391543b7b65c6476e60b8f72e9ad07c92f3b3e11c8feae96dedc4b14a6226ef3201244f37cfc1ee5b96781f48d2b000000075349474d415f3125001d1954a18571eaa007144c5a567bb0d2be4def08a8be918b8c05e3b27d312c59ed41e09e144eab5de77ca89a2fd783be702a47c951d3112e3de02ce6e47c000000075349474d415f3223994e6a23618e60fa01c449a7ab88378709197e186d48d604bfb6931ffb15ad11c5ec7a0700570f80088fd5198ab5d5c227f2ad2a455a6edeec024156bb7beb000000075349474d415f3300cda5845f23468a13275d18bddae27c6bb189cf9aa95b6a03a0cb6688c7e8d829639b45cf8607c525cc400b55ebf90205f2f378626dc3406cc59b2d1b474fba000000075349474d415f342d299e7928496ea2d37f10b43afd6a80c90a33b483090d18069ffa275eedb2fc2f82121e8de43dc036d99b478b6227ceef34248939987a19011f065d8b5cef5c0000000010000000000000000100000002000000030000000400000005000000060000000700000008000000090000000a0000000b0000000c0000000d0000000e0000000f"
    }
  ],
  "debug": {
    "debugSymbols": [
      "eJyrVsrJT04syczPK1ayqq6tBQAz9wY7",
      "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"
    ],
    "fileMap": {
      "0": {
        "source": "mod storage;\nmod ecdsa_public_key_note;\n\n// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\ncontract EcdsaAccount {\n    use dep::std;\n    use dep::aztec::entrypoint;\n    use dep::aztec::entrypoint::EntrypointPayload;\n    use dep::aztec::abi;\n    use dep::aztec::abi::PrivateContextInputs;\n    use dep::aztec::abi::CallContext;\n    use dep::aztec::context::PrivateContext;\n    use dep::aztec::log::emit_encrypted_log;\n    use dep::aztec::oracle::get_public_key::get_public_key;\n    use dep::aztec::types::vec::BoundedVec;\n    use dep::aztec::types::point::Point;\n    use dep::aztec::constants_gen::GENERATOR_INDEX__SIGNATURE_PAYLOAD;\n\n    use dep::aztec::constants_gen::MAX_NOTE_FIELDS_LENGTH;\n    use dep::aztec::note::{\n        note_header::{NoteHeader},\n        utils as note_utils,\n    };\n\n    use crate::storage::Storage;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNote;\n    use crate::ecdsa_public_key_note::EcdsaPublicKeyNoteInterface;\n    use crate::ecdsa_public_key_note::ECDSA_PUBLIC_KEY_NOTE_LEN;\n\n    // All calls made by this account will be routed through this entrypoint\n    fn entrypoint(  \n        inputs: pub PrivateContextInputs,\n        payload: pub EntrypointPayload, // contains a set of arguments, selectors, targets and a nonce\n        signature: pub [u8;64],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        \n        // Initialise context\n        // ENTRYPOINT_PAYLOAD_SIZE(13) + 64\n        let mut args: BoundedVec<Field, 77> = BoundedVec::new(0);\n        args.push_array(payload.serialize());\n        for byte in signature { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n\n        // Load public key from storage\n        let storage = Storage::init();\n        let public_key = storage.public_key.get_note(&mut context);\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let payload_fields: [Field; entrypoint::ENTRYPOINT_PAYLOAD_SIZE] = payload.serialize();\n        let message_field: Field = std::hash::pedersen_with_separator(payload_fields, GENERATOR_INDEX__SIGNATURE_PAYLOAD)[0];\n        let message_bytes = message_field.to_be_bytes(32);\n        let hashed_message: [u8; 32] = std::hash::sha256(message_bytes);\n        let verification = std::ecdsa_secp256k1::verify_signature(public_key.x, public_key.y, signature, hashed_message);\n        assert(verification == true);\n\n        payload.execute_calls(&mut context);\n\n        context.finish()\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    fn constructor(\n        inputs: pub PrivateContextInputs,\n        signing_pub_key_x: pub [u8;32],\n        signing_pub_key_y: pub [u8;32],\n    ) -> distinct pub abi::PrivateCircuitPublicInputs {\n        let storage = Storage::init();\n        \n        let mut args: BoundedVec<Field, 64> = BoundedVec::new(0);\n        for byte in signing_pub_key_x { args.push(byte as Field); }\n        for byte in signing_pub_key_y { args.push(byte as Field); }\n        let mut context = PrivateContext::new(inputs, abi::hash_args(args.storage));\n        \n        let this = context.this_address();\n        let mut pub_key_note = EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        storage.public_key.initialise(&mut context, &mut pub_key_note);\n        \n        emit_encrypted_log(\n            &mut context,\n            this,\n            storage.public_key.storage_slot,\n            get_public_key(this),\n            pub_key_note.serialise(),\n        );\n\n        context.finish()\n    }\n\n    // Computes note hash and nullifier.\n    // Note 1: Needs to be defined by every contract producing logs.\n    // Note 2: Having it in all the contracts gives us the ability to compute the note hash and nullifier differently for different kind of notes.\n    unconstrained fn compute_note_hash_and_nullifier(contract_address: Field, nonce: Field, storage_slot: Field, preimage: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> [Field; 4] {\n        assert(storage_slot == 1);\n        let note_header = NoteHeader { contract_address, nonce, storage_slot };\n        note_utils::compute_note_hash_and_nullifier(EcdsaPublicKeyNoteInterface, note_header, preimage)\n    }\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-contracts/src/contracts/ecdsa_account_contract/src/main"
      },
      "3": {
        "source": "mod poseidon;\n\n#[foreign(sha256)]\nfn sha256<N>(_input : [u8; N]) -> [u8; 32] {}\n\n#[foreign(blake2s)]\nfn blake2s<N>(_input : [u8; N]) -> [u8; 32] {}\n\nfn pedersen<N>(input : [Field; N]) -> [Field; 2] {\n    pedersen_with_separator(input, 0)\n}\n\n#[foreign(pedersen)]\nfn pedersen_with_separator<N>(_input : [Field; N], _separator : u32) -> [Field; 2] {}\n\n#[foreign(hash_to_field_128_security)]\nfn hash_to_field<N>(_input : [Field; N]) -> Field {}\n\n#[foreign(keccak256)]\nfn keccak256<N>(_input : [u8; N], _message_size: u32) -> [u8; 32] {}\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\nfn mimc<N>(x: Field, k: Field, constants: [Field; N], exp : Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1 .. constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    };\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS = 91;\n\n//mimc implementation with hardcoded parameters for BN254 curve.\nfn mimc_bn254<N>(array: [Field; N]) -> Field {\n    //mimc parameters\n    let exponent = 7;\n    //generated from seed \"mimc\" using keccak256 \n    let constants: [Field; MIMC_BN254_ROUNDS] = [\n        0, \n        20888961410941983456478427210666206549300505294776164667214940546594746570981,\n        15265126113435022738560151911929040668591755459209400716467504685752745317193,\n        8334177627492981984476504167502758309043212251641796197711684499645635709656,\n        1374324219480165500871639364801692115397519265181803854177629327624133579404,\n        11442588683664344394633565859260176446561886575962616332903193988751292992472,\n        2558901189096558760448896669327086721003508630712968559048179091037845349145,\n        11189978595292752354820141775598510151189959177917284797737745690127318076389,\n        3262966573163560839685415914157855077211340576201936620532175028036746741754,\n        17029914891543225301403832095880481731551830725367286980611178737703889171730,\n        4614037031668406927330683909387957156531244689520944789503628527855167665518,\n        19647356996769918391113967168615123299113119185942498194367262335168397100658,\n        5040699236106090655289931820723926657076483236860546282406111821875672148900,\n        2632385916954580941368956176626336146806721642583847728103570779270161510514,\n        17691411851977575435597871505860208507285462834710151833948561098560743654671,\n        11482807709115676646560379017491661435505951727793345550942389701970904563183,\n        8360838254132998143349158726141014535383109403565779450210746881879715734773,\n        12663821244032248511491386323242575231591777785787269938928497649288048289525,\n        3067001377342968891237590775929219083706800062321980129409398033259904188058,\n        8536471869378957766675292398190944925664113548202769136103887479787957959589,\n        19825444354178182240559170937204690272111734703605805530888940813160705385792,\n        16703465144013840124940690347975638755097486902749048533167980887413919317592,\n        13061236261277650370863439564453267964462486225679643020432589226741411380501,\n        10864774797625152707517901967943775867717907803542223029967000416969007792571,\n        10035653564014594269791753415727486340557376923045841607746250017541686319774,\n        3446968588058668564420958894889124905706353937375068998436129414772610003289,\n        4653317306466493184743870159523234588955994456998076243468148492375236846006,\n        8486711143589723036499933521576871883500223198263343024003617825616410932026,\n        250710584458582618659378487568129931785810765264752039738223488321597070280,\n        2104159799604932521291371026105311735948154964200596636974609406977292675173,\n        16313562605837709339799839901240652934758303521543693857533755376563489378839,\n        6032365105133504724925793806318578936233045029919447519826248813478479197288,\n        14025118133847866722315446277964222215118620050302054655768867040006542798474,\n        7400123822125662712777833064081316757896757785777291653271747396958201309118,\n        1744432620323851751204287974553233986555641872755053103823939564833813704825,\n        8316378125659383262515151597439205374263247719876250938893842106722210729522,\n        6739722627047123650704294650168547689199576889424317598327664349670094847386,\n        21211457866117465531949733809706514799713333930924902519246949506964470524162,\n        13718112532745211817410303291774369209520657938741992779396229864894885156527,\n        5264534817993325015357427094323255342713527811596856940387954546330728068658,\n        18884137497114307927425084003812022333609937761793387700010402412840002189451,\n        5148596049900083984813839872929010525572543381981952060869301611018636120248,\n        19799686398774806587970184652860783461860993790013219899147141137827718662674,\n        19240878651604412704364448729659032944342952609050243268894572835672205984837,\n        10546185249390392695582524554167530669949955276893453512788278945742408153192,\n        5507959600969845538113649209272736011390582494851145043668969080335346810411,\n        18177751737739153338153217698774510185696788019377850245260475034576050820091,\n        19603444733183990109492724100282114612026332366576932662794133334264283907557,\n        10548274686824425401349248282213580046351514091431715597441736281987273193140,\n        1823201861560942974198127384034483127920205835821334101215923769688644479957,\n        11867589662193422187545516240823411225342068709600734253659804646934346124945,\n        18718569356736340558616379408444812528964066420519677106145092918482774343613,\n        10530777752259630125564678480897857853807637120039176813174150229243735996839,\n        20486583726592018813337145844457018474256372770211860618687961310422228379031,\n        12690713110714036569415168795200156516217175005650145422920562694422306200486,\n        17386427286863519095301372413760745749282643730629659997153085139065756667205,\n        2216432659854733047132347621569505613620980842043977268828076165669557467682,\n        6309765381643925252238633914530877025934201680691496500372265330505506717193,\n        20806323192073945401862788605803131761175139076694468214027227878952047793390,\n        4037040458505567977365391535756875199663510397600316887746139396052445718861,\n        19948974083684238245321361840704327952464170097132407924861169241740046562673,\n        845322671528508199439318170916419179535949348988022948153107378280175750024,\n        16222384601744433420585982239113457177459602187868460608565289920306145389382,\n        10232118865851112229330353999139005145127746617219324244541194256766741433339,\n        6699067738555349409504843460654299019000594109597429103342076743347235369120,\n        6220784880752427143725783746407285094967584864656399181815603544365010379208,\n        6129250029437675212264306655559561251995722990149771051304736001195288083309,\n        10773245783118750721454994239248013870822765715268323522295722350908043393604,\n        4490242021765793917495398271905043433053432245571325177153467194570741607167,\n        19596995117319480189066041930051006586888908165330319666010398892494684778526,\n        837850695495734270707668553360118467905109360511302468085569220634750561083,\n        11803922811376367215191737026157445294481406304781326649717082177394185903907,\n        10201298324909697255105265958780781450978049256931478989759448189112393506592,\n        13564695482314888817576351063608519127702411536552857463682060761575100923924,\n        9262808208636973454201420823766139682381973240743541030659775288508921362724,\n        173271062536305557219323722062711383294158572562695717740068656098441040230,\n        18120430890549410286417591505529104700901943324772175772035648111937818237369,\n        20484495168135072493552514219686101965206843697794133766912991150184337935627,\n        19155651295705203459475805213866664350848604323501251939850063308319753686505,\n        11971299749478202793661982361798418342615500543489781306376058267926437157297,\n        18285310723116790056148596536349375622245669010373674803854111592441823052978,\n        7069216248902547653615508023941692395371990416048967468982099270925308100727,\n        6465151453746412132599596984628739550147379072443683076388208843341824127379,\n        16143532858389170960690347742477978826830511669766530042104134302796355145785,\n        19362583304414853660976404410208489566967618125972377176980367224623492419647,\n        1702213613534733786921602839210290505213503664731919006932367875629005980493,\n        10781825404476535814285389902565833897646945212027592373510689209734812292327,\n        4212716923652881254737947578600828255798948993302968210248673545442808456151,\n        7594017890037021425366623750593200398174488805473151513558919864633711506220,\n        18979889247746272055963929241596362599320706910852082477600815822482192194401,\n        13602139229813231349386885113156901793661719180900395818909719758150455500533,\n    ];\n\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, constants, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n",
        "path": "std/hash"
      },
      "18": {
        "source": "\nimpl Field {\n    #[builtin(to_le_bits)]\n    fn to_le_bits(_x : Field, _bit_size: u32) -> [u1] {}\n    #[builtin(to_be_bits)]\n    fn to_be_bits(_x : Field, _bit_size: u32) -> [u1] {}\n\n    fn to_le_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_le_radix(256, byte_size)\n    }\n    fn to_be_bytes(x : Field, byte_size: u32) -> [u8] {\n        x.to_be_radix(256, byte_size)\n    }\n\n    #[builtin(to_le_radix)]\n    //decompose _x into a _result_len vector over the _radix basis\n    //_radix must be less than 256\n    fn to_le_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n    #[builtin(to_be_radix)]\n    fn to_be_radix(_x : Field, _radix: u32, _result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    fn sgn0(self) -> u1 {\n        self as u1\n    }\n}\n\n#[builtin(modulus_num_bits)]\nfn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\nfn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\nfn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\nfn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\nfn modulus_le_bytes() -> [u8] {}\n",
        "path": "std/field"
      },
      "31": {
        "source": "use crate::constants_gen::{\n    RETURN_VALUES_LENGTH,\n    MAX_READ_REQUESTS_PER_CALL,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    GENERATOR_INDEX__FUNCTION_ARGS,\n    HISTORIC_BLOCK_DATA_LENGTH,\n    CONTRACT_DEPLOYMENT_DATA_LENGTH,\n    CALL_CONTEXT_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH,\n    CONTRACT_STORAGE_READ_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH,\n    GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__FUNCTION_DATA,\n    GENERATOR_INDEX__PUBLIC_DATA_READ,\n    GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST,\n    GENERATOR_INDEX__CALL_CONTEXT,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS,\n    GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA,\n};\n\nuse crate::oracle::debug_log;\nuse crate::types::vec::BoundedVec;\nuse crate::types::point::Point;\n\nstruct PrivateGlobalVariables {\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateGlobalVariables {\n    fn serialize(self) -> [Field; 2] {\n        [self.chain_id, self.version]\n    }\n}\n\nstruct PublicGlobalVariables {\n    chain_id: Field,\n    version: Field,\n    block_number: Field,\n    timestamp: Field,\n}\n\nimpl PublicGlobalVariables {\n    fn serialize(self) -> [Field; 4] {\n        [self.chain_id, self.version, self.block_number, self.timestamp]\n    }\n}\n\nstruct ContractDeploymentData {\n    deployer_public_key: Point,\n    constructor_vk_hash : Field,\n    function_tree_root : Field,\n    contract_address_salt : Field,\n    portal_contract_address : Field,\n}\n\nimpl ContractDeploymentData {\n    fn serialize(self) -> [Field; CONTRACT_DEPLOYMENT_DATA_LENGTH] {\n        [\n            self.deployer_public_key.x,\n            self.deployer_public_key.y,\n            self.constructor_vk_hash,\n            self.function_tree_root,\n            self.contract_address_salt,\n            self.portal_contract_address,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA)[0]\n    }\n}\n\n// PrivateContextInputs are expected to be provided to each private function\nstruct PrivateContextInputs {\n    call_context : CallContext,\n    block_data: HistoricBlockData,\n\n    contract_deployment_data: ContractDeploymentData,\n\n    private_global_variables: PrivateGlobalVariables,\n}\n\n// PublicContextInputs are expected to be provided to each public function\nstruct PublicContextInputs {\n    call_context: CallContext,\n    block_data: HistoricBlockData,\n\n    public_global_variables: PublicGlobalVariables,\n}\n\nstruct CallContext {\n    msg_sender : Field,\n    storage_contract_address : Field,\n    portal_contract_address : Field,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n    is_contract_deployment: bool,\n}\n\nimpl CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        [\n            self.msg_sender,\n            self.storage_contract_address,\n            self.portal_contract_address,\n            self.is_delegate_call as Field,\n            self.is_static_call as Field,\n            self.is_contract_deployment as Field,\n        ]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)[0]\n    }\n}\n\nstruct HistoricBlockData {\n    private_data_tree_root : Field,\n    nullifier_tree_root : Field,\n    contract_tree_root : Field,\n    l1_to_l2_messages_tree_root : Field,\n    blocks_tree_root: Field,\n    public_data_tree_root: Field,\n    global_variables_hash: Field,\n}\n\nimpl HistoricBlockData {\n    // NOTE: this order must match the order in `private_circuit_public_inputs.hpp`\n    fn serialize(self) -> [Field; HISTORIC_BLOCK_DATA_LENGTH] {\n        [\n            self.private_data_tree_root,\n            self.nullifier_tree_root,\n            self.contract_tree_root,\n            self.l1_to_l2_messages_tree_root,\n            self.blocks_tree_root,\n            self.public_data_tree_root,\n            self.global_variables_hash,\n        ]\n    }\n\n    fn empty() -> Self {\n        Self { private_data_tree_root: 0, nullifier_tree_root: 0, contract_tree_root: 0, l1_to_l2_messages_tree_root: 0, blocks_tree_root: 0, public_data_tree_root: 0, global_variables_hash: 0 }\n    }\n}\n\nstruct FunctionData {\n    function_selector: Field,\n    is_internal: bool,\n    is_private: bool,\n    is_constructor: bool,\n}\n\nimpl FunctionData {\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator([\n            self.function_selector,\n            self.is_internal as Field,\n            self.is_private as Field,\n            self.is_constructor as Field,\n        ], GENERATOR_INDEX__FUNCTION_DATA)[0]\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    read_requests: [Field; crate::abi::MAX_READ_REQUESTS_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    nullified_commitments: [Field; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_stack: [Field; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_l2_to_l1_msgs: [Field; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    // Explore introducing a new type like uint256 (similar to Point), so it's more explicit that\n    // we're talking about a single number backed by two field elements.\n    encrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    encrypted_log_preimages_length: Field,\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    contract_deployment_data: ContractDeploymentData,\n    chain_id: Field,\n    version: Field,\n}\n\nimpl PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0); \n        fields.push(self.call_context.hash());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.nullified_commitments);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.contract_deployment_data.hash());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n\n        dep::std::hash::pedersen_with_separator(fields.storage, GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        fields.push_array(self.read_requests);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.private_call_stack);\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.encrypted_logs_hash);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.encrypted_log_preimages_length);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push_array(self.contract_deployment_data.serialize());\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.storage\n    }\n}\n\nstruct ContractStorageRead {\n    storage_slot: Field,\n    value: Field,\n}\n\nimpl ContractStorageRead {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_READ_LENGTH] {\n        [self.storage_slot, self.value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_READ)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, value: 0 }\n    }\n}\n\nstruct ContractStorageUpdateRequest {\n    storage_slot: Field,\n    old_value: Field,\n    new_value: Field,\n}\n\nimpl ContractStorageUpdateRequest {\n    fn serialize(self) -> [Field; CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH] {\n        [self.storage_slot, self.old_value, self.new_value]\n    }\n\n    fn hash(self) -> Field {\n        dep::std::hash::pedersen_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_DATA_UPDATE_REQUEST)[0]\n    }\n\n    fn empty() -> Self {\n        Self { storage_slot: 0, old_value: 0, new_value: 0 }\n    }\n}\n\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n    args_hash: Field,\n    return_values: [Field; RETURN_VALUES_LENGTH],\n    contract_storage_update_requests: [ContractStorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_read: [ContractStorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n    public_call_stack: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_commitments: [Field; MAX_NEW_COMMITMENTS_PER_CALL],\n    new_nullifiers: [Field; crate::abi::MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [Field; crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n    unencrypted_logs_hash: [Field; NUM_FIELDS_PER_SHA256],\n    unencrypted_log_preimages_length: Field,\n    block_data: HistoricBlockData,\n    prover_address: Field,\n\n    // TODO: include globals in here and check them elsewhere\n    // https://github.com/AztecProtocol/aztec-packages/issues/1567\n}\n\nimpl PublicCircuitPublicInputs {\n    \n    fn hash(self) -> Field {\n        let mut inputs: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_HASH_INPUT_LENGTH> = BoundedVec::new(0);\n        inputs.push(self.call_context.hash());\n        inputs.push(self.args_hash);\n        inputs.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            inputs.push(self.contract_storage_update_requests[i].hash());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            inputs.push(self.contract_storage_read[i].hash());\n        }\n        inputs.push_array(self.public_call_stack);\n        inputs.push_array(self.new_commitments);\n        inputs.push_array(self.new_nullifiers);\n        inputs.push_array(self.new_l2_to_l1_msgs);\n\n        // We do not include block_data since it's not in the cpp hash\n\n        inputs.push_array(self.unencrypted_logs_hash);\n        inputs.push(self.unencrypted_log_preimages_length);\n        inputs.push_array(self.block_data.serialize()); // see https://github.com/AztecProtocol/aztec-packages/issues/1473\n        inputs.push(self.prover_address);\n\n        dep::std::hash::pedersen_with_separator(inputs.storage, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)[0]\n    }\n\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new(0); \n        fields.push_array(self.call_context.serialize());   \n        fields.push(self.args_hash);\n        fields.push_array(self.return_values);\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.push_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.push_array(self.contract_storage_read[i].serialize());\n        }\n        fields.push_array(self.public_call_stack);\n        fields.push_array(self.new_commitments);\n        fields.push_array(self.new_nullifiers);\n        fields.push_array(self.new_l2_to_l1_msgs);\n        fields.push_array(self.unencrypted_logs_hash);\n        fields.push(self.unencrypted_log_preimages_length);\n        fields.push_array(self.block_data.serialize());\n        fields.push(self.prover_address);\n        fields.storage\n    }\n}\n\nglobal ARGS_HASH_CHUNK_LENGTH: u32 = 32;\nglobal ARGS_HASH_CHUNK_COUNT: u32 = 16;\n\nfn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < (args.len() as u32) {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < (args.len() as u32) {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = dep::std::hash::pedersen_with_separator(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS)[0];\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        dep::std::hash::pedersen_with_separator(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)[0]\n    }\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/abi"
      },
      "32": {
        "source": "use crate::constants_gen::{\n    EMPTY_NULLIFIED_COMMITMENT,\n    MAX_NEW_COMMITMENTS_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL,\n    NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH,\n};\n\nuse crate::abi;\n\nuse crate::abi::{\n    hash_args,\n    CallContext,\n    ContractDeploymentData,\n    HistoricBlockData,\n    FunctionData,\n    PrivateCircuitPublicInputs,\n    PublicCircuitPublicInputs,\n};\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// l1 to l2 messaging\nuse crate::messaging::process_l1_to_l2_message;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;\n\nuse crate::types::{\n    vec::BoundedVec,\n    point::Point,\n};\n\nuse crate::utils::arr_copy_slice;\n\nuse crate::oracle::{\n    arguments,\n    call_private_function::call_private_function_internal,\n    public_call::call_public_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal,\n    context::get_portal_address,\n};\n\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    inputs: abi::PrivateContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<Field, MAX_READ_REQUESTS_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n    nullified_commitments: BoundedVec<Field, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<Field, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    block_data: HistoricBlockData,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n}\n\nimpl PrivateContext {\n    fn new(inputs: abi::PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            read_requests: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n            nullified_commitments: BoundedVec::new(0),\n\n            block_data: inputs.block_data,\n\n            private_call_stack: BoundedVec::new(0),\n            public_call_stack: BoundedVec::new(0),\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn finish(self) -> abi::PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = abi::PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            read_requests: self.read_requests.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            nullified_commitments: self.nullified_commitments.storage,\n            private_call_stack: self.private_call_stack.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            encrypted_logs_hash: encrypted_logs_hash,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            encrypted_log_preimages_length: encrypted_log_preimages_length,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.block_data,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version,\n        };\n        priv_circuit_pub_inputs\n    }\n\n    fn push_read_request(&mut self, read_request: Field) {\n        self.read_requests.push(read_request);\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n        self.nullified_commitments.push(nullified_commitment);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, inputs: abi::PrivateContextInputs, msg_key: Field, content: Field, secret: Field) {\n        let nullifier = process_l1_to_l2_message(inputs.block_data.l1_to_l2_messages_tree_root, inputs.call_context.storage_contract_address, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_private_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let fields = call_private_function_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PrivateCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PrivateCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                // TODO handle the offsets as a variable incremented during extraction?\n                args_hash: fields[11],\n                return_values: arr_copy_slice(fields, [0; RETURN_VALUES_LENGTH], 12),\n                read_requests: arr_copy_slice(fields, [0; MAX_READ_REQUESTS_PER_CALL], 16),\n                new_commitments: arr_copy_slice(fields, [0; MAX_NEW_COMMITMENTS_PER_CALL], 20),\n                new_nullifiers: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 24),\n                nullified_commitments: arr_copy_slice(fields, [0; MAX_NEW_NULLIFIERS_PER_CALL], 28),\n                private_call_stack: arr_copy_slice(fields, [0; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL], 32),\n                public_call_stack: arr_copy_slice(fields, [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL], 36),\n                new_l2_to_l1_msgs: arr_copy_slice(fields, [0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL], 40),\n                encrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 42),\n                unencrypted_logs_hash: arr_copy_slice(fields, [0; NUM_FIELDS_PER_SHA256], 44),\n                encrypted_log_preimages_length: fields[46],\n                unencrypted_log_preimages_length: fields[47],\n                block_data: HistoricBlockData {\n                    // Must match order in `private_circuit_public_inputs.hpp`\n                    private_data_tree_root : fields[48],\n                    nullifier_tree_root : fields[49],\n                    contract_tree_root : fields[50],\n                    l1_to_l2_messages_tree_root : fields[51],\n                    blocks_tree_root : fields[52],\n                    public_data_tree_root: fields[53],\n                    global_variables_hash: fields[54],\n                },\n                contract_deployment_data: ContractDeploymentData {\n                    deployer_public_key: Point::new(fields[55], fields[56]),\n                    constructor_vk_hash : fields[57],\n                    function_tree_root : fields[58],\n                    contract_address_salt : fields[59],\n                    portal_contract_address : fields[60],\n                },\n                chain_id: fields[61],\n                version: fields[62],\n            },\n            is_execution_request: fields[63] as bool,\n        };\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        assert(item.is_execution_request == false);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.private_call_stack.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field, \n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash)\n    }\n\n    fn call_public_function_no_args(\n        &mut self,\n        contract_address: Field, \n        function_selector: Field,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0)\n    }\n\n    fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: Field,\n        function_selector: Field,\n        args_hash: Field\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address, \n            function_selector, \n            args_hash\n        );\n        let item = PublicCallStackItem {\n            contract_address: fields[0],\n            function_data: FunctionData {\n                function_selector: fields[1],\n                is_internal: fields[2] as bool,\n                is_private: fields[3] as bool,\n                is_constructor: fields[4] as bool,\n            },\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: CallContext {\n                    msg_sender : fields[5],\n                    storage_contract_address : fields[6],\n                    portal_contract_address : fields[7],\n                    \n                    is_delegate_call : fields[8] as bool,\n                    is_static_call : fields[9] as bool,\n                    is_contract_deployment: fields[10] as bool,\n                },\n                args_hash: fields[11],\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [ContractStorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_read: [ContractStorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_commitments: [0; MAX_NEW_COMMITMENTS_PER_CALL],\n                new_nullifiers: [0; MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs:[0; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash:[0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                block_data: HistoricBlockData::empty(),\n                prover_address: 0,\n            },\n            is_execution_request: true,\n        };\n\n        assert(contract_address == item.contract_address);\n        assert(function_selector == item.function_data.function_selector);\n        \n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        // We are issuing a regular call which is not delegate, static, or deployment. We also constrain\n        // the msg_sender in the nested call to be equal to our address, and the execution context address\n        // for the nested call to be equal to the address we actually called.\n        assert(item.public_inputs.call_context.is_delegate_call == false);\n        assert(item.public_inputs.call_context.is_static_call == false);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n        assert(item.public_inputs.call_context.msg_sender == self.inputs.call_context.storage_contract_address);\n        assert(item.public_inputs.call_context.storage_contract_address == contract_address);\n\n        self.public_call_stack.push(item.hash());\n    }\n}\n\nuse crate::abi::{\n    ContractStorageRead,\n    ContractStorageUpdateRequest\n};\n\nstruct PublicContext {\n    inputs: abi::PublicContextInputs,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    contract_storage_update_requests: BoundedVec<ContractStorageUpdateRequest, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL>,\n    contract_storage_read: BoundedVec<ContractStorageRead, MAX_PUBLIC_DATA_READS_PER_CALL>,\n    public_call_stack: BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n\n    new_commitments: BoundedVec<Field, MAX_NEW_COMMITMENTS_PER_CALL>,\n    new_nullifiers: BoundedVec<Field, crate::abi::MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    new_l2_to_l1_msgs: BoundedVec<Field, crate::abi::MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n\n    unencrypted_logs_hash: BoundedVec<Field, NUM_FIELDS_PER_SHA256>,\n    unencrypted_logs_preimages_length: Field,\n\n    block_data: HistoricBlockData,\n    prover_address: Field,\n}\n\nimpl PublicContext {\n    fn new(inputs: abi::PublicContextInputs, args_hash: Field) -> PublicContext {\n        let empty_storage_read = ContractStorageRead::empty();\n        let empty_storage_update = ContractStorageUpdateRequest::empty();\n        PublicContext {\n            inputs: inputs,\n\n            args_hash: args_hash,\n            return_values: BoundedVec::new(0),\n\n            contract_storage_update_requests: BoundedVec::new(empty_storage_update),\n            contract_storage_read: BoundedVec::new(empty_storage_read),\n            public_call_stack: BoundedVec::new(0),\n\n            new_commitments: BoundedVec::new(0),\n            new_nullifiers: BoundedVec::new(0),\n\n            new_l2_to_l1_msgs: BoundedVec::new(0),\n\n            \n            unencrypted_logs_hash: BoundedVec::new(0),\n            unencrypted_logs_preimages_length: 0,\n\n            block_data: inputs.block_data,\n            prover_address: 0,\n\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n        }\n    }\n\n    fn msg_sender(self) -> Field {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> Field {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> Field {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.public_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.public_global_variables.version\n    }\n\n    fn block_number(self) -> Field {\n        self.inputs.public_global_variables.block_number\n    }\n\n    fn timestamp(self) -> Field {\n        self.inputs.public_global_variables.timestamp\n    }\n\n    fn finish(self) -> abi::PublicCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_log_preimages_length = 0;\n\n\n        // Compute the public call stack hashes\n        let pub_circuit_pub_inputs = abi::PublicCircuitPublicInputs {\n            call_context: self.inputs.call_context, // Done\n            args_hash: self.args_hash, // Done\n            contract_storage_update_requests: self.contract_storage_update_requests.storage,\n            contract_storage_read: self.contract_storage_read.storage,\n            return_values: self.return_values.storage,\n            new_commitments: self.new_commitments.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            public_call_stack: self.public_call_stack.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            unencrypted_logs_hash: unencrypted_logs_hash,\n            unencrypted_log_preimages_length: unencrypted_log_preimages_length,\n            block_data: self.inputs.block_data,\n            prover_address: self.prover_address,\n        };\n        pub_circuit_pub_inputs\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_commitments.push(note_hash);\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        self.new_nullifiers.push(nullifier);\n    }\n\n    fn message_portal(&mut self, content: Field) {\n        self.new_l2_to_l1_msgs.push(content);\n    }\n\n    // PrivateContextInputs must be temporarily passed in to prevent too many unknowns\n    // Note this returns self to get around an issue where mutable structs do not maintain mutations unless reassigned\n    fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field) {\n        let this = (*self).this_address();\n        let nullifier = process_l1_to_l2_message(self.block_data.l1_to_l2_messages_tree_root, this, msg_key, content, secret);\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT)\n    }\n\n    fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    fn call_public_function<ARGS_COUNT>(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n        args: [Field; ARGS_COUNT],\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = abi::hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            args_hash,\n        )\n    }\n\n    fn call_public_function_no_args(\n        _self: Self,\n        contract_address: Field, \n        function_selector: Field,\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        call_public_function_internal(\n            contract_address, \n            function_selector, \n            0,\n        )\n    }\n\n}",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/context"
      },
      "33": {
        "source": "use crate::context::PrivateContext;\nuse crate::oracle;\nuse crate::types::point::Point;\n\nfn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: Field,\n    storage_slot: Field,\n    encryption_pub_key: Point,\n    log: [Field; N],\n) {\n    let _ = oracle::logs::emit_encrypted_log(contract_address, storage_slot, encryption_pub_key, log);\n    context.accumulate_encrypted_logs(log);\n}\n\nfn emit_unencrypted_log<T>(\n    context: &mut PrivateContext,\n    log: T,\n) {\n    let _ = oracle::logs::emit_unencrypted_log(log);\n    context.accumulate_unencrypted_logs(log);\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/log"
      },
      "39": {
        "source": "use dep::std::option::Option;\nuse crate::abi::PublicContextInputs;\nuse crate::context::{\n    PrivateContext,\n    PublicContext,\n};\nuse crate::note::{\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n    utils::compute_inner_note_hash,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\nuse crate::constants_gen::EMPTY_NULLIFIED_COMMITMENT;\n\nfn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(*note);\n    assert(notify_created_note(storage_slot, preimage, inner_note_hash) == 0);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0 };\n    let set_header = note_interface.set_header;\n    set_header(note, header);\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\nfn destroy_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n    note_interface: NoteInterface<Note, N>,\n) {\n    let mut nullifier = 0;\n    let mut nullified_commitment: Field = EMPTY_NULLIFIED_COMMITMENT;\n    let compute_nullifier = note_interface.compute_nullifier;\n    nullifier = compute_nullifier(note);\n\n    let serialise = note_interface.serialise;\n    let preimage = serialise(note);\n\n    // We also need the note commitment corresponding to the \"nullifier\"\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    // 0 nonce implies \"transient\" nullifier (must nullify a commitment in this TX).\n    // `nullified_commitment` is used to inform the kernel which pending commitment\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // commitment) in which case `nullified_commitment` is not used since the kernel\n    // just siloes and forwards the nullier to its output.\n    if (header.nonce == 0) {\n        // TODO(suyash): Can we reuse the note commitment computed in `compute_nullifier`?\n        nullified_commitment = compute_inner_note_hash(note_interface, note);\n    }\n    assert(notify_nullified_note(storage_slot, nullifier, preimage, nullified_commitment) == 0);\n\n    context.push_new_nullifier(nullifier, nullified_commitment)\n}",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/lifecycle"
      },
      "40": {
        "source": "use dep::std::option::Option;\nuse crate::constants_gen::{\n    MAX_READ_REQUESTS_PER_CALL,\n    GET_NOTE_ORACLE_RETURN_LENGTH,\n    GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE,\n    VIEW_NOTE_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort},\n    note_interface::NoteInterface,\n    note_header::NoteHeader,\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_or_nullify,\n    utils::compute_unique_siloed_note_hash,\n    utils::compute_inner_note_hash,\n    utils::compute_siloed_note_hash,\n};\nuse crate::messaging::get_commitment_getter_data::make_commitment_getter_data;\nuse crate::oracle;\nuse crate::types::vec::BoundedVec;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n    let contract_address = context.this_address();\n    assert(header.contract_address == contract_address);\n    assert(header.storage_slot == storage_slot);\n}\n\nfn ensure_note_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    let saved_note = get_note_internal(storage_slot, note_interface);\n\n    // Only copy over the header to the original note to make sure the preimage is the same.\n    let get_header = note_interface.get_header;\n    let set_header = note_interface.set_header;\n    let note_header = get_header(saved_note);\n    set_header(note, note_header);\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, *note);\n    context.push_read_request(note_hash_for_read_request);\n}\n\n// Ensure a note's hash exists in the tree without retrieving the entire\n// notes via the oracle.\n// Modifies the note by populating it with header info.\nfn ensure_note_hash_exists<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    note: &mut Note,\n) {\n    // Initialize header of note. Must be done before computing note hashes as it initializes the:\n    // - storage slot (used in inner note hash)\n    // - the contract address (used in siloed note hash)\n    // - and the nonce (used in the unique siloed note hash)\n    let set_header = note_interface.set_header;\n    let note_header = NoteHeader {\n        contract_address: (*context).this_address(),\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n        // real nonce (once public kernel applies nonces).\n        nonce: 0,\n        storage_slot\n    };\n    set_header(note, note_header);\n\n    // Get a note from oracle and early out if it doesn't exist.\n    let inner_note_hash = compute_inner_note_hash(note_interface, *note);\n\n    let raw_oracle_ret = oracle::get_commitment::get_commitment(inner_note_hash);\n    let deserialized_oracle_ret = make_commitment_getter_data(raw_oracle_ret, 0);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // unique_siloed_note_hash once public kernel applies nonces\n    let saved_siloed_note_hash = deserialized_oracle_ret.message;\n\n    assert(saved_siloed_note_hash != 0); // TODO(dbanks12): necessary?\n\n    check_note_header(*context, storage_slot, note_interface, *note);\n\n    // Ensure that the note hash retrieved from oracle matches the one computed from note.\n    let computed_siloed_note_hash = compute_siloed_note_hash(note_interface, *note);\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): should be\n    // compute_note_hash_for_read_or_nullify once public kernel applies nonces\n    assert(computed_siloed_note_hash == saved_siloed_note_hash);\n\n    context.push_read_request(computed_siloed_note_hash);\n}\n\nfn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let note = get_note_internal(storage_slot, note_interface);\n\n    check_note_header(*context, storage_slot, note_interface, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\nfn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let opt_notes = get_notes_internal(storage_slot, note_interface, options);\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        let mut note_hash_for_read_request = 0;\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            check_note_header(*context, storage_slot, note_interface, note);\n            note_hash_for_read_request = compute_note_hash_for_read_or_nullify(note_interface, note);\n        };\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n        // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n        context.push_read_request(note_hash_for_read_request);\n    };\n\n    // TODO(#1660)\n    // Move it back to get_notes_internal and only make read request for selected notes.\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained fn get_note_internal<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n) -> Note {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        0,\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        placeholder_note,\n        placeholder_fields,\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>,\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn view_notes<Note, N>(\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n    options: NoteViewerOptions<Note, N>,\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] {\n    let (num_selects, select_by, select_values, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    oracle::notes::get_notes(\n        storage_slot,\n        note_interface,\n        num_selects,\n        select_by,\n        select_values,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        placeholder_opt_notes,\n        placeholder_fields,\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [Field; N], [u8; N], [u2; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            num_selects += 1;\n        };\n    };\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    };\n\n    (num_selects, select_by, select_values, sort_by, sort_order)\n}",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_getter"
      },
      "42": {
        "source": "use dep::std::hash::{pedersen, pedersen_with_separator};\nuse crate::constants_gen::{GENERATOR_INDEX__UNIQUE_COMMITMENT, GENERATOR_INDEX__SILOED_COMMITMENT};\n\nfn compute_inner_hash(storage_slot: Field, note_hash: Field) -> Field {\n    // TODO(#1205) Do we need a generator index here?\n    pedersen([storage_slot, note_hash])[0]\n}\n\nfn compute_siloed_hash(contract_address: Field, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address, inner_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__SILOED_COMMITMENT)[0]\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_with_separator(inputs, GENERATOR_INDEX__UNIQUE_COMMITMENT)[0]\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/note_hash"
      },
      "46": {
        "source": "use crate::note::{\n    note_hash::{compute_inner_hash, compute_siloed_hash, compute_unique_hash},\n    note_header::NoteHeader,\n    note_interface::NoteInterface,\n};\nuse crate::utils::arr_copy_slice;\n\nfn compute_inner_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n\n    compute_inner_hash(header.storage_slot, note_hash)\n}\n\nfn compute_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let inner_note_hash = compute_inner_note_hash(note_interface, note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    let siloed_note_hash = compute_siloed_note_hash(note_interface, note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\nfn compute_note_hash_for_read_or_nullify<Note, N>(\n    note_interface: NoteInterface<Note, N>,\n    note_with_header: Note,\n) -> Field {\n    let get_header = note_interface.get_header;\n    let header = get_header(note_with_header);\n\n    if (header.nonce == 0) {\n        // when nonce is zero, that means we are reading a pending note (doesn't have a nonce yet),\n        // so we just read the inner_note_hash (kernel will silo by contract address)\n        compute_inner_note_hash(note_interface, note_with_header)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note_interface, note_with_header)\n    }\n\n}\n\nfn compute_note_hash_and_nullifier<Note, N, S>(\n    note_interface: NoteInterface<Note, N>,\n    note_header: NoteHeader,\n    preimage: [Field; S],\n) -> [Field; 4] {\n    let deserialise = note_interface.deserialise;\n    let set_header = note_interface.set_header;\n    let mut note = deserialise(arr_copy_slice(preimage, [0; N], 0));\n    set_header(&mut note, note_header);\n\n    let compute_note_hash = note_interface.compute_note_hash;\n    let note_hash = compute_note_hash(note);\n    let inner_note_hash = compute_inner_hash(note_header.storage_slot, note_hash);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let compute_nullifier = note_interface.compute_nullifier;\n    let inner_nullifier = compute_nullifier(note);\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/note/utils"
      },
      "48": {
        "source": "use dep::std::hash::pedersen_with_separator;\nuse crate::context::PrivateContext;\nuse crate::note::{\n    lifecycle::create_note,\n    note_getter::{get_note, view_notes},\n    note_interface::NoteInterface,\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle;\nuse crate::constants_gen::{\n    GENERATOR_INDEX__INITIALISATION_NULLIFIER,\n    EMPTY_NULLIFIED_COMMITMENT,\n};\n\nstruct ImmutableSingleton<Note, N> {\n    storage_slot: Field,\n    note_interface: NoteInterface<Note, N>,\n}\n\nimpl<Note, N> ImmutableSingleton<Note, N> {\n    fn new(storage_slot: Field, note_interface: NoteInterface<Note, N>) -> Self {\n        ImmutableSingleton { storage_slot, note_interface }\n    }\n\n    unconstrained fn is_initialised(self) -> bool {\n        let nullifier = self.compute_initialisation_nullifier();\n        oracle::notes::is_nullifier_emitted(nullifier)\n    }\n\n    fn initialise(self, context: &mut PrivateContext, note: &mut Note) {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialisation_nullifier();\n        context.push_new_nullifier(nullifier, EMPTY_NULLIFIED_COMMITMENT);\n\n        create_note(context, self.storage_slot, note, self.note_interface);\n    }\n\n    fn compute_initialisation_nullifier(self) -> Field {\n        pedersen_with_separator([self.storage_slot], GENERATOR_INDEX__INITIALISATION_NULLIFIER)[0]\n    }\n    \n    fn get_note(self, context: &mut PrivateContext) -> Note {\n        let storage_slot = self.storage_slot;\n        get_note(context, storage_slot, self.note_interface)\n    }\n\n    unconstrained fn view_note(self) -> Note {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, self.note_interface, options)[0].unwrap()\n    }\n}",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/state_vars/immutable_singleton"
      },
      "55": {
        "source": "\nstruct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: Field,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    fn new(initial_value: T) -> Self {\n        BoundedVec { storage: [initial_value; MaxLen], len: 0 }\n    }\n\n    fn get(mut self: Self, index: Field) -> T {\n        assert(index as u64 < self.len as u64);\n        self.storage[index]\n    }\n\n    fn push(&mut self, elem: T) {\n        assert(self.len as u64 < MaxLen as u64);\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    fn push_array<Len>(&mut self, array: [T; Len]) {\n        let newLen = self.len + array.len();\n        assert(newLen as u64 <= MaxLen as u64);\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = newLen;\n    }\n\n    fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n\n        let elem = self.storage[self.len - 1];\n        self.len -= 1;\n        elem\n    }\n}\n\n// #[test]\n// fn test_vec() {\n//     let vec: BoundedVec<Field, 2> = BoundedVec::new(0);\n//     assert(vec.len == 0);\n//     let vec1 = vec.push(1);\n//     assert(vec1.len == 1);\n//     let vec2 = vec1.push(1);\n//     assert(vec2.len == 2);\n//     let vec3 = vec2.push(1);\n//     assert(vec3.len == 3);\n//     let x = vec3.pop();\n//     assert(x == 1);\n// }",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/types/vec"
      },
      "70": {
        "source": "use crate::types::point::Point;\nuse dep::std::hash;\nuse crate::constants_gen::GENERATOR_INDEX__CONTRACT_ADDRESS;\n\n#[oracle(getPublicKey)]\nfn get_public_key_oracle(_address: Field) -> [Field; 3] {}\n\nunconstrained fn get_public_key_internal(address: Field) -> [Field; 3] {\n  get_public_key_oracle(address)\n}\n\nfn get_public_key(address: Field) -> Point {\n  let result = get_public_key_internal(address);\n  let pub_key_x = result[0];\n  let pub_key_y = result[1];\n  let partial_address = result[2];\n  \n  let calculated_address = hash::pedersen_with_separator([pub_key_x, pub_key_y, partial_address], GENERATOR_INDEX__CONTRACT_ADDRESS)[0];\n  assert(calculated_address == address);\n  \n  Point::new(pub_key_x, pub_key_y)\n}\n",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/oracle/get_public_key"
      },
      "78": {
        "source": "use crate::abi;\nuse crate::types::vec::BoundedVec;\nuse crate::context::PrivateContext;\nuse crate::private_call_stack_item::PrivateCallStackItem;\nuse crate::public_call_stack_item::PublicCallStackItem;    \n\nglobal ACCOUNT_MAX_PRIVATE_CALLS: Field = 2;\nglobal ACCOUNT_MAX_PUBLIC_CALLS: Field = 2;\nglobal ACCOUNT_MAX_CALLS: Field = 4;\n// 1 (ARGS_HASH) + 1 (FUNCTION_SELECTOR) + 1 (TARGET_ADDRESS)\nglobal FUNCTION_CALL_SIZE: Field = 3;\n\nstruct FunctionCall {\n  args_hash: Field,\n  function_selector: Field,\n  target_address: Field,\n}\n\nimpl FunctionCall {\n  fn serialize(self) -> [Field; FUNCTION_CALL_SIZE] {\n    [self.args_hash, self.function_selector, self.target_address]\n  }\n}\n\n// FUNCTION_CALL_SIZE * (ACCOUNT_MAX_PUBLIC_CALLS + ACCOUNT_MAX_PRIVATE_CALLS) + 1\nglobal ENTRYPOINT_PAYLOAD_SIZE: Field = 13;\nglobal ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES: Field = 416;\n\nstruct EntrypointPayload {\n  // Noir doesnt support nested arrays or structs yet so we flatten everything\n  flattened_args_hashes: [Field; ACCOUNT_MAX_CALLS],\n  flattened_selectors: [Field; ACCOUNT_MAX_CALLS],\n  flattened_targets: [Field; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n\nimpl EntrypointPayload {\n  // TODO(#1207) Do we need a generator index?\n  fn hash(self) -> Field {\n    dep::std::hash::pedersen(self.serialize())[0]\n  }\n\n  // Serializes the entrypoint struct\n  fn serialize(self) -> [Field; ENTRYPOINT_PAYLOAD_SIZE] {\n    let mut fields: BoundedVec<Field, ENTRYPOINT_PAYLOAD_SIZE> = BoundedVec::new(0); \n    fields.push_array(self.flattened_args_hashes);\n    fields.push_array(self.flattened_selectors);\n    fields.push_array(self.flattened_targets);\n    fields.push(self.nonce);\n    fields.storage\n  }\n\n  // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n  fn to_be_bytes(self) -> [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] {\n    let mut bytes: [u8; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES] = [0; ENTRYPOINT_PAYLOAD_SIZE_IN_BYTES];\n\n    let args_len = self.flattened_args_hashes.len();\n    let selectors_len = self.flattened_selectors.len();\n    let targets_len = self.flattened_targets.len();\n\n    for i in 0..args_len {\n      let item_bytes = self.flattened_args_hashes[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..selectors_len {\n      let item_bytes = self.flattened_selectors[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[args_len * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n\n    for i in 0..targets_len {\n      let item_bytes = self.flattened_targets[i].to_be_bytes(32);\n      for j in 0..32 { \n        bytes[(args_len + selectors_len) * 32 + i * 32 + j] = item_bytes[j];\n      }\n    }\n    \n    let item_bytes = self.nonce.to_be_bytes(32);\n    for j in 0..32 { \n      bytes[(args_len + selectors_len + targets_len) * 32 + j] = item_bytes[j];\n    }\n\n    bytes\n  }\n\n  // Executes all private and public calls \n  fn execute_calls(self, context: &mut PrivateContext) {\n    for i in 0..ACCOUNT_MAX_PRIVATE_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_private_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n    for i in ACCOUNT_MAX_PRIVATE_CALLS..ACCOUNT_MAX_CALLS {\n        let target_address = self.flattened_targets[i];\n        if target_address != 0 {\n            let function_selector = self.flattened_selectors[i];\n            let args_hash = self.flattened_args_hashes[i];\n            let _callStackItem = context.call_public_function_with_packed_args(target_address, function_selector, args_hash);\n        }\n    }\n  }\n}",
        "path": "/mnt/user-data/jan/aztec-packages/yarn-project/noir-libs/noir-aztec/src/entrypoint"
      }
    }
  }
}
