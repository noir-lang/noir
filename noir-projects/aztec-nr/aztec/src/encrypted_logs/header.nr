use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};

use crate::keys::point_to_symmetric_key::point_to_symmetric_key;

use std::aes128::aes128_encrypt;

struct EncryptedLogHeader {
    address: AztecAddress,
}

impl EncryptedLogHeader {
    fn new(address: AztecAddress) -> Self {
        EncryptedLogHeader { address }
    }

    fn compute_ciphertext(self, secret: Scalar, point: Point) -> [u8; 48] {
        let full_key = point_to_symmetric_key(secret, point);
        let mut sym_key = [0; 16];
        let mut iv = [0; 16];

        for i in 0..16 {
            sym_key[i] = full_key[i];
            iv[i] = full_key[i + 16];
        }

        let input: [u8; 32] = self.address.to_field().to_be_bytes(32).as_array();
        aes128_encrypt(input, iv, sym_key).as_array()
    }
}

#[test]
fn test_encrypted_log_header_matches_noir() {
    let address = AztecAddress::from_field(0xdeadbeef);
    let header = EncryptedLogHeader::new(address);
    let secret = Scalar {
        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,
        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06
    };
    let point = Point {
        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,
        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,
        is_infinite: false
    };

    let ciphertext = header.compute_ciphertext(secret, point);

    // The following value was generated by `encrypted_log_header.test.ts`.
    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.
    let expected_header_ciphertext_from_typescript = [
        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209
    ];

    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);
}
