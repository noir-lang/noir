{"run_id":"1757446422-167065291","line":1978,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"acir_variant_in_brillig_not_last_to_dispatch","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1978,"expression":"ssa_string"},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 1, Field 2)\n  b2():\n    v6, v7 = call f3() -> (Field, Field)\n    jmp b3(v6, v7)\n  b3(v1: Field, v2: Field):\n    call f6(v2)\n    return\n}\nbrillig(inline) fn lambda f1 {\n  b0():\n    return\n}\nbrillig(inline) fn lambda f2 {\n  b0():\n    return\n}\nbrillig(inline) fn return_lambda f3 {\n  b0():\n    return Field 4, Field 5\n}\nacir(inline) fn zeroed_lambda f4 {\n  b0():\n    return\n}\nbrillig(inline) fn zeroed_lambda f5 {\n  b0():\n    return\n}\nbrillig(inline_always) fn apply f6 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b3, else: b2\n  b1():\n    return\n  b2():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b5, else: b4\n  b3():\n    call f1()\n    jmp b1()\n  b4():\n    constrain v0 == Field 5\n    call f5()\n    jmp b1()\n  b5():\n    call f2()\n    jmp b1()\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 1, Field 2)\n  b2():\n    v8, v9 = call f3() -> (Field, Field)\n    jmp b3(v8, v9)\n  b3(v1: Field, v2: Field):\n    call f6(v2)\n    return\n}\nbrillig(inline) fn lambda f1 {\n  b0():\n    return\n}\nbrillig(inline) fn lambda f2 {\n  b0():\n    return\n}\nbrillig(inline) fn return_lambda f3 {\n  b0():\n    return Field 4, Field 5\n}\nacir(inline) fn zeroed_lambda f4 {\n  b0():\n    return\n}\nbrillig(inline) fn zeroed_lambda f5 {\n  b0():\n    return\n}\nbrillig(inline_always) fn apply f6 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b3, else: b2\n  b1():\n    return\n  b2():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b5, else: b4\n  b3():\n    call f1()\n    jmp b1()\n  b4():\n    constrain v0 == Field 5\n    call f5()\n    jmp b1()\n  b5():\n    call f2()\n    jmp b1()\n}"}}
{"run_id":"1757446422-167065291","line":2078,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"brillig_variant_in_acir","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":2078,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 1, Field 2)\n  b2():\n    v6, v7 = call f3() -> (Field, Field)\n    jmp b3(v6, v7)\n  b3(v1: Field, v2: Field):\n    call f6(v2)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn return_lambda f3 {\n  b0():\n    return Field 4, Field 5\n}\nbrillig(inline) fn zeroed_lambda f4 {\n  b0():\n    return\n}\nacir(inline) fn zeroed_lambda f5 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f6 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b4, else: b3\n  b2():\n    call f1()\n    jmp b9()\n  b3():\n    v8 = eq v0, Field 4\n    jmpif v8 then: b6, else: b5\n  b4():\n    call f2()\n    jmp b8()\n  b5():\n    constrain v0 == Field 5\n    call f5()\n    jmp b7()\n  b6():\n    call f4()\n    jmp b7()\n  b7():\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 1, Field 2)\n  b2():\n    v8, v9 = call f3() -> (Field, Field)\n    jmp b3(v8, v9)\n  b3(v1: Field, v2: Field):\n    call f6(v2)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn return_lambda f3 {\n  b0():\n    return Field 4, Field 5\n}\nbrillig(inline) fn zeroed_lambda f4 {\n  b0():\n    return\n}\nacir(inline) fn zeroed_lambda f5 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f6 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b4, else: b3\n  b2():\n    call f1()\n    jmp b9()\n  b3():\n    v8 = eq v0, Field 4\n    jmpif v8 then: b6, else: b5\n  b4():\n    call f2()\n    jmp b8()\n  b5():\n    constrain v0 == Field 5\n    call f5()\n    jmp b7()\n  b6():\n    call f4()\n    jmp b7()\n  b7():\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"}}
{"run_id":"1757446422-167065291","line":1173,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_function_with_dynamic_dispatch_id","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1173,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v2 = sub v0, u32 1\n    v4 = call f2(v2) -> u32\n    return v4\n}\nacir(inline) fn lambdas_with_input_and_return_values f1 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 2)\n  b2():\n    v6 = eq v0, u32 1\n    jmpif v6 then: b4, else: b5\n  b3(v1: Field):\n    v11 = call f5(v1, v0) -> u32\n    return v11\n  b4():\n    jmp b6(Field 3)\n  b5():\n    jmp b6(Field 4)\n  b6(v2: Field):\n    jmp b3(v2)\n}\nacir(inline) fn lambda f2 {\n  b0(v0: u32):\n    return v0\n}\nacir(inline) fn lambda f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nacir(inline) fn lambda f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 2\n    return v2\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v9 = eq v0, Field 3\n    jmpif v9 then: b4, else: b3\n  b2():\n    v7 = call f2(v1) -> u32\n    jmp b6(v7)\n  b3():\n    constrain v0 == Field 4\n    v14 = call f4(v1) -> u32\n    jmp b5(v14)\n  b4():\n    v11 = call f3(v1) -> u32\n    jmp b5(v11)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v2 = sub v0, u32 1\n    v4 = call f2(v2) -> u32\n    return v4\n}\nacir(inline) fn lambdas_with_input_and_return_values f1 {\n  b0(v0: u32):\n    v4 = eq v0, u32 0\n    jmpif v4 then: b1, else: b2\n  b1():\n    jmp b3(Field 2)\n  b2():\n    v7 = eq v0, u32 1\n    jmpif v7 then: b4, else: b5\n  b3(v1: Field):\n    v11 = call f5(v1, v0) -> u32\n    return v11\n  b4():\n    jmp b6(Field 3)\n  b5():\n    jmp b6(Field 4)\n  b6(v2: Field):\n    jmp b3(v2)\n}\nacir(inline) fn lambda f2 {\n  b0(v0: u32):\n    return v0\n}\nacir(inline) fn lambda f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nacir(inline) fn lambda f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 2\n    return v2\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v7 = eq v0, Field 3\n    jmpif v7 then: b4, else: b3\n  b2():\n    v14 = call f2(v1) -> u32\n    jmp b6(v14)\n  b3():\n    constrain v0 == Field 4\n    v10 = call f4(v1) -> u32\n    jmp b5(v10)\n  b4():\n    v12 = call f3(v1) -> u32\n    jmp b5(v12)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"}}
{"run_id":"1757446422-167065291","line":873,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_inherits_caller_runtime","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":873,"expression":"ssa_string"},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v9 = eq v0, Field 3\n    jmpif v9 then: b4, else: b3\n  b2():\n    v7 = call f2(v1) -> u32\n    jmp b6(v7)\n  b3():\n    constrain v0 == Field 4\n    v14 = call f4(v1) -> u32\n    jmp b5(v14)\n  b4():\n    v11 = call f3(v1) -> u32\n    jmp b5(v11)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v7 = eq v0, Field 3\n    jmpif v7 then: b4, else: b3\n  b2():\n    v14 = call f2(v1) -> u32\n    jmp b6(v14)\n  b3():\n    constrain v0 == Field 4\n    v10 = call f4(v1) -> u32\n    jmp b5(v10)\n  b4():\n    v12 = call f3(v1) -> u32\n    jmp b5(v12)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"}}
{"run_id":"1757448902-392408295","line":1349,"new":null,"old":null}
{"run_id":"1757448902-392408295","line":1382,"new":null,"old":null}
{"run_id":"1757448902-392408295","line":1474,"new":null,"old":null}
{"run_id":"1757448902-392408295","line":1101,"new":null,"old":null}
{"run_id":"1757448902-392408295","line":1423,"new":null,"old":null}
{"run_id":"1757448902-392408295","line":1271,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"fn_in_array","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1271,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v5 = make_array [Field 1, Field 2, Field 3, Field 4] : [Field; 4]\n    v7 = lt v0, u32 4\n    constrain v7 == u1 1, \"Index out of bounds\"\n    v9 = array_get v5, index v0 -> Field\n    call f5(v9)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn lambda f3 {\n  b0():\n    return\n}\nacir(inline) fn lambda f4 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v4 = eq v0, Field 2\n    jmpif v4 then: b4, else: b3\n  b2():\n    (no terminator instruction)\n  b3():\n    (no terminator instruction)\n  b4():\n    call f2()\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v5 = make_array [Field 1, Field 2, Field 3, Field 4] : [Field; 4]\n    v7 = lt v0, u32 4\n    constrain v7 == u1 1, \"Index out of bounds\"\n    v9 = array_get v5, index v0 -> Field\n    call f5(v9)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn lambda f3 {\n  b0():\n    return\n}\nacir(inline) fn lambda f4 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b4, else: b3\n  b2():\n    call f1()\n    jmp b9()\n  b3():\n    v8 = eq v0, Field 3\n    jmpif v8 then: b6, else: b5\n  b4():\n    call f2()\n    jmp b8()\n  b5():\n    constrain v0 == Field 4\n    call f4()\n    jmp b7()\n  b6():\n    call f3()\n    jmp b7()\n  b7():\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"}}
{"run_id":"1757448902-392408295","line":1027,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_created_for_stored_functions","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1027,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u1):\n    v1 = allocate -> &mut Field\n    store Field 1 at v1\n    jmpif v0 then: b1, else: b2\n  b1():\n    store Field 2 at v1\n    jmp b2()\n  b2():\n    v4 = load v1 -> Field\n    v6 = call f3(v4) -> u32\n    return v6\n}\nacir(inline) fn foo f1 {\n  b0():\n    return u32 1\n}\nacir(inline) fn bar f2 {\n  b0():\n    return u32 2\n}\nacir(inline) fn caller f3 {\n  b0(v0: Field):\n    v2 = call f4(v0) -> u32\n    v3 = call f4(v0) -> u32\n    v4 = add v2, v3\n    return v4\n}\nacir(inline_always) fn apply f4 {\n  b0(v0: Field):\n    v3 = eq v0, Field 1\n    jmpif v3 then: b2, else: b1\n  b1():\n    (no terminator instruction)\n  b2():\n    v5 = call f1() -> u32\n    jmp b3(v5)\n  b3(v1: u32):\n    return v1\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u1):\n    v1 = allocate -> &mut Field\n    store Field 1 at v1\n    jmpif v0 then: b1, else: b2\n  b1():\n    store Field 2 at v1\n    jmp b2()\n  b2():\n    v4 = load v1 -> Field\n    v6 = call f3(v4) -> u32\n    return v6\n}\nacir(inline) fn foo f1 {\n  b0():\n    return u32 1\n}\nacir(inline) fn bar f2 {\n  b0():\n    return u32 2\n}\nacir(inline) fn caller f3 {\n  b0(v0: Field):\n    v2 = call f4(v0) -> u32\n    v3 = call f4(v0) -> u32\n    v4 = add v2, v3\n    return v4\n}\nacir(inline_always) fn apply f4 {\n  b0(v0: Field):\n    v3 = eq v0, Field 1\n    jmpif v3 then: b2, else: b1\n  b1():\n    constrain v0 == Field 2\n    v8 = call f2() -> u32\n    jmp b3(v8)\n  b2():\n    v5 = call f1() -> u32\n    jmp b3(v5)\n  b3(v1: u32):\n    return v1\n}"}}
{"run_id":"1757448902-392408295","line":873,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_inherits_caller_runtime","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":873,"expression":"ssa_string"},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    (no terminator instruction)\n  b2():\n    v7 = call f2(v1) -> u32\n    jmp b6(v7)\n  b6(v3: u32):\n    return v3\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v7 = eq v0, Field 3\n    jmpif v7 then: b4, else: b3\n  b2():\n    v14 = call f2(v1) -> u32\n    jmp b6(v14)\n  b3():\n    constrain v0 == Field 4\n    v10 = call f4(v1) -> u32\n    jmp b5(v10)\n  b4():\n    v12 = call f3(v1) -> u32\n    jmp b5(v12)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"}}
{"run_id":"1757450212-846140831","line":1349,"new":null,"old":null}
{"run_id":"1757450212-846140831","line":1382,"new":null,"old":null}
{"run_id":"1757450212-846140831","line":1101,"new":null,"old":null}
{"run_id":"1757450212-846140831","line":1423,"new":null,"old":null}
{"run_id":"1757450212-846140831","line":1474,"new":null,"old":null}
{"run_id":"1757450212-846140831","line":1027,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_created_for_stored_functions","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1027,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u1):\n    v1 = allocate -> &mut Field\n    store Field 1 at v1\n    jmpif v0 then: b1, else: b2\n  b1():\n    store Field 2 at v1\n    jmp b2()\n  b2():\n    v4 = load v1 -> Field\n    v6 = call f3(v4) -> u32\n    return v6\n}\nacir(inline) fn foo f1 {\n  b0():\n    return u32 1\n}\nacir(inline) fn bar f2 {\n  b0():\n    return u32 2\n}\nacir(inline) fn caller f3 {\n  b0(v0: Field):\n    v2 = call f4(v0) -> u32\n    v3 = call f4(v0) -> u32\n    v4 = add v2, v3\n    return v4\n}\nacir(inline_always) fn apply f4 {\n  b0(v0: Field):\n    v3 = eq v0, Field 1\n    jmpif v3 then: b2, else: b1\n  b1():\n    (no terminator instruction)\n  b2():\n    v5 = call f1() -> u32\n    jmp b3(v5)\n  b3(v1: u32):\n    return v1\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u1):\n    v1 = allocate -> &mut Field\n    store Field 1 at v1\n    jmpif v0 then: b1, else: b2\n  b1():\n    store Field 2 at v1\n    jmp b2()\n  b2():\n    v4 = load v1 -> Field\n    v6 = call f3(v4) -> u32\n    return v6\n}\nacir(inline) fn foo f1 {\n  b0():\n    return u32 1\n}\nacir(inline) fn bar f2 {\n  b0():\n    return u32 2\n}\nacir(inline) fn caller f3 {\n  b0(v0: Field):\n    v2 = call f4(v0) -> u32\n    v3 = call f4(v0) -> u32\n    v4 = add v2, v3\n    return v4\n}\nacir(inline_always) fn apply f4 {\n  b0(v0: Field):\n    v3 = eq v0, Field 1\n    jmpif v3 then: b2, else: b1\n  b1():\n    constrain v0 == Field 2\n    v8 = call f2() -> u32\n    jmp b3(v8)\n  b2():\n    v5 = call f1() -> u32\n    jmp b3(v5)\n  b3(v1: u32):\n    return v1\n}"}}
{"run_id":"1757450212-846140831","line":873,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"apply_inherits_caller_runtime","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":873,"expression":"ssa_string"},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    (no terminator instruction)\n  b2():\n    v7 = call f2(v1) -> u32\n    jmp b6(v7)\n  b6(v3: u32):\n    return v3\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"brillig(inline) fn main f0 {\n  b0(v0: u32):\n    v3 = call f1(Field 2, v0) -> u32\n    v5 = add v0, u32 1\n    v6 = eq v3, v5\n    constrain v3 == v5\n    v8 = call f1(Field 3, v0) -> u32\n    v9 = add v0, u32 1\n    v10 = eq v8, v9\n    constrain v8 == v9\n    v12 = call f1(Field 4, v0) -> u32\n    v13 = add v0, u32 1\n    constrain v12 == v13\n    return\n}\nbrillig(inline) fn wrapper f1 {\n  b0(v0: Field, v1: u32):\n    v3 = call f5(v0, v1) -> u32\n    return v3\n}\nbrillig(inline) fn increment f2 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_acir f3 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline) fn increment_three f4 {\n  b0(v0: u32):\n    v2 = add v0, u32 1\n    return v2\n}\nbrillig(inline_always) fn apply f5 {\n  b0(v0: Field, v1: u32):\n    v5 = eq v0, Field 2\n    jmpif v5 then: b2, else: b1\n  b1():\n    v7 = eq v0, Field 3\n    jmpif v7 then: b4, else: b3\n  b2():\n    v14 = call f2(v1) -> u32\n    jmp b6(v14)\n  b3():\n    constrain v0 == Field 4\n    v10 = call f4(v1) -> u32\n    jmp b5(v10)\n  b4():\n    v12 = call f3(v1) -> u32\n    jmp b5(v12)\n  b5(v2: u32):\n    jmp b6(v2)\n  b6(v3: u32):\n    return v3\n}"}}
{"run_id":"1757450212-846140831","line":1271,"new":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","snapshot_name":"fn_in_array","metadata":{"source":"compiler/noirc_evaluator/src/ssa/opt/defunctionalize.rs","assertion_line":1271,"expression":"ssa_string"},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v5 = make_array [Field 1, Field 2, Field 3, Field 4] : [Field; 4]\n    v7 = lt v0, u32 4\n    constrain v7 == u1 1, \"Index out of bounds\"\n    v9 = array_get v5, index v0 -> Field\n    call f5(v9)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn lambda f3 {\n  b0():\n    return\n}\nacir(inline) fn lambda f4 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v4 = eq v0, Field 2\n    jmpif v4 then: b4, else: b3\n  b2():\n    (no terminator instruction)\n  b3():\n    (no terminator instruction)\n  b4():\n    call f2()\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"},"old":{"module_name":"noirc_evaluator__ssa__opt__defunctionalize__tests","metadata":{},"snapshot":"acir(inline) fn main f0 {\n  b0(v0: u32):\n    v5 = make_array [Field 1, Field 2, Field 3, Field 4] : [Field; 4]\n    v7 = lt v0, u32 4\n    constrain v7 == u1 1, \"Index out of bounds\"\n    v9 = array_get v5, index v0 -> Field\n    call f5(v9)\n    return\n}\nacir(inline) fn lambda f1 {\n  b0():\n    return\n}\nacir(inline) fn lambda f2 {\n  b0():\n    return\n}\nacir(inline) fn lambda f3 {\n  b0():\n    return\n}\nacir(inline) fn lambda f4 {\n  b0():\n    return\n}\nacir(inline_always) fn apply f5 {\n  b0(v0: Field):\n    v2 = eq v0, Field 1\n    jmpif v2 then: b2, else: b1\n  b1():\n    v5 = eq v0, Field 2\n    jmpif v5 then: b4, else: b3\n  b2():\n    call f1()\n    jmp b9()\n  b3():\n    v8 = eq v0, Field 3\n    jmpif v8 then: b6, else: b5\n  b4():\n    call f2()\n    jmp b8()\n  b5():\n    constrain v0 == Field 4\n    call f4()\n    jmp b7()\n  b6():\n    call f3()\n    jmp b7()\n  b7():\n    jmp b8()\n  b8():\n    jmp b9()\n  b9():\n    return\n}"}}
