acir(inline) predicate_pure fn main f0 {
  b0(v0: u128, v1: u128, v2: u8):
    v3 = add v0, v1
    v5 = eq v3, u128 2358023
    constrain v3 == u128 2358023
    v6 = sub v1, v0
    v8 = eq v6, u128 2333333
    constrain v6 == u128 2333333
    v9 = mul v0, v1
    v11 = eq v9, u128 28957394910
    constrain v9 == u128 28957394910
    v12 = div v1, v0
    v14 = eq v12, u128 190
    constrain v12 == u128 190
    v15 = mod v1, v0
    v17 = eq v15, u128 128
    constrain v15 == u128 128
    v18 = not v0
    v20 = eq v18, u128 340282366920938463463374607431768199110
    constrain v18 == u128 340282366920938463463374607431768199110
    v21 = xor v0, v1
    v23 = eq v21, u128 2358007
    constrain v21 == u128 2358007
    v24 = and v0, v1
    v26 = eq v24, u128 8
    constrain v24 == u128 8
    v27 = or v0, v1
    v29 = eq v27, u128 2358015
    constrain v27 == u128 2358015
    v30 = shr v0, v2
    v32 = eq v30, u128 3086
    constrain v30 == u128 3086
    v33 = shl v0, v2
    v35 = lt v2, u8 128
    constrain v35 == u1 1, "attempt to bit-shift with overflow"
    v37 = truncate v33 to 128 bits, max_bit_size: 129
    v39 = eq v33, u128 49380
    constrain v33 == u128 49380
    v40 = lt v0, v1
    constrain v40 == u1 1
    v41 = lt v1, v0
    v42 = not v41
    constrain v41 == u1 0
    v44 = eq v0, v1
    v45 = not v44
    constrain v44 == u1 0
    v46 = lt v0, v1
    constrain v46 == u1 1
    v47 = lt v1, v0
    v48 = not v47
    constrain v47 == u1 0
    return
}
