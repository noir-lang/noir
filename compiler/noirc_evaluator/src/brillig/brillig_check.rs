//! Post-codegen checks that can highlight potential issues with the generated bytecode.

use std::{collections::HashMap, fmt::Display, ops::Range};

use acvm::acir::brillig::{BlackBoxOp, HeapArray, HeapVector, MemoryAddress, Opcode, ValueOrArray};

use crate::{
    brillig::{
        brillig_gen::brillig_fn::FunctionContext,
        brillig_ir::{
            BrilligContext,
            artifact::{BrilligArtifact, LabelType, OpcodeLocation},
            registers::{RegisterAllocator, Stack},
        },
    },
    ssa::ir::{basic_block::BasicBlockId, dfg::DataFlowGraph},
};

pub(crate) enum OpcodeAdvisory {
    /// A memory address is being written by the opcode that no other following opcode reads.
    NeverRead,
    /// A memory address is being written by the opcode that will get overwritten before being read.
    OverwrittenBeforeRead { write_at: OpcodeLocation, read_at: OpcodeLocation },
}

/// Go through opcodes and collect advisories, indicating opcodes which could potentially be removed:
/// * writing to a `destination` to that isn't read from
/// * writing to a `destination` that gets overwritten before being read, within the same block
pub(crate) fn collect_opcode_advisories<F>(
    dfg: &DataFlowGraph,
    function_context: &FunctionContext,
    brillig_context: &BrilligContext<F, Stack>,
) -> HashMap<OpcodeLocation, OpcodeAdvisory> {
    let block_opcode_ranges = collect_block_opcode_ranges(brillig_context);

    // Accumulate stack addresses read. These are all in the same function context,
    // so they should fit in one stack frame, which makes relative addresses comparable.
    let registers = brillig_context.registers();
    let registers: &Stack = &registers;

    let mut ctx = CheckContext::new(registers, function_context.blocks[0]);

    for block_id in function_context.post_order() {
        ctx.on_new_block();

        let range =
            block_opcode_ranges.get(block_id).expect("ICE: every block has a range").clone();

        for i in range.rev() {
            let opcode = &brillig_context.artifact().byte_code[i];

            ctx.visit_opcode(opcode, i);
        }
    }

    ctx.into_advisories()
}

/// Display the opcodes and their corresponding advisories.
pub(crate) fn show_opcode_advisories<F: Display>(
    advisories: &HashMap<OpcodeLocation, OpcodeAdvisory>,
    artifact: &BrilligArtifact<F>,
) {
    println!(
        "// There are {} Brillig opcode advisories for function {}",
        advisories.len(),
        artifact.name
    );

    println!("fn {}", artifact.name);
    let width = artifact.byte_code.len().to_string().len();
    for (index, opcode) in artifact.byte_code.iter().enumerate() {
        let advisory = match advisories.get(&index) {
            Some(OpcodeAdvisory::NeverRead) => " // Never read",
            Some(OpcodeAdvisory::OverwrittenBeforeRead { write_at, read_at }) => {
                &format!(" // Overwritten at {write_at} before read at {read_at}")
            }
            None => "",
        };
        println!("{index:>width$}: {opcode}{advisory}");
    }
}

/// Go through the labels in the [BrilligContext] and collect the opcode locations
/// where each block starts and ends.
fn collect_block_opcode_ranges<F, R: RegisterAllocator>(
    brillig_context: &BrilligContext<F, R>,
) -> HashMap<BasicBlockId, Range<OpcodeLocation>> {
    let mut ranges = HashMap::new();

    let mut labels = brillig_context.artifact().labels.iter().collect::<Vec<_>>();
    labels.sort_by_key(|(_, location)| **location);

    let mut last_start = None;
    for (label, location) in labels {
        match (&label.label_type, last_start) {
            (LabelType::Function(_, Some(block_id)), None) => {
                last_start = Some((*block_id, *location));
            }
            (LabelType::Function(_, Some(new_block_id)), Some((block_id, start))) => {
                if *new_block_id != block_id {
                    ranges.insert(block_id, Range { start, end: *location });
                    last_start = Some((*new_block_id, *location));
                }
            }
            (_, Some((block_id, start))) => {
                ranges.insert(block_id, Range { start, end: *location });
                last_start = None;
            }
            (_, None) => {}
        }
    }
    if let Some((block_id, start)) = last_start {
        ranges.insert(block_id, Range { start, end: brillig_context.artifact().byte_code.len() });
    }

    ranges
}

struct CheckContext {
    /// Range of acceptable relative stack addresses.
    address_range: Range<usize>,

    /// Processing blocks in a DFS fashion:
    /// 1. visit a block
    /// 2. visit its successors
    /// 3. visit the block again, after its successors are complete
    ///
    /// The flag indicates whether we are doing the 2nd visit.
    block_stack: Vec<(BasicBlockId, bool)>,

    /// Union of [MemoryAddress] which are read by the descendants of a block.
    reads_after: im::HashMap<BasicBlockId, im::HashSet<MemoryAddress>>,

    /// Advisories collected while visiting the opcodes.
    advisories: HashMap<OpcodeLocation, OpcodeAdvisory>,
}

impl CheckContext {
    fn new<R: RegisterAllocator>(registers: &R, entry_block_id: BasicBlockId) -> Self {
        Self {
            address_range: Range { start: registers.start(), end: registers.end() },
            block_stack: vec![(entry_block_id, false)],
            reads_after: Default::default(),
            advisories: Default::default(),
        }
    }

    /// Visit blocks and collect all opcode advisories.
    fn collect_advisories(&mut self, dfg: &DataFlowGraph) {
        while let Some((block_id, successors_ready)) = self.block_stack.pop() {
            if successors_ready {
                // Get the
                // Merge all the reads from successors.
                let reads_after =
                    dfg[block_id].successors().fold(im::HashSet::new(), |acc, successor_id| {
                        if let Some(addresses) = ctx.reads_after.get(&successor_id) {
                            acc.union(addresses.clone())
                        } else {
                            acc
                        }
                    });
                // Associate the reads in descendants by with the block.
                ctx.reads_after.insert(block_id, reads_after);
            } else {
                // Revisit later.
                ctx.block_stack.push((block_id, true));
                // Visit successors first.
                for successor_id in dfg[block_id].successors() {
                    ctx.block_stack.push((successor_id, false));
                }
            }
        }
    }

    /// Expected to be called with each opcode, traversing blocks in Post Order,
    /// feeding the opcodes back to front.
    fn visit_opcode<F>(&mut self, opcode: &Opcode<F>, location: OpcodeLocation) {
        match opcode {
            Opcode::BinaryFieldOp { destination, lhs, rhs, .. }
            | Opcode::BinaryIntOp { destination, lhs, rhs, .. } => {
                self.read(lhs, location);
                self.read(rhs, location);
                self.write(destination, location);
            }
            Opcode::Cast { destination, source, .. }
            | Opcode::Mov { destination, source }
            | Opcode::Not { destination, source, .. } => {
                self.read(source, location);
                self.write(destination, location);
            }
            Opcode::Load { destination, source_pointer } => {
                self.read(source_pointer, location);
                self.write(destination, location);
            }
            Opcode::Store { destination_pointer, source, .. } => {
                self.read(destination_pointer, location); // the write goes where the pointer points
                self.read(source, location);
            }
            Opcode::JumpIf { condition, .. } => {
                self.read(condition, location);
            }
            Opcode::CalldataCopy { destination_address, size_address, offset_address } => {
                self.read(size_address, location);
                self.read(offset_address, location);
                self.write(destination_address, location);
            }
            Opcode::Const { destination, .. } => {
                self.write(destination, location);
            }
            Opcode::IndirectConst { destination_pointer, .. } => {
                self.read(destination_pointer, location);
            }
            Opcode::ForeignCall { destinations, inputs, .. } => {
                for input in inputs {
                    self.read_value_or_array(input, location);
                }
                for destination in destinations {
                    self.write_value_or_array(destination, location);
                }
            }
            Opcode::ConditionalMov { source_a, source_b, condition, .. } => {
                self.read(condition, location);
                self.read(source_a, location);
                self.read(source_b, location);
            }
            Opcode::BlackBox(black_box_op) => self.visit_black_box_op(black_box_op, location),
            Opcode::Trap { revert_data } => self.read_heap_vector(revert_data, location),
            Opcode::Stop { return_data } => self.read_heap_vector(return_data, location),
            Opcode::Jump { .. } | Opcode::Call { .. } | Opcode::Return { .. } => {}
        }
    }

    /// Return the collected advisories.
    fn into_advisories(self) -> HashMap<OpcodeLocation, OpcodeAdvisory> {
        self.advisories
    }

    /// Check if the address belongs to the stack.
    fn is_within_bounds(&self, addr: &MemoryAddress) -> bool {
        match addr {
            MemoryAddress::Direct(_) => false,
            MemoryAddress::Relative(idx) => self.address_range.contains(idx),
        }
    }

    /// Remember the opcode location where a memory address was last read.
    fn read(&mut self, addr: &MemoryAddress, location: OpcodeLocation) {
        if !self.is_within_bounds(addr) {
            return;
        }
        self.reads.insert(*addr, location);
    }

    /// Remember the opcode location where a memory address was last read.
    ///
    /// Insert an advisory if:
    /// * the address is not read after this opcode
    /// * the address is read after this, but before that there is another write
    fn write(&mut self, addr: &MemoryAddress, location: OpcodeLocation) {
        if !self.is_within_bounds(addr) {
            return;
        }
        if let Some(read_at) = self.reads.get(addr) {
            if let Some(write_at) = self.writes.get(addr) {
                if write_at < read_at {
                    self.advisories.insert(
                        location,
                        OpcodeAdvisory::OverwrittenBeforeRead {
                            write_at: *write_at,
                            read_at: *read_at,
                        },
                    );
                }
            }
        } else {
            self.advisories.insert(location, OpcodeAdvisory::NeverRead);
        }
        self.writes.insert(*addr, location);
    }

    fn read_heap_array(&mut self, array: &HeapArray, location: OpcodeLocation) {
        self.read(&array.pointer, location);
    }

    fn read_heap_vector(&mut self, vector: &HeapVector, location: OpcodeLocation) {
        self.read(&vector.pointer, location);
        self.read(&vector.size, location);
    }

    fn read_value_or_array(&mut self, value: &ValueOrArray, location: OpcodeLocation) {
        match value {
            ValueOrArray::MemoryAddress(memory_address) => self.read(memory_address, location),
            ValueOrArray::HeapArray(heap_array) => self.read_heap_array(heap_array, location),
            ValueOrArray::HeapVector(heap_vector) => self.read_heap_vector(heap_vector, location),
        }
    }

    fn write_heap_array(&mut self, array: &HeapArray, location: OpcodeLocation) {
        self.write(&array.pointer, location);
    }

    fn write_heap_vector(&mut self, vector: &HeapVector, location: OpcodeLocation) {
        self.write(&vector.pointer, location);
        self.write(&vector.size, location);
    }

    fn write_value_or_array(&mut self, value: &ValueOrArray, location: OpcodeLocation) {
        match value {
            ValueOrArray::MemoryAddress(memory_address) => self.write(memory_address, location),
            ValueOrArray::HeapArray(heap_array) => self.write_heap_array(heap_array, location),
            ValueOrArray::HeapVector(heap_vector) => self.write_heap_vector(heap_vector, location),
        }
    }

    fn visit_black_box_op(&mut self, op: &BlackBoxOp, location: OpcodeLocation) {
        match op {
            BlackBoxOp::AES128Encrypt { inputs, iv, key, outputs } => {
                self.read_heap_vector(inputs, location);
                self.read_heap_array(iv, location);
                self.read_heap_array(key, location);
                self.write_heap_vector(outputs, location);
            }
            BlackBoxOp::Blake2s { message, output } | BlackBoxOp::Blake3 { message, output } => {
                self.read_heap_vector(message, location);
                self.write_heap_array(output, location);
            }
            BlackBoxOp::Keccakf1600 { input, output } => {
                self.read_heap_array(input, location);
                self.write_heap_array(output, location);
            }
            BlackBoxOp::EcdsaSecp256k1 {
                hashed_msg,
                public_key_x,
                public_key_y,
                signature,
                result,
            }
            | BlackBoxOp::EcdsaSecp256r1 {
                hashed_msg,
                public_key_x,
                public_key_y,
                signature,
                result,
            } => {
                self.read_heap_vector(hashed_msg, location);
                self.read_heap_array(public_key_x, location);
                self.read_heap_array(public_key_y, location);
                self.read_heap_array(signature, location);
                self.write(result, location);
            }
            BlackBoxOp::MultiScalarMul { points, scalars, outputs } => {
                self.read_heap_vector(points, location);
                self.read_heap_vector(scalars, location);
                self.write_heap_array(outputs, location);
            }
            BlackBoxOp::EmbeddedCurveAdd {
                input1_x,
                input1_y,
                input1_infinite,
                input2_x,
                input2_y,
                input2_infinite,
                result,
            } => {
                self.read(input1_x, location);
                self.read(input1_y, location);
                self.read(input1_infinite, location);
                self.read(input2_x, location);
                self.read(input2_y, location);
                self.read(input2_infinite, location);
                self.write_heap_array(result, location);
            }
            BlackBoxOp::Poseidon2Permutation { message, output } => {
                self.read_heap_vector(message, location);
                self.write_heap_array(output, location);
            }
            BlackBoxOp::Sha256Compression { input, hash_values, output } => {
                self.read_heap_array(input, location);
                self.read_heap_array(hash_values, location);
                self.write_heap_array(output, location);
            }
            BlackBoxOp::ToRadix { input, radix, output_pointer, num_limbs, output_bits } => {
                self.read(input, location);
                self.read(radix, location);
                self.read(num_limbs, location);
                self.read(output_bits, location);
                self.read(output_pointer, location); // indirect
            }
        }
    }
}
